;(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof module === 'object' && module.exports) {
        try {
            var JSDOM = require("jsdom").JSDOM;
            var DOM = new JSDOM();
            var window = DOM.window;
            var navigator = window.navigator;
            module.exports = factory(window, navigator);
        } catch (error) {
            module.exports = factory();
        }
    } else {
        root.pc = factory(root, root.navigator);
  }
}(this, function (_window, _navigator) {
  window = _window || window;
  navigator = _navigator || navigator;

  /*
 PlayCanvas Engine v1.4.3 revision c1a9280
 http://playcanvas.com
 Copyright 2011-2018 PlayCanvas Ltd. All rights reserved.
*/
var _typeLookup = function() {
  var result = {};
  var names = ["Array", "Object", "Function", "Date", "RegExp", "Float32Array"];
  for (var i = 0;i < names.length;i++) {
    result["[object " + names[i] + "]"] = names[i].toLowerCase();
  }
  return result;
}();
var pc = {version:"1.4.3", revision:"c1a9280", config:{}, common:{}, apps:{}, data:{}, unpack:function() {
  console.warn("pc.unpack has been deprecated and will be removed shortly. Please update your code.");
}, makeArray:function(arr) {
  var i, ret = [], length = arr.length;
  for (i = 0;i < length;++i) {
    ret.push(arr[i]);
  }
  return ret;
}, type:function(obj) {
  if (obj === null) {
    return "null";
  }
  var type = typeof obj;
  if (type === "undefined" || type === "number" || type === "string" || type === "boolean") {
    return type;
  }
  return _typeLookup[Object.prototype.toString.call(obj)];
}, extend:function(target, ex) {
  var prop, copy;
  for (prop in ex) {
    copy = ex[prop];
    if (pc.type(copy) == "object") {
      target[prop] = pc.extend({}, copy);
    } else {
      if (pc.type(copy) == "array") {
        target[prop] = pc.extend([], copy);
      } else {
        target[prop] = copy;
      }
    }
  }
  return target;
}, isDefined:function(o) {
  var a;
  return o !== a;
}};
if (typeof exports !== "undefined") {
  exports.pc = pc;
}
;(function() {
  if (typeof document === "undefined") {
    return;
  }
  var fullscreenchange = function(event) {
    var e = document.createEvent("CustomEvent");
    e.initCustomEvent("fullscreenchange", true, false, null);
    event.target.dispatchEvent(e);
  };
  var fullscreenerror = function(event) {
    var e = document.createEvent("CustomEvent");
    e.initCustomEvent("fullscreenerror", true, false, null);
    event.target.dispatchEvent(e);
  };
  document.addEventListener("webkitfullscreenchange", fullscreenchange, false);
  document.addEventListener("mozfullscreenchange", fullscreenchange, false);
  document.addEventListener("MSFullscreenChange", fullscreenchange, false);
  document.addEventListener("webkitfullscreenerror", fullscreenerror, false);
  document.addEventListener("mozfullscreenerror", fullscreenerror, false);
  document.addEventListener("MSFullscreenError", fullscreenerror, false);
  if (Element.prototype.mozRequestFullScreen) {
    Element.prototype.requestFullscreen = function() {
      this.mozRequestFullScreen();
    };
  } else {
    Element.prototype.requestFullscreen = Element.prototype.requestFullscreen || Element.prototype.webkitRequestFullscreen || Element.prototype.msRequestFullscreen;
  }
  document.exitFullscreen = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
  if (!document.hasOwnProperty("fullscreenElement")) {
    Object.defineProperty(document, "fullscreenElement", {enumerable:true, configurable:false, get:function() {
      return document.webkitCurrentFullScreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
    }});
  }
  if (!document.hasOwnProperty("fullscreenEnabled")) {
    Object.defineProperty(document, "fullscreenEnabled", {enumerable:true, configurable:false, get:function() {
      return document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
    }});
  }
})();
Math.log2 = Math.log2 || function(x) {
  return Math.log(x) * Math.LOG2E;
};
if (typeof Object.assign != "function") {
  Object.defineProperty(Object, "assign", {value:function assign(target, varArgs) {
    if (target == null) {
      throw new TypeError("Cannot convert undefined or null to object");
    }
    var to = Object(target);
    for (var index = 1;index < arguments.length;index++) {
      var nextSource = arguments[index];
      if (nextSource != null) {
        for (var nextKey in nextSource) {
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
    return to;
  }, writable:true, configurable:true});
}
;(function() {
  if (typeof navigator === "undefined" || typeof document === "undefined") {
    return;
  }
  navigator.pointer = navigator.pointer || navigator.webkitPointer || navigator.mozPointer;
  var pointerlockchange = function() {
    var e = document.createEvent("CustomEvent");
    e.initCustomEvent("pointerlockchange", true, false, null);
    document.dispatchEvent(e);
  };
  var pointerlockerror = function() {
    var e = document.createEvent("CustomEvent");
    e.initCustomEvent("pointerlockerror", true, false, null);
    document.dispatchEvent(e);
  };
  document.addEventListener("webkitpointerlockchange", pointerlockchange, false);
  document.addEventListener("webkitpointerlocklost", pointerlockchange, false);
  document.addEventListener("mozpointerlockchange", pointerlockchange, false);
  document.addEventListener("mozpointerlocklost", pointerlockchange, false);
  document.addEventListener("webkitpointerlockerror", pointerlockerror, false);
  document.addEventListener("mozpointerlockerror", pointerlockerror, false);
  if (Element.prototype.mozRequestPointerLock) {
    Element.prototype.requestPointerLock = function() {
      this.mozRequestPointerLock();
    };
  } else {
    Element.prototype.requestPointerLock = Element.prototype.requestPointerLock || Element.prototype.webkitRequestPointerLock || Element.prototype.mozRequestPointerLock;
  }
  if (!Element.prototype.requestPointerLock && navigator.pointer) {
    Element.prototype.requestPointerLock = function() {
      var el = this;
      document.pointerLockElement = el;
      navigator.pointer.lock(el, pointerlockchange, pointerlockerror);
    };
  }
  document.exitPointerLock = document.exitPointerLock || document.webkitExitPointerLock || document.mozExitPointerLock;
  if (!document.exitPointerLock) {
    document.exitPointerLock = function() {
      if (navigator.pointer) {
        document.pointerLockElement = null;
        navigator.pointer.unlock();
      }
    };
  }
})();
(function() {
  var lastTime = 0;
  var vendors = ["ms", "moz", "webkit", "o"];
  for (var x = 0;x < vendors.length && !window.requestAnimationFrame;++x) {
    window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
    window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
  }
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(callback, element) {
      var currTime = (new Date).getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function() {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }
  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };
  }
})();
if (!String.prototype.endsWith) {
  String.prototype.endsWith = function(search, this_len) {
    if (this_len === undefined || this_len > this.length) {
      this_len = this.length;
    }
    return this.substring(this_len - search.length, this_len) === search;
  };
}
if (!String.prototype.includes) {
  String.prototype.includes = function(search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > this.length) {
      return false;
    } else {
      return this.indexOf(search, start) !== -1;
    }
  };
}
if (!String.prototype.startsWith) {
  String.prototype.startsWith = function(search, pos) {
    return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  };
}
;Object.assign(pc, function() {
  var Color = function(r, g, b, a) {
    this.buffer = new ArrayBuffer(4 * 4);
    this.data = new Float32Array(this.buffer, 0, 4);
    this.data3 = new Float32Array(this.buffer, 0, 3);
    var length = r && r.length;
    if (length === 3 || length === 4) {
      this.data[0] = r[0];
      this.data[1] = r[1];
      this.data[2] = r[2];
      this.data[3] = r[3] !== undefined ? r[3] : 1.0;
    } else {
      this.data[0] = r || 0;
      this.data[1] = g || 0;
      this.data[2] = b || 0;
      this.data[3] = a !== undefined ? a : 1.0;
    }
  };
  Object.assign(Color.prototype, {clone:function() {
    return new pc.Color(this.data[0], this.data[1], this.data[2], this.data[3]);
  }, copy:function(rhs) {
    var a = this.data, b = rhs.data;
    a[0] = b[0];
    a[1] = b[1];
    a[2] = b[2];
    a[3] = b[3];
    return this;
  }, set:function(r, g, b, a) {
    var c = this.data;
    c[0] = r;
    c[1] = g;
    c[2] = b;
    c[3] = a === undefined ? 1 : a;
    return this;
  }, fromString:function(hex) {
    var i = parseInt(hex.replace("#", "0x"), 16);
    var bytes;
    if (hex.length > 7) {
      bytes = pc.math.intToBytes32(i);
    } else {
      bytes = pc.math.intToBytes24(i);
      bytes[3] = 255;
    }
    this.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);
    return this;
  }, toString:function(alpha) {
    var s = "#" + ((1 << 24) + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255)).toString(16).slice(1);
    if (alpha === true) {
      var a = Math.round(this.a * 255).toString(16);
      if (this.a < 16 / 255) {
        s += "0" + a;
      } else {
        s += a;
      }
    }
    return s;
  }});
  Object.defineProperty(Color.prototype, "r", {get:function() {
    return this.data[0];
  }, set:function(value) {
    this.data[0] = value;
  }});
  Object.defineProperty(Color.prototype, "g", {get:function() {
    return this.data[1];
  }, set:function(value) {
    this.data[1] = value;
  }});
  Object.defineProperty(Color.prototype, "b", {get:function() {
    return this.data[2];
  }, set:function(value) {
    this.data[2] = value;
  }});
  Object.defineProperty(Color.prototype, "a", {get:function() {
    return this.data[3];
  }, set:function(value) {
    this.data[3] = value;
  }});
  return {Color:Color};
}());
pc.guid = function() {
  return {create:function() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }};
}();
Object.assign(pc, function() {
  var Timer = function Timer() {
    this._isRunning = false;
    this._a = 0;
    this._b = 0;
  };
  Object.assign(Timer.prototype, {start:function() {
    this._isRunning = true;
    this._a = pc.now();
  }, stop:function() {
    this._isRunning = false;
    this._b = pc.now();
  }, getMilliseconds:function() {
    return this._b - this._a;
  }});
  return {Timer:Timer, now:!window.performance || !window.performance.now || !window.performance.timing ? Date.now : function() {
    return window.performance.now();
  }};
}());
Object.assign(pc, function() {
  return {hashCode:function(str) {
    var hash = 0;
    for (var i = 0, len = str.length;i < len;i++) {
      hash = (hash << 5) - hash + str.charCodeAt(i);
      hash |= 0;
    }
    return hash;
  }};
}());
Object.assign(pc, function() {
  return {createURI:function(options) {
    var s = "";
    if ((options.authority || options.scheme) && (options.host || options.hostpath)) {
      throw new Error("Can't have 'scheme' or 'authority' and 'host' or 'hostpath' option");
    }
    if (options.host && options.hostpath) {
      throw new Error("Can't have 'host' and 'hostpath' option");
    }
    if (options.path && options.hostpath) {
      throw new Error("Can't have 'path' and 'hostpath' option");
    }
    if (options.scheme) {
      s += options.scheme + ":";
    }
    if (options.authority) {
      s += "//" + options.authority;
    }
    if (options.host) {
      s += options.host;
    }
    if (options.path) {
      s += options.path;
    }
    if (options.hostpath) {
      s += options.hostpath;
    }
    if (options.query) {
      s += "?" + options.query;
    }
    if (options.fragment) {
      s += "#" + options.fragment;
    }
    return s;
  }, URI:function(uri) {
    var re = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/, result = uri.match(re);
    this.scheme = result[2];
    this.authority = result[4];
    this.path = result[5];
    this.query = result[7];
    this.fragment = result[9];
    this.toString = function() {
      var s = "";
      if (this.scheme) {
        s += this.scheme + ":";
      }
      if (this.authority) {
        s += "//" + this.authority;
      }
      s += this.path;
      if (this.query) {
        s += "?" + this.query;
      }
      if (this.fragment) {
        s += "#" + this.fragment;
      }
      return s;
    };
    this.getQuery = function() {
      var vars;
      var pair;
      var result = {};
      if (this.query) {
        vars = decodeURIComponent(this.query).split("&");
        vars.forEach(function(item, index, arr) {
          pair = item.split("=");
          result[pair[0]] = pair[1];
        }, this);
      }
      return result;
    };
    this.setQuery = function(params) {
      var q = "";
      for (var key in params) {
        if (params.hasOwnProperty(key)) {
          if (q !== "") {
            q += "&";
          }
          q += encodeURIComponent(key) + "=" + encodeURIComponent(params[key]);
        }
      }
      this.query = q;
    };
  }};
}());
Object.assign(pc, function() {
  var log = {write:function(text) {
    console.log(text);
  }, open:function() {
    pc.log.write("Powered by PlayCanvas " + pc.version + " " + pc.revision);
  }, info:function(text) {
    console.info("INFO:    " + text);
  }, debug:function(text) {
    console.debug("DEBUG:   " + text);
  }, error:function(text) {
    console.error("ERROR:   " + text);
  }, warning:function(text) {
    console.warn("WARNING: " + text);
  }, alert:function(text) {
    pc.log.write("ALERT:   " + text);
    alert(text);
  }, assert:function(condition, text) {
    if (condition === false) {
      pc.log.write("ASSERT:  " + text);
    }
  }};
  return {log:log};
}());
var logINFO = pc.log.info;
var logDEBUG = pc.log.debug;
var logWARNING = pc.log.warning;
var logERROR = pc.log.error;
var logALERT = pc.log.alert;
var logASSERT = pc.log.assert;
pc.path = function() {
  return {delimiter:"/", join:function() {
    var index;
    var num = arguments.length;
    var result = arguments[0];
    for (index = 0;index < num - 1;++index) {
      var one = arguments[index];
      var two = arguments[index + 1];
      if (!pc.isDefined(one) || !pc.isDefined(two)) {
        throw new Error("undefined argument to pc.path.join");
      }
      if (two[0] === pc.path.delimiter) {
        result = two;
        continue;
      }
      if (one && two && one[one.length - 1] !== pc.path.delimiter && two[0] !== pc.path.delimiter) {
        result += pc.path.delimiter + two;
      } else {
        result += two;
      }
    }
    return result;
  }, split:function(path) {
    var parts = path.split(pc.path.delimiter);
    var tail = parts.slice(parts.length - 1)[0];
    var head = parts.slice(0, parts.length - 1).join(pc.path.delimiter);
    return [head, tail];
  }, getBasename:function(path) {
    return pc.path.split(path)[1];
  }, getDirectory:function(path) {
    var parts = path.split(pc.path.delimiter);
    return parts.slice(0, parts.length - 1).join(pc.path.delimiter);
  }, getExtension:function(path) {
    var ext = path.split("?")[0].split(".").pop();
    if (ext !== path) {
      return "." + ext;
    }
    return "";
  }, isRelativePath:function(s) {
    return s.charAt(0) !== "/" && s.match(/:\/\//) === null;
  }, extractPath:function(s) {
    var path = ".", parts = s.split("/"), i = 0;
    if (parts.length > 1) {
      if (pc.path.isRelativePath(s) === false) {
        path = "";
      }
      for (i = 0;i < parts.length - 1;++i) {
        path += "/" + parts[i];
      }
    }
    return path;
  }};
}();
pc.string = function() {
  return {ASCII_LOWERCASE:"abcdefghijklmnopqrstuvwxyz", ASCII_UPPERCASE:"ABCDEFGHIJKLMNOPQRSTUVWXYZ", ASCII_LETTERS:this.ASCII_LOWERCASE + this.ASCII_UPPERCASE, format:function(s) {
    var i = 0, regexp, args = pc.makeArray(arguments);
    args.shift();
    for (i = 0;i < args.length;i++) {
      regexp = new RegExp("\\{" + i + "\\}", "gi");
      s = s.replace(regexp, args[i]);
    }
    return s;
  }, startsWith:function(s, subs) {
    console.warn("WARNING: startsWith: Function is deprecated. Use String.startsWith instead.");
    return s.startsWith(subs);
  }, endsWith:function(s, subs) {
    console.warn("WARNING: endsWith: Function is deprecated. Use String.endsWith instead.");
    return s.endsWith(subs);
  }, toBool:function(s, strict) {
    if (s === "true") {
      return true;
    }
    if (strict) {
      if (s === "false") {
        return false;
      }
      throw new Error("Not a boolean string");
    }
    return false;
  }};
}();
pc.debug = function() {
  var table = null;
  var row = null;
  var title = null;
  var field = null;
  return {display:function(data) {
    function init() {
      table = document.createElement("table");
      row = document.createElement("tr");
      title = document.createElement("td");
      field = document.createElement("td");
      table.style.cssText = "position:absolute;font-family:sans-serif;font-size:12px;color:#cccccc";
      table.style.top = "0px";
      table.style.left = "0px";
      table.style.border = "thin solid #cccccc";
      document.body.appendChild(table);
    }
    if (!table) {
      init();
    }
    table.innerHTML = "";
    for (var key in data) {
      var r = row.cloneNode();
      var t = title.cloneNode();
      var f = field.cloneNode();
      t.textContent = key;
      f.textContent = data[key];
      r.appendChild(t);
      r.appendChild(f);
      table.appendChild(r);
    }
  }};
}();
pc.events = {attach:function(target) {
  var ev = pc.events;
  target.on = ev.on;
  target.off = ev.off;
  target.fire = ev.fire;
  target.once = ev.once;
  target.hasEvent = ev.hasEvent;
  target._callbackActive = {};
  return target;
}, on:function(name, callback, scope) {
  if (!name || typeof name !== "string" || !callback) {
    return this;
  }
  if (!this._callbacks) {
    this._callbacks = {};
  }
  if (!this._callbacks[name]) {
    this._callbacks[name] = [];
  }
  if (!this._callbackActive) {
    this._callbackActive = {};
  }
  if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) {
    this._callbackActive[name] = this._callbackActive[name].slice();
  }
  this._callbacks[name].push({callback:callback, scope:scope || this});
  return this;
}, off:function(name, callback, scope) {
  if (!this._callbacks) {
    return this;
  }
  if (this._callbackActive) {
    if (name) {
      if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) {
        this._callbackActive[name] = this._callbackActive[name].slice();
      }
    } else {
      for (var key in this._callbackActive) {
        if (!this._callbacks[key]) {
          continue;
        }
        if (this._callbacks[key] !== this._callbackActive[key]) {
          continue;
        }
        this._callbackActive[key] = this._callbackActive[key].slice();
      }
    }
  }
  if (!name) {
    this._callbacks = null;
  } else {
    if (!callback) {
      if (this._callbacks[name]) {
        delete this._callbacks[name];
      }
    } else {
      var events = this._callbacks[name];
      if (!events) {
        return this;
      }
      var i = events.length;
      while (i--) {
        if (events[i].callback !== callback) {
          continue;
        }
        if (scope && events[i].scope !== scope) {
          continue;
        }
        events.splice(i, 1);
      }
    }
  }
  return this;
}, fire:function(name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
  if (!name || !this._callbacks || !this._callbacks[name]) {
    return this;
  }
  var callbacks;
  if (!this._callbackActive) {
    this._callbackActive = {};
  }
  if (!this._callbackActive[name]) {
    this._callbackActive[name] = this._callbacks[name];
  } else {
    if (this._callbackActive[name] === this._callbacks[name]) {
      this._callbackActive[name] = this._callbackActive[name].slice();
    }
    callbacks = this._callbacks[name].slice();
  }
  for (var i = 0;(callbacks || this._callbackActive[name]) && i < (callbacks || this._callbackActive[name]).length;i++) {
    var evt = (callbacks || this._callbackActive[name])[i];
    evt.callback.call(evt.scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    if (evt.callback.once) {
      var ind = this._callbacks[name].indexOf(evt);
      if (ind !== -1) {
        if (this._callbackActive[name] === this._callbacks[name]) {
          this._callbackActive[name] = this._callbackActive[name].slice();
        }
        this._callbacks[name].splice(ind, 1);
      }
    }
  }
  if (!callbacks) {
    this._callbackActive[name] = null;
  }
  return this;
}, once:function(name, callback, scope) {
  callback.once = true;
  this.on(name, callback, scope);
  return this;
}, hasEvent:function(name) {
  return this._callbacks && this._callbacks[name] && this._callbacks[name].length !== 0 || false;
}};
Object.assign(pc, function() {
  var TagsCache = function(key) {
    this._index = {};
    this._key = key || null;
  };
  Object.assign(TagsCache.prototype, {addItem:function(item) {
    var tags = item.tags._list;
    for (var i = 0;i < tags.length;i++) {
      this.add(tags[i], item);
    }
  }, removeItem:function(item) {
    var tags = item.tags._list;
    for (var i = 0;i < tags.length;i++) {
      this.remove(tags[i], item);
    }
  }, add:function(tag, item) {
    if (this._index[tag] && this._index[tag].list.indexOf(item) !== -1) {
      return;
    }
    if (!this._index[tag]) {
      this._index[tag] = {list:[]};
      if (this._key) {
        this._index[tag].keys = {};
      }
    }
    this._index[tag].list.push(item);
    if (this._key) {
      this._index[tag].keys[item[this._key]] = item;
    }
  }, remove:function(tag, item) {
    if (!this._index[tag]) {
      return;
    }
    if (this._key) {
      if (!this._index[tag].keys[item[this._key]]) {
        return;
      }
    }
    var ind = this._index[tag].indexOf(item);
    if (ind === -1) {
      return;
    }
    this._index[tag].list.splice(ind, 1);
    if (this._key) {
      delete this._index[tag].keys[item[this._key]];
    }
    if (this._index[tag].list.length === 0) {
      delete this._index[tag];
    }
  }, find:function(args) {
    var self = this;
    var index = {};
    var items = [];
    var i, n, t;
    var item, tag, tags, tagsRest, missingIndex;
    var sort = function(a, b) {
      return self._index[a].list.length - self._index[b].list.length;
    };
    for (i = 0;i < args.length;i++) {
      tag = args[i];
      if (tag instanceof Array) {
        if (tag.length === 0) {
          continue;
        }
        if (tag.length === 1) {
          tag = tag[0];
        } else {
          missingIndex = false;
          for (t = 0;t < tag.length;t++) {
            if (!this._index[tag[t]]) {
              missingIndex = true;
              break;
            }
          }
          if (missingIndex) {
            continue;
          }
          tags = tag.slice(0).sort(sort);
          tagsRest = tags.slice(1);
          if (tagsRest.length === 1) {
            tagsRest = tagsRest[0];
          }
          for (n = 0;n < this._index[tags[0]].list.length;n++) {
            item = this._index[tags[0]].list[n];
            if ((this._key ? !index[item[this._key]] : items.indexOf(item) === -1) && item.tags.has(tagsRest)) {
              if (this._key) {
                index[item[this._key]] = true;
              }
              items.push(item);
            }
          }
          continue;
        }
      }
      if (tag && typeof tag === "string" && this._index[tag]) {
        for (n = 0;n < this._index[tag].list.length;n++) {
          item = this._index[tag].list[n];
          if (this._key) {
            if (!index[item[this._key]]) {
              index[item[this._key]] = true;
              items.push(item);
            }
          } else {
            if (items.indexOf(item) === -1) {
              items.push(item);
            }
          }
        }
      }
    }
    return items;
  }});
  var Tags = function(parent) {
    this._index = {};
    this._list = [];
    this._parent = parent;
    pc.events.attach(this);
  };
  Object.assign(Tags.prototype, {add:function() {
    var changed = false;
    var tags = this._processArguments(arguments, true);
    if (!tags.length) {
      return changed;
    }
    for (var i = 0;i < tags.length;i++) {
      if (this._index[tags[i]]) {
        continue;
      }
      changed = true;
      this._index[tags[i]] = true;
      this._list.push(tags[i]);
      this.fire("add", tags[i], this._parent);
    }
    if (changed) {
      this.fire("change", this._parent);
    }
    return changed;
  }, remove:function() {
    var changed = false;
    if (!this._list.length) {
      return changed;
    }
    var tags = this._processArguments(arguments, true);
    if (!tags.length) {
      return changed;
    }
    for (var i = 0;i < tags.length;i++) {
      if (!this._index[tags[i]]) {
        continue;
      }
      changed = true;
      delete this._index[tags[i]];
      this._list.splice(this._list.indexOf(tags[i]), 1);
      this.fire("remove", tags[i], this._parent);
    }
    if (changed) {
      this.fire("change", this._parent);
    }
    return changed;
  }, clear:function() {
    if (!this._list.length) {
      return;
    }
    var tags = this._list.slice(0);
    this._list = [];
    this._index = {};
    for (var i = 0;i < tags.length;i++) {
      this.fire("remove", tags[i], this._parent);
    }
    this.fire("change", this._parent);
  }, has:function() {
    if (!this._list.length) {
      return false;
    }
    return this._has(this._processArguments(arguments));
  }, _has:function(tags) {
    if (!this._list.length || !tags.length) {
      return false;
    }
    for (var i = 0;i < tags.length;i++) {
      if (tags[i].length === 1) {
        if (this._index[tags[i][0]]) {
          return true;
        }
      } else {
        var multiple = true;
        for (var t = 0;t < tags[i].length;t++) {
          if (this._index[tags[i][t]]) {
            continue;
          }
          multiple = false;
          break;
        }
        if (multiple) {
          return true;
        }
      }
    }
    return false;
  }, list:function() {
    return this._list.slice(0);
  }, _processArguments:function(args, flat) {
    var tags = [];
    var tmp = [];
    if (!args || !args.length) {
      return tags;
    }
    for (var i = 0;i < args.length;i++) {
      if (args[i] instanceof Array) {
        if (!flat) {
          tmp = [];
        }
        for (var t = 0;t < args[i].length;t++) {
          if (typeof args[i][t] !== "string") {
            continue;
          }
          if (flat) {
            tags.push(args[i][t]);
          } else {
            tmp.push(args[i][t]);
          }
        }
        if (!flat && tmp.length) {
          tags.push(tmp);
        }
      } else {
        if (typeof args[i] === "string") {
          if (flat) {
            tags.push(args[i]);
          } else {
            tags.push([args[i]]);
          }
        }
      }
    }
    return tags;
  }});
  Object.defineProperty(Tags.prototype, "size", {get:function() {
    return this._list.length;
  }});
  return {TagsCache:TagsCache, Tags:Tags};
}());
Object.assign(pc, function() {
  var AllocatePool = function(constructor, size) {
    this._constructor = constructor;
    this._pool = [];
    this._count = 0;
    this._resize(size);
  };
  Object.assign(AllocatePool.prototype, {_resize:function(size) {
    if (size > this._pool.length) {
      for (var i = this._pool.length;i < size;i++) {
        this._pool[i] = new this._constructor;
      }
    }
  }, allocate:function() {
    if (this._count >= this._pool.length) {
      this._resize(this._pool.length * 2);
    }
    return this._pool[this._count++];
  }, freeAll:function() {
    this._count = 0;
  }});
  return {AllocatePool:AllocatePool};
}());
Object.assign(pc, function() {
  var platform = {desktop:false, mobile:false, ios:false, android:false, windows:false, cocoonjs:false, xbox:false, gamepads:false, touch:false};
  var ua = navigator.userAgent;
  if (/(windows|mac os|linux|cros)/i.test(ua)) {
    platform.desktop = true;
  }
  if (/xbox/i.test(ua)) {
    platform.xbox = true;
  }
  if (/(windows phone|iemobile|wpdesktop)/i.test(ua)) {
    platform.desktop = false;
    platform.mobile = true;
    platform.windows = true;
  } else {
    if (/android/i.test(ua)) {
      platform.desktop = false;
      platform.mobile = true;
      platform.android = true;
    } else {
      if (/ip([ao]d|hone)/i.test(ua)) {
        platform.desktop = false;
        platform.mobile = true;
        platform.ios = true;
      }
    }
  }
  if (navigator.isCocoonJS) {
    platform.cocoonjs = true;
  }
  platform.touch = "ontouchstart" in window;
  platform.gamepads = "getGamepads" in navigator;
  return {platform:platform};
}());
pc.math = {DEG_TO_RAD:Math.PI / 180, RAD_TO_DEG:180 / Math.PI, clamp:function(value, min, max) {
  if (value >= max) {
    return max;
  }
  if (value <= min) {
    return min;
  }
  return value;
}, intToBytes24:function(i) {
  var r, g, b;
  r = i >> 16 & 255;
  g = i >> 8 & 255;
  b = i & 255;
  return [r, g, b];
}, intToBytes32:function(i) {
  var r, g, b, a;
  r = i >> 24 & 255;
  g = i >> 16 & 255;
  b = i >> 8 & 255;
  a = i & 255;
  return [r, g, b, a];
}, bytesToInt24:function(r, g, b) {
  if (r.length) {
    b = r[2];
    g = r[1];
    r = r[0];
  }
  return r << 16 | g << 8 | b;
}, bytesToInt32:function(r, g, b, a) {
  if (r.length) {
    a = r[3];
    b = r[2];
    g = r[1];
    r = r[0];
  }
  return (r << 24 | g << 16 | b << 8 | a) >>> 32;
}, lerp:function(a, b, alpha) {
  return a + (b - a) * pc.math.clamp(alpha, 0, 1);
}, lerpAngle:function(a, b, alpha) {
  if (b - a > 180) {
    b -= 360;
  }
  if (b - a < -180) {
    b += 360;
  }
  return pc.math.lerp(a, b, pc.math.clamp(alpha, 0, 1));
}, powerOfTwo:function(x) {
  return x !== 0 && !(x & x - 1);
}, nextPowerOfTwo:function(val) {
  val--;
  val |= val >> 1;
  val |= val >> 2;
  val |= val >> 4;
  val |= val >> 8;
  val |= val >> 16;
  val++;
  return val;
}, random:function(min, max) {
  var diff = max - min;
  return Math.random() * diff + min;
}, smoothstep:function(min, max, x) {
  if (x <= min) {
    return 0;
  }
  if (x >= max) {
    return 1;
  }
  x = (x - min) / (max - min);
  return x * x * (3 - 2 * x);
}, smootherstep:function(min, max, x) {
  if (x <= min) {
    return 0;
  }
  if (x >= max) {
    return 1;
  }
  x = (x - min) / (max - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
}};
Object.assign(pc, function() {
  var Vec2 = function(x, y) {
    if (x && x.length === 2) {
      this.data = new Float32Array(x);
      return;
    }
    this.data = new Float32Array(2);
    this.data[0] = x || 0;
    this.data[1] = y || 0;
  };
  Object.assign(Vec2.prototype, {add:function(rhs) {
    var a = this.data, b = rhs.data;
    a[0] += b[0];
    a[1] += b[1];
    return this;
  }, add2:function(lhs, rhs) {
    var a = lhs.data, b = rhs.data, r = this.data;
    r[0] = a[0] + b[0];
    r[1] = a[1] + b[1];
    return this;
  }, clone:function() {
    return (new Vec2).copy(this);
  }, copy:function(rhs) {
    var a = this.data, b = rhs.data;
    a[0] = b[0];
    a[1] = b[1];
    return this;
  }, dot:function(rhs) {
    var a = this.data, b = rhs.data;
    return a[0] * b[0] + a[1] * b[1];
  }, equals:function(rhs) {
    var a = this.data, b = rhs.data;
    return a[0] === b[0] && a[1] === b[1];
  }, length:function() {
    var v = this.data;
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  }, lengthSq:function() {
    var v = this.data;
    return v[0] * v[0] + v[1] * v[1];
  }, lerp:function(lhs, rhs, alpha) {
    var a = lhs.data, b = rhs.data, r = this.data;
    r[0] = a[0] + alpha * (b[0] - a[0]);
    r[1] = a[1] + alpha * (b[1] - a[1]);
    return this;
  }, mul:function(rhs) {
    var a = this.data, b = rhs.data;
    a[0] *= b[0];
    a[1] *= b[1];
    return this;
  }, mul2:function(lhs, rhs) {
    var a = lhs.data, b = rhs.data, r = this.data;
    r[0] = a[0] * b[0];
    r[1] = a[1] * b[1];
    return this;
  }, normalize:function() {
    var v = this.data;
    var lengthSq = v[0] * v[0] + v[1] * v[1];
    if (lengthSq > 0) {
      var invLength = 1 / Math.sqrt(lengthSq);
      v[0] *= invLength;
      v[1] *= invLength;
    }
    return this;
  }, scale:function(scalar) {
    var v = this.data;
    v[0] *= scalar;
    v[1] *= scalar;
    return this;
  }, set:function(x, y) {
    var v = this.data;
    v[0] = x;
    v[1] = y;
    return this;
  }, sub:function(rhs) {
    var a = this.data, b = rhs.data;
    a[0] -= b[0];
    a[1] -= b[1];
    return this;
  }, sub2:function(lhs, rhs) {
    var a = lhs.data, b = rhs.data, r = this.data;
    r[0] = a[0] - b[0];
    r[1] = a[1] - b[1];
    return this;
  }, toString:function() {
    return "[" + this.data[0] + ", " + this.data[1] + "]";
  }});
  Object.defineProperty(Vec2.prototype, "x", {get:function() {
    return this.data[0];
  }, set:function(value) {
    this.data[0] = value;
  }});
  Object.defineProperty(Vec2.prototype, "y", {get:function() {
    return this.data[1];
  }, set:function(value) {
    this.data[1] = value;
  }});
  Object.defineProperty(Vec2, "ONE", {get:function() {
    var one = new Vec2(1, 1);
    return function() {
      return one;
    };
  }()});
  Object.defineProperty(Vec2, "RIGHT", {get:function() {
    var right = new Vec2(1, 0);
    return function() {
      return right;
    };
  }()});
  Object.defineProperty(Vec2, "UP", {get:function() {
    var down = new Vec2(0, 1);
    return function() {
      return down;
    };
  }()});
  Object.defineProperty(Vec2, "ZERO", {get:function() {
    var zero = new Vec2(0, 0);
    return function() {
      return zero;
    };
  }()});
  return {Vec2:Vec2};
}());
Object.assign(pc, function() {
  var Vec3 = function(x, y, z) {
    if (x && x.length === 3) {
      this.data = new Float32Array(x);
      return;
    }
    this.data = new Float32Array(3);
    this.data[0] = x || 0;
    this.data[1] = y || 0;
    this.data[2] = z || 0;
  };
  Object.assign(Vec3.prototype, {add:function(rhs) {
    var a = this.data, b = rhs.data;
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
    return this;
  }, add2:function(lhs, rhs) {
    var a = lhs.data, b = rhs.data, r = this.data;
    r[0] = a[0] + b[0];
    r[1] = a[1] + b[1];
    r[2] = a[2] + b[2];
    return this;
  }, clone:function() {
    return (new Vec3).copy(this);
  }, copy:function(rhs) {
    var a = this.data, b = rhs.data;
    a[0] = b[0];
    a[1] = b[1];
    a[2] = b[2];
    return this;
  }, cross:function(lhs, rhs) {
    var a, b, r, ax, ay, az, bx, by, bz;
    a = lhs.data;
    b = rhs.data;
    r = this.data;
    ax = a[0];
    ay = a[1];
    az = a[2];
    bx = b[0];
    by = b[1];
    bz = b[2];
    r[0] = ay * bz - by * az;
    r[1] = az * bx - bz * ax;
    r[2] = ax * by - bx * ay;
    return this;
  }, dot:function(rhs) {
    var a = this.data, b = rhs.data;
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }, equals:function(rhs) {
    var a = this.data, b = rhs.data;
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
  }, length:function() {
    var v = this.data;
    return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
  }, lengthSq:function() {
    var v = this.data;
    return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
  }, lerp:function(lhs, rhs, alpha) {
    var a = lhs.data, b = rhs.data, r = this.data;
    r[0] = a[0] + alpha * (b[0] - a[0]);
    r[1] = a[1] + alpha * (b[1] - a[1]);
    r[2] = a[2] + alpha * (b[2] - a[2]);
    return this;
  }, mul:function(rhs) {
    var a = this.data, b = rhs.data;
    a[0] *= b[0];
    a[1] *= b[1];
    a[2] *= b[2];
    return this;
  }, mul2:function(lhs, rhs) {
    var a = lhs.data, b = rhs.data, r = this.data;
    r[0] = a[0] * b[0];
    r[1] = a[1] * b[1];
    r[2] = a[2] * b[2];
    return this;
  }, normalize:function() {
    var v = this.data;
    var lengthSq = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
    if (lengthSq > 0) {
      var invLength = 1 / Math.sqrt(lengthSq);
      v[0] *= invLength;
      v[1] *= invLength;
      v[2] *= invLength;
    }
    return this;
  }, project:function(rhs) {
    var a = this.data;
    var b = rhs.data;
    var a_dot_b = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    var b_dot_b = b[0] * b[0] + b[1] * b[1] + b[2] * b[2];
    var s = a_dot_b / b_dot_b;
    a[0] = b[0] * s;
    a[1] = b[1] * s;
    a[2] = b[2] * s;
    return this;
  }, scale:function(scalar) {
    var v = this.data;
    v[0] *= scalar;
    v[1] *= scalar;
    v[2] *= scalar;
    return this;
  }, set:function(x, y, z) {
    var v = this.data;
    v[0] = x;
    v[1] = y;
    v[2] = z;
    return this;
  }, sub:function(rhs) {
    var a = this.data, b = rhs.data;
    a[0] -= b[0];
    a[1] -= b[1];
    a[2] -= b[2];
    return this;
  }, sub2:function(lhs, rhs) {
    var a = lhs.data, b = rhs.data, r = this.data;
    r[0] = a[0] - b[0];
    r[1] = a[1] - b[1];
    r[2] = a[2] - b[2];
    return this;
  }, toString:function() {
    return "[" + this.data[0] + ", " + this.data[1] + ", " + this.data[2] + "]";
  }});
  Object.defineProperty(Vec3.prototype, "x", {get:function() {
    return this.data[0];
  }, set:function(value) {
    this.data[0] = value;
  }});
  Object.defineProperty(Vec3.prototype, "y", {get:function() {
    return this.data[1];
  }, set:function(value) {
    this.data[1] = value;
  }});
  Object.defineProperty(Vec3.prototype, "z", {get:function() {
    return this.data[2];
  }, set:function(value) {
    this.data[2] = value;
  }});
  Object.defineProperty(Vec3, "BACK", {get:function() {
    var back = new Vec3(0, 0, 1);
    return function() {
      return back;
    };
  }()});
  Object.defineProperty(Vec3, "DOWN", {get:function() {
    var down = new Vec3(0, -1, 0);
    return function() {
      return down;
    };
  }()});
  Object.defineProperty(Vec3, "FORWARD", {get:function() {
    var forward = new Vec3(0, 0, -1);
    return function() {
      return forward;
    };
  }()});
  Object.defineProperty(Vec3, "LEFT", {get:function() {
    var left = new Vec3(-1, 0, 0);
    return function() {
      return left;
    };
  }()});
  Object.defineProperty(Vec3, "ONE", {get:function() {
    var one = new Vec3(1, 1, 1);
    return function() {
      return one;
    };
  }()});
  Object.defineProperty(Vec3, "RIGHT", {get:function() {
    var right = new Vec3(1, 0, 0);
    return function() {
      return right;
    };
  }()});
  Object.defineProperty(Vec3, "UP", {get:function() {
    var down = new Vec3(0, 1, 0);
    return function() {
      return down;
    };
  }()});
  Object.defineProperty(Vec3, "ZERO", {get:function() {
    var zero = new Vec3(0, 0, 0);
    return function() {
      return zero;
    };
  }()});
  return {Vec3:Vec3};
}());
Object.assign(pc, function() {
  var Vec4 = function(x, y, z, w) {
    if (x && x.length === 4) {
      this.data = new Float32Array(x);
      return;
    }
    this.data = new Float32Array(4);
    this.data[0] = x || 0;
    this.data[1] = y || 0;
    this.data[2] = z || 0;
    this.data[3] = w || 0;
  };
  Object.assign(Vec4.prototype, {add:function(rhs) {
    var a = this.data, b = rhs.data;
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
    a[3] += b[3];
    return this;
  }, add2:function(lhs, rhs) {
    var a = lhs.data, b = rhs.data, r = this.data;
    r[0] = a[0] + b[0];
    r[1] = a[1] + b[1];
    r[2] = a[2] + b[2];
    r[3] = a[3] + b[3];
    return this;
  }, clone:function() {
    return (new Vec4).copy(this);
  }, copy:function(rhs) {
    var a = this.data, b = rhs.data;
    a[0] = b[0];
    a[1] = b[1];
    a[2] = b[2];
    a[3] = b[3];
    return this;
  }, dot:function(rhs) {
    var a = this.data, b = rhs.data;
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }, equals:function(rhs) {
    var a = this.data, b = rhs.data;
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
  }, length:function() {
    var v = this.data;
    return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2] + v[3] * v[3]);
  }, lengthSq:function() {
    var v = this.data;
    return v[0] * v[0] + v[1] * v[1] + v[2] * v[2] + v[3] * v[3];
  }, lerp:function(lhs, rhs, alpha) {
    var a = lhs.data, b = rhs.data, r = this.data;
    r[0] = a[0] + alpha * (b[0] - a[0]);
    r[1] = a[1] + alpha * (b[1] - a[1]);
    r[2] = a[2] + alpha * (b[2] - a[2]);
    r[3] = a[3] + alpha * (b[3] - a[3]);
    return this;
  }, mul:function(rhs) {
    var a = this.data, b = rhs.data;
    a[0] *= b[0];
    a[1] *= b[1];
    a[2] *= b[2];
    a[3] *= b[3];
    return this;
  }, mul2:function(lhs, rhs) {
    var a = lhs.data, b = rhs.data, r = this.data;
    r[0] = a[0] * b[0];
    r[1] = a[1] * b[1];
    r[2] = a[2] * b[2];
    r[3] = a[3] * b[3];
    return this;
  }, normalize:function() {
    var v = this.data;
    var lengthSq = v[0] * v[0] + v[1] * v[1] + v[2] * v[2] + v[3] * v[3];
    if (lengthSq > 0) {
      var invLength = 1 / Math.sqrt(lengthSq);
      v[0] *= invLength;
      v[1] *= invLength;
      v[2] *= invLength;
      v[3] *= invLength;
    }
    return this;
  }, scale:function(scalar) {
    var v = this.data;
    v[0] *= scalar;
    v[1] *= scalar;
    v[2] *= scalar;
    v[3] *= scalar;
    return this;
  }, set:function(x, y, z, w) {
    var v = this.data;
    v[0] = x;
    v[1] = y;
    v[2] = z;
    v[3] = w;
    return this;
  }, sub:function(rhs) {
    var a = this.data, b = rhs.data;
    a[0] -= b[0];
    a[1] -= b[1];
    a[2] -= b[2];
    a[3] -= b[3];
    return this;
  }, sub2:function(lhs, rhs) {
    var a = lhs.data, b = rhs.data, r = this.data;
    r[0] = a[0] - b[0];
    r[1] = a[1] - b[1];
    r[2] = a[2] - b[2];
    r[3] = a[3] - b[3];
    return this;
  }, toString:function() {
    return "[" + this.data[0] + ", " + this.data[1] + ", " + this.data[2] + ", " + this.data[3] + "]";
  }});
  Object.defineProperty(Vec4.prototype, "x", {get:function() {
    return this.data[0];
  }, set:function(value) {
    this.data[0] = value;
  }});
  Object.defineProperty(Vec4.prototype, "y", {get:function() {
    return this.data[1];
  }, set:function(value) {
    this.data[1] = value;
  }});
  Object.defineProperty(Vec4.prototype, "z", {get:function() {
    return this.data[2];
  }, set:function(value) {
    this.data[2] = value;
  }});
  Object.defineProperty(Vec4.prototype, "w", {get:function() {
    return this.data[3];
  }, set:function(value) {
    this.data[3] = value;
  }});
  Object.defineProperty(Vec4, "ONE", {get:function() {
    var one = new Vec4(1, 1, 1, 1);
    return function() {
      return one;
    };
  }()});
  Object.defineProperty(Vec4, "ZERO", {get:function() {
    var zero = new Vec4(0, 0, 0, 0);
    return function() {
      return zero;
    };
  }()});
  return {Vec4:Vec4};
}());
Object.assign(pc, function() {
  var typeNumber = "number";
  var Mat3 = function(v0, v1, v2, v3, v4, v5, v6, v7, v8) {
    if (v0 && v0.length === 9) {
      this.data = new Float32Array(v0);
      return;
    }
    this.data = new Float32Array(9);
    if (typeof v0 === typeNumber) {
      this.data[0] = v0;
      this.data[1] = v1;
      this.data[2] = v2;
      this.data[3] = v3;
      this.data[4] = v4;
      this.data[5] = v5;
      this.data[6] = v6;
      this.data[7] = v7;
      this.data[8] = v8;
    } else {
      this.setIdentity();
    }
  };
  Object.assign(Mat3.prototype, {clone:function() {
    return (new pc.Mat3).copy(this);
  }, copy:function(rhs) {
    var src = rhs.data;
    var dst = this.data;
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
    dst[4] = src[4];
    dst[5] = src[5];
    dst[6] = src[6];
    dst[7] = src[7];
    dst[8] = src[8];
    return this;
  }, equals:function(rhs) {
    var l = this.data;
    var r = rhs.data;
    return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8];
  }, isIdentity:function() {
    var m = this.data;
    return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 1 && m[5] === 0 && m[6] === 0 && m[7] === 0 && m[8] === 1;
  }, setIdentity:function() {
    var m = this.data;
    m[0] = 1;
    m[1] = 0;
    m[2] = 0;
    m[3] = 0;
    m[4] = 1;
    m[5] = 0;
    m[6] = 0;
    m[7] = 0;
    m[8] = 1;
    return this;
  }, toString:function() {
    var t = "[";
    for (var i = 0;i < 9;i++) {
      t += this.data[i];
      t += i !== 9 ? ", " : "";
    }
    t += "]";
    return t;
  }, transpose:function() {
    var m = this.data;
    var tmp;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  }});
  Object.defineProperty(Mat3, "IDENTITY", {get:function() {
    var identity = new Mat3;
    return function() {
      return identity;
    };
  }()});
  Object.defineProperty(Mat3, "ZERO", {get:function() {
    var zero = new Mat3(0, 0, 0, 0, 0, 0, 0, 0, 0);
    return function() {
      return zero;
    };
  }()});
  return {Mat3:Mat3};
}());
Object.assign(pc, function() {
  var typeNumber = "number";
  var Mat4 = function(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {
    if (v0 && v0.length === 16) {
      this.data = new Float32Array(v0);
      return;
    }
    this.data = new Float32Array(16);
    if (typeof v0 === typeNumber) {
      this.data[0] = v0;
      this.data[1] = v1;
      this.data[2] = v2;
      this.data[3] = v3;
      this.data[4] = v4;
      this.data[5] = v5;
      this.data[6] = v6;
      this.data[7] = v7;
      this.data[8] = v8;
      this.data[9] = v9;
      this.data[10] = v10;
      this.data[11] = v11;
      this.data[12] = v12;
      this.data[13] = v13;
      this.data[14] = v14;
      this.data[15] = v15;
    } else {
      this.setIdentity();
    }
  };
  Object.assign(Mat4.prototype, {add2:function(lhs, rhs) {
    var a = lhs.data, b = rhs.data, r = this.data;
    r[0] = a[0] + b[0];
    r[1] = a[1] + b[1];
    r[2] = a[2] + b[2];
    r[3] = a[3] + b[3];
    r[4] = a[4] + b[4];
    r[5] = a[5] + b[5];
    r[6] = a[6] + b[6];
    r[7] = a[7] + b[7];
    r[8] = a[8] + b[8];
    r[9] = a[9] + b[9];
    r[10] = a[10] + b[10];
    r[11] = a[11] + b[11];
    r[12] = a[12] + b[12];
    r[13] = a[13] + b[13];
    r[14] = a[14] + b[14];
    r[15] = a[15] + b[15];
    return this;
  }, add:function(rhs) {
    return this.add2(this, rhs);
  }, clone:function() {
    return (new pc.Mat4).copy(this);
  }, copy:function(rhs) {
    var src = rhs.data, dst = this.data;
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
    dst[4] = src[4];
    dst[5] = src[5];
    dst[6] = src[6];
    dst[7] = src[7];
    dst[8] = src[8];
    dst[9] = src[9];
    dst[10] = src[10];
    dst[11] = src[11];
    dst[12] = src[12];
    dst[13] = src[13];
    dst[14] = src[14];
    dst[15] = src[15];
    return this;
  }, equals:function(rhs) {
    var l = this.data, r = rhs.data;
    return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8] && l[9] === r[9] && l[10] === r[10] && l[11] === r[11] && l[12] === r[12] && l[13] === r[13] && l[14] === r[14] && l[15] === r[15];
  }, isIdentity:function() {
    var m = this.data;
    return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
  }, mul2:function(lhs, rhs) {
    var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b0, b1, b2, b3, a = lhs.data, b = rhs.data, r = this.data;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a30 = a[12];
    a31 = a[13];
    a32 = a[14];
    a33 = a[15];
    b0 = b[0];
    b1 = b[1];
    b2 = b[2];
    b3 = b[3];
    r[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
    r[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
    r[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
    r[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    r[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
    r[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
    r[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
    r[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    r[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
    r[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
    r[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
    r[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
    r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
    r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
    r[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
    return this;
  }, mul:function(rhs) {
    return this.mul2(this, rhs);
  }, transformPoint:function(vec, res) {
    var x, y, z, m = this.data, v = vec.data;
    res = res === undefined ? new pc.Vec3 : res;
    x = v[0] * m[0] + v[1] * m[4] + v[2] * m[8] + m[12];
    y = v[0] * m[1] + v[1] * m[5] + v[2] * m[9] + m[13];
    z = v[0] * m[2] + v[1] * m[6] + v[2] * m[10] + m[14];
    return res.set(x, y, z);
  }, transformVector:function(vec, res) {
    var x, y, z, m = this.data, v = vec.data;
    res = res === undefined ? new pc.Vec3 : res;
    x = v[0] * m[0] + v[1] * m[4] + v[2] * m[8];
    y = v[0] * m[1] + v[1] * m[5] + v[2] * m[9];
    z = v[0] * m[2] + v[1] * m[6] + v[2] * m[10];
    return res.set(x, y, z);
  }, transformVec4:function(vec, res) {
    var x, y, z, w, m = this.data, v = vec.data;
    res = res === undefined ? new pc.Vec4 : res;
    x = v[0] * m[0] + v[1] * m[4] + v[2] * m[8] + v[3] * m[12];
    y = v[0] * m[1] + v[1] * m[5] + v[2] * m[9] + v[3] * m[13];
    z = v[0] * m[2] + v[1] * m[6] + v[2] * m[10] + v[3] * m[14];
    w = v[0] * m[3] + v[1] * m[7] + v[2] * m[11] + v[3] * m[15];
    return res.set(x, y, z, w);
  }, setLookAt:function() {
    var x, y, z;
    x = new pc.Vec3;
    y = new pc.Vec3;
    z = new pc.Vec3;
    return function(position, target, up) {
      z.sub2(position, target).normalize();
      y.copy(up).normalize();
      x.cross(y, z).normalize();
      y.cross(z, x);
      var r = this.data;
      r[0] = x.x;
      r[1] = x.y;
      r[2] = x.z;
      r[3] = 0;
      r[4] = y.x;
      r[5] = y.y;
      r[6] = y.z;
      r[7] = 0;
      r[8] = z.x;
      r[9] = z.y;
      r[10] = z.z;
      r[11] = 0;
      r[12] = position.x;
      r[13] = position.y;
      r[14] = position.z;
      r[15] = 1;
      return this;
    };
  }(), setFrustum:function(left, right, bottom, top, znear, zfar) {
    var temp1, temp2, temp3, temp4, r;
    temp1 = 2 * znear;
    temp2 = right - left;
    temp3 = top - bottom;
    temp4 = zfar - znear;
    r = this.data;
    r[0] = temp1 / temp2;
    r[1] = 0;
    r[2] = 0;
    r[3] = 0;
    r[4] = 0;
    r[5] = temp1 / temp3;
    r[6] = 0;
    r[7] = 0;
    r[8] = (right + left) / temp2;
    r[9] = (top + bottom) / temp3;
    r[10] = (-zfar - znear) / temp4;
    r[11] = -1;
    r[12] = 0;
    r[13] = 0;
    r[14] = -temp1 * zfar / temp4;
    r[15] = 0;
    return this;
  }, setPerspective:function(fov, aspect, znear, zfar, fovIsHorizontal) {
    var xmax, ymax;
    if (!fovIsHorizontal) {
      ymax = znear * Math.tan(fov * Math.PI / 360);
      xmax = ymax * aspect;
    } else {
      xmax = znear * Math.tan(fov * Math.PI / 360);
      ymax = xmax / aspect;
    }
    return this.setFrustum(-xmax, xmax, -ymax, ymax, znear, zfar);
  }, setOrtho:function(left, right, bottom, top, near, far) {
    var r = this.data;
    r[0] = 2 / (right - left);
    r[1] = 0;
    r[2] = 0;
    r[3] = 0;
    r[4] = 0;
    r[5] = 2 / (top - bottom);
    r[6] = 0;
    r[7] = 0;
    r[8] = 0;
    r[9] = 0;
    r[10] = -2 / (far - near);
    r[11] = 0;
    r[12] = -(right + left) / (right - left);
    r[13] = -(top + bottom) / (top - bottom);
    r[14] = -(far + near) / (far - near);
    r[15] = 1;
    return this;
  }, setFromAxisAngle:function(axis, angle) {
    var x, y, z, c, s, t, tx, ty, m;
    angle *= pc.math.DEG_TO_RAD;
    x = axis.x;
    y = axis.y;
    z = axis.z;
    c = Math.cos(angle);
    s = Math.sin(angle);
    t = 1 - c;
    tx = t * x;
    ty = t * y;
    m = this.data;
    m[0] = tx * x + c;
    m[1] = tx * y + s * z;
    m[2] = tx * z - s * y;
    m[3] = 0;
    m[4] = tx * y - s * z;
    m[5] = ty * y + c;
    m[6] = ty * z + s * x;
    m[7] = 0;
    m[8] = tx * z + s * y;
    m[9] = ty * z - x * s;
    m[10] = t * z * z + c;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    return this;
  }, setTranslate:function(x, y, z) {
    var m = this.data;
    m[0] = 1;
    m[1] = 0;
    m[2] = 0;
    m[3] = 0;
    m[4] = 0;
    m[5] = 1;
    m[6] = 0;
    m[7] = 0;
    m[8] = 0;
    m[9] = 0;
    m[10] = 1;
    m[11] = 0;
    m[12] = x;
    m[13] = y;
    m[14] = z;
    m[15] = 1;
    return this;
  }, setScale:function(x, y, z) {
    var m = this.data;
    m[0] = x;
    m[1] = 0;
    m[2] = 0;
    m[3] = 0;
    m[4] = 0;
    m[5] = y;
    m[6] = 0;
    m[7] = 0;
    m[8] = 0;
    m[9] = 0;
    m[10] = z;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    return this;
  }, invert:function() {
    var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b00, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10, b11, det, invDet, m;
    m = this.data;
    a00 = m[0];
    a01 = m[1];
    a02 = m[2];
    a03 = m[3];
    a10 = m[4];
    a11 = m[5];
    a12 = m[6];
    a13 = m[7];
    a20 = m[8];
    a21 = m[9];
    a22 = m[10];
    a23 = m[11];
    a30 = m[12];
    a31 = m[13];
    a32 = m[14];
    a33 = m[15];
    b00 = a00 * a11 - a01 * a10;
    b01 = a00 * a12 - a02 * a10;
    b02 = a00 * a13 - a03 * a10;
    b03 = a01 * a12 - a02 * a11;
    b04 = a01 * a13 - a03 * a11;
    b05 = a02 * a13 - a03 * a12;
    b06 = a20 * a31 - a21 * a30;
    b07 = a20 * a32 - a22 * a30;
    b08 = a20 * a33 - a23 * a30;
    b09 = a21 * a32 - a22 * a31;
    b10 = a21 * a33 - a23 * a31;
    b11 = a22 * a33 - a23 * a32;
    det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (det === 0) {
      this.setIdentity();
    } else {
      invDet = 1 / det;
      m[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
      m[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
      m[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
      m[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
      m[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
      m[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
      m[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
      m[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
      m[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
      m[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
      m[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
      m[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
      m[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
      m[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
      m[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
      m[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
    }
    return this;
  }, set:function(src) {
    var dst = this.data;
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
    dst[4] = src[4];
    dst[5] = src[5];
    dst[6] = src[6];
    dst[7] = src[7];
    dst[8] = src[8];
    dst[9] = src[9];
    dst[10] = src[10];
    dst[11] = src[11];
    dst[12] = src[12];
    dst[13] = src[13];
    dst[14] = src[14];
    dst[15] = src[15];
    return this;
  }, setIdentity:function() {
    var m = this.data;
    m[0] = 1;
    m[1] = 0;
    m[2] = 0;
    m[3] = 0;
    m[4] = 0;
    m[5] = 1;
    m[6] = 0;
    m[7] = 0;
    m[8] = 0;
    m[9] = 0;
    m[10] = 1;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    return this;
  }, setTRS:function(t, r, s) {
    var tx, ty, tz, qx, qy, qz, qw, sx, sy, sz, x2, y2, z2, xx, xy, xz, yy, yz, zz, wx, wy, wz, m;
    tx = t.x;
    ty = t.y;
    tz = t.z;
    qx = r.x;
    qy = r.y;
    qz = r.z;
    qw = r.w;
    sx = s.x;
    sy = s.y;
    sz = s.z;
    x2 = qx + qx;
    y2 = qy + qy;
    z2 = qz + qz;
    xx = qx * x2;
    xy = qx * y2;
    xz = qx * z2;
    yy = qy * y2;
    yz = qy * z2;
    zz = qz * z2;
    wx = qw * x2;
    wy = qw * y2;
    wz = qw * z2;
    m = this.data;
    m[0] = (1 - (yy + zz)) * sx;
    m[1] = (xy + wz) * sx;
    m[2] = (xz - wy) * sx;
    m[3] = 0;
    m[4] = (xy - wz) * sy;
    m[5] = (1 - (xx + zz)) * sy;
    m[6] = (yz + wx) * sy;
    m[7] = 0;
    m[8] = (xz + wy) * sz;
    m[9] = (yz - wx) * sz;
    m[10] = (1 - (xx + yy)) * sz;
    m[11] = 0;
    m[12] = tx;
    m[13] = ty;
    m[14] = tz;
    m[15] = 1;
    return this;
  }, transpose:function() {
    var tmp, m = this.data;
    tmp = m[1];
    m[1] = m[4];
    m[4] = tmp;
    tmp = m[2];
    m[2] = m[8];
    m[8] = tmp;
    tmp = m[3];
    m[3] = m[12];
    m[12] = tmp;
    tmp = m[6];
    m[6] = m[9];
    m[9] = tmp;
    tmp = m[7];
    m[7] = m[13];
    m[13] = tmp;
    tmp = m[11];
    m[11] = m[14];
    m[14] = tmp;
    return this;
  }, invertTo3x3:function(res) {
    var a11, a21, a31, a12, a22, a32, a13, a23, a33, m, r, det, idet;
    m = this.data;
    r = res.data;
    var m0 = m[0];
    var m1 = m[1];
    var m2 = m[2];
    var m4 = m[4];
    var m5 = m[5];
    var m6 = m[6];
    var m8 = m[8];
    var m9 = m[9];
    var m10 = m[10];
    a11 = m10 * m5 - m6 * m9;
    a21 = -m10 * m1 + m2 * m9;
    a31 = m6 * m1 - m2 * m5;
    a12 = -m10 * m4 + m6 * m8;
    a22 = m10 * m0 - m2 * m8;
    a32 = -m6 * m0 + m2 * m4;
    a13 = m9 * m4 - m5 * m8;
    a23 = -m9 * m0 + m1 * m8;
    a33 = m5 * m0 - m1 * m4;
    det = m0 * a11 + m1 * a12 + m2 * a13;
    if (det === 0) {
      return this;
    }
    idet = 1 / det;
    r[0] = idet * a11;
    r[1] = idet * a21;
    r[2] = idet * a31;
    r[3] = idet * a12;
    r[4] = idet * a22;
    r[5] = idet * a32;
    r[6] = idet * a13;
    r[7] = idet * a23;
    r[8] = idet * a33;
    return this;
  }, getTranslation:function(t) {
    t = t === undefined ? new pc.Vec3 : t;
    return t.set(this.data[12], this.data[13], this.data[14]);
  }, getX:function(x) {
    x = x === undefined ? new pc.Vec3 : x;
    return x.set(this.data[0], this.data[1], this.data[2]);
  }, getY:function(y) {
    y = y === undefined ? new pc.Vec3 : y;
    return y.set(this.data[4], this.data[5], this.data[6]);
  }, getZ:function(z) {
    z = z === undefined ? new pc.Vec3 : z;
    return z.set(this.data[8], this.data[9], this.data[10]);
  }, getScale:function() {
    var x, y, z;
    x = new pc.Vec3;
    y = new pc.Vec3;
    z = new pc.Vec3;
    return function(scale) {
      scale = scale === undefined ? new pc.Vec3 : scale;
      this.getX(x);
      this.getY(y);
      this.getZ(z);
      scale.set(x.length(), y.length(), z.length());
      return scale;
    };
  }(), setFromEulerAngles:function(ex, ey, ez) {
    var s1, c1, s2, c2, s3, c3, m;
    ex *= pc.math.DEG_TO_RAD;
    ey *= pc.math.DEG_TO_RAD;
    ez *= pc.math.DEG_TO_RAD;
    s1 = Math.sin(-ex);
    c1 = Math.cos(-ex);
    s2 = Math.sin(-ey);
    c2 = Math.cos(-ey);
    s3 = Math.sin(-ez);
    c3 = Math.cos(-ez);
    m = this.data;
    m[0] = c2 * c3;
    m[1] = -c2 * s3;
    m[2] = s2;
    m[3] = 0;
    m[4] = c1 * s3 + c3 * s1 * s2;
    m[5] = c1 * c3 - s1 * s2 * s3;
    m[6] = -c2 * s1;
    m[7] = 0;
    m[8] = s1 * s3 - c1 * c3 * s2;
    m[9] = c3 * s1 + c1 * s2 * s3;
    m[10] = c1 * c2;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    return this;
  }, getEulerAngles:function() {
    var scale = new pc.Vec3;
    return function(eulers) {
      var x, y, z, sx, sy, sz, m, halfPi;
      eulers = eulers === undefined ? new pc.Vec3 : eulers;
      this.getScale(scale);
      sx = scale.x;
      sy = scale.y;
      sz = scale.z;
      m = this.data;
      y = Math.asin(-m[2] / sx);
      halfPi = Math.PI * 0.5;
      if (y < halfPi) {
        if (y > -halfPi) {
          x = Math.atan2(m[6] / sy, m[10] / sz);
          z = Math.atan2(m[1] / sx, m[0] / sx);
        } else {
          z = 0;
          x = -Math.atan2(m[4] / sy, m[5] / sy);
        }
      } else {
        z = 0;
        x = Math.atan2(m[4] / sy, m[5] / sy);
      }
      return eulers.set(x, y, z).scale(pc.math.RAD_TO_DEG);
    };
  }(), toString:function() {
    var i, t;
    t = "[";
    for (i = 0;i < 16;i += 1) {
      t += this.data[i];
      t += i !== 15 ? ", " : "";
    }
    t += "]";
    return t;
  }});
  Object.defineProperty(Mat4, "IDENTITY", {get:function() {
    var identity = new Mat4;
    return function() {
      return identity;
    };
  }()});
  Object.defineProperty(Mat4, "ZERO", {get:function() {
    var zero = new Mat4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    return function() {
      return zero;
    };
  }()});
  return {Mat4:Mat4};
}());
Object.assign(pc, function() {
  var Quat = function(x, y, z, w) {
    if (x && x.length === 4) {
      this.x = x[0];
      this.y = x[1];
      this.z = x[2];
      this.w = x[3];
    } else {
      this.x = x === undefined ? 0 : x;
      this.y = y === undefined ? 0 : y;
      this.z = z === undefined ? 0 : z;
      this.w = w === undefined ? 1 : w;
    }
  };
  Object.assign(Quat.prototype, {clone:function() {
    return new pc.Quat(this.x, this.y, this.z, this.w);
  }, conjugate:function() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    return this;
  }, copy:function(rhs) {
    this.x = rhs.x;
    this.y = rhs.y;
    this.z = rhs.z;
    this.w = rhs.w;
    return this;
  }, equals:function(rhs) {
    return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
  }, getAxisAngle:function(axis) {
    var rad = Math.acos(this.w) * 2;
    var s = Math.sin(rad / 2);
    if (s !== 0) {
      axis.x = this.x / s;
      axis.y = this.y / s;
      axis.z = this.z / s;
      if (axis.x < 0 || axis.y < 0 || axis.z < 0) {
        axis.x *= -1;
        axis.y *= -1;
        axis.z *= -1;
        rad *= -1;
      }
    } else {
      axis.x = 1;
      axis.y = 0;
      axis.z = 0;
    }
    return rad * pc.math.RAD_TO_DEG;
  }, getEulerAngles:function(eulers) {
    var x, y, z, qx, qy, qz, qw, a2;
    eulers = eulers === undefined ? new pc.Vec3 : eulers;
    qx = this.x;
    qy = this.y;
    qz = this.z;
    qw = this.w;
    a2 = 2 * (qw * qy - qx * qz);
    if (a2 <= -0.99999) {
      x = 2 * Math.atan2(qx, qw);
      y = -Math.PI / 2;
      z = 0;
    } else {
      if (a2 >= 0.99999) {
        x = 2 * Math.atan2(qx, qw);
        y = Math.PI / 2;
        z = 0;
      } else {
        x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));
        y = Math.asin(a2);
        z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
      }
    }
    return eulers.set(x, y, z).scale(pc.math.RAD_TO_DEG);
  }, invert:function() {
    return this.conjugate().normalize();
  }, length:function() {
    var x, y, z, w;
    x = this.x;
    y = this.y;
    z = this.z;
    w = this.w;
    return Math.sqrt(x * x + y * y + z * z + w * w);
  }, lengthSq:function() {
    var x, y, z, w;
    return x * x + y * y + z * z + w * w;
  }, mul:function(rhs) {
    var q1x, q1y, q1z, q1w, q2x, q2y, q2z, q2w;
    q1x = this.x;
    q1y = this.y;
    q1z = this.z;
    q1w = this.w;
    q2x = rhs.x;
    q2y = rhs.y;
    q2z = rhs.z;
    q2w = rhs.w;
    this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
    this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
    this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
    this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
    return this;
  }, mul2:function(lhs, rhs) {
    var q1x, q1y, q1z, q1w, q2x, q2y, q2z, q2w;
    q1x = lhs.x;
    q1y = lhs.y;
    q1z = lhs.z;
    q1w = lhs.w;
    q2x = rhs.x;
    q2y = rhs.y;
    q2z = rhs.z;
    q2w = rhs.w;
    this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
    this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
    this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
    this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
    return this;
  }, normalize:function() {
    var len = this.length();
    if (len === 0) {
      this.x = this.y = this.z = 0;
      this.w = 1;
    } else {
      len = 1 / len;
      this.x *= len;
      this.y *= len;
      this.z *= len;
      this.w *= len;
    }
    return this;
  }, set:function(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }, setFromAxisAngle:function(axis, angle) {
    var sa, ca;
    angle *= 0.5 * pc.math.DEG_TO_RAD;
    sa = Math.sin(angle);
    ca = Math.cos(angle);
    this.x = sa * axis.x;
    this.y = sa * axis.y;
    this.z = sa * axis.z;
    this.w = ca;
    return this;
  }, setFromEulerAngles:function(ex, ey, ez) {
    var sx, cx, sy, cy, sz, cz, halfToRad;
    halfToRad = 0.5 * pc.math.DEG_TO_RAD;
    ex *= halfToRad;
    ey *= halfToRad;
    ez *= halfToRad;
    sx = Math.sin(ex);
    cx = Math.cos(ex);
    sy = Math.sin(ey);
    cy = Math.cos(ey);
    sz = Math.sin(ez);
    cz = Math.cos(ez);
    this.x = sx * cy * cz - cx * sy * sz;
    this.y = cx * sy * cz + sx * cy * sz;
    this.z = cx * cy * sz - sx * sy * cz;
    this.w = cx * cy * cz + sx * sy * sz;
    return this;
  }, setFromMat4:function(m) {
    var m00, m01, m02, m10, m11, m12, m20, m21, m22, tr, s, rs, lx, ly, lz;
    m = m.data;
    m00 = m[0];
    m01 = m[1];
    m02 = m[2];
    m10 = m[4];
    m11 = m[5];
    m12 = m[6];
    m20 = m[8];
    m21 = m[9];
    m22 = m[10];
    lx = 1 / Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
    ly = 1 / Math.sqrt(m10 * m10 + m11 * m11 + m12 * m12);
    lz = 1 / Math.sqrt(m20 * m20 + m21 * m21 + m22 * m22);
    m00 *= lx;
    m01 *= lx;
    m02 *= lx;
    m10 *= ly;
    m11 *= ly;
    m12 *= ly;
    m20 *= lz;
    m21 *= lz;
    m22 *= lz;
    tr = m00 + m11 + m22;
    if (tr >= 0) {
      s = Math.sqrt(tr + 1);
      this.w = s * 0.5;
      s = 0.5 / s;
      this.x = (m12 - m21) * s;
      this.y = (m20 - m02) * s;
      this.z = (m01 - m10) * s;
    } else {
      if (m00 > m11) {
        if (m00 > m22) {
          rs = m00 - (m11 + m22) + 1;
          rs = Math.sqrt(rs);
          this.x = rs * 0.5;
          rs = 0.5 / rs;
          this.w = (m12 - m21) * rs;
          this.y = (m01 + m10) * rs;
          this.z = (m02 + m20) * rs;
        } else {
          rs = m22 - (m00 + m11) + 1;
          rs = Math.sqrt(rs);
          this.z = rs * 0.5;
          rs = 0.5 / rs;
          this.w = (m01 - m10) * rs;
          this.x = (m20 + m02) * rs;
          this.y = (m21 + m12) * rs;
        }
      } else {
        if (m11 > m22) {
          rs = m11 - (m22 + m00) + 1;
          rs = Math.sqrt(rs);
          this.y = rs * 0.5;
          rs = 0.5 / rs;
          this.w = (m20 - m02) * rs;
          this.z = (m12 + m21) * rs;
          this.x = (m10 + m01) * rs;
        } else {
          rs = m22 - (m00 + m11) + 1;
          rs = Math.sqrt(rs);
          this.z = rs * 0.5;
          rs = 0.5 / rs;
          this.w = (m01 - m10) * rs;
          this.x = (m20 + m02) * rs;
          this.y = (m21 + m12) * rs;
        }
      }
    }
    return this;
  }, slerp:function(lhs, rhs, alpha) {
    var lx, ly, lz, lw, rx, ry, rz, rw;
    lx = lhs.x;
    ly = lhs.y;
    lz = lhs.z;
    lw = lhs.w;
    rx = rhs.x;
    ry = rhs.y;
    rz = rhs.z;
    rw = rhs.w;
    var cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;
    if (cosHalfTheta < 0) {
      rw = -rw;
      rx = -rx;
      ry = -ry;
      rz = -rz;
      cosHalfTheta = -cosHalfTheta;
    }
    if (Math.abs(cosHalfTheta) >= 1) {
      this.w = lw;
      this.x = lx;
      this.y = ly;
      this.z = lz;
      return this;
    }
    var halfTheta = Math.acos(cosHalfTheta);
    var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
    if (Math.abs(sinHalfTheta) < 0.001) {
      this.w = lw * 0.5 + rw * 0.5;
      this.x = lx * 0.5 + rx * 0.5;
      this.y = ly * 0.5 + ry * 0.5;
      this.z = lz * 0.5 + rz * 0.5;
      return this;
    }
    var ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;
    var ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;
    this.w = lw * ratioA + rw * ratioB;
    this.x = lx * ratioA + rx * ratioB;
    this.y = ly * ratioA + ry * ratioB;
    this.z = lz * ratioA + rz * ratioB;
    return this;
  }, transformVector:function(vec, res) {
    if (res === undefined) {
      res = new pc.Vec3;
    }
    var x = vec.x, y = vec.y, z = vec.z;
    var qx = this.x, qy = this.y, qz = this.z, qw = this.w;
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    res.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    res.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    res.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return res;
  }, toString:function() {
    return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]";
  }});
  Object.defineProperty(Quat, "IDENTITY", {get:function() {
    var identity = new Quat;
    return function() {
      return identity;
    };
  }()});
  Object.defineProperty(Quat, "ZERO", {get:function() {
    var zero = new Quat(0, 0, 0, 0);
    return function() {
      return zero;
    };
  }()});
  return {Quat:Quat};
}());
Object.assign(pc, function() {
  var CURVE_LINEAR = 0;
  var CURVE_SMOOTHSTEP = 1;
  var CURVE_CATMULL = 2;
  var CURVE_CARDINAL = 3;
  var Curve = function(data) {
    this.keys = [];
    this.type = CURVE_SMOOTHSTEP;
    this.tension = 0.5;
    if (data) {
      for (var i = 0;i < data.length - 1;i += 2) {
        this.keys.push([data[i], data[i + 1]]);
      }
    }
    this.sort();
  };
  Object.assign(Curve.prototype, {add:function(time, value) {
    var keys = this.keys;
    var len = keys.length;
    var i = 0;
    for (;i < len;i++) {
      if (keys[i][0] > time) {
        break;
      }
    }
    var key = [time, value];
    this.keys.splice(i, 0, key);
    return key;
  }, get:function(index) {
    return this.keys[index];
  }, sort:function() {
    this.keys.sort(function(a, b) {
      return a[0] - b[0];
    });
  }, value:function(time) {
    var i, len;
    var keys = this.keys;
    if (!keys.length) {
      return 0;
    }
    if (time < keys[0][0]) {
      return keys[0][1];
    } else {
      if (time > keys[keys.length - 1][0]) {
        return keys[keys.length - 1][1];
      }
    }
    var leftTime = 0;
    var leftValue = keys.length ? keys[0][1] : 0;
    var rightTime = 1;
    var rightValue = 0;
    for (i = 0, len = keys.length;i < len;i++) {
      if (keys[i][0] === time) {
        return keys[i][1];
      }
      rightValue = keys[i][1];
      if (time < keys[i][0]) {
        rightTime = keys[i][0];
        break;
      }
      leftTime = keys[i][0];
      leftValue = keys[i][1];
    }
    var div = rightTime - leftTime;
    var interpolation = div === 0 ? 0 : (time - leftTime) / div;
    if (this.type === CURVE_SMOOTHSTEP) {
      interpolation *= interpolation * (3 - 2 * interpolation);
    } else {
      if (this.type === CURVE_CATMULL || this.type === CURVE_CARDINAL) {
        var p1 = leftValue;
        var p2 = rightValue;
        var p0 = p1 + (p1 - p2);
        var p3 = p2 + (p2 - p1);
        var dt1 = rightTime - leftTime;
        var dt0 = dt1;
        var dt2 = dt1;
        if (i > 0) {
          i--;
        }
        if (i > 0) {
          p0 = keys[i - 1][1];
          dt0 = keys[i][0] - keys[i - 1][0];
        }
        if (keys.length > i + 1) {
          dt1 = keys[i + 1][0] - keys[i][0];
        }
        if (keys.length > i + 2) {
          dt2 = keys[i + 2][0] - keys[i + 1][0];
          p3 = keys[i + 2][1];
        }
        p0 = p1 + (p0 - p1) * dt1 / dt0;
        p3 = p2 + (p3 - p2) * dt1 / dt2;
        if (this.type === CURVE_CATMULL) {
          return this._interpolateCatmullRom(p0, p1, p2, p3, interpolation);
        }
        return this._interpolateCardinal(p0, p1, p2, p3, interpolation, this.tension);
      }
    }
    return pc.math.lerp(leftValue, rightValue, interpolation);
  }, _interpolateHermite:function(p0, p1, t0, t1, s) {
    var s2 = s * s;
    var s3 = s * s * s;
    var h0 = 2 * s3 - 3 * s2 + 1;
    var h1 = -2 * s3 + 3 * s2;
    var h2 = s3 - 2 * s2 + s;
    var h3 = s3 - s2;
    return p0 * h0 + p1 * h1 + t0 * h2 + t1 * h3;
  }, _interpolateCardinal:function(p0, p1, p2, p3, s, t) {
    var t0 = t * (p2 - p0);
    var t1 = t * (p3 - p1);
    return this._interpolateHermite(p1, p2, t0, t1, s);
  }, _interpolateCatmullRom:function(p0, p1, p2, p3, s) {
    return this._interpolateCardinal(p0, p1, p2, p3, s, 0.5);
  }, closest:function(time) {
    var keys = this.keys;
    var length = keys.length;
    var min = 2;
    var result = null;
    for (var i = 0;i < length;i++) {
      var diff = Math.abs(time - keys[i][0]);
      if (min >= diff) {
        min = diff;
        result = keys[i];
      } else {
        break;
      }
    }
    return result;
  }, clone:function() {
    var result = new pc.Curve;
    result.keys = pc.extend(result.keys, this.keys);
    result.type = this.type;
    return result;
  }, quantize:function(precision) {
    precision = Math.max(precision, 2);
    var values = new Float32Array(precision);
    var step = 1.0 / (precision - 1);
    for (var i = 0;i < precision;i++) {
      var value = this.value(step * i);
      values[i] = value;
    }
    return values;
  }});
  Object.defineProperty(Curve.prototype, "length", {get:function() {
    return this.keys.length;
  }});
  return {Curve:Curve, CURVE_LINEAR:CURVE_LINEAR, CURVE_SMOOTHSTEP:CURVE_SMOOTHSTEP, CURVE_CATMULL:CURVE_CATMULL, CURVE_CARDINAL:CURVE_CARDINAL};
}());
Object.assign(pc, function() {
  var CurveSet = function() {
    var i;
    this.curves = [];
    this._type = pc.CURVE_SMOOTHSTEP;
    if (arguments.length > 1) {
      for (i = 0;i < arguments.length;i++) {
        this.curves.push(new pc.Curve(arguments[i]));
      }
    } else {
      if (arguments.length === 0) {
        this.curves.push(new pc.Curve);
      } else {
        var arg = arguments[0];
        if (pc.type(arg) === "number") {
          for (i = 0;i < arg;i++) {
            this.curves.push(new pc.Curve);
          }
        } else {
          for (i = 0;i < arg.length;i++) {
            this.curves.push(new pc.Curve(arg[i]));
          }
        }
      }
    }
  };
  Object.assign(CurveSet.prototype, {get:function(index) {
    return this.curves[index];
  }, value:function(time, result) {
    var length = this.curves.length;
    result = result || [];
    result.length = length;
    for (var i = 0;i < length;i++) {
      result[i] = this.curves[i].value(time);
    }
    return result;
  }, clone:function() {
    var result = new pc.CurveSet;
    result.curves = [];
    for (var i = 0;i < this.curves.length;i++) {
      result.curves.push(this.curves[i].clone());
    }
    result._type = this._type;
    return result;
  }, quantize:function(precision) {
    precision = Math.max(precision, 2);
    var numCurves = this.curves.length;
    var values = new Float32Array(precision * numCurves);
    var step = 1.0 / (precision - 1);
    var temp = [];
    for (var i = 0;i < precision;i++) {
      var value = this.value(step * i, temp);
      if (numCurves == 1) {
        values[i] = value[0];
      } else {
        for (var j = 0;j < numCurves;j++) {
          values[i * numCurves + j] = value[j];
        }
      }
    }
    return values;
  }});
  Object.defineProperty(CurveSet.prototype, "length", {get:function() {
    return this.curves.length;
  }});
  Object.defineProperty(CurveSet.prototype, "type", {get:function() {
    return this._type;
  }, set:function(value) {
    this._type = value;
    for (var i = 0;i < this.curves.length;i++) {
      this.curves[i].type = value;
    }
  }});
  return {CurveSet:CurveSet};
}());
Object.assign(pc, function() {
  var tmpVecA = new pc.Vec3;
  var tmpVecB = new pc.Vec3;
  var tmpVecC = new pc.Vec3;
  var tmpVecD = new pc.Vec3;
  var tmpVecE = new pc.Vec3;
  var BoundingBox = function BoundingBox(center, halfExtents) {
    this.center = center || new pc.Vec3(0, 0, 0);
    this.halfExtents = halfExtents || new pc.Vec3(0.5, 0.5, 0.5);
    this._min = new pc.Vec3;
    this._max = new pc.Vec3;
  };
  Object.assign(BoundingBox.prototype, {add:function(other) {
    var tc = this.center.data;
    var tcx = tc[0];
    var tcy = tc[1];
    var tcz = tc[2];
    var th = this.halfExtents.data;
    var thx = th[0];
    var thy = th[1];
    var thz = th[2];
    var tminx = tcx - thx;
    var tmaxx = tcx + thx;
    var tminy = tcy - thy;
    var tmaxy = tcy + thy;
    var tminz = tcz - thz;
    var tmaxz = tcz + thz;
    var oc = other.center.data;
    var ocx = oc[0];
    var ocy = oc[1];
    var ocz = oc[2];
    var oh = other.halfExtents.data;
    var ohx = oh[0];
    var ohy = oh[1];
    var ohz = oh[2];
    var ominx = ocx - ohx;
    var omaxx = ocx + ohx;
    var ominy = ocy - ohy;
    var omaxy = ocy + ohy;
    var ominz = ocz - ohz;
    var omaxz = ocz + ohz;
    if (ominx < tminx) {
      tminx = ominx;
    }
    if (omaxx > tmaxx) {
      tmaxx = omaxx;
    }
    if (ominy < tminy) {
      tminy = ominy;
    }
    if (omaxy > tmaxy) {
      tmaxy = omaxy;
    }
    if (ominz < tminz) {
      tminz = ominz;
    }
    if (omaxz > tmaxz) {
      tmaxz = omaxz;
    }
    tc[0] = (tminx + tmaxx) * 0.5;
    tc[1] = (tminy + tmaxy) * 0.5;
    tc[2] = (tminz + tmaxz) * 0.5;
    th[0] = (tmaxx - tminx) * 0.5;
    th[1] = (tmaxy - tminy) * 0.5;
    th[2] = (tmaxz - tminz) * 0.5;
  }, copy:function(src) {
    this.center.copy(src.center);
    this.halfExtents.copy(src.halfExtents);
    this.type = src.type;
  }, clone:function() {
    return new pc.BoundingBox(this.center.clone(), this.halfExtents.clone());
  }, intersects:function(other) {
    var aMax = this.getMax();
    var aMin = this.getMin();
    var bMax = other.getMax();
    var bMin = other.getMin();
    return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
  }, _intersectsRay:function(ray, point) {
    var tMin = tmpVecA.copy(this.getMin()).sub(ray.origin).data;
    var tMax = tmpVecB.copy(this.getMax()).sub(ray.origin).data;
    var dir = ray.direction.data;
    for (var i = 0;i < 3;i++) {
      if (dir[i] === 0) {
        tMin[i] = tMin[i] < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
        tMax[i] = tMax[i] < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
      } else {
        tMin[i] /= dir[i];
        tMax[i] /= dir[i];
      }
    }
    var realMin = tmpVecC.set(Math.min(tMin[0], tMax[0]), Math.min(tMin[1], tMax[1]), Math.min(tMin[2], tMax[2])).data;
    var realMax = tmpVecD.set(Math.max(tMin[0], tMax[0]), Math.max(tMin[1], tMax[1]), Math.max(tMin[2], tMax[2])).data;
    var minMax = Math.min(Math.min(realMax[0], realMax[1]), realMax[2]);
    var maxMin = Math.max(Math.max(realMin[0], realMin[1]), realMin[2]);
    var intersects = minMax >= maxMin && maxMin >= 0;
    if (intersects) {
      point.copy(ray.direction).scale(maxMin).add(ray.origin);
    }
    return intersects;
  }, _fastIntersectsRay:function(ray) {
    var diff = tmpVecA;
    var cross = tmpVecB;
    var prod = tmpVecC;
    var absDiff = tmpVecD;
    var absDir = tmpVecE;
    var rayDir = ray.direction;
    diff.sub2(ray.origin, this.center);
    absDiff.set(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));
    prod.mul2(diff, rayDir);
    if (absDiff.x > this.halfExtents.x && prod.x >= 0) {
      return false;
    }
    if (absDiff.y > this.halfExtents.y && prod.y >= 0) {
      return false;
    }
    if (absDiff.z > this.halfExtents.z && prod.z >= 0) {
      return false;
    }
    absDir.set(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));
    cross.cross(rayDir, diff);
    cross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));
    if (cross.x > this.halfExtents.y * absDir.z + this.halfExtents.z * absDir.y) {
      return false;
    }
    if (cross.y > this.halfExtents.x * absDir.z + this.halfExtents.z * absDir.x) {
      return false;
    }
    if (cross.z > this.halfExtents.x * absDir.y + this.halfExtents.y * absDir.x) {
      return false;
    }
    return true;
  }, intersectsRay:function(ray, point) {
    if (point) {
      return this._intersectsRay(ray, point);
    }
    return this._fastIntersectsRay(ray);
  }, setMinMax:function(min, max) {
    this.center.add2(max, min).scale(0.5);
    this.halfExtents.sub2(max, min).scale(0.5);
  }, getMin:function() {
    return this._min.copy(this.center).sub(this.halfExtents);
  }, getMax:function() {
    return this._max.copy(this.center).add(this.halfExtents);
  }, containsPoint:function(point) {
    var min = this.getMin();
    var max = this.getMax();
    var i;
    for (i = 0;i < 3;++i) {
      if (point.data[i] < min.data[i] || point.data[i] > max.data[i]) {
        return false;
      }
    }
    return true;
  }, setFromTransformedAabb:function(aabb, m) {
    var bc = this.center;
    var br = this.halfExtents;
    var ac = aabb.center.data;
    var ar = aabb.halfExtents.data;
    m = m.data;
    var mx0 = m[0];
    var mx1 = m[4];
    var mx2 = m[8];
    var my0 = m[1];
    var my1 = m[5];
    var my2 = m[9];
    var mz0 = m[2];
    var mz1 = m[6];
    var mz2 = m[10];
    var mx0a = Math.abs(mx0);
    var mx1a = Math.abs(mx1);
    var mx2a = Math.abs(mx2);
    var my0a = Math.abs(my0);
    var my1a = Math.abs(my1);
    var my2a = Math.abs(my2);
    var mz0a = Math.abs(mz0);
    var mz1a = Math.abs(mz1);
    var mz2a = Math.abs(mz2);
    bc.set(m[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2], m[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2], m[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2]);
    br.set(mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2], my0a * ar[0] + my1a * ar[1] + my2a * ar[2], mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2]);
  }, compute:function(vertices) {
    var min = tmpVecA.set(vertices[0], vertices[1], vertices[2]);
    var max = tmpVecB.set(vertices[0], vertices[1], vertices[2]);
    var numVerts = vertices.length / 3;
    for (var i = 1;i < numVerts;i++) {
      var x = vertices[i * 3 + 0];
      var y = vertices[i * 3 + 1];
      var z = vertices[i * 3 + 2];
      if (x < min.x) {
        min.x = x;
      }
      if (y < min.y) {
        min.y = y;
      }
      if (z < min.z) {
        min.z = z;
      }
      if (x > max.x) {
        max.x = x;
      }
      if (y > max.y) {
        max.y = y;
      }
      if (z > max.z) {
        max.z = z;
      }
    }
    this.setMinMax(min, max);
  }, intersectsBoundingSphere:function(sphere) {
    var sq = this._distanceToBoundingSphereSq(sphere);
    if (sq <= sphere.radius * sphere.radius) {
      return true;
    }
    return false;
  }, _distanceToBoundingSphereSq:function(sphere) {
    var boxMin = this.getMin();
    var boxMax = this.getMax();
    var sq = 0;
    for (var i = 0;i < 3;++i) {
      var out = 0;
      var pn = sphere.center.data[i];
      var bMin = boxMin.data[i];
      var bMax = boxMax.data[i];
      var val = 0;
      if (pn < bMin) {
        val = bMin - pn;
        out += val * val;
      }
      if (pn > bMax) {
        val = pn - bMax;
        out += val * val;
      }
      sq += out;
    }
    return sq;
  }});
  return {BoundingBox:BoundingBox};
}());
Object.assign(pc, function() {
  var tmpVecA = new pc.Vec3;
  var tmpVecB = new pc.Vec3;
  var tmpVecC = new pc.Vec3;
  var tmpVecD = new pc.Vec3;
  function BoundingSphere(center, radius) {
    this.center = center || new pc.Vec3(0, 0, 0);
    this.radius = radius === undefined ? 0.5 : radius;
  }
  Object.assign(BoundingSphere.prototype, {containsPoint:function(point) {
    var lenSq = tmpVecA.sub2(point, this.center).lengthSq();
    var r = this.radius;
    return lenSq < r * r;
  }, compute:function(vertices) {
    var i;
    var numVerts = vertices.length / 3;
    var vertex = tmpVecA;
    var avgVertex = tmpVecB;
    var sum = tmpVecC;
    for (i = 0;i < numVerts;i++) {
      vertex.set(vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]);
      sum.addSelf(vertex);
      if (i % 100 === 0) {
        sum.scale(1 / numVerts);
        avgVertex.add(sum);
        sum.set(0, 0, 0);
      }
    }
    sum.scale(1 / numVerts);
    avgVertex.add(sum);
    this.center.copy(avgVertex);
    var maxDistSq = 0;
    var centerToVert = tmpVecD;
    for (i = 0;i < numVerts;i++) {
      vertex.set(vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]);
      centerToVert.sub2(vertex, this.center);
      maxDistSq = Math.max(centerToVert.lengthSq(), maxDistSq);
    }
    this.radius = Math.sqrt(maxDistSq);
  }, intersectsRay:function(ray, point) {
    var m = tmpVecA.copy(ray.origin).sub(this.center);
    var b = m.dot(tmpVecB.copy(ray.direction).normalize());
    var c = m.dot(m) - this.radius * this.radius;
    if (c > 0 && b > 0) {
      return null;
    }
    var discr = b * b - c;
    if (discr < 0) {
      return false;
    }
    var t = Math.abs(-b - Math.sqrt(discr));
    if (point) {
      point.copy(ray.direction).scale(t).add(ray.origin);
    }
    return true;
  }, intersectsBoundingSphere:function(sphere) {
    tmpVecA.sub2(sphere.center, this.center);
    var totalRadius = sphere.radius + this.radius;
    if (tmpVecA.lengthSq() <= totalRadius * totalRadius) {
      return true;
    }
    return false;
  }});
  return {BoundingSphere:BoundingSphere};
}());
Object.assign(pc, function() {
  var viewProj = new pc.Mat4;
  var Frustum = function Frustum(projectionMatrix, viewMatrix) {
    projectionMatrix = projectionMatrix || (new pc.Mat4).setPerspective(90, 16 / 9, 0.1, 1000);
    viewMatrix = viewMatrix || new pc.Mat4;
    this.planes = [];
    for (var i = 0;i < 6;i++) {
      this.planes[i] = [];
    }
    this.update(projectionMatrix, viewMatrix);
  };
  Object.assign(Frustum.prototype, {update:function(projectionMatrix, viewMatrix) {
    viewProj.mul2(projectionMatrix, viewMatrix);
    var vpm = viewProj.data;
    this.planes[0][0] = vpm[3] - vpm[0];
    this.planes[0][1] = vpm[7] - vpm[4];
    this.planes[0][2] = vpm[11] - vpm[8];
    this.planes[0][3] = vpm[15] - vpm[12];
    var t = Math.sqrt(this.planes[0][0] * this.planes[0][0] + this.planes[0][1] * this.planes[0][1] + this.planes[0][2] * this.planes[0][2]);
    this.planes[0][0] /= t;
    this.planes[0][1] /= t;
    this.planes[0][2] /= t;
    this.planes[0][3] /= t;
    this.planes[1][0] = vpm[3] + vpm[0];
    this.planes[1][1] = vpm[7] + vpm[4];
    this.planes[1][2] = vpm[11] + vpm[8];
    this.planes[1][3] = vpm[15] + vpm[12];
    t = Math.sqrt(this.planes[1][0] * this.planes[1][0] + this.planes[1][1] * this.planes[1][1] + this.planes[1][2] * this.planes[1][2]);
    this.planes[1][0] /= t;
    this.planes[1][1] /= t;
    this.planes[1][2] /= t;
    this.planes[1][3] /= t;
    this.planes[2][0] = vpm[3] + vpm[1];
    this.planes[2][1] = vpm[7] + vpm[5];
    this.planes[2][2] = vpm[11] + vpm[9];
    this.planes[2][3] = vpm[15] + vpm[13];
    t = Math.sqrt(this.planes[2][0] * this.planes[2][0] + this.planes[2][1] * this.planes[2][1] + this.planes[2][2] * this.planes[2][2]);
    this.planes[2][0] /= t;
    this.planes[2][1] /= t;
    this.planes[2][2] /= t;
    this.planes[2][3] /= t;
    this.planes[3][0] = vpm[3] - vpm[1];
    this.planes[3][1] = vpm[7] - vpm[5];
    this.planes[3][2] = vpm[11] - vpm[9];
    this.planes[3][3] = vpm[15] - vpm[13];
    t = Math.sqrt(this.planes[3][0] * this.planes[3][0] + this.planes[3][1] * this.planes[3][1] + this.planes[3][2] * this.planes[3][2]);
    this.planes[3][0] /= t;
    this.planes[3][1] /= t;
    this.planes[3][2] /= t;
    this.planes[3][3] /= t;
    this.planes[4][0] = vpm[3] - vpm[2];
    this.planes[4][1] = vpm[7] - vpm[6];
    this.planes[4][2] = vpm[11] - vpm[10];
    this.planes[4][3] = vpm[15] - vpm[14];
    t = Math.sqrt(this.planes[4][0] * this.planes[4][0] + this.planes[4][1] * this.planes[4][1] + this.planes[4][2] * this.planes[4][2]);
    this.planes[4][0] /= t;
    this.planes[4][1] /= t;
    this.planes[4][2] /= t;
    this.planes[4][3] /= t;
    this.planes[5][0] = vpm[3] + vpm[2];
    this.planes[5][1] = vpm[7] + vpm[6];
    this.planes[5][2] = vpm[11] + vpm[10];
    this.planes[5][3] = vpm[15] + vpm[14];
    t = Math.sqrt(this.planes[5][0] * this.planes[5][0] + this.planes[5][1] * this.planes[5][1] + this.planes[5][2] * this.planes[5][2]);
    this.planes[5][0] /= t;
    this.planes[5][1] /= t;
    this.planes[5][2] /= t;
    this.planes[5][3] /= t;
  }, containsPoint:function(point) {
    for (var p = 0;p < 6;p++) {
      if (this.planes[p][0] * point.x + this.planes[p][1] * point.y + this.planes[p][2] * point.z + this.planes[p][3] <= 0) {
        return false;
      }
    }
    return true;
  }, containsSphere:function(sphere) {
    var c = 0;
    var d;
    var p;
    var sr = sphere.radius;
    var sc = sphere.center.data;
    var scx = sc[0];
    var scy = sc[1];
    var scz = sc[2];
    var planes = this.planes;
    var plane;
    for (p = 0;p < 6;p++) {
      plane = planes[p];
      d = plane[0] * scx + plane[1] * scy + plane[2] * scz + plane[3];
      if (d <= -sr) {
        return 0;
      }
      if (d > sr) {
        c++;
      }
    }
    return c === 6 ? 2 : 1;
  }});
  return {Frustum:Frustum};
}());
Object.assign(pc, function() {
  var tmpVecA = new pc.Vec3;
  var Plane = function Plane(point, normal) {
    this.normal = normal || new pc.Vec3(0, 0, 1);
    this.point = point || new pc.Vec3(0, 0, 0);
  };
  Object.assign(Plane.prototype, {intersectsLine:function(start, end, point) {
    var d = -this.normal.dot(this.point);
    var d0 = this.normal.dot(start) + d;
    var d1 = this.normal.dot(end) + d;
    var t = d0 / (d0 - d1);
    var intersects = t >= 0 && t <= 1;
    if (intersects && point) {
      point.lerp(start, end, t);
    }
    return intersects;
  }, intersectsRay:function(ray, point) {
    var pointToOrigin = tmpVecA.sub2(this.point, ray.origin);
    var t = this.normal.dot(pointToOrigin) / this.normal.dot(ray.direction);
    var intersects = t >= 0;
    if (intersects && point) {
      point.copy(ray.direction).scale(t).add(ray.origin);
    }
    return intersects;
  }});
  return {Plane:Plane};
}());
Object.assign(pc, function() {
  var Ray = function Ray(origin, direction) {
    this.origin = origin || new pc.Vec3(0, 0, 0);
    this.direction = direction || new pc.Vec3(0, 0, -1);
  };
  return {Ray:Ray};
}());
Object.assign(pc, function() {
  var tmpRay = new pc.Ray;
  var tmpVec3 = new pc.Vec3;
  var tmpSphere = new pc.BoundingSphere;
  var tmpMat4 = new pc.Mat4;
  var OrientedBox = function OrientedBox(worldTransform, halfExtents) {
    this.halfExtents = halfExtents || new pc.Vec3(0.5, 0.5, 0.5);
    worldTransform = worldTransform || tmpMat4.setIdentity();
    this._modelTransform = worldTransform.clone().invert();
    this._aabb = new pc.BoundingBox(new pc.Vec3, this.halfExtents);
  };
  Object.assign(OrientedBox.prototype, {intersectsRay:function(ray, point) {
    this._modelTransform.transformPoint(ray.origin, tmpRay.origin);
    this._modelTransform.transformVector(ray.direction, tmpRay.direction);
    if (point) {
      var result = this._aabb._intersectsRay(tmpRay, point);
      tmpMat4.copy(this._modelTransform).invert().transformPoint(point, point);
      return result;
    }
    return this._aabb._fastIntersectsRay(tmpRay);
  }, containsPoint:function(point) {
    this._modelTransform.transformPoint(point, tmpVec3);
    return this._aabb.containsPoint(tmpVec3);
  }, intersectsBoundingSphere:function(sphere) {
    this._modelTransform.transformPoint(sphere.center, tmpSphere.center);
    tmpSphere.radius = sphere.radius;
    if (this._aabb.intersectsBoundingSphere(tmpSphere)) {
      return true;
    }
    return false;
  }});
  Object.defineProperty(OrientedBox.prototype, "worldTransform", {set:function(value) {
    this._modelTransform.copy(value).invert();
  }});
  return {OrientedBox:OrientedBox};
}());
(function() {
  var enums = {ADDRESS_REPEAT:0, ADDRESS_CLAMP_TO_EDGE:1, ADDRESS_MIRRORED_REPEAT:2, BLENDMODE_ZERO:0, BLENDMODE_ONE:1, BLENDMODE_SRC_COLOR:2, BLENDMODE_ONE_MINUS_SRC_COLOR:3, BLENDMODE_DST_COLOR:4, BLENDMODE_ONE_MINUS_DST_COLOR:5, BLENDMODE_SRC_ALPHA:6, BLENDMODE_SRC_ALPHA_SATURATE:7, BLENDMODE_ONE_MINUS_SRC_ALPHA:8, BLENDMODE_DST_ALPHA:9, BLENDMODE_ONE_MINUS_DST_ALPHA:10, BLENDEQUATION_ADD:0, BLENDEQUATION_SUBTRACT:1, BLENDEQUATION_REVERSE_SUBTRACT:2, BLENDEQUATION_MIN:3, BLENDEQUATION_MAX:4, BUFFER_STATIC:0, 
  BUFFER_DYNAMIC:1, BUFFER_STREAM:2, BUFFER_GPUDYNAMIC:3, CLEARFLAG_COLOR:1, CLEARFLAG_DEPTH:2, CLEARFLAG_STENCIL:4, CUBEFACE_POSX:0, CUBEFACE_NEGX:1, CUBEFACE_POSY:2, CUBEFACE_NEGY:3, CUBEFACE_POSZ:4, CUBEFACE_NEGZ:5, CULLFACE_NONE:0, CULLFACE_BACK:1, CULLFACE_FRONT:2, CULLFACE_FRONTANDBACK:3, TYPE_INT8:0, TYPE_UINT8:1, TYPE_INT16:2, TYPE_UINT16:3, TYPE_INT32:4, TYPE_UINT32:5, TYPE_FLOAT32:6, FILTER_NEAREST:0, FILTER_LINEAR:1, FILTER_NEAREST_MIPMAP_NEAREST:2, FILTER_NEAREST_MIPMAP_LINEAR:3, FILTER_LINEAR_MIPMAP_NEAREST:4, 
  FILTER_LINEAR_MIPMAP_LINEAR:5, FUNC_NEVER:0, FUNC_LESS:1, FUNC_EQUAL:2, FUNC_LESSEQUAL:3, FUNC_GREATER:4, FUNC_NOTEQUAL:5, FUNC_GREATEREQUAL:6, FUNC_ALWAYS:7, INDEXFORMAT_UINT8:0, INDEXFORMAT_UINT16:1, INDEXFORMAT_UINT32:2, PIXELFORMAT_A8:0, PIXELFORMAT_L8:1, PIXELFORMAT_L8_A8:2, PIXELFORMAT_R5_G6_B5:3, PIXELFORMAT_R5_G5_B5_A1:4, PIXELFORMAT_R4_G4_B4_A4:5, PIXELFORMAT_R8_G8_B8:6, PIXELFORMAT_R8_G8_B8_A8:7, PIXELFORMAT_DXT1:8, PIXELFORMAT_DXT3:9, PIXELFORMAT_DXT5:10, PIXELFORMAT_RGB16F:11, PIXELFORMAT_RGBA16F:12, 
  PIXELFORMAT_RGB32F:13, PIXELFORMAT_RGBA32F:14, PIXELFORMAT_R32F:15, PIXELFORMAT_DEPTH:16, PIXELFORMAT_DEPTHSTENCIL:17, PIXELFORMAT_111110F:18, PIXELFORMAT_SRGB:19, PIXELFORMAT_SRGBA:20, PIXELFORMAT_ETC1:21, PIXELFORMAT_PVRTC_2BPP_RGB_1:22, PIXELFORMAT_PVRTC_2BPP_RGBA_1:23, PIXELFORMAT_PVRTC_4BPP_RGB_1:24, PIXELFORMAT_PVRTC_4BPP_RGBA_1:25, PRIMITIVE_POINTS:0, PRIMITIVE_LINES:1, PRIMITIVE_LINELOOP:2, PRIMITIVE_LINESTRIP:3, PRIMITIVE_TRIANGLES:4, PRIMITIVE_TRISTRIP:5, PRIMITIVE_TRIFAN:6, SEMANTIC_POSITION:"POSITION", 
  SEMANTIC_NORMAL:"NORMAL", SEMANTIC_TANGENT:"TANGENT", SEMANTIC_BLENDWEIGHT:"BLENDWEIGHT", SEMANTIC_BLENDINDICES:"BLENDINDICES", SEMANTIC_COLOR:"COLOR", SEMANTIC_TEXCOORD0:"TEXCOORD0", SEMANTIC_TEXCOORD1:"TEXCOORD1", SEMANTIC_TEXCOORD2:"TEXCOORD2", SEMANTIC_TEXCOORD3:"TEXCOORD3", SEMANTIC_TEXCOORD4:"TEXCOORD4", SEMANTIC_TEXCOORD5:"TEXCOORD5", SEMANTIC_TEXCOORD6:"TEXCOORD6", SEMANTIC_TEXCOORD7:"TEXCOORD7", SEMANTIC_ATTR0:"ATTR0", SEMANTIC_ATTR1:"ATTR1", SEMANTIC_ATTR2:"ATTR2", SEMANTIC_ATTR3:"ATTR3", 
  SEMANTIC_ATTR4:"ATTR4", SEMANTIC_ATTR5:"ATTR5", SEMANTIC_ATTR6:"ATTR6", SEMANTIC_ATTR7:"ATTR7", SEMANTIC_ATTR8:"ATTR8", SEMANTIC_ATTR9:"ATTR9", SEMANTIC_ATTR10:"ATTR10", SEMANTIC_ATTR11:"ATTR11", SEMANTIC_ATTR12:"ATTR12", SEMANTIC_ATTR13:"ATTR13", SEMANTIC_ATTR14:"ATTR14", SEMANTIC_ATTR15:"ATTR15", SHADERTAG_MATERIAL:1, STENCILOP_KEEP:0, STENCILOP_ZERO:1, STENCILOP_REPLACE:2, STENCILOP_INCREMENT:3, STENCILOP_INCREMENTWRAP:4, STENCILOP_DECREMENT:5, STENCILOP_DECREMENTWRAP:6, STENCILOP_INVERT:7, 
  TEXTURELOCK_READ:1, TEXTURELOCK_WRITE:2, TEXHINT_NONE:0, TEXHINT_SHADOWMAP:1, TEXHINT_ASSET:2, TEXHINT_LIGHTMAP:3, UNIFORMTYPE_BOOL:0, UNIFORMTYPE_INT:1, UNIFORMTYPE_FLOAT:2, UNIFORMTYPE_VEC2:3, UNIFORMTYPE_VEC3:4, UNIFORMTYPE_VEC4:5, UNIFORMTYPE_IVEC2:6, UNIFORMTYPE_IVEC3:7, UNIFORMTYPE_IVEC4:8, UNIFORMTYPE_BVEC2:9, UNIFORMTYPE_BVEC3:10, UNIFORMTYPE_BVEC4:11, UNIFORMTYPE_MAT2:12, UNIFORMTYPE_MAT3:13, UNIFORMTYPE_MAT4:14, UNIFORMTYPE_TEXTURE2D:15, UNIFORMTYPE_TEXTURECUBE:16, UNIFORMTYPE_FLOATARRAY:17, 
  UNIFORMTYPE_TEXTURE2D_SHADOW:18, UNIFORMTYPE_TEXTURECUBE_SHADOW:19, UNIFORMTYPE_TEXTURE3D:20};
  Object.assign(pc, enums);
  pc.gfx = {};
  Object.assign(pc.gfx, enums);
})();
Object.assign(pc, function() {
  var ScopeId = function(name) {
    this.name = name;
    this.value = null;
    this.versionObject = new pc.VersionedObject;
  };
  Object.assign(ScopeId.prototype, {setValue:function(value) {
    this.value = value;
    this.versionObject.increment();
  }, getValue:function(value) {
    return this.value;
  }});
  return {ScopeId:ScopeId};
}());
Object.assign(pc, function() {
  var ScopeSpace = function(name) {
    this.name = name;
    this.variables = {};
    this.namespaces = {};
  };
  Object.assign(ScopeSpace.prototype, {resolve:function(name) {
    if (!this.variables.hasOwnProperty(name)) {
      this.variables[name] = new pc.ScopeId(name);
    }
    return this.variables[name];
  }, getSubSpace:function(name) {
    if (!this.namespaces.hasOwnProperty(name)) {
      this.namespaces[name] = new pc.ScopeSpace(name);
    }
    return this.namespaces[name];
  }});
  return {ScopeSpace:ScopeSpace};
}());
Object.assign(pc, function() {
  var Version = function() {
    this.globalId = 0;
    this.revision = 0;
  };
  Object.assign(Version.prototype, {equals:function(other) {
    return this.globalId === other.globalId && this.revision === other.revision;
  }, notequals:function(other) {
    return this.globalId !== other.globalId || this.revision !== other.revision;
  }, copy:function(other) {
    this.globalId = other.globalId;
    this.revision = other.revision;
  }, reset:function() {
    this.globalId = 0;
    this.revision = 0;
  }});
  return {Version:Version};
}());
Object.assign(pc, function() {
  var idCounter = 0;
  var VersionedObject = function() {
    idCounter++;
    this.version = new pc.Version;
    this.version.globalId = idCounter;
  };
  Object.assign(VersionedObject.prototype, {increment:function() {
    this.version.revision++;
  }});
  return {VersionedObject:VersionedObject};
}());
Object.assign(pc, function() {
  function VertexIteratorSetter(buffer, vertexElement) {
    this.index = 0;
    switch(vertexElement.dataType) {
      case pc.TYPE_INT8:
        this.array = new Int8Array(buffer, vertexElement.offset);
        break;
      case pc.TYPE_UINT8:
        this.array = new Uint8Array(buffer, vertexElement.offset);
        break;
      case pc.TYPE_INT16:
        this.array = new Int16Array(buffer, vertexElement.offset);
        break;
      case pc.TYPE_UINT16:
        this.array = new Uint16Array(buffer, vertexElement.offset);
        break;
      case pc.TYPE_INT32:
        this.array = new Int32Array(buffer, vertexElement.offset);
        break;
      case pc.TYPE_UINT32:
        this.array = new Uint32Array(buffer, vertexElement.offset);
        break;
      case pc.TYPE_FLOAT32:
        this.array = new Float32Array(buffer, vertexElement.offset);
        break;
    }
    switch(vertexElement.numComponents) {
      case 1:
        this.set = VertexIteratorSetter_set1;
        break;
      case 2:
        this.set = VertexIteratorSetter_set2;
        break;
      case 3:
        this.set = VertexIteratorSetter_set3;
        break;
      case 4:
        this.set = VertexIteratorSetter_set4;
        break;
    }
  }
  function VertexIteratorSetter_set1(a) {
    this.array[this.index] = a;
  }
  function VertexIteratorSetter_set2(a, b) {
    this.array[this.index] = a;
    this.array[this.index + 1] = b;
  }
  function VertexIteratorSetter_set3(a, b, c) {
    this.array[this.index] = a;
    this.array[this.index + 1] = b;
    this.array[this.index + 2] = c;
  }
  function VertexIteratorSetter_set4(a, b, c, d) {
    this.array[this.index] = a;
    this.array[this.index + 1] = b;
    this.array[this.index + 2] = c;
    this.array[this.index + 3] = d;
  }
  function VertexIterator(vertexBuffer) {
    this.vertexBuffer = vertexBuffer;
    this.buffer = this.vertexBuffer.lock();
    this.setters = [];
    this.element = {};
    var vertexFormat = this.vertexBuffer.getFormat();
    for (var i = 0;i < vertexFormat.elements.length;i++) {
      var vertexElement = vertexFormat.elements[i];
      this.setters[i] = new VertexIteratorSetter(this.buffer, vertexElement);
      this.element[vertexElement.name] = this.setters[i];
    }
  }
  Object.assign(VertexIterator.prototype, {next:function() {
    var i = 0;
    var setters = this.setters;
    var numSetters = this.setters.length;
    var vertexFormat = this.vertexBuffer.getFormat();
    while (i < numSetters) {
      var setter = setters[i++];
      setter.index += vertexFormat.size / setter.array.constructor.BYTES_PER_ELEMENT;
    }
  }, end:function() {
    this.vertexBuffer.unlock();
  }});
  return {VertexIterator:VertexIterator};
}());
Object.assign(pc, function() {
  var _typeSize = [];
  _typeSize[pc.TYPE_INT8] = 1;
  _typeSize[pc.TYPE_UINT8] = 1;
  _typeSize[pc.TYPE_INT16] = 2;
  _typeSize[pc.TYPE_UINT16] = 2;
  _typeSize[pc.TYPE_INT32] = 4;
  _typeSize[pc.TYPE_UINT32] = 4;
  _typeSize[pc.TYPE_FLOAT32] = 4;
  var VertexFormat = function(graphicsDevice, description) {
    var i, len, element;
    this.elements = [];
    this.hasUv0 = false;
    this.hasUv1 = false;
    this.hasColor = false;
    this.size = 0;
    for (i = 0, len = description.length;i < len;i++) {
      var elementDesc = description[i];
      element = {name:elementDesc.semantic, offset:0, stride:0, stream:-1, scopeId:graphicsDevice.scope.resolve(elementDesc.semantic), dataType:elementDesc.type, numComponents:elementDesc.components, normalize:elementDesc.normalize === undefined ? false : elementDesc.normalize, size:elementDesc.components * _typeSize[elementDesc.type]};
      this.elements.push(element);
      this.size += Math.ceil(element.size / 4) * 4;
      if (elementDesc.semantic === pc.SEMANTIC_TEXCOORD0) {
        this.hasUv0 = true;
      } else {
        if (elementDesc.semantic === pc.SEMANTIC_TEXCOORD1) {
          this.hasUv1 = true;
        } else {
          if (elementDesc.semantic === pc.SEMANTIC_COLOR) {
            this.hasColor = true;
          }
        }
      }
    }
    var offset = 0;
    for (i = 0, len = this.elements.length;i < len;i++) {
      element = this.elements[i];
      element.offset = offset;
      element.stride = this.size;
      offset += element.size;
    }
  };
  return {VertexFormat:VertexFormat};
}());
Object.assign(pc, function() {
  var VertexBuffer = function(graphicsDevice, format, numVertices, usage, initialData) {
    this.usage = usage || pc.BUFFER_STATIC;
    this.format = format;
    this.numVertices = numVertices;
    this.numBytes = format.size * numVertices;
    graphicsDevice._vram.vb += this.numBytes;
    this.device = graphicsDevice;
    if (initialData) {
      this.setData(initialData);
    } else {
      this.storage = new ArrayBuffer(this.numBytes);
    }
    this.device.buffers.push(this);
  };
  Object.assign(VertexBuffer.prototype, {destroy:function() {
    var device = this.device;
    var idx = device.buffers.indexOf(this);
    if (idx !== -1) {
      device.buffers.splice(idx, 1);
    }
    if (this.bufferId) {
      var gl = device.gl;
      gl.deleteBuffer(this.bufferId);
      device._vram.vb -= this.storage.byteLength;
      this.bufferId = null;
      device.boundBuffer = null;
      device.vertexBuffers.length = 0;
      device.vbOffsets.length = 0;
      device.attributesInvalidated = true;
      for (var loc in device.enabledAttributes) {
        gl.disableVertexAttribArray(loc);
      }
      device.enabledAttributes = {};
    }
  }, getFormat:function() {
    return this.format;
  }, getUsage:function() {
    return this.usage;
  }, getNumVertices:function() {
    return this.numVertices;
  }, lock:function() {
    return this.storage;
  }, unlock:function() {
    var gl = this.device.gl;
    if (!this.bufferId) {
      this.bufferId = gl.createBuffer();
    }
    var glUsage;
    switch(this.usage) {
      case pc.BUFFER_STATIC:
        glUsage = gl.STATIC_DRAW;
        break;
      case pc.BUFFER_DYNAMIC:
        glUsage = gl.DYNAMIC_DRAW;
        break;
      case pc.BUFFER_STREAM:
        glUsage = gl.STREAM_DRAW;
        break;
      case pc.BUFFER_GPUDYNAMIC:
        if (this.device.webgl2) {
          glUsage = gl.DYNAMIC_COPY;
        } else {
          glUsage = gl.STATIC_DRAW;
        }
        break;
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, this.bufferId);
    gl.bufferData(gl.ARRAY_BUFFER, this.storage, glUsage);
  }, setData:function(data) {
    if (data.byteLength !== this.numBytes) {
      console.error("VertexBuffer: wrong initial data size: expected " + this.numBytes + ", got " + data.byteLength);
      return false;
    }
    this.storage = data;
    this.unlock();
    return true;
  }});
  return {VertexBuffer:VertexBuffer};
}());
Object.assign(pc, function() {
  var IndexBuffer = function(graphicsDevice, format, numIndices, usage, initialData) {
    this.usage = usage || pc.BUFFER_STATIC;
    this.format = format;
    this.numIndices = numIndices;
    this.device = graphicsDevice;
    var gl = this.device.gl;
    var bytesPerIndex;
    if (format === pc.INDEXFORMAT_UINT8) {
      bytesPerIndex = 1;
      this.glFormat = gl.UNSIGNED_BYTE;
    } else {
      if (format === pc.INDEXFORMAT_UINT16) {
        bytesPerIndex = 2;
        this.glFormat = gl.UNSIGNED_SHORT;
      } else {
        if (format === pc.INDEXFORMAT_UINT32) {
          bytesPerIndex = 4;
          this.glFormat = gl.UNSIGNED_INT;
        }
      }
    }
    this.bytesPerIndex = bytesPerIndex;
    this.numBytes = this.numIndices * bytesPerIndex;
    if (initialData) {
      this.setData(initialData);
    } else {
      this.storage = new ArrayBuffer(this.numBytes);
    }
    graphicsDevice._vram.ib += this.numBytes;
    this.device.buffers.push(this);
  };
  Object.assign(IndexBuffer.prototype, {destroy:function() {
    var device = this.device;
    var idx = device.buffers.indexOf(this);
    if (idx !== -1) {
      device.buffers.splice(idx, 1);
    }
    if (this.bufferId) {
      var gl = this.device.gl;
      gl.deleteBuffer(this.bufferId);
      this.device._vram.ib -= this.storage.byteLength;
      this.bufferId = null;
      if (this.device.indexBuffer === this) {
        this.device.indexBuffer = null;
      }
    }
  }, getFormat:function() {
    return this.format;
  }, getNumIndices:function() {
    return this.numIndices;
  }, lock:function() {
    return this.storage;
  }, unlock:function() {
    var gl = this.device.gl;
    if (!this.bufferId) {
      this.bufferId = gl.createBuffer();
    }
    var glUsage;
    switch(this.usage) {
      case pc.BUFFER_STATIC:
        glUsage = gl.STATIC_DRAW;
        break;
      case pc.BUFFER_DYNAMIC:
        glUsage = gl.DYNAMIC_DRAW;
        break;
      case pc.BUFFER_STREAM:
        glUsage = gl.STREAM_DRAW;
        break;
      case pc.BUFFER_GPUDYNAMIC:
        if (this.device.webgl2) {
          glUsage = gl.DYNAMIC_COPY;
        } else {
          glUsage = gl.STATIC_DRAW;
        }
        break;
    }
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.bufferId);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.storage, glUsage);
  }, setData:function(data) {
    if (data.byteLength !== this.numBytes) {
      console.error("IndexBuffer: wrong initial data size: expected " + this.numBytes + ", got " + data.byteLength);
      return false;
    }
    this.storage = data;
    this.unlock();
    return true;
  }});
  return {IndexBuffer:IndexBuffer};
}());
Object.assign(pc, function() {
  var TransformFeedback = function(inputBuffer, usage) {
    usage = usage || pc.BUFFER_GPUDYNAMIC;
    this.device = inputBuffer.device;
    var gl = this.device.gl;
    this._inputBuffer = inputBuffer;
    if (usage === pc.BUFFER_GPUDYNAMIC && inputBuffer.usage !== usage) {
      gl.bindBuffer(gl.ARRAY_BUFFER, inputBuffer.bufferId);
      gl.bufferData(gl.ARRAY_BUFFER, inputBuffer.storage, gl.DYNAMIC_COPY);
    }
    this._outputBuffer = new pc.VertexBuffer(inputBuffer.device, inputBuffer.format, inputBuffer.numVertices, usage, inputBuffer.storage);
  };
  TransformFeedback.createShader = function(graphicsDevice, vsCode, name) {
    return pc.shaderChunks.createShaderFromCode(graphicsDevice, vsCode, null, name, true);
  };
  Object.assign(TransformFeedback.prototype, {destroy:function() {
    this._outputBuffer.destroy();
  }, process:function(shader, swap) {
    if (swap === undefined) {
      swap = true;
    }
    var device = this.device;
    device.setRenderTarget(null);
    device.updateBegin();
    device.setVertexBuffer(this._inputBuffer, 0);
    device.setRaster(false);
    device.setTransformFeedbackBuffer(this._outputBuffer);
    device.setShader(shader);
    device.draw({type:pc.PRIMITIVE_POINTS, base:0, count:this._inputBuffer.numVertices, indexed:false});
    device.setTransformFeedbackBuffer(null);
    device.setRaster(true);
    device.updateEnd();
    if (swap) {
      var tmp = this._inputBuffer.bufferId;
      this._inputBuffer.bufferId = this._outputBuffer.bufferId;
      this._outputBuffer.bufferId = tmp;
    }
  }});
  Object.defineProperty(TransformFeedback.prototype, "inputBuffer", {get:function() {
    return this._inputBuffer;
  }});
  Object.defineProperty(TransformFeedback.prototype, "outputBuffer", {get:function() {
    return this._outputBuffer;
  }});
  return {TransformFeedback:TransformFeedback};
}());
Object.assign(pc, function() {
  var Texture = function(graphicsDevice, options) {
    this.device = graphicsDevice;
    this.name = null;
    this._width = 4;
    this._height = 4;
    this._depth = 1;
    this._pot = true;
    this._format = pc.PIXELFORMAT_R8_G8_B8_A8;
    this.rgbm = false;
    this._cubemap = false;
    this._volume = false;
    this.fixCubemapSeams = false;
    this._flipY = true;
    this._mipmaps = true;
    this._minFilter = pc.FILTER_LINEAR_MIPMAP_LINEAR;
    this._magFilter = pc.FILTER_LINEAR;
    this._anisotropy = 1;
    this._addressU = pc.ADDRESS_REPEAT;
    this._addressV = pc.ADDRESS_REPEAT;
    this._addressW = pc.ADDRESS_REPEAT;
    this._compareOnRead = false;
    this._compareFunc = pc.FUNC_LESS;
    if (options !== undefined) {
      this._width = options.width !== undefined ? options.width : this._width;
      this._height = options.height !== undefined ? options.height : this._height;
      this._pot = pc.math.powerOfTwo(this._width) && pc.math.powerOfTwo(this._height);
      this._format = options.format !== undefined ? options.format : this._format;
      this.rgbm = options.rgbm !== undefined ? options.rgbm : this.rgbm;
      if (options.mipmaps !== undefined) {
        this._mipmaps = options.mipmaps;
      } else {
        this._mipmaps = options.autoMipmap !== undefined ? options.autoMipmap : this._mipmaps;
      }
      this._cubemap = options.cubemap !== undefined ? options.cubemap : this._cubemap;
      this.fixCubemapSeams = options.fixCubemapSeams !== undefined ? options.fixCubemapSeams : this.fixCubemapSeams;
      this._minFilter = options.minFilter !== undefined ? options.minFilter : this._minFilter;
      this._magFilter = options.magFilter !== undefined ? options.magFilter : this._magFilter;
      this._anisotropy = options.anisotropy !== undefined ? options.anisotropy : this._anisotropy;
      this._addressU = options.addressU !== undefined ? options.addressU : this._addressU;
      this._addressV = options.addressV !== undefined ? options.addressV : this._addressV;
      this._compareOnRead = options.compareOnRead !== undefined ? options.compareOnRead : this._compareOnRead;
      this._compareFunc = options._compareFunc !== undefined ? options._compareFunc : this._compareFunc;
      this._flipY = options.flipY !== undefined ? options.flipY : this._flipY;
      if (graphicsDevice.webgl2) {
        this._depth = options.depth !== undefined ? options.depth : this._depth;
        this._volume = options.volume !== undefined ? options.volume : this._volume;
        this._addressW = options.addressW !== undefined ? options.addressW : this._addressW;
      }
    }
    this._compressed = this._format === pc.PIXELFORMAT_DXT1 || this._format === pc.PIXELFORMAT_DXT3 || this._format === pc.PIXELFORMAT_DXT5 || this._format >= pc.PIXELFORMAT_ETC1;
    this._invalid = false;
    this._lockedLevel = -1;
    this._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];
    this.dirtyAll();
    this._gpuSize = 0;
    this.device.textures.push(this);
  };
  Object.defineProperty(Texture.prototype, "minFilter", {get:function() {
    return this._minFilter;
  }, set:function(v) {
    if (this._minFilter !== v) {
      this._minFilter = v;
      this._minFilterDirty = true;
    }
  }});
  Object.defineProperty(Texture.prototype, "magFilter", {get:function() {
    return this._magFilter;
  }, set:function(v) {
    if (this._magFilter !== v) {
      this._magFilter = v;
      this._magFilterDirty = true;
    }
  }});
  Object.defineProperty(Texture.prototype, "addressU", {get:function() {
    return this._addressU;
  }, set:function(v) {
    if (this._addressU !== v) {
      this._addressU = v;
      this._addressUDirty = true;
    }
  }});
  Object.defineProperty(Texture.prototype, "addressV", {get:function() {
    return this._addressV;
  }, set:function(v) {
    if (this._addressV !== v) {
      this._addressV = v;
      this._addressVDirty = true;
    }
  }});
  Object.defineProperty(Texture.prototype, "addressW", {get:function() {
    return this._addressW;
  }, set:function(addressW) {
    if (!this.device.webgl2) {
      return;
    }
    if (!this._volume) {
      logWARNING("Can't set W addressing mode for a non-3D texture.");
      return;
    }
    if (addressW !== this._addressW) {
      this._addressW = addressW;
      this._addressWDirty = true;
    }
  }});
  Object.defineProperty(Texture.prototype, "compareOnRead", {get:function() {
    return this._compareOnRead;
  }, set:function(v) {
    if (this._compareOnRead !== v) {
      this._compareOnRead = v;
      this._compareModeDirty = true;
    }
  }});
  Object.defineProperty(Texture.prototype, "compareFunc", {get:function() {
    return this._compareFunc;
  }, set:function(v) {
    if (this._compareFunc !== v) {
      this._compareFunc = v;
      this._compareModeDirty = true;
    }
  }});
  Object.defineProperty(Texture.prototype, "autoMipmap", {get:function() {
    return this._mipmaps;
  }, set:function(v) {
    this._mipmaps = v;
  }});
  Object.defineProperty(Texture.prototype, "mipmaps", {get:function() {
    return this._mipmaps;
  }, set:function(v) {
    if (this._mipmaps !== v) {
      this._mipmaps = v;
      this._minFilterDirty = true;
      if (v) {
        this._needsMipmapsUpload = true;
      }
    }
  }});
  Object.defineProperty(Texture.prototype, "anisotropy", {get:function() {
    return this._anisotropy;
  }, set:function(v) {
    if (this._anisotropy !== v) {
      this._anisotropy = v;
      this._anisotropyDirty = true;
    }
  }});
  Object.defineProperty(Texture.prototype, "width", {get:function() {
    return this._width;
  }});
  Object.defineProperty(Texture.prototype, "height", {get:function() {
    return this._height;
  }});
  Object.defineProperty(Texture.prototype, "depth", {get:function() {
    return this._depth;
  }});
  Object.defineProperty(Texture.prototype, "format", {get:function() {
    return this._format;
  }});
  Object.defineProperty(Texture.prototype, "cubemap", {get:function() {
    return this._cubemap;
  }});
  var _pixelFormat2Size = null;
  Object.defineProperty(Texture.prototype, "gpuSize", {get:function() {
    if (!_pixelFormat2Size) {
      _pixelFormat2Size = [];
      _pixelFormat2Size[pc.PIXELFORMAT_A8] = 1;
      _pixelFormat2Size[pc.PIXELFORMAT_L8] = 1;
      _pixelFormat2Size[pc.PIXELFORMAT_L8_A8] = 1;
      _pixelFormat2Size[pc.PIXELFORMAT_R5_G6_B5] = 2;
      _pixelFormat2Size[pc.PIXELFORMAT_R5_G5_B5_A1] = 2;
      _pixelFormat2Size[pc.PIXELFORMAT_R4_G4_B4_A4] = 2;
      _pixelFormat2Size[pc.PIXELFORMAT_R8_G8_B8] = 4;
      _pixelFormat2Size[pc.PIXELFORMAT_R8_G8_B8_A8] = 4;
      _pixelFormat2Size[pc.PIXELFORMAT_RGB16F] = 8;
      _pixelFormat2Size[pc.PIXELFORMAT_RGBA16F] = 8;
      _pixelFormat2Size[pc.PIXELFORMAT_RGB32F] = 16;
      _pixelFormat2Size[pc.PIXELFORMAT_RGBA32F] = 16;
      _pixelFormat2Size[pc.PIXELFORMAT_R32F] = 4;
      _pixelFormat2Size[pc.PIXELFORMAT_DEPTH] = 4;
      _pixelFormat2Size[pc.PIXELFORMAT_DEPTHSTENCIL] = 4;
      _pixelFormat2Size[pc.PIXELFORMAT_111110F] = 4;
      _pixelFormat2Size[pc.PIXELFORMAT_SRGB] = 4;
      _pixelFormat2Size[pc.PIXELFORMAT_SRGBA] = 4;
    }
    var mips = 1;
    if (this._pot && (this._mipmaps || this._minFilter === pc.FILTER_NEAREST_MIPMAP_NEAREST || this._minFilter === pc.FILTER_NEAREST_MIPMAP_LINEAR || this._minFilter === pc.FILTER_LINEAR_MIPMAP_NEAREST || this._minFilter === pc.FILTER_LINEAR_MIPMAP_LINEAR) && !(this._compressed && this._levels.length === 1)) {
      mips = Math.round(Math.log2(Math.max(this._width, this._height)) + 1);
    }
    var mipWidth = this._width;
    var mipHeight = this._height;
    var mipDepth = this._depth;
    var size = 0;
    for (var i = 0;i < mips;i++) {
      if (!this._compressed) {
        size += mipWidth * mipHeight * mipDepth * _pixelFormat2Size[this._format];
      } else {
        if (this._format === pc.PIXELFORMAT_ETC1) {
          size += Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8 * mipDepth;
        } else {
          if (this._format === pc.PIXELFORMAT_PVRTC_2BPP_RGB_1 || this._format === pc.PIXELFORMAT_PVRTC_2BPP_RGBA_1) {
            size += Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4 * mipDepth;
          } else {
            if (this._format === pc.PIXELFORMAT_PVRTC_4BPP_RGB_1 || this._format === pc.PIXELFORMAT_PVRTC_4BPP_RGBA_1) {
              size += Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2 * mipDepth;
            } else {
              var DXT_BLOCK_WIDTH = 4;
              var DXT_BLOCK_HEIGHT = 4;
              var blockSize = this._format === pc.PIXELFORMAT_DXT1 ? 8 : 16;
              var numBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);
              var numBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);
              var numBlocks = numBlocksAcross * numBlocksDown;
              size += numBlocks * blockSize * mipDepth;
            }
          }
        }
      }
      mipWidth = Math.max(mipWidth * 0.5, 1);
      mipHeight = Math.max(mipHeight * 0.5, 1);
      mipDepth = Math.max(mipDepth * 0.5, 1);
    }
    if (this._cubemap) {
      size *= 6;
    }
    return size;
  }});
  Object.defineProperty(Texture.prototype, "volume", {get:function() {
    return this._volume;
  }});
  Object.defineProperty(Texture.prototype, "flipY", {get:function() {
    return this._flipY;
  }, set:function(flipY) {
    if (this._flipY !== flipY) {
      this._flipY = flipY;
      this._needsUpload = true;
    }
  }});
  Object.assign(Texture.prototype, {destroy:function() {
    var device = this.device;
    var idx = device.textures.indexOf(this);
    if (idx !== -1) {
      device.textures.splice(idx, 1);
    }
    if (this._glTextureId) {
      var gl = this.device.gl;
      gl.deleteTexture(this._glTextureId);
      this.device._vram.tex -= this._gpuSize;
      this._glTextureId = null;
    }
  }, dirtyAll:function() {
    this._glTextureId = undefined;
    this._levelsUpdated = this._cubemap ? [[true, true, true, true, true, true]] : [true];
    this._needsUpload = true;
    this._needsMipmapsUpload = this._mipmaps;
    this._mipmapsUploaded = false;
    this._minFilterDirty = true;
    this._magFilterDirty = true;
    this._addressUDirty = true;
    this._addressVDirty = true;
    this._addressWDirty = this._volume;
    this._anisotropyDirty = true;
    this._compareModeDirty = true;
  }, lock:function(options) {
    options = options || {level:0, face:0, mode:pc.TEXTURELOCK_WRITE};
    if (options.level === undefined) {
      options.level = 0;
    }
    if (options.face === undefined) {
      options.face = 0;
    }
    if (options.mode === undefined) {
      options.mode = pc.TEXTURELOCK_WRITE;
    }
    this._lockedLevel = options.level;
    if (this._levels[options.level] === null) {
      switch(this._format) {
        case pc.PIXELFORMAT_A8:
        case pc.PIXELFORMAT_L8:
          this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth);
          break;
        case pc.PIXELFORMAT_L8_A8:
          this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 2);
          break;
        case pc.PIXELFORMAT_R5_G6_B5:
        case pc.PIXELFORMAT_R5_G5_B5_A1:
        case pc.PIXELFORMAT_R4_G4_B4_A4:
          this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth);
          break;
        case pc.PIXELFORMAT_R8_G8_B8:
          this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 3);
          break;
        case pc.PIXELFORMAT_R8_G8_B8_A8:
          this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 4);
          break;
        case pc.PIXELFORMAT_DXT1:
          this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 8 * this._depth);
          break;
        case pc.PIXELFORMAT_DXT3:
        case pc.PIXELFORMAT_DXT5:
          this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 16 * this._depth);
          break;
        case pc.PIXELFORMAT_RGB16F:
          this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 3);
          break;
        case pc.PIXELFORMAT_RGB32F:
          this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 3);
          break;
        case pc.PIXELFORMAT_RGBA16F:
          this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 4);
          break;
        case pc.PIXELFORMAT_RGBA32F:
          this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 4);
          break;
      }
    }
    return this._levels[options.level];
  }, setSource:function(source) {
    var i;
    var invalid = false;
    var width, height;
    if (this._cubemap) {
      if (source[0]) {
        width = source[0].width || 0;
        height = source[0].height || 0;
        for (i = 0;i < 6;i++) {
          if (!source[i] || source[i].width !== width || source[i].height !== height || !(source[i] instanceof HTMLImageElement) && !(source[i] instanceof HTMLCanvasElement) && !(source[i] instanceof HTMLVideoElement)) {
            invalid = true;
            break;
          }
        }
      } else {
        invalid = true;
      }
      if (!invalid) {
        for (i = 0;i < 6;i++) {
          if (this._levels[0][i] !== source[i]) {
            this._levelsUpdated[0][i] = true;
          }
        }
      }
    } else {
      if (!(source instanceof HTMLImageElement) && !(source instanceof HTMLCanvasElement) && !(source instanceof HTMLVideoElement)) {
        invalid = true;
      }
      if (!invalid) {
        if (source !== this._levels[0]) {
          this._levelsUpdated[0] = true;
        }
        width = source.width;
        height = source.height;
      }
    }
    if (invalid) {
      this._width = 4;
      this._height = 4;
      this._pot = true;
      if (this._cubemap) {
        for (i = 0;i < 6;i++) {
          this._levels[0][i] = null;
          this._levelsUpdated[0][i] = true;
        }
      } else {
        this._levels[0] = null;
        this._levelsUpdated[0] = true;
      }
    } else {
      this._width = width;
      this._height = height;
      this._pot = pc.math.powerOfTwo(this._width) && pc.math.powerOfTwo(this._height);
      this._levels[0] = source;
    }
    if (this._invalid !== invalid || !invalid) {
      this._invalid = invalid;
      this.upload();
    }
  }, getSource:function() {
    return this._levels[0];
  }, unlock:function() {
    this.upload();
    this._lockedLevel = -1;
  }, upload:function() {
    this._needsUpload = true;
    this._needsMipmapsUpload = this._mipmaps;
  }, getDds:function() {
    if (this.format !== pc.PIXELFORMAT_R8_G8_B8_A8) {
      console.error("This format is not implemented yet");
    }
    var fsize = 128;
    var i = 0;
    var j;
    var face;
    while (this._levels[i]) {
      var mipSize;
      if (!this.cubemap) {
        mipSize = this._levels[i].length;
        if (!mipSize) {
          console.error("No byte array for mip " + i);
          return;
        }
        fsize += mipSize;
      } else {
        for (face = 0;face < 6;face++) {
          if (!this._levels[i][face]) {
            console.error("No level data for mip " + i + ", face " + face);
            return;
          }
          mipSize = this._levels[i][face].length;
          if (!mipSize) {
            console.error("No byte array for mip " + i + ", face " + face);
            return;
          }
          fsize += mipSize;
        }
      }
      fsize += this._levels[i].length;
      i++;
    }
    var buff = new ArrayBuffer(fsize);
    var header = new Uint32Array(buff, 0, 128 / 4);
    var DDS_MAGIC = 542327876;
    var DDS_HEADER_SIZE = 124;
    var DDS_FLAGS_REQUIRED = 1 | 2 | 4 | 4096 | 524288;
    var DDS_FLAGS_MIPMAP = 131072;
    var DDS_PIXELFORMAT_SIZE = 32;
    var DDS_PIXELFLAGS_RGBA8 = 1 | 64;
    var DDS_CAPS_REQUIRED = 4096;
    var DDS_CAPS_MIPMAP = 4194304;
    var DDS_CAPS_COMPLEX = 8;
    var DDS_CAPS2_CUBEMAP = 512 | 1024 | 2048 | 4096 | 8192 | 16384 | 32768;
    var flags = DDS_FLAGS_REQUIRED;
    if (this._levels.length > 1) {
      flags |= DDS_FLAGS_MIPMAP;
    }
    var caps = DDS_CAPS_REQUIRED;
    if (this._levels.length > 1) {
      caps |= DDS_CAPS_MIPMAP;
    }
    if (this._levels.length > 1 || this.cubemap) {
      caps |= DDS_CAPS_COMPLEX;
    }
    var caps2 = this.cubemap ? DDS_CAPS2_CUBEMAP : 0;
    header[0] = DDS_MAGIC;
    header[1] = DDS_HEADER_SIZE;
    header[2] = flags;
    header[3] = this.height;
    header[4] = this.width;
    header[5] = this.width * this.height * 4;
    header[6] = 0;
    header[7] = this._levels.length;
    for (i = 0;i < 11;i++) {
      header[8 + i] = 0;
    }
    header[19] = DDS_PIXELFORMAT_SIZE;
    header[20] = DDS_PIXELFLAGS_RGBA8;
    header[21] = 0;
    header[22] = 32;
    header[23] = 16711680;
    header[24] = 65280;
    header[25] = 255;
    header[26] = 4278190080;
    header[27] = caps;
    header[28] = caps2;
    header[29] = 0;
    header[30] = 0;
    header[31] = 0;
    var offset = 128;
    var level, mip;
    if (!this.cubemap) {
      for (i = 0;i < this._levels.length;i++) {
        level = this._levels[i];
        mip = new Uint8Array(buff, offset, level.length);
        for (j = 0;j < level.length;j++) {
          mip[j] = level[j];
        }
        offset += level.length;
      }
    } else {
      for (face = 0;face < 6;face++) {
        for (i = 0;i < this._levels.length;i++) {
          level = this._levels[i][face];
          mip = new Uint8Array(buff, offset, level.length);
          for (j = 0;j < level.length;j++) {
            mip[j] = level[j];
          }
          offset += level.length;
        }
      }
    }
    return buff;
  }});
  return {Texture:Texture};
}());
Object.assign(pc, function() {
  var defaultOptions = {depth:true, face:0};
  var RenderTarget = function(options) {
    var _arg2 = arguments[1];
    var _arg3 = arguments[2];
    if (options instanceof pc.GraphicsDevice) {
      this._colorBuffer = _arg2;
      options = _arg3;
    } else {
      this._colorBuffer = options.colorBuffer;
    }
    this._glFrameBuffer = null;
    this._glDepthBuffer = null;
    options = options !== undefined ? options : defaultOptions;
    this._depthBuffer = options.depthBuffer;
    this._face = options.face !== undefined ? options.face : 0;
    if (this._depthBuffer) {
      var format = this._depthBuffer._format;
      if (format === pc.PIXELFORMAT_DEPTH) {
        this._depth = true;
        this._stencil = false;
      } else {
        if (format === pc.PIXELFORMAT_DEPTHSTENCIL) {
          this._depth = true;
          this._stencil = true;
        } else {
          this._depth = false;
          this._stencil = false;
        }
      }
    } else {
      this._depth = options.depth !== undefined ? options.depth : true;
      this._stencil = options.stencil !== undefined ? options.stencil : false;
    }
    this._samples = options.samples !== undefined ? options.samples : 1;
    this.autoResolve = options.autoResolve !== undefined ? options.autoResolve : true;
    this._glResolveFrameBuffer = null;
    this._glMsaaColorBuffer = null;
    this._glMsaaDepthBuffer = null;
  };
  Object.assign(RenderTarget.prototype, {destroy:function() {
    if (!this._device) {
      return;
    }
    var device = this._device;
    var idx = device.targets.indexOf(this);
    if (idx !== -1) {
      device.targets.splice(idx, 1);
    }
    var gl = device.gl;
    if (this._glFrameBuffer) {
      gl.deleteFramebuffer(this._glFrameBuffer);
      this._glFrameBuffer = null;
    }
    if (this._glDepthBuffer) {
      gl.deleteRenderbuffer(this._glDepthBuffer);
      this._glDepthBuffer = null;
    }
    if (this._glResolveFrameBuffer) {
      gl.deleteFramebuffer(this._glResolveFrameBuffer);
      this._glResolveFrameBuffer = null;
    }
    if (this._glMsaaColorBuffer) {
      gl.deleteRenderbuffer(this._glMsaaColorBuffer);
      this._glMsaaColorBuffer = null;
    }
    if (this._glMsaaDepthBuffer) {
      gl.deleteRenderbuffer(this._glMsaaDepthBuffer);
      this._glMsaaDepthBuffer = null;
    }
  }, resolve:function(color, depth) {
    if (!this._device) {
      return;
    }
    if (!this._device.webgl2) {
      return;
    }
    var gl = this._device.gl;
    if (color === undefined) {
      color = true;
    }
    if (depth === undefined && this._depthBuffer) {
      depth = true;
    }
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._glFrameBuffer);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._glResolveFrameBuffer);
    gl.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
  }, copy:function(source, color, depth) {
    if (!this._device) {
      if (source._device) {
        this._device = source._device;
      } else {
        return false;
      }
    }
    return this._device.copyRenderTarget(source, this, color, depth);
  }});
  Object.defineProperty(RenderTarget.prototype, "colorBuffer", {get:function() {
    return this._colorBuffer;
  }});
  Object.defineProperty(RenderTarget.prototype, "depthBuffer", {get:function() {
    return this._depthBuffer;
  }});
  Object.defineProperty(RenderTarget.prototype, "face", {get:function() {
    return this._face;
  }});
  Object.defineProperty(RenderTarget.prototype, "width", {get:function() {
    return this._colorBuffer ? this._colorBuffer.width : this._depthBuffer.width;
  }});
  Object.defineProperty(RenderTarget.prototype, "height", {get:function() {
    return this._colorBuffer ? this._colorBuffer.height : this._depthBuffer.height;
  }});
  return {RenderTarget:RenderTarget};
}());
Object.assign(pc, function() {
  var ShaderInput = function(graphicsDevice, name, type, locationId) {
    this.locationId = locationId;
    this.scopeId = graphicsDevice.scope.resolve(name);
    this.version = new pc.Version;
    if (type === pc.UNIFORMTYPE_FLOAT) {
      if (name.substr(name.length - 3) === "[0]") {
        type = pc.UNIFORMTYPE_FLOATARRAY;
      }
    }
    this.dataType = type;
    this.value = [null, null, null, null];
    this.array = [];
  };
  return {ShaderInput:ShaderInput};
}());
Object.assign(pc, function() {
  function addLineNumbers(src) {
    var chunks = src.split("\n");
    for (var i = 0, len = chunks.length;i < len;i++) {
      chunks[i] = i + 1 + ":\t" + chunks[i];
    }
    return chunks.join("\n");
  }
  function createShader(gl, type, src) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    return shader;
  }
  function createProgram(gl, vertexShader, fragmentShader) {
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    return program;
  }
  var Shader = function(graphicsDevice, definition) {
    this.device = graphicsDevice;
    this.definition = definition;
    this._refCount = 0;
    this.compile();
    this.device.shaders.push(this);
  };
  Object.assign(Shader.prototype, {compile:function() {
    this.ready = false;
    var gl = this.device.gl;
    this.vshader = createShader(gl, gl.VERTEX_SHADER, this.definition.vshader);
    this.fshader = createShader(gl, gl.FRAGMENT_SHADER, this.definition.fshader);
    this.program = createProgram(gl, this.vshader, this.fshader);
    this.device._shaderStats.vsCompiled++;
    this.device._shaderStats.fsCompiled++;
    this.device._shaderStats.linked++;
    if (this.definition.tag === pc.SHADERTAG_MATERIAL) {
      this.device._shaderStats.materialShaders++;
    }
  }, link:function() {
    var gl = this.device.gl;
    var retValue = true;
    if (this.device.webgl2 && this.definition.useTransformFeedback) {
      var attrs = this.definition.attributes;
      var outNames = [];
      for (var attr in attrs) {
        if (attrs.hasOwnProperty(attr)) {
          outNames.push("out_" + attr);
        }
      }
      gl.transformFeedbackVaryings(this.program, outNames, gl.INTERLEAVED_ATTRIBS);
    }
    gl.linkProgram(this.program);
    if (!gl.getShaderParameter(this.vshader, gl.COMPILE_STATUS)) {
      logERROR("Failed to compile vertex shader:\n\n" + addLineNumbers(this.definition.vshader) + "\n\n" + gl.getShaderInfoLog(this.vshader));
      retValue = false;
    }
    if (!gl.getShaderParameter(this.fshader, gl.COMPILE_STATUS)) {
      logERROR("Failed to compile fragment shader:\n\n" + addLineNumbers(this.definition.fshader) + "\n\n" + gl.getShaderInfoLog(this.fshader));
      retValue = false;
    }
    if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
      logERROR("Failed to link shader program. Error: " + gl.getProgramInfoLog(this.program));
      retValue = false;
    }
    gl.deleteShader(this.vshader);
    gl.deleteShader(this.fshader);
    this.attributes = [];
    this.uniforms = [];
    this.samplers = [];
    var i = 0;
    var info, location;
    var _typeToPc = {};
    _typeToPc[gl.BOOL] = pc.UNIFORMTYPE_BOOL;
    _typeToPc[gl.INT] = pc.UNIFORMTYPE_INT;
    _typeToPc[gl.FLOAT] = pc.UNIFORMTYPE_FLOAT;
    _typeToPc[gl.FLOAT_VEC2] = pc.UNIFORMTYPE_VEC2;
    _typeToPc[gl.FLOAT_VEC3] = pc.UNIFORMTYPE_VEC3;
    _typeToPc[gl.FLOAT_VEC4] = pc.UNIFORMTYPE_VEC4;
    _typeToPc[gl.INT_VEC2] = pc.UNIFORMTYPE_IVEC2;
    _typeToPc[gl.INT_VEC3] = pc.UNIFORMTYPE_IVEC3;
    _typeToPc[gl.INT_VEC4] = pc.UNIFORMTYPE_IVEC4;
    _typeToPc[gl.BOOL_VEC2] = pc.UNIFORMTYPE_BVEC2;
    _typeToPc[gl.BOOL_VEC3] = pc.UNIFORMTYPE_BVEC3;
    _typeToPc[gl.BOOL_VEC4] = pc.UNIFORMTYPE_BVEC4;
    _typeToPc[gl.FLOAT_MAT2] = pc.UNIFORMTYPE_MAT2;
    _typeToPc[gl.FLOAT_MAT3] = pc.UNIFORMTYPE_MAT3;
    _typeToPc[gl.FLOAT_MAT4] = pc.UNIFORMTYPE_MAT4;
    _typeToPc[gl.SAMPLER_2D] = pc.UNIFORMTYPE_TEXTURE2D;
    _typeToPc[gl.SAMPLER_CUBE] = pc.UNIFORMTYPE_TEXTURECUBE;
    if (this.device.webgl2) {
      _typeToPc[gl.SAMPLER_2D_SHADOW] = pc.UNIFORMTYPE_TEXTURE2D_SHADOW;
      _typeToPc[gl.SAMPLER_CUBE_SHADOW] = pc.UNIFORMTYPE_TEXTURECUBE_SHADOW;
      _typeToPc[gl.SAMPLER_3D] = pc.UNIFORMTYPE_TEXTURE3D;
    }
    var numAttributes = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);
    while (i < numAttributes) {
      info = gl.getActiveAttrib(this.program, i++);
      location = gl.getAttribLocation(this.program, info.name);
      if (this.definition.attributes[info.name] === undefined) {
        console.error('Vertex shader attribute "' + info.name + '" is not mapped to a semantic in shader definition.');
      }
      this.attributes.push(new pc.ShaderInput(this.device, this.definition.attributes[info.name], _typeToPc[info.type], location));
    }
    i = 0;
    var numUniforms = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);
    while (i < numUniforms) {
      info = gl.getActiveUniform(this.program, i++);
      location = gl.getUniformLocation(this.program, info.name);
      if (info.type === gl.SAMPLER_2D || info.type === gl.SAMPLER_CUBE || this.device.webgl2 && (info.type === gl.SAMPLER_2D_SHADOW || info.type === gl.SAMPLER_CUBE_SHADOW || info.type === gl.SAMPLER_3D)) {
        this.samplers.push(new pc.ShaderInput(this.device, info.name, _typeToPc[info.type], location));
      } else {
        this.uniforms.push(new pc.ShaderInput(this.device, info.name, _typeToPc[info.type], location));
      }
    }
    this.ready = true;
    return retValue;
  }, destroy:function() {
    var device = this.device;
    var idx = device.shaders.indexOf(this);
    if (idx !== -1) {
      device.shaders.splice(idx, 1);
    }
    if (this.program) {
      var gl = device.gl;
      gl.deleteProgram(this.program);
      this.program = null;
      this.device.removeShaderFromCache(this);
    }
  }});
  return {Shader:Shader};
}());
Object.assign(pc, function() {
  var ProgramLibrary = function(device) {
    this._device = device;
    this._cache = {};
    this._generators = {};
    this._isClearingCache = false;
  };
  ProgramLibrary.prototype.register = function(name, generator) {
    if (!this.isRegistered(name)) {
      this._generators[name] = generator;
    }
  };
  ProgramLibrary.prototype.unregister = function(name) {
    if (this.isRegistered(name)) {
      delete this._generators[name];
    }
  };
  ProgramLibrary.prototype.isRegistered = function(name) {
    var generator = this._generators[name];
    return generator !== undefined;
  };
  ProgramLibrary.prototype.getProgram = function(name, options) {
    var generator = this._generators[name];
    if (generator === undefined) {
      return null;
    }
    var gd = this._device;
    var key = generator.generateKey(gd, options);
    var shader = this._cache[key];
    if (!shader) {
      var shaderDefinition = generator.createShaderDefinition(gd, options);
      shader = this._cache[key] = new pc.Shader(gd, shaderDefinition);
    }
    return shader;
  };
  ProgramLibrary.prototype.clearCache = function() {
    var cache = this._cache;
    this._isClearingCache = true;
    for (var key in cache) {
      if (cache.hasOwnProperty(key)) {
        cache[key].destroy();
      }
    }
    this._cache = {};
    this._isClearingCache = false;
  };
  ProgramLibrary.prototype.removeFromCache = function(shader) {
    if (this._isClearingCache) {
      return;
    }
    var cache = this._cache;
    for (var key in cache) {
      if (cache.hasOwnProperty(key)) {
        if (cache[key] === shader) {
          delete cache[key];
          break;
        }
      }
    }
  };
  return {ProgramLibrary:ProgramLibrary};
}());
Object.assign(pc, function() {
  var EVENT_RESIZE = "resizecanvas";
  var _downsampleImage = function(image, size) {
    var srcW = image.width;
    var srcH = image.height;
    if (srcW > size || srcH > size) {
      var scale = size / Math.max(srcW, srcH);
      var dstW = Math.floor(srcW * scale);
      var dstH = Math.floor(srcH * scale);
      console.warn("Image dimensions larger than max supported texture size of " + size + ". " + "Resizing from " + srcW + ", " + srcH + " to " + dstW + ", " + dstH + ".");
      var canvas = document.createElement("canvas");
      canvas.width = dstW;
      canvas.height = dstH;
      var context = canvas.getContext("2d");
      context.drawImage(image, 0, 0, srcW, srcH, 0, 0, dstW, dstH);
      return canvas;
    }
    return image;
  };
  function _isIE() {
    var ua = window.navigator.userAgent;
    var msie = ua.indexOf("MSIE ");
    var trident = navigator.userAgent.match(/Trident.*rv:11\./);
    return msie > 0 || !!trident;
  }
  function testRenderable(gl, pixelFormat) {
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    var width = 2;
    var height = 2;
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, pixelFormat, null);
    var fbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    gl.bindTexture(gl.TEXTURE_2D, null);
    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
      gl.deleteTexture(texture);
      return false;
    }
    gl.deleteTexture(texture);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return true;
  }
  function testUnsignedByteAttribute(gl) {
    var storage = new ArrayBuffer(16);
    var bufferId = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);
    gl.bufferData(gl.ARRAY_BUFFER, storage, gl.STATIC_DRAW);
    gl.getError();
    gl.vertexAttribPointer(0, 4, gl.UNSIGNED_BYTE, false, 4, 0);
    var supported = gl.getError() === 0;
    gl.deleteBuffer(bufferId);
    return supported;
  }
  var GraphicsDevice = function(canvas, options) {
    var i;
    this.canvas = canvas;
    this.shader = null;
    this.indexBuffer = null;
    this.vertexBuffers = [];
    this.vbOffsets = [];
    this._enableAutoInstancing = false;
    this.autoInstancingMaxObjects = 16384;
    this.attributesInvalidated = true;
    this.boundBuffer = null;
    this.instancedAttribs = {};
    this.enabledAttributes = {};
    this.transformFeedbackBuffer = null;
    this.activeFramebuffer = null;
    this.activeTexture = 0;
    this.textureUnits = [];
    this._maxPixelRatio = 1;
    this.renderTarget = null;
    this.feedback = null;
    this._width = 0;
    this._height = 0;
    this.updateClientRect();
    this.shaders = [];
    this.buffers = [];
    this.textures = [];
    this.targets = [];
    this.contextLost = false;
    canvas.addEventListener("webglcontextlost", function(event) {
      event.preventDefault();
      this.contextLost = true;
      this.fire("devicelost");
    }.bind(this), false);
    canvas.addEventListener("webglcontextrestored", function() {
      this.initializeContext();
      this.contextLost = false;
      this.fire("devicerestored");
    }.bind(this), false);
    var preferWebGl2 = options && options.preferWebGl2 !== undefined ? options.preferWebGl2 : true;
    var names = preferWebGl2 ? ["webgl2", "experimental-webgl2", "webgl", "experimental-webgl"] : ["webgl", "experimental-webgl"];
    var gl = null;
    options = options || {};
    options.stencil = true;
    for (i = 0;i < names.length;i++) {
      try {
        gl = canvas.getContext(names[i], options);
      } catch (e) {
      }
      if (gl) {
        this.webgl2 = preferWebGl2 && i < 2;
        break;
      }
    }
    if (!gl) {
      throw new Error("WebGL not supported");
    }
    this.gl = gl;
    this.initializeExtensions();
    this.initializeCapabilities();
    this.initializeRenderState();
    for (i = 0;i < this.maxCombinedTextures;i++) {
      this.textureUnits.push([null, null, null]);
    }
    (function() {
      this.defaultClearOptions = {color:[0, 0, 0, 1], depth:1, stencil:0, flags:pc.CLEARFLAG_COLOR | pc.CLEARFLAG_DEPTH};
      this.glAddress = [gl.REPEAT, gl.CLAMP_TO_EDGE, gl.MIRRORED_REPEAT];
      this.glBlendEquation = [gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT, this.webgl2 ? gl.MIN : this.extBlendMinmax ? this.extBlendMinmax.MIN_EXT : gl.FUNC_ADD, this.webgl2 ? gl.MAX : this.extBlendMinmax ? this.extBlendMinmax.MAX_EXT : gl.FUNC_ADD];
      this.glBlendFunction = [gl.ZERO, gl.ONE, gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.DST_COLOR, gl.ONE_MINUS_DST_COLOR, gl.SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.ONE_MINUS_SRC_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA];
      this.glComparison = [gl.NEVER, gl.LESS, gl.EQUAL, gl.LEQUAL, gl.GREATER, gl.NOTEQUAL, gl.GEQUAL, gl.ALWAYS];
      this.glStencilOp = [gl.KEEP, gl.ZERO, gl.REPLACE, gl.INCR, gl.INCR_WRAP, gl.DECR, gl.DECR_WRAP, gl.INVERT];
      this.glClearFlag = [0, gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT];
      this.glCull = [0, gl.BACK, gl.FRONT, gl.FRONT_AND_BACK];
      this.glFilter = [gl.NEAREST, gl.LINEAR, gl.NEAREST_MIPMAP_NEAREST, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_LINEAR];
      this.glPrimitive = [gl.POINTS, gl.LINES, gl.LINE_LOOP, gl.LINE_STRIP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN];
      this.glType = [gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT, gl.FLOAT];
      this.targetToSlot = {};
      this.targetToSlot[gl.TEXTURE_2D] = 0;
      this.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;
      this.targetToSlot[gl.TEXTURE_3D] = 2;
      var scopeX, scopeY, scopeZ, scopeW;
      var uniformValue;
      this.commitFunction = [];
      this.commitFunction[pc.UNIFORMTYPE_BOOL] = function(uniform, value) {
        if (uniform.value !== value) {
          gl.uniform1i(uniform.locationId, value);
          uniform.value = value;
        }
      };
      this.commitFunction[pc.UNIFORMTYPE_INT] = this.commitFunction[pc.UNIFORMTYPE_BOOL];
      this.commitFunction[pc.UNIFORMTYPE_FLOAT] = function(uniform, value) {
        if (uniform.value !== value) {
          gl.uniform1f(uniform.locationId, value);
          uniform.value = value;
        }
      };
      this.commitFunction[pc.UNIFORMTYPE_VEC2] = function(uniform, value) {
        uniformValue = uniform.value;
        scopeX = value[0];
        scopeY = value[1];
        if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
          gl.uniform2fv(uniform.locationId, value);
          uniformValue[0] = scopeX;
          uniformValue[1] = scopeY;
        }
      };
      this.commitFunction[pc.UNIFORMTYPE_VEC3] = function(uniform, value) {
        uniformValue = uniform.value;
        scopeX = value[0];
        scopeY = value[1];
        scopeZ = value[2];
        if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
          gl.uniform3fv(uniform.locationId, value);
          uniformValue[0] = scopeX;
          uniformValue[1] = scopeY;
          uniformValue[2] = scopeZ;
        }
      };
      this.commitFunction[pc.UNIFORMTYPE_VEC4] = function(uniform, value) {
        uniformValue = uniform.value;
        scopeX = value[0];
        scopeY = value[1];
        scopeZ = value[2];
        scopeW = value[3];
        if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
          gl.uniform4fv(uniform.locationId, value);
          uniformValue[0] = scopeX;
          uniformValue[1] = scopeY;
          uniformValue[2] = scopeZ;
          uniformValue[3] = scopeW;
        }
      };
      this.commitFunction[pc.UNIFORMTYPE_IVEC2] = function(uniform, value) {
        uniformValue = uniform.value;
        scopeX = value[0];
        scopeY = value[1];
        if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
          gl.uniform2iv(uniform.locationId, value);
          uniformValue[0] = scopeX;
          uniformValue[1] = scopeY;
        }
      };
      this.commitFunction[pc.UNIFORMTYPE_BVEC2] = this.commitFunction[pc.UNIFORMTYPE_IVEC2];
      this.commitFunction[pc.UNIFORMTYPE_IVEC3] = function(uniform, value) {
        uniformValue = uniform.value;
        scopeX = value[0];
        scopeY = value[1];
        scopeZ = value[2];
        if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
          gl.uniform3iv(uniform.locationId, value);
          uniformValue[0] = scopeX;
          uniformValue[1] = scopeY;
          uniformValue[2] = scopeZ;
        }
      };
      this.commitFunction[pc.UNIFORMTYPE_BVEC3] = this.commitFunction[pc.UNIFORMTYPE_IVEC3];
      this.commitFunction[pc.UNIFORMTYPE_IVEC4] = function(uniform, value) {
        uniformValue = uniform.value;
        scopeX = value[0];
        scopeY = value[1];
        scopeZ = value[2];
        scopeW = value[3];
        if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
          gl.uniform4iv(uniform.locationId, value);
          uniformValue[0] = scopeX;
          uniformValue[1] = scopeY;
          uniformValue[2] = scopeZ;
          uniformValue[3] = scopeW;
        }
      };
      this.commitFunction[pc.UNIFORMTYPE_BVEC4] = this.commitFunction[pc.UNIFORMTYPE_IVEC4];
      this.commitFunction[pc.UNIFORMTYPE_MAT2] = function(uniform, value) {
        gl.uniformMatrix2fv(uniform.locationId, false, value);
      };
      this.commitFunction[pc.UNIFORMTYPE_MAT3] = function(uniform, value) {
        gl.uniformMatrix3fv(uniform.locationId, false, value);
      };
      this.commitFunction[pc.UNIFORMTYPE_MAT4] = function(uniform, value) {
        gl.uniformMatrix4fv(uniform.locationId, false, value);
      };
      this.commitFunction[pc.UNIFORMTYPE_FLOATARRAY] = function(uniform, value) {
        gl.uniform1fv(uniform.locationId, value);
      };
      this.scope = new pc.ScopeSpace("Device");
      this.programLib = new pc.ProgramLibrary(this);
      for (var generator in pc.programlib) {
        this.programLib.register(generator, pc.programlib[generator]);
      }
      pc.events.attach(this);
      this.supportsBoneTextures = this.extTextureFloat && this.maxVertexTextures > 0;
      this.useTexCubeLod = this.extTextureLod && this.maxTextures < 16;
      var numUniforms = this.vertexUniformsCount;
      numUniforms -= 4 * 4;
      numUniforms -= 8;
      numUniforms -= 1;
      numUniforms -= 4 * 4;
      this.boneLimit = Math.floor(numUniforms / 4);
      this.boneLimit = Math.min(this.boneLimit, 128);
      if (this.unmaskedRenderer === "Mali-450 MP") {
        this.boneLimit = 34;
      }
      if (this.unmaskedRenderer === "Apple A8 GPU") {
        this.forceCpuParticles = true;
      }
      this._drawCallsPerFrame = 0;
      this._shaderSwitchesPerFrame = 0;
      this._primsPerFrame = [];
      for (i = pc.PRIMITIVE_POINTS;i <= pc.PRIMITIVE_TRIFAN;i++) {
        this._primsPerFrame[i] = 0;
      }
      this._renderTargetCreationTime = 0;
      this._vram = {tex:0, vb:0, ib:0};
      this._shaderStats = {vsCompiled:0, fsCompiled:0, linked:0, materialShaders:0, compileTime:0};
      this.supportsUnsignedByte = testUnsignedByteAttribute(gl);
      this.constantTexSource = this.scope.resolve("source");
      if (!pc._benchmarked) {
        if (this.extTextureFloat) {
          if (this.webgl2) {
            this.extTextureFloatRenderable = this.extColorBufferFloat;
          } else {
            this.extTextureFloatRenderable = testRenderable(gl, gl.FLOAT);
          }
        }
        if (this.extTextureHalfFloat) {
          if (this.webgl2) {
            this.extTextureHalfFloatRenderable = this.extColorBufferFloat;
          } else {
            this.extTextureHalfFloatRenderable = testRenderable(gl, this.extTextureHalfFloat.HALF_FLOAT_OES);
          }
        }
        if (this.extTextureFloatRenderable) {
          var device = this;
          var chunks = pc.shaderChunks;
          var test1 = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.precisionTestPS, "ptest1");
          var test2 = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.precisionTest2PS, "ptest2");
          var size = 1;
          var tex = new pc.Texture(device, {format:pc.PIXELFORMAT_RGBA32F, width:size, height:size, mipmaps:false, minFilter:pc.FILTER_NEAREST, magFilter:pc.FILTER_NEAREST});
          var targ = new pc.RenderTarget(device, tex, {depth:false});
          pc.drawQuadWithShader(device, targ, test1);
          var tex2 = new pc.Texture(device, {format:pc.PIXELFORMAT_R8_G8_B8_A8, width:size, height:size, mipmaps:false, minFilter:pc.FILTER_NEAREST, magFilter:pc.FILTER_NEAREST});
          var targ2 = new pc.RenderTarget(device, tex2, {depth:false});
          this.constantTexSource.setValue(tex);
          pc.drawQuadWithShader(device, targ2, test2);
          var pixels = new Uint8Array(size * size * 4);
          gl.bindFramebuffer(gl.FRAMEBUFFER, targ2._glFrameBuffer);
          gl.readPixels(0, 0, size, size, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
          var x = pixels[0] / 255.0;
          var y = pixels[1] / 255.0;
          var z = pixels[2] / 255.0;
          var w = pixels[3] / 255.0;
          var f = x / (256.0 * 256.0 * 256.0) + y / (256.0 * 256.0) + z / 256.0 + w;
          this.extTextureFloatHighPrecision = f === 0.0;
          tex.destroy();
          targ.destroy();
          tex2.destroy();
          targ2.destroy();
          pc.destroyPostEffectQuad();
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        pc.extTextureFloatRenderable = this.extTextureFloatRenderable;
        pc.extTextureHalfFloatRenderable = this.extTextureHalfFloatRenderable;
        pc.extTextureFloatHighPrecision = this.extTextureFloatHighPrecision;
        pc._benchmarked = true;
      } else {
        this.extTextureFloatRenderable = pc.extTextureFloatRenderable;
        this.extTextureHalfFloatRenderable = pc.extTextureHalfFloatRenderable;
        this.extTextureFloatHighPrecision = pc.extTextureFloatHighPrecision;
      }
    }).call(this);
  };
  Object.assign(GraphicsDevice.prototype, {getPrecision:function() {
    var gl = this.gl;
    var precision = "highp";
    if (gl.getShaderPrecisionFormat) {
      var vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);
      var vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);
      var fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
      var fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);
      var highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;
      var mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;
      if (!highpAvailable) {
        if (mediumpAvailable) {
          precision = "mediump";
        } else {
          precision = "lowp";
        }
      }
    }
    return precision;
  }, initializeExtensions:function() {
    var gl = this.gl;
    if (this.webgl2) {
      this.extBlendMinmax = true;
      this.extDrawBuffers = true;
      this.extInstancing = true;
      this.extStandardDerivatives = true;
      this.extTextureFloat = true;
      this.extTextureHalfFloat = true;
      this.extTextureHalfFloatLinear = true;
      this.extTextureLod = true;
      this.extUintElement = true;
    } else {
      this.extBlendMinmax = gl.getExtension("EXT_blend_minmax");
      this.extDrawBuffers = gl.getExtension("EXT_draw_buffers");
      this.extInstancing = gl.getExtension("ANGLE_instanced_arrays");
      this.extStandardDerivatives = gl.getExtension("OES_standard_derivatives");
      this.extTextureFloat = gl.getExtension("OES_texture_float");
      this.extTextureHalfFloat = gl.getExtension("OES_texture_half_float");
      this.extTextureHalfFloatLinear = gl.getExtension("OES_texture_half_float_linear");
      this.extTextureLod = gl.getExtension("EXT_shader_texture_lod");
      this.extUintElement = gl.getExtension("OES_element_index_uint");
    }
    this.extRendererInfo = gl.getExtension("WEBGL_debug_renderer_info");
    this.extTextureFloatLinear = gl.getExtension("OES_texture_float_linear");
    this.extColorBufferFloat = gl.getExtension("EXT_color_buffer_float");
    this.extTextureFilterAnisotropic = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
    this.extCompressedTextureETC1 = gl.getExtension("WEBGL_compressed_texture_etc1");
    this.extCompressedTexturePVRTC = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
    this.extCompressedTextureS3TC = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
    if (this.extCompressedTextureS3TC && _isIE()) {
      this.extCompressedTextureS3TC = null;
    }
  }, initializeCapabilities:function() {
    var gl = this.gl;
    this.maxPrecision = this.precision = this.getPrecision();
    var contextAttribs = gl.getContextAttributes();
    this.supportsMsaa = contextAttribs.antialias;
    this.supportsStencil = contextAttribs.stencil;
    this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    this.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
    this.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
    this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.maxCombinedTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    this.vertexUniformsCount = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    this.fragmentUniformsCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
    this.unmaskedRenderer = this.extRendererInfo ? gl.getParameter(this.extRendererInfo.UNMASKED_RENDERER_WEBGL) : "";
    this.unmaskedVendor = this.extRendererInfo ? gl.getParameter(this.extRendererInfo.UNMASKED_VENDOR_WEBGL) : "";
    if (this.webgl2) {
      this.maxDrawBuffers = gl.getParameter(gl.MAX_DRAW_BUFFERS);
      this.maxColorAttachments = gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);
      this.maxVolumeSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
    } else {
      this.maxDrawBuffers = this.extDrawBuffers ? gl.getParameter(this.extDrawBuffers.MAX_DRAW_BUFFERS_EXT) : 1;
      this.maxColorAttachments = this.extDrawBuffers ? gl.getParameter(this.extDrawBuffers.MAX_COLOR_ATTACHMENTS_EXT) : 1;
      this.maxVolumeSize = 1;
    }
  }, initializeRenderState:function() {
    var gl = this.gl;
    this.blending = false;
    gl.disable(gl.BLEND);
    this.blendSrc = pc.BLENDMODE_ONE;
    this.blendDst = pc.BLENDMODE_ZERO;
    this.blendSrcAlpha = pc.BLENDMODE_ONE;
    this.blendDstAlpha = pc.BLENDMODE_ZERO;
    this.separateAlphaBlend = false;
    this.blendEquation = pc.BLENDEQUATION_ADD;
    this.blendAlphaEquation = pc.BLENDEQUATION_ADD;
    this.separateAlphaEquation = false;
    gl.blendFunc(gl.ONE, gl.ZERO);
    gl.blendEquation(gl.FUNC_ADD);
    this.writeRed = true;
    this.writeGreen = true;
    this.writeBlue = true;
    this.writeAlpha = true;
    gl.colorMask(true, true, true, true);
    this.cullMode = pc.CULLFACE_BACK;
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    this.depthTest = true;
    gl.enable(gl.DEPTH_TEST);
    this.depthFunc = pc.FUNC_LESSEQUAL;
    gl.depthFunc(gl.LEQUAL);
    this.depthWrite = true;
    gl.depthMask(true);
    this.stencil = false;
    gl.disable(gl.STENCIL_TEST);
    this.stencilFuncFront = this.stencilFuncBack = pc.FUNC_ALWAYS;
    this.stencilRefFront = this.stencilRefBack = 0;
    this.stencilMaskFront = this.stencilMaskBack = 255;
    gl.stencilFunc(gl.ALWAYS, 0, 255);
    this.stencilFailFront = this.stencilFailBack = pc.STENCILOP_KEEP;
    this.stencilZfailFront = this.stencilZfailBack = pc.STENCILOP_KEEP;
    this.stencilZpassFront = this.stencilZpassBack = pc.STENCILOP_KEEP;
    this.stencilWriteMaskFront = 255;
    this.stencilWriteMaskBack = 255;
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilMask(255);
    this.alphaToCoverage = false;
    this.raster = true;
    if (this.webgl2) {
      gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
      gl.disable(gl.RASTERIZER_DISCARD);
    }
    this.depthBiasEnabled = false;
    gl.disable(gl.POLYGON_OFFSET_FILL);
    this.clearDepth = 1;
    gl.clearDepth(1);
    this.clearRed = 0;
    this.clearBlue = 0;
    this.clearGreen = 0;
    this.clearAlpha = 0;
    gl.clearColor(0, 0, 0, 0);
    this.clearStencil = 0;
    gl.clearStencil(0);
    this.vx = this.vy = this.vw = this.vh = 0;
    this.sx = this.sy = this.sw = this.sh = 0;
    if (this.webgl2) {
      gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);
    } else {
      if (this.extStandardDerivatives) {
        gl.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, gl.NICEST);
      }
    }
    gl.enable(gl.SCISSOR_TEST);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
  }, initializeContext:function() {
    this.initializeExtensions();
    this.initializeCapabilities();
    this.initializeRenderState();
    var i, len;
    for (i = 0, len = this.shaders.length;i < len;i++) {
      this.shaders[i].compile();
    }
    this.shader = null;
    for (i = 0, len = this.buffers.length;i < len;i++) {
      this.buffers[i].bufferId = undefined;
      this.buffers[i].unlock();
    }
    this.boundBuffer = null;
    this.indexBuffer = null;
    this.attributesInvalidated = true;
    this.enabledAttributes = {};
    this.vertexBuffers = [];
    for (i = 0, len = this.textures.length;i < len;i++) {
      var texture = this.textures[i];
      texture.dirtyAll();
    }
    this.activeTexture = 0;
    this.textureUnits.length = 0;
    for (i = 0;i < this.maxCombinedTextures;i++) {
      this.textureUnits.push([null, null, null]);
    }
    for (i = 0, len = this.targets.length;i < len;i++) {
      this.targets[i]._glFrameBuffer = undefined;
      this.targets[i]._glDepthBuffer = undefined;
      this.targets[i]._glResolveFrameBuffer = undefined;
      this.targets[i]._glMsaaColorBuffer = undefined;
      this.targets[i]._glMsaaDepthBuffer = undefined;
    }
    this.renderTarget = null;
    this.activeFramebuffer = null;
    this.feedback = null;
    this.transformFeedbackBuffer = null;
  }, updateClientRect:function() {
    this.clientRect = this.canvas.getBoundingClientRect();
  }, setViewport:function(x, y, w, h) {
    if (this.vx !== x || this.vy !== y || this.vw !== w || this.vh !== h) {
      this.gl.viewport(x, y, w, h);
      this.vx = x;
      this.vy = y;
      this.vw = w;
      this.vh = h;
    }
  }, setScissor:function(x, y, w, h) {
    if (this.sx !== x || this.sy !== y || this.sw !== w || this.sh !== h) {
      this.gl.scissor(x, y, w, h);
      this.sx = x;
      this.sy = y;
      this.sw = w;
      this.sh = h;
    }
  }, getProgramLibrary:function() {
    return this.programLib;
  }, setProgramLibrary:function(programLib) {
    this.programLib = programLib;
  }, setFramebuffer:function(fb) {
    if (this.activeFramebuffer !== fb) {
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, fb);
      this.activeFramebuffer = fb;
    }
  }, _checkFbo:function() {
    var gl = this.gl;
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    switch(status) {
      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        console.error("ERROR: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
        break;
      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        console.error("ERROR: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
        break;
      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        console.error("ERROR: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
        break;
      case gl.FRAMEBUFFER_UNSUPPORTED:
        console.error("ERROR: FRAMEBUFFER_UNSUPPORTED");
        break;
      case gl.FRAMEBUFFER_COMPLETE:
        break;
      default:
        break;
    }
  }, copyRenderTarget:function(source, dest, color, depth) {
    var gl = this.gl;
    if (!this.webgl2 && depth) {
      return false;
    }
    if (color) {
      if (!dest) {
        if (!source._colorBuffer) {
          return false;
        }
      } else {
        if (!source._colorBuffer || !dest._colorBuffer) {
          return false;
        }
        if (source._colorBuffer._format !== dest._colorBuffer._format) {
          return false;
        }
      }
    }
    if (depth) {
      if (!source._depthBuffer || !dest._depthBuffer) {
        return false;
      }
      if (source._depthBuffer._format !== dest._depthBuffer._format) {
        return false;
      }
    }
    if (this.webgl2 && dest) {
      var prevRt = this.renderTarget;
      this.renderTarget = dest;
      this.updateBegin();
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, source ? source._glFrameBuffer : null);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dest._glFrameBuffer);
      var w = source ? source.width : dest.width;
      var h = source ? source.height : dest.height;
      gl.blitFramebuffer(0, 0, w, h, 0, 0, w, h, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);
      this.renderTarget = prevRt;
      gl.bindFramebuffer(gl.FRAMEBUFFER, prevRt ? prevRt._glFrameBuffer : null);
    } else {
      if (!this._copyShader) {
        var chunks = pc.shaderChunks;
        this._copyShader = chunks.createShaderFromCode(this, chunks.fullscreenQuadVS, chunks.outputTex2DPS, "outputTex2D");
      }
      this.constantTexSource.setValue(source._colorBuffer);
      pc.drawQuadWithShader(this, dest, this._copyShader);
    }
    return true;
  }, updateBegin:function() {
    var gl = this.gl;
    this.boundBuffer = null;
    this.indexBuffer = null;
    var target = this.renderTarget;
    if (target) {
      if (!target._glFrameBuffer) {
        target._device = this;
        target._glFrameBuffer = gl.createFramebuffer();
        this.setFramebuffer(target._glFrameBuffer);
        var colorBuffer = target._colorBuffer;
        if (colorBuffer) {
          if (!colorBuffer._glTextureId) {
            colorBuffer._width = Math.min(colorBuffer.width, this.maxRenderBufferSize);
            colorBuffer._height = Math.min(colorBuffer.height, this.maxRenderBufferSize);
            this.setTexture(colorBuffer, 0);
          }
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer._glTextureId, 0);
        }
        var depthBuffer = target._depthBuffer;
        if (depthBuffer && this.webgl2) {
          if (!depthBuffer._glTextureId) {
            depthBuffer._width = Math.min(depthBuffer.width, this.maxRenderBufferSize);
            depthBuffer._height = Math.min(depthBuffer.height, this.maxRenderBufferSize);
            this.setTexture(depthBuffer, 0);
          }
          if (target._stencil) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer._glTextureId, 0);
          } else {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer._glTextureId, 0);
          }
        } else {
          if (target._depth) {
            var willRenderMsaa = target._samples > 1 && this.webgl2;
            if (!willRenderMsaa) {
              if (!target._glDepthBuffer) {
                target._glDepthBuffer = gl.createRenderbuffer();
              }
              gl.bindRenderbuffer(gl.RENDERBUFFER, target._glDepthBuffer);
              if (target._stencil) {
                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, target.width, target.height);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, target._glDepthBuffer);
              } else {
                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, target.width, target.height);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target._glDepthBuffer);
              }
              gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            }
          }
        }
        if (this.webgl2 && target._samples > 1) {
          target._glResolveFrameBuffer = target._glFrameBuffer;
          target._glFrameBuffer = gl.createFramebuffer();
          this.setFramebuffer(target._glFrameBuffer);
          if (colorBuffer) {
            if (!target._glMsaaColorBuffer) {
              target._glMsaaColorBuffer = gl.createRenderbuffer();
            }
            gl.bindRenderbuffer(gl.RENDERBUFFER, target._glMsaaColorBuffer);
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer._glInternalFormat, target.width, target.height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, target._glMsaaColorBuffer);
          }
          if (target._depth) {
            if (!target._glMsaaDepthBuffer) {
              target._glMsaaDepthBuffer = gl.createRenderbuffer();
            }
            gl.bindRenderbuffer(gl.RENDERBUFFER, target._glMsaaDepthBuffer);
            if (target._stencil) {
              gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH24_STENCIL8, target.width, target.height);
              gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, target._glMsaaDepthBuffer);
            } else {
              gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH_COMPONENT32F, target.width, target.height);
              gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target._glMsaaDepthBuffer);
            }
          }
        }
        this.targets.push(target);
      } else {
        this.setFramebuffer(target._glFrameBuffer);
      }
    } else {
      this.setFramebuffer(null);
    }
  }, updateEnd:function() {
    var gl = this.gl;
    var target = this.renderTarget;
    if (target) {
      var colorBuffer = target._colorBuffer;
      if (colorBuffer && colorBuffer._glTextureId && colorBuffer.mipmaps && colorBuffer._pot) {
        this.bindTexture(this.maxCombinedTextures - 1, colorBuffer._glTarget, colorBuffer._glTextureId);
        gl.generateMipmap(colorBuffer._glTarget);
      }
      if (this.webgl2 && target._samples > 1 && target.autoResolve) {
        target.resolve();
      }
    }
  }, initializeTexture:function(texture) {
    var gl = this.gl;
    var ext;
    texture._glTextureId = gl.createTexture();
    texture._glTarget = texture._cubemap ? gl.TEXTURE_CUBE_MAP : texture._volume ? gl.TEXTURE_3D : gl.TEXTURE_2D;
    switch(texture._format) {
      case pc.PIXELFORMAT_A8:
        texture._glFormat = gl.ALPHA;
        texture._glInternalFormat = gl.ALPHA;
        texture._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case pc.PIXELFORMAT_L8:
        texture._glFormat = gl.LUMINANCE;
        texture._glInternalFormat = gl.LUMINANCE;
        texture._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case pc.PIXELFORMAT_L8_A8:
        texture._glFormat = gl.LUMINANCE_ALPHA;
        texture._glInternalFormat = gl.LUMINANCE_ALPHA;
        texture._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case pc.PIXELFORMAT_R5_G6_B5:
        texture._glFormat = gl.RGB;
        texture._glInternalFormat = gl.RGB;
        texture._glPixelType = gl.UNSIGNED_SHORT_5_6_5;
        break;
      case pc.PIXELFORMAT_R5_G5_B5_A1:
        texture._glFormat = gl.RGBA;
        texture._glInternalFormat = gl.RGBA;
        texture._glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;
        break;
      case pc.PIXELFORMAT_R4_G4_B4_A4:
        texture._glFormat = gl.RGBA;
        texture._glInternalFormat = gl.RGBA;
        texture._glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;
        break;
      case pc.PIXELFORMAT_R8_G8_B8:
        texture._glFormat = gl.RGB;
        texture._glInternalFormat = this.webgl2 ? gl.RGB8 : gl.RGB;
        texture._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case pc.PIXELFORMAT_R8_G8_B8_A8:
        texture._glFormat = gl.RGBA;
        texture._glInternalFormat = this.webgl2 ? gl.RGBA8 : gl.RGBA;
        texture._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case pc.PIXELFORMAT_DXT1:
        ext = this.extCompressedTextureS3TC;
        texture._glFormat = gl.RGB;
        texture._glInternalFormat = ext.COMPRESSED_RGB_S3TC_DXT1_EXT;
        break;
      case pc.PIXELFORMAT_DXT3:
        ext = this.extCompressedTextureS3TC;
        texture._glFormat = gl.RGBA;
        texture._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        break;
      case pc.PIXELFORMAT_DXT5:
        ext = this.extCompressedTextureS3TC;
        texture._glFormat = gl.RGBA;
        texture._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        break;
      case pc.PIXELFORMAT_ETC1:
        ext = this.extCompressedTextureETC1;
        texture._glFormat = gl.RGB;
        texture._glInternalFormat = ext.COMPRESSED_RGB_ETC1_WEBGL;
        break;
      case pc.PIXELFORMAT_PVRTC_2BPP_RGB_1:
        ext = this.extCompressedTexturePVRTC;
        texture._glFormat = gl.RGB;
        texture._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        break;
      case pc.PIXELFORMAT_PVRTC_2BPP_RGBA_1:
        ext = this.extCompressedTexturePVRTC;
        texture._glFormat = gl.RGBA;
        texture._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        break;
      case pc.PIXELFORMAT_PVRTC_4BPP_RGB_1:
        ext = this.extCompressedTexturePVRTC;
        texture._glFormat = gl.RGB;
        texture._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        break;
      case pc.PIXELFORMAT_PVRTC_4BPP_RGBA_1:
        ext = this.extCompressedTexturePVRTC;
        texture._glFormat = gl.RGBA;
        texture._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        break;
      case pc.PIXELFORMAT_RGB16F:
        ext = this.extTextureHalfFloat;
        texture._glFormat = gl.RGB;
        if (this.webgl2) {
          texture._glInternalFormat = gl.RGB16F;
          texture._glPixelType = gl.HALF_FLOAT;
        } else {
          texture._glInternalFormat = gl.RGB;
          texture._glPixelType = ext.HALF_FLOAT_OES;
        }
        break;
      case pc.PIXELFORMAT_RGBA16F:
        ext = this.extTextureHalfFloat;
        texture._glFormat = gl.RGBA;
        if (this.webgl2) {
          texture._glInternalFormat = gl.RGBA16F;
          texture._glPixelType = gl.HALF_FLOAT;
        } else {
          texture._glInternalFormat = gl.RGBA;
          texture._glPixelType = ext.HALF_FLOAT_OES;
        }
        break;
      case pc.PIXELFORMAT_RGB32F:
        texture._glFormat = gl.RGB;
        if (this.webgl2) {
          texture._glInternalFormat = gl.RGB32F;
        } else {
          texture._glInternalFormat = gl.RGB;
        }
        texture._glPixelType = gl.FLOAT;
        break;
      case pc.PIXELFORMAT_RGBA32F:
        texture._glFormat = gl.RGBA;
        if (this.webgl2) {
          texture._glInternalFormat = gl.RGBA32F;
        } else {
          texture._glInternalFormat = gl.RGBA;
        }
        texture._glPixelType = gl.FLOAT;
        break;
      case pc.PIXELFORMAT_R32F:
        texture._glFormat = gl.RED;
        texture._glInternalFormat = gl.R32F;
        texture._glPixelType = gl.FLOAT;
        break;
      case pc.PIXELFORMAT_DEPTH:
        if (this.webgl2) {
          texture._glFormat = gl.DEPTH_COMPONENT;
          texture._glInternalFormat = gl.DEPTH_COMPONENT32F;
          texture._glPixelType = gl.FLOAT;
        } else {
          texture._glFormat = gl.DEPTH_COMPONENT;
          texture._glInternalFormat = gl.DEPTH_COMPONENT;
          texture._glPixelType = gl.UNSIGNED_SHORT;
        }
        break;
      case pc.PIXELFORMAT_DEPTHSTENCIL:
        texture._glFormat = gl.DEPTH_STENCIL;
        texture._glInternalFormat = gl.DEPTH24_STENCIL8;
        texture._glPixelType = gl.UNSIGNED_INT_24_8;
        break;
      case pc.PIXELFORMAT_111110F:
        texture._glFormat = gl.RGB;
        texture._glInternalFormat = gl.R11F_G11F_B10F;
        texture._glPixelType = gl.FLOAT;
        break;
      case pc.PIXELFORMAT_SRGB:
        texture._glFormat = gl.RGB;
        texture._glInternalFormat = gl.SRGB8;
        texture._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case pc.PIXELFORMAT_SRGBA:
        texture._glFormat = gl.RGBA;
        texture._glInternalFormat = gl.SRGB8_ALPHA8;
        texture._glPixelType = gl.UNSIGNED_BYTE;
        break;
    }
  }, uploadTexture:function(texture) {
    var gl = this.gl;
    if (!texture._needsUpload && (texture._needsMipmapsUpload && texture._mipmapsUploaded || !texture._pot)) {
      return;
    }
    var mipLevel = 0;
    var mipObject;
    var resMult;
    while (texture._levels[mipLevel] || mipLevel === 0) {
      if (!texture._needsUpload && mipLevel === 0) {
        mipLevel++;
        continue;
      } else {
        if (mipLevel && (!texture._needsMipmapsUpload || !texture._mipmaps)) {
          break;
        }
      }
      mipObject = texture._levels[mipLevel];
      if (mipLevel == 1 && !texture._compressed) {
        gl.generateMipmap(texture._glTarget);
        texture._mipmapsUploaded = true;
      }
      if (texture._cubemap) {
        var face;
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        if (mipObject[0] instanceof HTMLCanvasElement || mipObject[0] instanceof HTMLImageElement || mipObject[0] instanceof HTMLVideoElement) {
          for (face = 0;face < 6;face++) {
            if (!texture._levelsUpdated[0][face]) {
              continue;
            }
            var src = mipObject[face];
            if (src instanceof HTMLImageElement) {
              if (src.width > this.maxCubeMapSize || src.height > this.maxCubeMapSize) {
                src = _downsampleImage(src, this.maxCubeMapSize);
                if (mipLevel === 0) {
                  texture.width = src.width;
                  texture.height = src.height;
                }
              }
            }
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, texture._glInternalFormat, texture._glFormat, texture._glPixelType, src);
          }
        } else {
          resMult = 1 / Math.pow(2, mipLevel);
          for (face = 0;face < 6;face++) {
            if (!texture._levelsUpdated[0][face]) {
              continue;
            }
            var texData = mipObject[face];
            if (texture._compressed) {
              gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texData);
            } else {
              gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texture._glFormat, texture._glPixelType, texData);
            }
          }
        }
      } else {
        if (texture._volume) {
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
          resMult = 1 / Math.pow(2, mipLevel);
          if (texture._compressed) {
            gl.compressedTexImage3D(gl.TEXTURE_3D, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, mipObject);
          } else {
            gl.texImage3D(gl.TEXTURE_3D, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, texture._glFormat, texture._glPixelType, mipObject);
          }
        } else {
          if (mipObject instanceof HTMLCanvasElement || mipObject instanceof HTMLImageElement || mipObject instanceof HTMLVideoElement) {
            if (mipObject instanceof HTMLImageElement) {
              if (mipObject.width > this.maxTextureSize || mipObject.height > this.maxTextureSize) {
                mipObject = _downsampleImage(mipObject, this.maxTextureSize);
                if (mipLevel === 0) {
                  texture.width = mipObject.width;
                  texture.height = mipObject.height;
                }
              }
            }
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture._flipY);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            gl.texImage2D(gl.TEXTURE_2D, mipLevel, texture._glInternalFormat, texture._glFormat, texture._glPixelType, mipObject);
          } else {
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            resMult = 1 / Math.pow(2, mipLevel);
            if (texture._compressed) {
              gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, mipObject);
            } else {
              gl.texImage2D(gl.TEXTURE_2D, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texture._glFormat, texture._glPixelType, mipObject);
            }
          }
          if (mipLevel === 0) {
            texture._mipmapsUploaded = false;
          } else {
            texture._mipmapsUploaded = true;
          }
        }
      }
      mipLevel++;
    }
    if (texture._needsUpload) {
      if (texture._cubemap) {
        for (var i = 0;i < 6;i++) {
          texture._levelsUpdated[0][i] = false;
        }
      } else {
        texture._levelsUpdated[0] = false;
      }
    }
    if (!texture._compressed && texture._mipmaps && texture._needsMipmapsUpload && texture._pot && texture._levels.length === 1) {
      gl.generateMipmap(texture._glTarget);
      texture._mipmapsUploaded = true;
    }
    if (texture._gpuSize) {
      this._vram.tex -= texture._gpuSize;
    }
    texture._gpuSize = texture.gpuSize;
    this._vram.tex += texture._gpuSize;
  }, bindTexture:function(textureUnit, textureTarget, textureObject) {
    var slot = this.targetToSlot[textureTarget];
    if (this.textureUnits[textureUnit][slot] !== textureObject) {
      var gl = this.gl;
      if (this.activeTexture !== textureUnit) {
        gl.activeTexture(gl.TEXTURE0 + textureUnit);
        this.activeTexture = textureUnit;
      }
      gl.bindTexture(textureTarget, textureObject);
      this.textureUnits[textureUnit][slot] = textureObject;
    }
  }, setTexture:function(texture, textureUnit) {
    var gl = this.gl;
    if (!texture._glTextureId) {
      this.initializeTexture(texture);
    }
    this.bindTexture(textureUnit, texture._glTarget, texture._glTextureId);
    var paramDirty = texture._minFilterDirty || texture._magFilterDirty || texture._addressUDirty || texture._addressVDirty || texture._addressWDirty || texture._anisotropyDirty || texture._compareModeDirty;
    if (paramDirty) {
      if (texture._minFilterDirty) {
        var filter = texture._minFilter;
        if (!texture._pot || !texture._mipmaps || texture._compressed && texture._levels.length === 1) {
          if (filter === pc.FILTER_NEAREST_MIPMAP_NEAREST || filter === pc.FILTER_NEAREST_MIPMAP_LINEAR) {
            filter = pc.FILTER_NEAREST;
          } else {
            if (filter === pc.FILTER_LINEAR_MIPMAP_NEAREST || filter === pc.FILTER_LINEAR_MIPMAP_LINEAR) {
              filter = pc.FILTER_LINEAR;
            }
          }
        }
        gl.texParameteri(texture._glTarget, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);
        texture._minFilterDirty = false;
      }
      if (texture._magFilterDirty) {
        gl.texParameteri(texture._glTarget, gl.TEXTURE_MAG_FILTER, this.glFilter[texture._magFilter]);
        texture._magFilterDirty = false;
      }
      if (texture._addressUDirty) {
        if (this.webgl2) {
          gl.texParameteri(texture._glTarget, gl.TEXTURE_WRAP_S, this.glAddress[texture._addressU]);
        } else {
          gl.texParameteri(texture._glTarget, gl.TEXTURE_WRAP_S, this.glAddress[texture._pot ? texture._addressU : pc.ADDRESS_CLAMP_TO_EDGE]);
        }
        texture._addressUDirty = false;
      }
      if (texture._addressVDirty) {
        if (this.webgl2) {
          gl.texParameteri(texture._glTarget, gl.TEXTURE_WRAP_T, this.glAddress[texture._addressV]);
        } else {
          gl.texParameteri(texture._glTarget, gl.TEXTURE_WRAP_T, this.glAddress[texture._pot ? texture._addressV : pc.ADDRESS_CLAMP_TO_EDGE]);
        }
        texture._addressVDirty = false;
      }
      if (texture._addressWDirty) {
        if (this.webgl2) {
          gl.texParameteri(texture._glTarget, gl.TEXTURE_WRAP_R, this.glAddress[texture._addressW]);
        }
        texture._addressWDirty = false;
      }
      if (texture._compareModeDirty) {
        if (this.webgl2) {
          gl.texParameteri(texture._glTarget, gl.TEXTURE_COMPARE_MODE, texture._compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);
          gl.texParameteri(texture._glTarget, gl.TEXTURE_COMPARE_FUNC, this.glComparison[texture._compareFunc]);
        }
        texture._compareModeDirty = false;
      }
      if (texture._anisotropyDirty) {
        var ext = this.extTextureFilterAnisotropic;
        if (ext) {
          gl.texParameterf(texture._glTarget, ext.TEXTURE_MAX_ANISOTROPY_EXT, Math.max(1, Math.min(Math.round(texture._anisotropy), this.maxAnisotropy)));
        }
        texture._anisotropyDirty = false;
      }
    }
    if (texture._needsUpload || texture._needsMipmapsUpload) {
      this.uploadTexture(texture);
      texture._needsUpload = false;
      texture._needsMipmapsUpload = false;
    }
  }, draw:function(primitive, numInstances) {
    var gl = this.gl;
    var i, j, len;
    var sampler, samplerValue, texture, numTextures;
    var uniform, scopeId, uniformVersion, programVersion, locationId;
    var shader = this.shader;
    var samplers = shader.samplers;
    var uniforms = shader.uniforms;
    if (numInstances > 1) {
      this.boundBuffer = null;
      this.attributesInvalidated = true;
    }
    if (this.attributesInvalidated) {
      var attribute, element, vertexBuffer, vbOffset, bufferId;
      var attributes = shader.attributes;
      for (i = 0, len = attributes.length;i < len;i++) {
        attribute = attributes[i];
        element = attribute.scopeId.value;
        if (element !== null) {
          vertexBuffer = this.vertexBuffers[element.stream];
          vbOffset = this.vbOffsets[element.stream] || 0;
          bufferId = vertexBuffer.bufferId;
          if (this.boundBuffer !== bufferId) {
            gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);
            this.boundBuffer = bufferId;
          }
          locationId = attribute.locationId;
          if (!this.enabledAttributes[locationId]) {
            gl.enableVertexAttribArray(locationId);
            this.enabledAttributes[locationId] = true;
          }
          gl.vertexAttribPointer(locationId, element.numComponents, this.glType[element.dataType], element.normalize, element.stride, element.offset + vbOffset);
          if (element.stream === 1 && numInstances > 1) {
            if (!this.instancedAttribs[locationId]) {
              this.extInstancing.vertexAttribDivisorANGLE(locationId, 1);
              this.instancedAttribs[locationId] = true;
            }
          } else {
            if (this.instancedAttribs[locationId]) {
              this.extInstancing.vertexAttribDivisorANGLE(locationId, 0);
              this.instancedAttribs[locationId] = false;
            }
          }
        }
      }
      this.attributesInvalidated = false;
    }
    var textureUnit = 0;
    for (i = 0, len = samplers.length;i < len;i++) {
      sampler = samplers[i];
      samplerValue = sampler.scopeId.value;
      if (!samplerValue) {
        continue;
      }
      if (samplerValue instanceof pc.Texture) {
        texture = samplerValue;
        this.setTexture(texture, textureUnit);
        if (sampler.slot !== textureUnit) {
          gl.uniform1i(sampler.locationId, textureUnit);
          sampler.slot = textureUnit;
        }
        textureUnit++;
      } else {
        sampler.array.length = 0;
        numTextures = samplerValue.length;
        for (j = 0;j < numTextures;j++) {
          texture = samplerValue[j];
          this.setTexture(texture, textureUnit);
          sampler.array[j] = textureUnit;
          textureUnit++;
        }
        gl.uniform1iv(sampler.locationId, sampler.array);
      }
    }
    for (i = 0, len = uniforms.length;i < len;i++) {
      uniform = uniforms[i];
      scopeId = uniform.scopeId;
      uniformVersion = uniform.version;
      programVersion = scopeId.versionObject.version;
      if (uniformVersion.globalId !== programVersion.globalId || uniformVersion.revision !== programVersion.revision) {
        uniformVersion.globalId = programVersion.globalId;
        uniformVersion.revision = programVersion.revision;
        if (scopeId.value !== null) {
          this.commitFunction[uniform.dataType](uniform, scopeId.value);
        }
      }
    }
    this._drawCallsPerFrame++;
    this._primsPerFrame[primitive.type] += primitive.count * (numInstances > 1 ? numInstances : 1);
    if (this.webgl2 && this.transformFeedbackBuffer) {
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.bufferId);
      gl.beginTransformFeedback(gl.POINTS);
    }
    if (primitive.indexed) {
      if (numInstances > 1) {
        this.extInstancing.drawElementsInstancedANGLE(this.glPrimitive[primitive.type], primitive.count, this.indexBuffer.glFormat, primitive.base * 2, numInstances);
        this.boundBuffer = null;
        this.attributesInvalidated = true;
      } else {
        gl.drawElements(this.glPrimitive[primitive.type], primitive.count, this.indexBuffer.glFormat, primitive.base * this.indexBuffer.bytesPerIndex);
      }
    } else {
      if (numInstances > 1) {
        this.extInstancing.drawArraysInstancedANGLE(this.glPrimitive[primitive.type], primitive.base, primitive.count, numInstances);
        this.boundBuffer = null;
        this.attributesInvalidated = true;
      } else {
        gl.drawArrays(this.glPrimitive[primitive.type], primitive.base, primitive.count);
      }
    }
    if (this.webgl2 && this.transformFeedbackBuffer) {
      gl.endTransformFeedback();
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
    }
  }, clear:function(options) {
    var defaultOptions = this.defaultClearOptions;
    options = options || defaultOptions;
    var flags = options.flags == undefined ? defaultOptions.flags : options.flags;
    if (flags !== 0) {
      var gl = this.gl;
      if (flags & pc.CLEARFLAG_COLOR) {
        var color = options.color == undefined ? defaultOptions.color : options.color;
        this.setClearColor(color[0], color[1], color[2], color[3]);
      }
      if (flags & pc.CLEARFLAG_DEPTH) {
        var depth = options.depth == undefined ? defaultOptions.depth : options.depth;
        this.setClearDepth(depth);
        if (!this.depthWrite) {
          gl.depthMask(true);
        }
      }
      if (flags & pc.CLEARFLAG_STENCIL) {
        var stencil = options.stencil == undefined ? defaultOptions.stencil : options.stencil;
        this.setClearStencil(stencil);
      }
      gl.clear(this.glClearFlag[flags]);
      if (flags & pc.CLEARFLAG_DEPTH) {
        if (!this.depthWrite) {
          gl.depthMask(false);
        }
      }
    }
  }, readPixels:function(x, y, w, h, pixels) {
    var gl = this.gl;
    gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  }, setClearDepth:function(depth) {
    if (depth !== this.clearDepth) {
      this.gl.clearDepth(depth);
      this.clearDepth = depth;
    }
  }, setClearColor:function(r, g, b, a) {
    if (r !== this.clearRed || g !== this.clearGreen || b !== this.clearBlue || a !== this.clearAlpha) {
      this.gl.clearColor(r, g, b, a);
      this.clearRed = r;
      this.clearGreen = g;
      this.clearBlue = b;
      this.clearAlpha = a;
    }
  }, setClearStencil:function(value) {
    if (value !== this.clearStencil) {
      this.gl.clearStencil(value);
      this.clearStencil = value;
    }
  }, setRenderTarget:function(renderTarget) {
    this.renderTarget = renderTarget;
  }, getRenderTarget:function() {
    return this.renderTarget;
  }, getDepthTest:function() {
    return this.depthTest;
  }, setDepthTest:function(depthTest) {
    if (this.depthTest !== depthTest) {
      var gl = this.gl;
      if (depthTest) {
        gl.enable(gl.DEPTH_TEST);
      } else {
        gl.disable(gl.DEPTH_TEST);
      }
      this.depthTest = depthTest;
    }
  }, setDepthFunc:function(func) {
    if (this.depthFunc === func) {
      return;
    }
    this.gl.depthFunc(this.glComparison[func]);
    this.depthFunc = func;
  }, getDepthWrite:function() {
    return this.depthWrite;
  }, setDepthWrite:function(writeDepth) {
    if (this.depthWrite !== writeDepth) {
      this.gl.depthMask(writeDepth);
      this.depthWrite = writeDepth;
    }
  }, setColorWrite:function(writeRed, writeGreen, writeBlue, writeAlpha) {
    if (this.writeRed !== writeRed || this.writeGreen !== writeGreen || this.writeBlue !== writeBlue || this.writeAlpha !== writeAlpha) {
      this.gl.colorMask(writeRed, writeGreen, writeBlue, writeAlpha);
      this.writeRed = writeRed;
      this.writeGreen = writeGreen;
      this.writeBlue = writeBlue;
      this.writeAlpha = writeAlpha;
    }
  }, setAlphaToCoverage:function(state) {
    if (!this.webgl2) {
      return;
    }
    if (this.alphaToCoverage === state) {
      return;
    }
    this.alphaToCoverage = state;
    if (state) {
      this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
    } else {
      this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
    }
  }, setTransformFeedbackBuffer:function(tf) {
    if (this.transformFeedbackBuffer === tf) {
      return;
    }
    this.transformFeedbackBuffer = tf;
    if (this.webgl2) {
      var gl = this.gl;
      if (tf) {
        if (!this.feedback) {
          this.feedback = gl.createTransformFeedback();
        }
        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.feedback);
      } else {
        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
      }
    }
  }, setRaster:function(on) {
    if (this.raster === on) {
      return;
    }
    this.raster = on;
    if (this.webgl2) {
      if (on) {
        this.gl.disable(this.gl.RASTERIZER_DISCARD);
      } else {
        this.gl.enable(this.gl.RASTERIZER_DISCARD);
      }
    }
  }, setDepthBias:function(on) {
    if (this.depthBiasEnabled === on) {
      return;
    }
    this.depthBiasEnabled = on;
    if (on) {
      this.gl.enable(this.gl.POLYGON_OFFSET_FILL);
    } else {
      this.gl.disable(this.gl.POLYGON_OFFSET_FILL);
    }
  }, setDepthBiasValues:function(constBias, slopeBias) {
    this.gl.polygonOffset(slopeBias, constBias);
  }, getBlending:function() {
    return this.blending;
  }, setBlending:function(blending) {
    if (this.blending !== blending) {
      var gl = this.gl;
      if (blending) {
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
      this.blending = blending;
    }
  }, setStencilTest:function(enable) {
    if (this.stencil !== enable) {
      var gl = this.gl;
      if (enable) {
        gl.enable(gl.STENCIL_TEST);
      } else {
        gl.disable(gl.STENCIL_TEST);
      }
      this.stencil = enable;
    }
  }, setStencilFunc:function(func, ref, mask) {
    if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask || this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
      var gl = this.gl;
      gl.stencilFunc(this.glComparison[func], ref, mask);
      this.stencilFuncFront = this.stencilFuncBack = func;
      this.stencilRefFront = this.stencilRefBack = ref;
      this.stencilMaskFront = this.stencilMaskBack = mask;
    }
  }, setStencilFuncFront:function(func, ref, mask) {
    if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask) {
      var gl = this.gl;
      gl.stencilFuncSeparate(gl.FRONT, this.glComparison[func], ref, mask);
      this.stencilFuncFront = func;
      this.stencilRefFront = ref;
      this.stencilMaskFront = mask;
    }
  }, setStencilFuncBack:function(func, ref, mask) {
    if (this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
      var gl = this.gl;
      gl.stencilFuncSeparate(gl.BACK, this.glComparison[func], ref, mask);
      this.stencilFuncBack = func;
      this.stencilRefBack = ref;
      this.stencilMaskBack = mask;
    }
  }, setStencilOperation:function(fail, zfail, zpass, writeMask) {
    if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass || this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
      this.gl.stencilOp(this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
      this.stencilFailFront = this.stencilFailBack = fail;
      this.stencilZfailFront = this.stencilZfailBack = zfail;
      this.stencilZpassFront = this.stencilZpassBack = zpass;
    }
    if (this.stencilWriteMaskFront !== writeMask || this.stencilWriteMaskBack !== writeMask) {
      this.gl.stencilMask(writeMask);
      this.stencilWriteMaskFront = writeMask;
      this.stencilWriteMaskBack = writeMask;
    }
  }, setStencilOperationFront:function(fail, zfail, zpass, writeMask) {
    if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass) {
      this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
      this.stencilFailFront = fail;
      this.stencilZfailFront = zfail;
      this.stencilZpassFront = zpass;
    }
    if (this.stencilWriteMaskFront !== writeMask) {
      this.gl.stencilMaskSeparate(this.gl.FRONT, writeMask);
      this.stencilWriteMaskFront = writeMask;
    }
  }, setStencilOperationBack:function(fail, zfail, zpass, writeMask) {
    if (this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
      this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
      this.stencilFailBack = fail;
      this.stencilZfailBack = zfail;
      this.stencilZpassBack = zpass;
    }
    if (this.stencilWriteMaskBack !== writeMask) {
      this.gl.stencilMaskSeparate(this.gl.BACK, writeMask);
      this.stencilWriteMaskBack = writeMask;
    }
  }, setBlendFunction:function(blendSrc, blendDst) {
    if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.separateAlphaBlend) {
      this.gl.blendFunc(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst]);
      this.blendSrc = blendSrc;
      this.blendDst = blendDst;
      this.separateAlphaBlend = false;
    }
  }, setBlendFunctionSeparate:function(blendSrc, blendDst, blendSrcAlpha, blendDstAlpha) {
    if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.blendSrcAlpha !== blendSrcAlpha || this.blendDstAlpha !== blendDstAlpha || !this.separateAlphaBlend) {
      this.gl.blendFuncSeparate(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst], this.glBlendFunction[blendSrcAlpha], this.glBlendFunction[blendDstAlpha]);
      this.blendSrc = blendSrc;
      this.blendDst = blendDst;
      this.blendSrcAlpha = blendSrcAlpha;
      this.blendDstAlpha = blendDstAlpha;
      this.separateAlphaBlend = true;
    }
  }, setBlendEquation:function(blendEquation) {
    if (this.blendEquation !== blendEquation || this.separateAlphaEquation) {
      this.gl.blendEquation(this.glBlendEquation[blendEquation]);
      this.blendEquation = blendEquation;
      this.separateAlphaEquation = false;
    }
  }, setBlendEquationSeparate:function(blendEquation, blendAlphaEquation) {
    if (this.blendEquation !== blendEquation || this.blendAlphaEquation !== blendAlphaEquation || !this.separateAlphaEquation) {
      this.gl.blendEquationSeparate(this.glBlendEquation[blendEquation], this.glBlendEquation[blendAlphaEquation]);
      this.blendEquation = blendEquation;
      this.blendAlphaEquation = blendAlphaEquation;
      this.separateAlphaEquation = true;
    }
  }, setCullMode:function(cullMode) {
    if (this.cullMode !== cullMode) {
      if (cullMode === pc.CULLFACE_NONE) {
        this.gl.disable(this.gl.CULL_FACE);
      } else {
        if (this.cullMode === pc.CULLFACE_NONE) {
          this.gl.enable(this.gl.CULL_FACE);
        }
        var mode = this.glCull[cullMode];
        if (this.cullFace !== mode) {
          this.gl.cullFace(mode);
          this.cullFace = mode;
        }
      }
      this.cullMode = cullMode;
    }
  }, getCullMode:function() {
    return this.cullMode;
  }, setIndexBuffer:function(indexBuffer) {
    if (this.indexBuffer !== indexBuffer) {
      this.indexBuffer = indexBuffer;
      var gl = this.gl;
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer ? indexBuffer.bufferId : null);
    }
  }, setVertexBuffer:function(vertexBuffer, stream, vbOffset) {
    if (this.vertexBuffers[stream] !== vertexBuffer || this.vbOffsets[stream] !== vbOffset) {
      this.vertexBuffers[stream] = vertexBuffer;
      this.vbOffsets[stream] = vbOffset;
      var vertexFormat = vertexBuffer.getFormat();
      var i = 0;
      var elements = vertexFormat.elements;
      var numElements = elements.length;
      while (i < numElements) {
        var vertexElement = elements[i++];
        vertexElement.stream = stream;
        vertexElement.scopeId.setValue(vertexElement);
      }
      this.attributesInvalidated = true;
    }
  }, setShader:function(shader) {
    if (shader !== this.shader) {
      this.shader = shader;
      if (!shader.ready) {
        if (!shader.link()) {
          return false;
        }
      }
      this._shaderSwitchesPerFrame++;
      this.gl.useProgram(shader.program);
      this.attributesInvalidated = true;
    }
    return true;
  }, getHdrFormat:function() {
    if (this.extTextureHalfFloatRenderable) {
      return pc.PIXELFORMAT_RGB16F;
    } else {
      if (this.extTextureFloatRenderable) {
        return pc.PIXELFORMAT_RGB32F;
      }
    }
    return pc.PIXELFORMAT_R8_G8_B8_A8;
  }, getBoneLimit:function() {
    return this.boneLimit;
  }, setBoneLimit:function(maxBones) {
    this.boneLimit = maxBones;
  }, enableValidation:function(enable) {
    console.warn("enableValidation: This function is deprecated and will be removed shortly.");
  }, validate:function() {
    console.warn("validate: This function is deprecated and will be removed shortly.");
  }, resizeCanvas:function(width, height) {
    this._width = width;
    this._height = height;
    var ratio = Math.min(this._maxPixelRatio, window.devicePixelRatio);
    width *= ratio;
    height *= ratio;
    this.canvas.width = width;
    this.canvas.height = height;
    this.fire(EVENT_RESIZE, width, height);
  }, setResolution:function(width, height) {
    this._width = width;
    this._height = height;
    this.canvas.width = width;
    this.canvas.height = height;
    this.fire(EVENT_RESIZE, width, height);
  }, clearShaderCache:function() {
    this.programLib.clearCache();
  }, removeShaderFromCache:function(shader) {
    this.programLib.removeFromCache(shader);
  }, destroy:function() {
    if (this.webgl2 && this.feedback) {
      this.gl.deleteTransformFeedback(this.feedback);
    }
  }});
  Object.defineProperty(GraphicsDevice.prototype, "width", {get:function() {
    return this.gl.drawingBufferWidth || this.canvas.width;
  }});
  Object.defineProperty(GraphicsDevice.prototype, "height", {get:function() {
    return this.gl.drawingBufferHeight || this.canvas.height;
  }});
  Object.defineProperty(GraphicsDevice.prototype, "fullscreen", {get:function() {
    return !!document.fullscreenElement;
  }, set:function(fullscreen) {
    if (fullscreen) {
      var canvas = this.gl.canvas;
      canvas.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  }});
  Object.defineProperty(GraphicsDevice.prototype, "enableAutoInstancing", {get:function() {
    return this._enableAutoInstancing;
  }, set:function(value) {
    this._enableAutoInstancing = value && this.extInstancing;
  }});
  Object.defineProperty(GraphicsDevice.prototype, "maxAnisotropy", {get:function() {
    var maxAniso;
    return function() {
      if (maxAniso === undefined) {
        maxAniso = 1;
        var gl = this.gl;
        var glExt = this.extTextureFilterAnisotropic;
        if (glExt) {
          maxAniso = gl.getParameter(glExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        }
      }
      return maxAniso;
    };
  }()});
  Object.defineProperty(GraphicsDevice.prototype, "maxPixelRatio", {get:function() {
    return this._maxPixelRatio;
  }, set:function(ratio) {
    this._maxPixelRatio = ratio;
    this.resizeCanvas(this._width, this._height);
  }});
  return {GraphicsDevice:GraphicsDevice, precalculatedTangents:true};
}());
Object.assign(pc, function() {
  var shaderChunks = {};
  var attrib2Semantic = {vertex_position:pc.SEMANTIC_POSITION, vertex_normal:pc.SEMANTIC_NORMAL, vertex_tangent:pc.SEMANTIC_TANGENT, vertex_texCoord0:pc.SEMANTIC_TEXCOORD0, vertex_texCoord1:pc.SEMANTIC_TEXCOORD1, vertex_texCoord2:pc.SEMANTIC_TEXCOORD2, vertex_texCoord3:pc.SEMANTIC_TEXCOORD3, vertex_texCoord4:pc.SEMANTIC_TEXCOORD4, vertex_texCoord5:pc.SEMANTIC_TEXCOORD5, vertex_texCoord6:pc.SEMANTIC_TEXCOORD6, vertex_texCoord7:pc.SEMANTIC_TEXCOORD7, vertex_color:pc.SEMANTIC_COLOR, vertex_boneIndices:pc.SEMANTIC_BLENDINDICES, 
  vertex_boneWeights:pc.SEMANTIC_BLENDWEIGHT};
  shaderChunks.collectAttribs = function(vsCode) {
    var attribs = {};
    var attrs = 0;
    var found = vsCode.indexOf("attribute");
    while (found >= 0) {
      if (found > 0 && vsCode[found - 1] === "/") {
        break;
      }
      var endOfLine = vsCode.indexOf(";", found);
      var startOfAttribName = vsCode.lastIndexOf(" ", endOfLine);
      var attribName = vsCode.substr(startOfAttribName + 1, endOfLine - (startOfAttribName + 1));
      var semantic = attrib2Semantic[attribName];
      if (semantic !== undefined) {
        attribs[attribName] = semantic;
      } else {
        attribs[attribName] = "ATTR" + attrs;
        attrs++;
      }
      found = vsCode.indexOf("attribute", found + 1);
    }
    return attribs;
  };
  shaderChunks.createShader = function(device, vsName, psName, useTransformFeedback) {
    var vsCode = shaderChunks[vsName];
    var psCode = pc.programlib.precisionCode(device) + "\n" + shaderChunks[psName];
    var attribs = this.collectAttribs(vsCode);
    if (device.webgl2) {
      vsCode = pc.programlib.versionCode(device) + this.gles3VS + vsCode;
      psCode = pc.programlib.versionCode(device) + this.gles3PS + psCode;
    }
    return new pc.Shader(device, {attributes:attribs, vshader:vsCode, fshader:psCode, useTransformFeedback:useTransformFeedback});
  };
  shaderChunks.createShaderFromCode = function(device, vsCode, psCode, uName, useTransformFeedback) {
    var shaderCache = device.programLib._cache;
    var cached = shaderCache[uName];
    if (cached !== undefined) {
      return cached;
    }
    psCode = pc.programlib.precisionCode(device) + "\n" + (psCode || pc.programlib.dummyFragmentCode());
    var attribs = this.collectAttribs(vsCode);
    if (device.webgl2) {
      vsCode = pc.programlib.versionCode(device) + this.gles3VS + vsCode;
      psCode = pc.programlib.versionCode(device) + this.gles3PS + psCode;
    }
    shaderCache[uName] = new pc.Shader(device, {attributes:attribs, vshader:vsCode, fshader:psCode, useTransformFeedback:useTransformFeedback});
    return shaderCache[uName];
  };
  return {shaderChunks:shaderChunks};
}());
Object.assign(pc, function() {
  var _postEffectQuadVB = null;
  var _postEffectQuadDraw = {type:pc.PRIMITIVE_TRISTRIP, base:0, count:4, indexed:false};
  function drawQuadWithShader(device, target, shader, rect, scissorRect, useBlend) {
    if (_postEffectQuadVB === null) {
      var vertexFormat = new pc.VertexFormat(device, [{semantic:pc.SEMANTIC_POSITION, components:2, type:pc.TYPE_FLOAT32}]);
      _postEffectQuadVB = new pc.VertexBuffer(device, vertexFormat, 4);
      var iterator = new pc.VertexIterator(_postEffectQuadVB);
      iterator.element[pc.SEMANTIC_POSITION].set(-1.0, -1.0);
      iterator.next();
      iterator.element[pc.SEMANTIC_POSITION].set(1.0, -1.0);
      iterator.next();
      iterator.element[pc.SEMANTIC_POSITION].set(-1.0, 1.0);
      iterator.next();
      iterator.element[pc.SEMANTIC_POSITION].set(1.0, 1.0);
      iterator.end();
    }
    var oldRt = device.renderTarget;
    device.setRenderTarget(target);
    device.updateBegin();
    var x, y, w, h;
    var sx, sy, sw, sh;
    if (!rect) {
      w = target ? target.width : device.width;
      h = target ? target.height : device.height;
      x = 0;
      y = 0;
    } else {
      x = rect.x;
      y = rect.y;
      w = rect.z;
      h = rect.w;
    }
    if (!scissorRect) {
      sx = x;
      sy = y;
      sw = w;
      sh = h;
    } else {
      sx = scissorRect.x;
      sy = scissorRect.y;
      sw = scissorRect.z;
      sh = scissorRect.w;
    }
    device.setViewport(x, y, w, h);
    device.setScissor(sx, sy, sw, sh);
    var oldDepthTest = device.getDepthTest();
    var oldDepthWrite = device.getDepthWrite();
    var oldCull = device.getCullMode();
    device.setDepthTest(false);
    device.setDepthWrite(false);
    device.setCullMode(pc.CULLFACE_NONE);
    if (!useBlend) {
      device.setBlending(false);
    }
    device.setVertexBuffer(_postEffectQuadVB, 0);
    device.setShader(shader);
    device.draw(_postEffectQuadDraw);
    device.setDepthTest(oldDepthTest);
    device.setDepthWrite(oldDepthWrite);
    device.setCullMode(oldCull);
    device.updateEnd();
    device.setRenderTarget(oldRt);
    device.updateBegin();
  }
  function destroyPostEffectQuad() {
    _postEffectQuadVB = null;
  }
  return {drawQuadWithShader:drawQuadWithShader, destroyPostEffectQuad:destroyPostEffectQuad};
}());
Object.assign(pc, function() {
  function syncToCpu(device, targ, face) {
    var tex = targ._colorBuffer;
    if (tex.format != pc.PIXELFORMAT_R8_G8_B8_A8) {
      return;
    }
    var pixels = new Uint8Array(tex.width * tex.height * 4);
    var gl = device.gl;
    device.setFramebuffer(targ._glFrameBuffer);
    gl.readPixels(0, 0, tex.width, tex.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    if (!tex._levels) {
      tex._levels = [];
    }
    if (!tex._levels[0]) {
      tex._levels[0] = [];
    }
    tex._levels[0][face] = pixels;
  }
  function prefilterCubemap(options) {
    var device = options.device;
    var sourceCubemap = options.sourceCubemap;
    var method = options.method;
    var samples = options.samples;
    var cpuSync = options.cpuSync;
    if (cpuSync && !sourceCubemap._levels[0]) {
      console.error("ERROR: prefilter: cubemap must have _levels");
      return;
    }
    var chunks = pc.shaderChunks;
    var rgbmSource = sourceCubemap.rgbm;
    var shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.rgbmPS + chunks.prefilterCubemapPS.replace(/\$METHOD/g, method === 0 ? "cos" : "phong").replace(/\$NUMSAMPLES/g, samples).replace(/\$textureCube/g, rgbmSource ? "textureCubeRGBM" : "textureCube"), "prefilter" + method + "" + samples + "" + rgbmSource);
    var shader2 = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.outputCubemapPS, "outputCubemap");
    var constantTexSource = device.scope.resolve("source");
    var constantParams = device.scope.resolve("params");
    var params = new pc.Vec4;
    var size = sourceCubemap.width;
    var format = sourceCubemap.format;
    var cmapsList = [[], options.filteredFixed, options.filteredRgbm, options.filteredFixedRgbm];
    var gloss = method === 0 ? [0.9, 0.85, 0.7, 0.4, 0.25] : [512, 128, 32, 8, 2];
    var mipSize = [64, 32, 16, 8, 4];
    var numMips = 5;
    var targ;
    var i, face, pass;
    var rgbFormat = format === pc.PIXELFORMAT_R8_G8_B8;
    var isImg = false;
    var nextCubemap, cubemap;
    if (cpuSync) {
      isImg = sourceCubemap._levels[0][0] instanceof HTMLImageElement;
    }
    if ((rgbFormat || isImg) && cpuSync) {
      format = pc.PIXELFORMAT_R8_G8_B8_A8;
      nextCubemap = new pc.gfx.Texture(device, {cubemap:true, rgbm:rgbmSource, format:format, width:size, height:size, mipmaps:false});
      for (face = 0;face < 6;face++) {
        targ = new pc.RenderTarget(device, nextCubemap, {face:face, depth:false});
        params.x = face;
        params.y = 0;
        constantTexSource.setValue(sourceCubemap);
        constantParams.setValue(params.data);
        pc.drawQuadWithShader(device, targ, shader2);
        syncToCpu(device, targ, face);
      }
      sourceCubemap = nextCubemap;
    }
    if (size > 128) {
      var log128 = Math.round(Math.log2(128));
      var logSize = Math.round(Math.log2(size));
      var steps = logSize - log128;
      for (i = 0;i < steps;i++) {
        size = sourceCubemap.width * 0.5;
        var sampleGloss = method === 0 ? 1 : Math.pow(2, Math.round(Math.log2(gloss[0]) + (steps - i) * 2));
        nextCubemap = new pc.gfx.Texture(device, {cubemap:true, rgbm:rgbmSource, format:format, width:size, height:size, mipmaps:false});
        for (face = 0;face < 6;face++) {
          targ = new pc.RenderTarget(device, nextCubemap, {face:face, depth:false});
          params.x = face;
          params.y = sampleGloss;
          params.z = size;
          params.w = rgbmSource ? 3 : 0;
          constantTexSource.setValue(sourceCubemap);
          constantParams.setValue(params.data);
          pc.drawQuadWithShader(device, targ, shader2);
          if (i === steps - 1 && cpuSync) {
            syncToCpu(device, targ, face);
          }
        }
        sourceCubemap = nextCubemap;
      }
    }
    options.sourceCubemap = sourceCubemap;
    var sourceCubemapRgbm = null;
    if (!rgbmSource && options.filteredFixedRgbm) {
      nextCubemap = new pc.gfx.Texture(device, {cubemap:true, rgbm:true, format:pc.PIXELFORMAT_R8_G8_B8_A8, width:size, height:size, mipmaps:false});
      for (face = 0;face < 6;face++) {
        targ = new pc.RenderTarget(device, nextCubemap, {face:face, depth:false});
        params.x = face;
        params.w = 2;
        constantTexSource.setValue(sourceCubemap);
        constantParams.setValue(params.data);
        pc.drawQuadWithShader(device, targ, shader2);
        syncToCpu(device, targ, face);
      }
      sourceCubemapRgbm = nextCubemap;
    }
    var unblurredGloss = method === 0 ? 1 : 2048;
    var startPass = method === 0 ? 0 : -1;
    cmapsList[startPass] = [];
    for (i = 0;i < numMips;i++) {
      for (pass = startPass;pass < cmapsList.length;pass++) {
        if (cmapsList[pass] != null) {
          cmapsList[pass][i] = new pc.gfx.Texture(device, {cubemap:true, rgbm:pass < 2 ? rgbmSource : true, format:pass < 2 ? format : pc.PIXELFORMAT_R8_G8_B8_A8, fixCubemapSeams:pass === 1 || pass === 3, width:mipSize[i], height:mipSize[i], mipmaps:false});
        }
      }
    }
    for (pass = startPass;pass < cmapsList.length;pass++) {
      if (cmapsList[pass] != null) {
        if (pass > 1 && rgbmSource) {
          cmapsList[pass] = cmapsList[pass - 2];
          continue;
        }
        for (i = 0;i < numMips;i++) {
          for (face = 0;face < 6;face++) {
            targ = new pc.RenderTarget(device, cmapsList[pass][i], {face:face, depth:false});
            params.x = face;
            params.y = pass < 0 ? unblurredGloss : gloss[i];
            params.z = mipSize[i];
            params.w = rgbmSource ? 3 : pass;
            constantTexSource.setValue(i === 0 ? sourceCubemap : method === 0 ? cmapsList[0][i - 1] : cmapsList[-1][i - 1]);
            constantParams.setValue(params.data);
            pc.drawQuadWithShader(device, targ, shader);
            if (cpuSync) {
              syncToCpu(device, targ, face);
            }
          }
        }
      }
    }
    options.filtered = cmapsList[0];
    var mips;
    if (cpuSync && options.singleFilteredFixed) {
      mips = [sourceCubemap, options.filteredFixed[0], options.filteredFixed[1], options.filteredFixed[2], options.filteredFixed[3], options.filteredFixed[4], options.filteredFixed[5]];
      cubemap = new pc.gfx.Texture(device, {cubemap:true, rgbm:rgbmSource, fixCubemapSeams:true, format:format, width:128, height:128, addressU:pc.ADDRESS_CLAMP_TO_EDGE, addressV:pc.ADDRESS_CLAMP_TO_EDGE});
      for (i = 0;i < 6;i++) {
        cubemap._levels[i] = mips[i]._levels[0];
      }
      cubemap.upload();
      cubemap._prefilteredMips = true;
      options.singleFilteredFixed = cubemap;
    }
    if (cpuSync && options.singleFilteredFixedRgbm && options.filteredFixedRgbm) {
      mips = [sourceCubemapRgbm, options.filteredFixedRgbm[0], options.filteredFixedRgbm[1], options.filteredFixedRgbm[2], options.filteredFixedRgbm[3], options.filteredFixedRgbm[4], options.filteredFixedRgbm[5]];
      cubemap = new pc.gfx.Texture(device, {cubemap:true, rgbm:true, fixCubemapSeams:true, format:pc.PIXELFORMAT_R8_G8_B8_A8, width:128, height:128, addressU:pc.ADDRESS_CLAMP_TO_EDGE, addressV:pc.ADDRESS_CLAMP_TO_EDGE});
      for (i = 0;i < 6;i++) {
        cubemap._levels[i] = mips[i]._levels[0];
      }
      cubemap.upload();
      cubemap._prefilteredMips = true;
      options.singleFilteredFixedRgbm = cubemap;
    }
  }
  function areaElement(x, y) {
    return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));
  }
  function texelCoordSolidAngle(u, v, size) {
    var _u = 2.0 * (u + 0.5) / size - 1.0;
    var _v = 2.0 * (v + 0.5) / size - 1.0;
    _u *= 1.0 - 1.0 / size;
    _v *= 1.0 - 1.0 / size;
    var invResolution = 1.0 / size;
    var x0 = _u - invResolution;
    var y0 = _v - invResolution;
    var x1 = _u + invResolution;
    var y1 = _v + invResolution;
    var solidAngle = areaElement(x0, y0) - areaElement(x0, y1) - areaElement(x1, y0) + areaElement(x1, y1);
    if (u === 0 && v === 0 || u === size - 1 && v === 0 || u === 0 && v === size - 1 || u === size - 1 && v === size - 1) {
      solidAngle /= 3;
    } else {
      if (u === 0 || v === 0 || u === size - 1 || v === size - 1) {
        solidAngle *= 0.5;
      }
    }
    return solidAngle;
  }
  function shFromCubemap(source, dontFlipX) {
    var face;
    var cubeSize = source.width;
    var x, y;
    if (source.format != pc.PIXELFORMAT_R8_G8_B8_A8) {
      console.error("ERROR: SH: cubemap must be RGBA8");
      return;
    }
    if (!source._levels[0]) {
      console.error("ERROR: SH: cubemap must be synced to CPU");
      return;
    }
    if (!source._levels[0][0].length) {
      if (source._levels[0][0] instanceof HTMLImageElement) {
        var device = pc.Application.getApplication().graphicsDevice;
        var gl = device.gl;
        var chunks = pc.shaderChunks;
        var shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.fullscreenQuadPS, "fsQuadSimple");
        var constantTexSource = device.scope.resolve("source");
        for (face = 0;face < 6;face++) {
          var img = source._levels[0][face];
          var tex = new pc.Texture(device, {cubemap:false, rgbm:false, format:source.format, width:cubeSize, height:cubeSize, mipmaps:false});
          tex._levels[0] = img;
          tex.upload();
          var tex2 = new pc.Texture(device, {cubemap:false, rgbm:false, format:source.format, width:cubeSize, height:cubeSize, mipmaps:false});
          var targ = new pc.RenderTarget(device, tex2, {depth:false});
          constantTexSource.setValue(tex);
          pc.drawQuadWithShader(device, targ, shader);
          var pixels = new Uint8Array(cubeSize * cubeSize * 4);
          gl.bindFramebuffer(gl.FRAMEBUFFER, targ._glFrameBuffer);
          gl.readPixels(0, 0, tex.width, tex.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
          source._levels[0][face] = pixels;
        }
      } else {
        console.error("ERROR: SH: cubemap must be composed of arrays or images");
        return;
      }
    }
    var dirs = [];
    for (y = 0;y < cubeSize;y++) {
      for (x = 0;x < cubeSize;x++) {
        var u = x / (cubeSize - 1) * 2 - 1;
        var v = y / (cubeSize - 1) * 2 - 1;
        dirs[y * cubeSize + x] = (new pc.Vec3(u, v, 1.0)).normalize();
      }
    }
    var sh = new Float32Array(9 * 3);
    var coef1 = 0;
    var coef2 = 1 * 3;
    var coef3 = 2 * 3;
    var coef4 = 3 * 3;
    var coef5 = 4 * 3;
    var coef6 = 5 * 3;
    var coef7 = 6 * 3;
    var coef8 = 7 * 3;
    var coef9 = 8 * 3;
    var nx = 0;
    var px = 1;
    var ny = 2;
    var py = 3;
    var nz = 4;
    var pz = 5;
    var addr, c, a, value, weight, dir, dx, dy, dz;
    var weight1, weight2, weight3, weight4, weight5;
    var accum = 0;
    for (face = 0;face < 6;face++) {
      for (y = 0;y < cubeSize;y++) {
        for (x = 0;x < cubeSize;x++) {
          addr = y * cubeSize + x;
          weight = texelCoordSolidAngle(x, y, cubeSize);
          weight1 = weight * 4 / 17;
          weight2 = weight * 8 / 17;
          weight3 = weight * 15 / 17;
          weight4 = weight * 5 / 68;
          weight5 = weight * 15 / 68;
          dir = dirs[addr];
          if (face == nx) {
            dx = dir.z;
            dy = -dir.y;
            dz = -dir.x;
          } else {
            if (face == px) {
              dx = -dir.z;
              dy = -dir.y;
              dz = dir.x;
            } else {
              if (face == ny) {
                dx = dir.x;
                dy = dir.z;
                dz = dir.y;
              } else {
                if (face == py) {
                  dx = dir.x;
                  dy = -dir.z;
                  dz = -dir.y;
                } else {
                  if (face == nz) {
                    dx = dir.x;
                    dy = -dir.y;
                    dz = dir.z;
                  } else {
                    if (face == pz) {
                      dx = -dir.x;
                      dy = -dir.y;
                      dz = -dir.z;
                    }
                  }
                }
              }
            }
          }
          if (!dontFlipX) {
            dx = -dx;
          }
          a = source._levels[0][face][addr * 4 + 3] / 255.0;
          for (c = 0;c < 3;c++) {
            value = source._levels[0][face][addr * 4 + c] / 255.0;
            if (source.rgbm) {
              value *= a * 8.0;
              value *= value;
            } else {
              value = Math.pow(value, 2.2);
            }
            sh[coef1 + c] += value * weight1;
            sh[coef2 + c] += value * weight2 * dx;
            sh[coef3 + c] += value * weight2 * dy;
            sh[coef4 + c] += value * weight2 * dz;
            sh[coef5 + c] += value * weight3 * dx * dz;
            sh[coef6 + c] += value * weight3 * dz * dy;
            sh[coef7 + c] += value * weight3 * dy * dx;
            sh[coef8 + c] += value * weight4 * (3.0 * dz * dz - 1.0);
            sh[coef9 + c] += value * weight5 * (dx * dx - dy * dy);
            accum += weight;
          }
        }
      }
    }
    for (c = 0;c < sh.length;c++) {
      sh[c] *= 4 * Math.PI / accum;
    }
    return sh;
  }
  return {prefilterCubemap:prefilterCubemap, shFromCubemap:shFromCubemap};
}());
Object.assign(pc, function() {
  var dpMult = 2.0;
  function paraboloidFromCubemap(device, sourceCubemap, fixSeamsAmount, dontFlipX) {
    var chunks = pc.shaderChunks;
    var shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, (sourceCubemap.fixCubemapSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS) + chunks.genParaboloidPS, "genParaboloid");
    var constantTexSource = device.scope.resolve("source");
    var constantParams = device.scope.resolve("params");
    var params = new pc.Vec4;
    var size = sourceCubemap.width;
    var rgbmSource = sourceCubemap.rgbm;
    var format = sourceCubemap.format;
    size = Math.max(size, 8) * dpMult;
    var tex = new pc.gfx.Texture(device, {rgbm:rgbmSource, format:format, width:size * 2, height:size, mipmaps:false});
    var targ = new pc.RenderTarget(device, tex, {depth:false});
    params.x = fixSeamsAmount;
    params.y = dontFlipX ? -1.0 : 1.0;
    constantTexSource.setValue(sourceCubemap);
    constantParams.setValue(params.data);
    pc.drawQuadWithShader(device, targ, shader);
    return tex;
  }
  function getDpAtlasRect(rect, mip) {
    rect.x = pc.math.clamp(mip - 2.0, 0, 1) * 0.5;
    var t = mip - rect.x * 6.0;
    var i = 1.0 - rect.x;
    rect.y = Math.min(t * 0.5, 0.75) * i + rect.x;
    rect.z = (1.0 - pc.math.clamp(t, 0, 1) * 0.5) * i;
    rect.w = rect.z * 0.5;
    return 1.0 / rect.z;
  }
  function generateDpAtlas(device, sixCubemaps, dontFlipX) {
    var dp, rect;
    rect = new pc.Vec4;
    var params = new pc.Vec4;
    var size = sixCubemaps[0].width * 2 * dpMult;
    var chunks = pc.shaderChunks;
    var shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.dpAtlasQuadPS, "dpAtlasQuad");
    var constantTexSource = device.scope.resolve("source");
    var constantParams = device.scope.resolve("params");
    var tex = new pc.gfx.Texture(device, {rgbm:sixCubemaps[0].rgbm, format:sixCubemaps[0].format, width:size, height:size, mipmaps:false});
    var targ = new pc.RenderTarget(device, tex, {depth:false});
    var borderSize = 2;
    var mip0Width = size;
    var scaleFactor = (mip0Width + borderSize) / mip0Width - 1;
    var scaleAmount;
    for (var i = 0;i < 6;i++) {
      dp = pc.paraboloidFromCubemap(device, sixCubemaps[i], i, dontFlipX);
      constantTexSource.setValue(dp);
      scaleAmount = getDpAtlasRect(rect, i);
      params.x = scaleAmount * scaleFactor;
      params.y = params.x * 2;
      params.x += 1;
      params.y += 1;
      constantParams.setValue(params.data);
      rect.x *= size;
      rect.y *= size;
      rect.z *= size;
      rect.w *= size;
      pc.drawQuadWithShader(device, targ, shader, rect);
    }
    return tex;
  }
  return {paraboloidFromCubemap:paraboloidFromCubemap, generateDpAtlas:generateDpAtlas};
}());
pc.shaderChunks.TBNPS = "void getTBN() {\n    dTBN = mat3(normalize(dTangentW), normalize(dBinormalW), normalize(dVertexNormalW));\n}\n";
pc.shaderChunks.TBNfastPS = "void getTBN() {\n    dTBN = mat3(dTangentW, dBinormalW, dVertexNormalW);\n}\n";
pc.shaderChunks.alphaTestPS = "uniform float alpha_ref;\nvoid alphaTest(float a) {\n    if (a < alpha_ref) discard;\n}\n";
pc.shaderChunks.ambientConstantPS = "\nvoid addAmbient() {\n    dDiffuseLight += light_globalAmbient;\n}\n";
pc.shaderChunks.ambientPrefilteredCubePS = "#ifndef PMREM4\n#define PMREM4\nuniform samplerCube texture_prefilteredCubeMap4;\n#endif\nvoid addAmbient() {\n    vec3 fixedReflDir = fixSeamsStatic(dNormalW, 1.0 - 1.0 / 4.0);\n    fixedReflDir.x *= -1.0;\n    dDiffuseLight += processEnvironment($DECODE(textureCube(texture_prefilteredCubeMap4, fixedReflDir)).rgb);\n}\n";
pc.shaderChunks.ambientPrefilteredCubeLodPS = "#ifndef PMREM4\n#define PMREM4\n#extension GL_EXT_shader_texture_lod : enable\nuniform samplerCube texture_prefilteredCubeMap128;\n#endif\nvoid addAmbient() {\n    vec3 fixedReflDir = fixSeamsStatic(dNormalW, 1.0 - 1.0 / 4.0);\n    fixedReflDir.x *= -1.0;\n    dDiffuseLight += processEnvironment($DECODE( textureCubeLodEXT(texture_prefilteredCubeMap128, fixedReflDir, 5.0) ).rgb);\n}\n";
pc.shaderChunks.ambientSHPS = "uniform vec3 ambientSH[9];\nvoid addAmbient() {\n    vec3 n = dNormalW;\n    vec3 color =\n                        ambientSH[0] +\n                        ambientSH[1] * n.x +\n                        ambientSH[2] * n.y +\n                        ambientSH[3] * n.z +\n                        ambientSH[4] * n.x * n.z +\n                        ambientSH[5] * n.z * n.y +\n                        ambientSH[6] * n.y * n.x +\n                        ambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n                        ambientSH[8] * (n.x * n.x - n.y * n.y);\n    dDiffuseLight += processEnvironment(max(color, vec3(0.0)));\n}\n";
pc.shaderChunks.aoPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_aoMap;\n#endif\nvoid applyAO() {\n    dAo = 1.0;\n    #ifdef MAPTEXTURE\n        dAo *= texture2D(texture_aoMap, $UV).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        dAo *= saturate(vVertexColor.$VC);\n    #endif\n    dDiffuseLight *= dAo;\n}\n";
pc.shaderChunks.aoSpecOccPS = "uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n    // approximated specular occlusion from AO\n    float specPow = exp2(dGlossiness * 11.0);\n    // http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx\n    float specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n    specOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n";
pc.shaderChunks.aoSpecOccConstPS = "void occludeSpecular() {\n    // approximated specular occlusion from AO\n    float specPow = exp2(dGlossiness * 11.0);\n    // http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx\n    float specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n";
pc.shaderChunks.aoSpecOccConstSimplePS = "void occludeSpecular() {\n    float specOcc = dAo;\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n";
pc.shaderChunks.aoSpecOccSimplePS = "uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n    float specOcc = mix(1.0, dAo, material_occludeSpecularIntensity);\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n";
pc.shaderChunks.bakeDirLmEndPS = "\n    vec4 dirLm = texture2D(texture_dirLightMap, vUv1);\n    if (bakeDir > 0.5) {\n        if (dAtten > 0.00001) {\n            dirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\n            dAtten = saturate(dAtten);\n            gl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\n            gl_FragColor.a = dirLm.w + dAtten;\n            gl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\n        } else {\n            gl_FragColor = dirLm;\n        }\n    } else {\n        gl_FragColor.rgb = dirLm.xyz;\n        gl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\n    }\n";
pc.shaderChunks.bakeLmEndPS = "\ngl_FragColor.rgb = dDiffuseLight;\ngl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\ngl_FragColor.rgb /= 8.0;\ngl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\ngl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\ngl_FragColor.rgb /= gl_FragColor.a;\n";
pc.shaderChunks.basePS = "\nuniform vec3 view_position;\nuniform vec3 light_globalAmbient;\nfloat square(float x) {\n    return x*x;\n}\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x) {\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n";
pc.shaderChunks.baseVS = "\nattribute vec3 vertex_position;\nattribute vec3 vertex_normal;\nattribute vec4 vertex_tangent;\nattribute vec2 vertex_texCoord0;\nattribute vec2 vertex_texCoord1;\nattribute vec4 vertex_color;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nvec3 dPositionW;\nmat4 dModelMatrix;\nmat3 dNormalMatrix;\nvec3 dLightPosW;\nvec3 dLightDirNormW;\nvec3 dNormalW;\n";
pc.shaderChunks.biasConstPS = "#define SHADOWBIAS\nfloat getShadowBias(float resolution, float maxBias) {\n    return maxBias;\n}\n";
pc.shaderChunks.blurVSMPS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n#ifdef GAUSS\nuniform float weight[SAMPLES];\n#endif\n#ifdef PACKED\nfloat decodeFloatRG(vec2 rg) {\n    return rg.y*(1.0/255.0) + rg.x;\n}\nvec2 encodeFloatRG( float v ) {\n  vec2 enc = vec2(1.0, 255.0) * v;\n  enc = fract(enc);\n  enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n  return enc;\n}\n#endif\nvoid main(void) {\n    vec3 moments = vec3(0.0);\n    vec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\n    for(int i=0; i<SAMPLES; i++) {\n        vec4 c = texture2D(source, uv + pixelOffset * float(i));\n        #ifdef PACKED\n        c.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));\n        #endif\n        #ifdef GAUSS\n        moments += c.xyz * weight[i];\n        #else\n        moments += c.xyz;\n        #endif\n    }\n    #ifndef GAUSS\n    moments /= float(SAMPLES);\n    #endif\n    #ifdef PACKED\n    gl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));\n    #else\n    gl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\n    #endif\n}\n";
pc.shaderChunks.combineDiffusePS = "vec3 combineColor() {\n    return dAlbedo * dDiffuseLight;\n}\n";
pc.shaderChunks.combineDiffuseSpecularPS = "vec3 combineColor() {\n    return mix(dAlbedo * dDiffuseLight, dSpecularLight + dReflection.rgb * dReflection.a, dSpecularity);\n}\n";
pc.shaderChunks.combineDiffuseSpecularNoConservePS = "vec3 combineColor() {\n    return dAlbedo * dDiffuseLight + (dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity;\n}\n";
pc.shaderChunks.combineDiffuseSpecularNoReflPS = "vec3 combineColor() {\n    return dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity;\n}\n";
pc.shaderChunks.combineDiffuseSpecularNoReflSeparateAmbientPS = "uniform vec3 material_ambient;\nvec3 combineColor() {\n    return (dDiffuseLight - light_globalAmbient) * dAlbedo + dSpecularLight * dSpecularity + material_ambient * light_globalAmbient;\n}\n";
pc.shaderChunks.combineDiffuseSpecularOldPS = "vec3 combineColor() {\n    return mix(dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity, dReflection.rgb, dReflection.a);\n}\n";
pc.shaderChunks.cookiePS = "vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n    return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    projPos.xy += cookieOffset;\n    vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n    return mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    projPos.xy += cookieOffset;\n    if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n    vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n    return mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\n    return mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\n}\n";
pc.shaderChunks.cubeMapProjectBoxPS = "uniform vec3 envBoxMin, envBoxMax;\nvec3 cubeMapProject(vec3 nrdir) {\n    vec3 rbmax = (envBoxMax - vPositionW) / nrdir;\n    vec3 rbmin = (envBoxMin - vPositionW) / nrdir;\n    vec3 rbminmax;\n    rbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\n    rbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\n    rbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\n    float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n    vec3 posonbox = vPositionW + nrdir * fa;\n    vec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\n    return posonbox - envBoxPos;\n}\n";
pc.shaderChunks.cubeMapProjectNonePS = "vec3 cubeMapProject(vec3 dir) {\n    return dir;\n}\n";
pc.shaderChunks.diffusePS = "#ifdef MAPCOLOR\nuniform vec3 material_diffuse;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseMap;\n#endif\nvoid getAlbedo() {\n    dAlbedo = vec3(1.0);\n    #ifdef MAPCOLOR\n        dAlbedo *= material_diffuse.rgb;\n    #endif\n    #ifdef MAPTEXTURE\n        dAlbedo *= texture2DSRGB(texture_diffuseMap, $UV).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        dAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n    #endif\n}\n";
pc.shaderChunks.dilatePS = "varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nvoid main(void) {\n    vec4 c = texture2D(source, vUv0);\n    c = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);\n    gl_FragColor = c;\n}\n";
pc.shaderChunks.dpAtlasQuadPS = "varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec4 params;\nvoid main(void) {\n    vec2 uv = vUv0;\n    uv = uv * 2.0 - vec2(1.0);\n    uv *= params.xy;\n    uv = uv * 0.5 + 0.5;\n    gl_FragColor = texture2D(source, uv);\n}\n";
pc.shaderChunks.emissivePS = "#ifdef MAPCOLOR\nuniform vec3 material_emissive;\n#endif\n#ifdef MAPFLOAT\nuniform float material_emissiveIntensity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_emissiveMap;\n#endif\nvec3 getEmission() {\n    vec3 emission = vec3(1.0);\n    #ifdef MAPFLOAT\n        emission *= material_emissiveIntensity;\n    #endif\n    #ifdef MAPCOLOR\n        emission *= material_emissive;\n    #endif\n    #ifdef MAPTEXTURE\n        emission *= $texture2DSAMPLE(texture_emissiveMap, $UV).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        emission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n    #endif\n    return emission;\n}\n";
pc.shaderChunks.endPS = "   gl_FragColor.rgb = combineColor();\n   gl_FragColor.rgb += getEmission();\n   gl_FragColor.rgb = addFog(gl_FragColor.rgb);\n   #ifndef HDR\n    gl_FragColor.rgb = toneMap(gl_FragColor.rgb);\n    gl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\n   #endif\n";
pc.shaderChunks.envConstPS = "vec3 processEnvironment(vec3 color) {\n    return color;\n}\n";
pc.shaderChunks.envMultiplyPS = "uniform float skyboxIntensity;\nvec3 processEnvironment(vec3 color) {\n    return color * skyboxIntensity;\n}\n";
pc.shaderChunks.extensionPS = "";
pc.shaderChunks.extensionVS = "\n";
pc.shaderChunks.falloffInvSquaredPS = "float getFalloffInvSquared(float lightRadius) {\n    float sqrDist = dot(dLightDirW, dLightDirW);\n    float falloff = 1.0 / (sqrDist + 1.0);\n    float invRadius = 1.0 / lightRadius;\n    falloff *= 16.0;\n    falloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n    return falloff;\n}\n";
pc.shaderChunks.falloffLinearPS = "float getFalloffLinear(float lightRadius) {\n    float d = length(dLightDirW);\n    return max(((lightRadius - d) / lightRadius), 0.0);\n}\n";
pc.shaderChunks.fixCubemapSeamsNonePS = "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n    return vec;\n}\nvec3 fixSeams(vec3 vec) {\n    return vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n    return vec;\n}\n";
pc.shaderChunks.fixCubemapSeamsStretchPS = "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n    float scale = 1.0 - exp2(mipmapIndex) / 128.0;\n    float M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n    if (abs(vec.x) != M) vec.x *= scale;\n    if (abs(vec.y) != M) vec.y *= scale;\n    if (abs(vec.z) != M) vec.z *= scale;\n    return vec;\n}\nvec3 fixSeams(vec3 vec) {\n    float scale = 1.0 - 1.0 / 128.0;\n    float M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n    if (abs(vec.x) != M) vec.x *= scale;\n    if (abs(vec.y) != M) vec.y *= scale;\n    if (abs(vec.z) != M) vec.z *= scale;\n    return vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n    float scale = invRecMipSize;\n    float M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n    if (abs(vec.x) != M) vec.x *= scale;\n    if (abs(vec.y) != M) vec.y *= scale;\n    if (abs(vec.z) != M) vec.z *= scale;\n    return vec;\n}\n";
pc.shaderChunks.fogExpPS = "uniform vec3 fog_color;\nuniform float fog_density;\nvec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = exp(-depth * fog_density);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    return mix(fog_color, color, fogFactor);\n}\n";
pc.shaderChunks.fogExp2PS = "uniform vec3 fog_color;\nuniform float fog_density;\nvec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = exp(-depth * depth * fog_density * fog_density);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    return mix(fog_color, color, fogFactor);\n}\n";
pc.shaderChunks.fogLinearPS = "uniform vec3 fog_color;\nuniform float fog_start;\nuniform float fog_end;\nvec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = (fog_end - depth) / (fog_end - fog_start);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    fogFactor = gammaCorrectInput(fogFactor);\n    return mix(fog_color, color, fogFactor);\n}\n";
pc.shaderChunks.fogNonePS = "vec3 addFog(vec3 color) {\n    return color;\n}\n";
pc.shaderChunks.fresnelSchlickPS = "// Schlick's approximation\nuniform float material_fresnelFactor; // unused\nvoid getFresnel() {\n    float fresnel = 1.0 - max(dot(dNormalW, dViewDirW), 0.0);\n    float fresnel2 = fresnel * fresnel;\n    fresnel *= fresnel2 * fresnel2;\n    fresnel *= dGlossiness * dGlossiness;\n    dSpecularity = dSpecularity + (1.0 - dSpecularity) * fresnel;\n}\n";
pc.shaderChunks.fullscreenQuadPS = "varying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n    gl_FragColor = texture2D(source, vUv0);\n}\n";
pc.shaderChunks.fullscreenQuadVS = "attribute vec2 vertex_position;\nvarying vec2 vUv0;\nvoid main(void)\n{\n    gl_Position = vec4(vertex_position, 0.5, 1.0);\n    vUv0 = vertex_position.xy*0.5+0.5;\n}\n";
pc.shaderChunks.gamma1_0PS = "vec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n    return texture2D(tex, uv);\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n    return texture2D(tex, uv, bias);\n}\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n    return textureCube(tex, uvw);\n}\nvec3 gammaCorrectOutput(vec3 color) {\n    return color;\n}\nvec3 gammaCorrectInput(vec3 color) {\n    return color;\n}\nfloat gammaCorrectInput(float color) {\n    return color;\n}\nvec4 gammaCorrectInput(vec4 color) {\n    return color;\n}\n";
pc.shaderChunks.gamma2_2PS = "vec3 gammaCorrectInput(vec3 color) {\n    return pow(color, vec3(2.2));\n}\nfloat gammaCorrectInput(float color) {\n    return pow(color, 2.2);\n}\nvec4 gammaCorrectInput(vec4 color) {\n    return vec4(pow(color.rgb, vec3(2.2)), color.a);\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n    vec4 rgba = texture2D(tex, uv);\n    rgba.rgb = gammaCorrectInput(rgba.rgb);\n    return rgba;\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n    vec4 rgba = texture2D(tex, uv, bias);\n    rgba.rgb = gammaCorrectInput(rgba.rgb);\n    return rgba;\n}\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n    vec4 rgba = textureCube(tex, uvw);\n    rgba.rgb = gammaCorrectInput(rgba.rgb);\n    return rgba;\n}\nvec3 gammaCorrectOutput(vec3 color) {\n#ifdef HDR\n    return color;\n#else\n    color += vec3(0.0000001);\n    return pow(color, vec3(0.45));\n#endif\n}\n";
pc.shaderChunks.genParaboloidPS = "varying vec2 vUv0;\nuniform samplerCube source;\nuniform vec4 params; // x = mip\nvoid main(void) {\n    vec2 uv = vUv0;\n    float side = uv.x < 0.5? 1.0 : -1.0;\n    vec2 tc;\n    tc.x = fract(uv.x * 2.0) * 2.0 - 1.0;\n    tc.y = uv.y * 2.0 - 1.0;\n    // scale projection a bit to have a little overlap for filtering\n    const float scale = 1.1;\n    tc *= scale;\n    vec3 dir;\n    dir.y = (dot(tc, tc) - 1.0) * side; // from 1.0 center to 0.0 borders quadratically\n    dir.xz = tc * -2.0;\n    dir.x *= -side * params.y; // flip original cubemap x instead of doing it at runtime\n    dir = fixSeams(dir, params.x);\n    vec4 color = textureCube(source, dir, -100.0);\n    gl_FragColor = color;\n}\n";
pc.shaderChunks.gles3PS = "#define varying in\nout highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\n#define GL2\n";
pc.shaderChunks.gles3VS = "#define attribute in\n#define varying out\n#define texture2D texture\n#define GL2\n#define VERTEXSHADER\n";
pc.shaderChunks.glossPS = "#ifdef MAPFLOAT\nuniform float material_shininess;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_glossMap;\n#endif\nvoid getGlossiness() {\n    dGlossiness = 1.0;\n    #ifdef MAPFLOAT\n        dGlossiness *= material_shininess;\n    #endif\n    #ifdef MAPTEXTURE\n        dGlossiness *= texture2D(texture_glossMap, $UV).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        dGlossiness *= saturate(vVertexColor.$VC);\n    #endif\n    dGlossiness += 0.0000001;\n}\n";
pc.shaderChunks.instancingVS = "\nattribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\n";
pc.shaderChunks.lightDiffuseLambertPS = "float getLightDiffuse() {\n    return max(dot(dNormalW, -dLightDirNormW), 0.0);\n}\n";
pc.shaderChunks.lightDirPointPS = "void getLightDirPoint(vec3 lightPosW) {\n    dLightDirW = vPositionW - lightPosW;\n    dLightDirNormW = normalize(dLightDirW);\n    dLightPosW = lightPosW;\n}\n";
pc.shaderChunks.lightSpecularBlinnPS = "// Energy-conserving (hopefully) Blinn-Phong\nfloat getLightSpecular() {\n    vec3 h = normalize( -dLightDirNormW + dViewDirW );\n    float nh = max( dot( h, dNormalW ), 0.0 );\n    float specPow = exp2(dGlossiness * 11.0); // glossiness is linear, power is not; 0 - 2048\n    specPow = antiAliasGlossiness(specPow);\n    // Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little\n    specPow = max(specPow, 0.0001);\n    return pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\n";
pc.shaderChunks.lightSpecularPhongPS = "float getLightSpecular() {\n    float specPow = dGlossiness;\n    specPow = antiAliasGlossiness(specPow);\n    // Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little\n    return pow(max(dot(dReflDirW, -dLightDirNormW), 0.0), specPow + 0.0001);\n}\n";
pc.shaderChunks.lightmapDirPS = "uniform sampler2D texture_lightMap;\nuniform sampler2D texture_dirLightMap;\nvoid addLightMap() {\n    vec3 color = $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n    vec4 dir = texture2D(texture_dirLightMap, $UV);\n    if (dot(dir.xyz,vec3(1.0)) < 0.00001) {\n        dDiffuseLight += color;\n        return;\n    }\n    dLightDirNormW = normalize(dir.xyz * 2.0 - vec3(1.0));\n    float vlight = saturate(dot(dLightDirNormW, -dVertexNormalW));\n    float flight = saturate(dot(dLightDirNormW, -dNormalW));\n    float nlight = (flight / max(vlight,0.01)) * 0.5;\n    dDiffuseLight += color * nlight * 2.0;\n}\nvoid addDirLightMap() {\n    vec4 dir = texture2D(texture_dirLightMap, $UV);\n    if (dot(dir.xyz,vec3(1.0)) < 0.00001) return;\n    vec3 color = $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n    dLightDirNormW = normalize(dir.xyz * 2.0 - vec3(1.0));\n    dSpecularLight += vec3(getLightSpecular()) * color;\n}\n";
pc.shaderChunks.lightmapSinglePS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_lightMap;\n#endif\nvoid addLightMap() {\n    vec3 lm = vec3(1.0);\n    #ifdef MAPTEXTURE\n        lm *= $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        lm *= saturate(vVertexColor.$VC);\n    #endif\n    \n    dDiffuseLight += lm;\n}\n";
pc.shaderChunks.lightmapSingleVertPS = "void addLightMap() {\n    dDiffuseLight += saturate(vVertexColor.$CH);\n}\n";
pc.shaderChunks.metalnessPS = "void processMetalness(float metalness) {\n    const float dielectricF0 = 0.04;\n    dSpecularity = mix(vec3(dielectricF0), dAlbedo, metalness);\n    dAlbedo *= 1.0 - metalness;\n}\n#ifdef MAPFLOAT\nuniform float material_metalness;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_metalnessMap;\n#endif\nvoid getSpecularity() {\n    float metalness = 1.0;\n    #ifdef MAPFLOAT\n        metalness *= material_metalness;\n    #endif\n    #ifdef MAPTEXTURE\n        metalness *= texture2D(texture_metalnessMap, $UV).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        metalness *= saturate(vVertexColor.$VC);\n    #endif\n    processMetalness(metalness);\n}\n";
pc.shaderChunks.msdfPS = "uniform sampler2D texture_msdfMap;\n#ifdef GL_OES_standard_derivatives\n#define USE_FWIDTH\n#endif\n#ifdef GL2\n#define USE_FWIDTH\n#endif\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\nfloat map (float min, float max, float v) {\n    return (v - min) / (max - min);\n}\n// msdf way\n// vec4 applyMsdf(vec4 color) {\n//     vec3 tsample = texture(texture_msdfMap, vUv0).rgb;\n   \n//     // separate\n//     vec2 msdfUnit = 4.0 / vec2(512.0, 256.0);\n//     float sigDist = median(tsample.r, tsample.g, tsample.b) - 0.5;\n//     sigDist *= dot(msdfUnit, 0.5/fwidth(vUv0));\n//     float distance = clamp(sigDist + 0.5, 0.0, 1.0);\n//     return mix(vec4(0.0), color, distance);\n// }\nuniform float font_sdfIntensity; // intensity is used to boost the value read from the SDF, 0 is no boost, 1.0 is max boost\nuniform float font_pxrange;      // the number of pixels between inside and outside the font in SDF\nuniform float font_textureWidth; // the width of the texture atlas\nvec4 applyMsdf(vec4 color) {\n    float font_size = 16.0; // TODO fix this\n    // sample the field\n    vec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n    // get the signed distance value\n    float sigDist = median(tsample.r, tsample.g, tsample.b);\n    #ifdef USE_FWIDTH\n        // smoothing depends on size of texture on screen\n        vec2 w = fwidth(vUv0);\n        float smoothing = clamp(map(0.0, 2.0 * font_pxrange / font_textureWidth, w.x), 0.0, 0.5);\n    #else\n        // smoothing gets smaller as the font size gets bigger\n        // don't have fwidth we can approximate from font size, this doesn't account for scaling\n        // so a big font scaled down will be wrong...\n        float smoothing = clamp(2.0 * font_pxrange / font_size, 0.0, 0.5);\n        // for small fonts we remap the distance field to intensify it\n        // float mapMin = 0.05;\n        // float mapMax = clamp(((font_size * 0.4 / 40.0) + 0.52), mapMin, 1.0);\n    #endif\n    float mapMin = 0.05;\n    float mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n    \n    // remap to a smaller range (used on smaller font sizes)\n    sigDist = map(mapMin, mapMax, sigDist);\n    float center = 0.5;\n    // calculate smoothing and use to generate opacity\n    // float smoothing = clamp(font_smoothing * (1.0-roy), 0.0, center);\n    float opacity = smoothstep(center-smoothing, center+smoothing, sigDist);\n    // return final color\n    return mix(vec4(0.0), color, opacity);\n}";
pc.shaderChunks.normalVS = "vec3 getNormal() {\n    #ifdef SKIN\n        dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n    #elif defined(INSTANCING)\n        dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n    #else\n        dNormalMatrix = matrix_normal;\n    #endif\n    return normalize(dNormalMatrix * vertex_normal);\n}\n";
pc.shaderChunks.normalInstancedVS = "vec3 getNormal() {\n    dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n    return normalize(dNormalMatrix * vertex_normal);\n}\n";
pc.shaderChunks.normalMapPS = "uniform sampler2D texture_normalMap;\nuniform float material_bumpiness;\nvoid getNormal() {\n    vec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n    dNormalMap = normalMap;\n    dNormalW = dTBN * normalMap;\n}\n";
pc.shaderChunks.normalMapFloatPS = "uniform sampler2D texture_normalMap;\nuniform float material_bumpiness;\nvoid getNormal() {\n    vec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n    dNormalMap = normalMap;\n    normalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness));\n    dNormalW = dTBN * normalMap;\n}\n";
pc.shaderChunks.normalMapFloatTBNfastPS = "uniform sampler2D texture_normalMap;\nuniform float material_bumpiness;\nvoid getNormal() {\n    vec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n    dNormalMap = normalMap;\n    normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness);\n    dNormalW = normalize(dTBN * normalMap);\n}\n";
pc.shaderChunks.normalSkinnedVS = "vec3 getNormal() {\n    dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n    return normalize(dNormalMatrix * vertex_normal);\n}\n";
pc.shaderChunks.normalVertexPS = "void getNormal() {\n    dNormalW = normalize(dVertexNormalW);\n}\n";
pc.shaderChunks.normalXYPS = "vec3 unpackNormal(vec4 nmap) {\n    vec3 normal;\n    normal.xy = nmap.wy * 2.0 - 1.0;\n    normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n    return normal;\n}\n";
pc.shaderChunks.normalXYZPS = "vec3 unpackNormal(vec4 nmap) {\n    return nmap.xyz * 2.0 - 1.0;\n}\n";
pc.shaderChunks.opacityPS = "#ifdef MAPFLOAT\nuniform float material_opacity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_opacityMap;\n#endif\nvoid getOpacity() {\n    dAlpha = 1.0;\n    #ifdef MAPFLOAT\n        dAlpha *= material_opacity;\n    #endif\n    #ifdef MAPTEXTURE\n        dAlpha *= texture2D(texture_opacityMap, $UV).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        dAlpha *= saturate(vVertexColor.$VC);\n    #endif\n}\n";
pc.shaderChunks.outputAlphaPS = "gl_FragColor.a = dAlpha;\n";
pc.shaderChunks.outputAlphaOpaquePS = "gl_FragColor.a = 1.0;\n";
pc.shaderChunks.outputAlphaPremulPS = "gl_FragColor.rgb *= dAlpha;\ngl_FragColor.a = dAlpha;\n";
pc.shaderChunks.outputCubemapPS = "varying vec2 vUv0;\nuniform samplerCube source;\nuniform vec4 params;\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\nvec4 encodeRGBM(vec4 color) { // modified RGBM\n    color.rgb = pow(color.rgb, vec3(0.5));\n    color.rgb *= 1.0 / 8.0;\n    color.a = saturate( max( max( color.r, color.g ), max( color.b, 1.0 / 255.0 ) ) );\n    color.a = ceil(color.a * 255.0) / 255.0;\n    color.rgb /= color.a;\n    return color;\n}\nvoid main(void) {\n    vec2 st = vUv0 * 2.0 - 1.0;\n    float face = params.x;\n    vec3 vec;\n    if (face==0.0) {\n        vec = vec3(1, -st.y, -st.x);\n    } else if (face==1.0) {\n        vec = vec3(-1, -st.y, st.x);\n    } else if (face==2.0) {\n        vec = vec3(st.x, 1, st.y);\n    } else if (face==3.0) {\n        vec = vec3(st.x, -1, -st.y);\n    } else if (face==4.0) {\n        vec = vec3(st.x, -st.y, 1);\n    } else {\n        vec = vec3(-st.x, -st.y, -1);\n    }\n    gl_FragColor = textureCube(source, vec);\n    if (params.w >= 2.0) gl_FragColor = encodeRGBM(gl_FragColor);\n}\n";
pc.shaderChunks.outputTex2DPS = "varying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n    gl_FragColor = texture2D(source, vUv0);\n}\n";
pc.shaderChunks.packDepthPS = "// Packing a float in GLSL with multiplication and mod\n// http://blog.gradientstudios.com/2012/08/23/shadow-map-improvement\nvec4 packFloat(float depth) {\n    const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n    const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n    // combination of mod and multiplication and division works better\n    vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n    res -= res.xxyz * bit_mask;\n    return res;\n}\n";
pc.shaderChunks.packDepthMaskPS = "vec4 packFloat(float depth) {\n    const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n    const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n    // combination of mod and multiplication and division works better\n    vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n    res.x = 0.0;\n    res -= res.xxyz * bit_mask;\n    return res;\n}\n";
pc.shaderChunks.parallaxPS = "uniform sampler2D texture_heightMap;\nuniform float material_heightMapFactor;\nvoid getParallax() {\n    float parallaxScale = material_heightMapFactor;\n    float height = texture2D(texture_heightMap, $UV).$CH;\n    height = height * parallaxScale - parallaxScale*0.5;\n    vec3 viewDirT = dViewDirW * dTBN;\n    viewDirT.z += 0.42;\n    dUvOffset = height * (viewDirT.xy / viewDirT.z);\n}\n";
pc.shaderChunks.particlePS = "varying vec4 texCoordsAlphaLife;\nuniform sampler2D colorMap;\nuniform sampler2D internalTex3;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nuniform float softening;\nuniform float colorMult;\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n    const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n    float depth = dot(rgbaDepth, bitShift);\n    return depth;\n}\n#endif\nvoid main(void) {\n    vec4 tex         = texture2DSRGB(colorMap, texCoordsAlphaLife.xy);\n    vec4 ramp     = texture2DSRGB(internalTex3, vec2(texCoordsAlphaLife.w, 0.0));\n    ramp.rgb *= colorMult;\n    ramp.a += texCoordsAlphaLife.z;\n    vec3 rgb =     tex.rgb * ramp.rgb;\n    float a =         tex.a * ramp.a;\n";
pc.shaderChunks.particleVS = "\nvec3 unpack3NFloats(float src) {\n    float r = fract(src);\n    float g = fract(src * 256.0);\n    float b = fract(src * 65536.0);\n    return vec3(r, g, b);\n}\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\nvec4 tex1Dlod_lerp(sampler2D tex, vec2 tc) {\n    return mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\n}\nvec4 tex1Dlod_lerp(sampler2D tex, vec2 tc, out vec3 w) {\n    vec4 a = texture2D(tex,tc);\n    vec4 b = texture2D(tex,tc + graphSampleSize);\n    float c = fract(tc.x*graphNumSamples);\n    vec3 unpackedA = unpack3NFloats(a.w);\n    vec3 unpackedB = unpack3NFloats(b.w);\n    w = mix(unpackedA, unpackedB, c);\n    return mix(a, b, c);\n}\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\n    float c = cos(pRotation);\n    float s = sin(pRotation);\n    mat2 m = mat2(c, -s, s, c);\n    rotMatrix = m;\n    return m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\n    vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n    return pos;\n}\nvoid main(void) {\n    vec3 meshLocalPos = particle_vertexData.xyz;\n    float id = floor(particle_vertexData.w);\n    float rndFactor = fract(sin(id + 1.0 + seed));\n    vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n    float uv = id / numParticlesPot;\n    readInput(uv);\n    vec2 velocityV = normalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used\n    float particleLifetime = lifetime;\n    if (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\n    vec2 quadXY = meshLocalPos.xy;\n    float nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n    vec3 paramDiv;\n    vec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n    float scale = params.y;\n    float scaleDiv = paramDiv.x;\n    float alphaDiv = paramDiv.z;\n    scale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\n    texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5,    (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0),    nlife);\n    vec3 particlePos = inPos;\n    vec3 particlePosMoved = vec3(0.0);\n    mat2 rotMatrix;\n";
pc.shaderChunks.particleAnimFrameClampVS = "\n    float animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.z), animTexParams.w);\n";
pc.shaderChunks.particleAnimFrameLoopVS = "\n    float animFrame = floor(texCoordsAlphaLife.w * animTexParams.z);\n";
pc.shaderChunks.particleAnimTexVS = "\n    float atlasX = animFrame * animTexParams.x;\n    float atlasY = floor(atlasX) * animTexParams.y;\n    atlasX = fract(atlasX);\n    texCoordsAlphaLife.xy *= animTexParams.xy;\n    texCoordsAlphaLife.xy += vec2(atlasX, atlasY);\n    texCoordsAlphaLife.y = 1.0 - texCoordsAlphaLife.y;\n";
pc.shaderChunks.particleInputFloatPS = "void readInput(float uv) {\n    vec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\n    vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\n    inPos = tex.xyz;\n    inVel = tex2.xyz;\n    inAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\n    inShow = tex.w >= 0.0;\n    inLife = tex2.w;\n}\n";
pc.shaderChunks.particleInputRgba8PS = "//RG=X, BA=Y\n//RG=Z, BA=A\n//RGB=V, A=visMode\n//RGBA=life\n#define PI2 6.283185307179586\nuniform vec3 inBoundsSize;\nuniform vec3 inBoundsCenter;\nuniform float maxVel;\nfloat decodeFloatRG(vec2 rg) {\n    return rg.y*(1.0/255.0) + rg.x;\n}\nfloat decodeFloatRGBA( vec4 rgba ) {\n  return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\nvoid readInput(float uv) {\n    vec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\n    vec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\n    vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\n    vec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\n    inPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n    inPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\n    inVel = tex2.xyz;\n    inVel = (inVel - vec3(0.5)) * maxVel;\n    inAngle = decodeFloatRG(tex1.ba) * PI2;\n    inShow = tex2.a > 0.5;\n    inLife = decodeFloatRGBA(tex3);\n    float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n    float maxPosLife = lifetime+1.0;\n    inLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\n}\n";
pc.shaderChunks.particleOutputFloatPS = "void writeOutput() {\n    if (gl_FragCoord.y<1.0) {\n        gl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\n    } else {\n        gl_FragColor = vec4(outVel, outLife);\n    }\n}\n";
pc.shaderChunks.particleOutputRgba8PS = "uniform vec3 outBoundsMul;\nuniform vec3 outBoundsAdd;\nvec2 encodeFloatRG( float v ) {\n  vec2 enc = vec2(1.0, 255.0) * v;\n  enc = fract(enc);\n  enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n  return enc;\n}\nvec4 encodeFloatRGBA( float v ) {\n  vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n  enc = fract(enc);\n  enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n  return enc;\n}\nvoid writeOutput() {\n    //outPos = (outPos - outBoundsCenter) / outBoundsSize + vec3(0.5);\n    outPos = outPos * outBoundsMul + outBoundsAdd;\n    outAngle = fract(outAngle / PI2);\n    outVel = (outVel / maxVel) + vec3(0.5); // TODO: mul\n    float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n    float maxPosLife = lifetime+1.0;\n    outLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n    if (gl_FragCoord.y < 1.0) {\n        gl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n    } else if (gl_FragCoord.y < 2.0) {\n        gl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n    } else if (gl_FragCoord.y < 3.0) {\n        gl_FragColor = vec4(outVel, visMode*0.5+0.5);\n    } else {\n        gl_FragColor = encodeFloatRGBA(outLife);\n    }\n}\n";
pc.shaderChunks.particleUpdaterAABBPS = "uniform mat3 spawnBounds;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n    return emitterPos + spawnBounds * (inBounds - vec3(0.5));\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n    localVelocity -= vec3(0, 0, initialVelocity);\n}\n";
pc.shaderChunks.particleUpdaterEndPS = "\n    writeOutput();\n}\n";
pc.shaderChunks.particleUpdaterInitPS = "varying vec2 vUv0;\nuniform sampler2D particleTexIN;\nuniform sampler2D internalTex0;\nuniform sampler2D internalTex1;\nuniform sampler2D internalTex2;\nuniform mat3 emitterMatrix;\nuniform vec3 emitterScale;\nuniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;\nuniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, seed;\nuniform float startAngle, startAngle2;\nuniform float initialVelocity;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\nfloat visMode;\nvec3 outPos;\nvec3 outVel;\nfloat outAngle;\nbool outShow;\nfloat outLife;\n";
pc.shaderChunks.particleUpdaterNoRespawnPS = "    if (outLife >= lifetime) {\n        outLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n        visMode = -1.0;\n    }\n";
pc.shaderChunks.particleUpdaterOnStopPS = "    visMode = outLife < 0.0? -1.0: visMode;\n";
pc.shaderChunks.particleUpdaterRespawnPS = "    if (outLife >= lifetime) {\n        outLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n        visMode = 1.0;\n    }\n    visMode = outLife < 0.0? 1.0: visMode;\n";
pc.shaderChunks.particleUpdaterSpherePS = "uniform float spawnBoundsSphere;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n    float rnd4 = fract(rndFactor * 1000.0);\n    return emitterPos + normalize(inBounds.xyz - vec3(0.5)) * rnd4 * spawnBoundsSphere;\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n    localVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\n}\n";
pc.shaderChunks.particleUpdaterStartPS = "float saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\nvec3 unpack3NFloats(float src) {\n    float r = fract(src);\n    float g = fract(src * 256.0);\n    float b = fract(src * 65536.0);\n    return vec3(r, g, b);\n}\nvec3 tex1Dlod_lerp(sampler2D tex, vec2 tc, out vec3 w) {\n    vec4 a = texture2D(tex, tc);\n    vec4 b = texture2D(tex, tc + graphSampleSize);\n    float c = fract(tc.x * graphNumSamples);\n    vec3 unpackedA = unpack3NFloats(a.w);\n    vec3 unpackedB = unpack3NFloats(b.w);\n    w = mix(unpackedA, unpackedB, c);\n    return mix(a.xyz, b.xyz, c);\n}\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash41(float p) {\n    vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\nvoid main(void)\n{\n    if (gl_FragCoord.x > numParticles) discard;\n    readInput(vUv0.x);\n    visMode = inShow? 1.0 : -1.0;\n    vec4 rndFactor = hash41(gl_FragCoord.x + seed);\n    float particleRate = rate + rateDiv * rndFactor.x;\n    outLife = inLife + delta;\n    float nlife = clamp(outLife / lifetime, 0.0, 1.0);\n    vec3 localVelocityDiv;\n    vec3 velocityDiv;\n    vec3 paramDiv;\n    vec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);\n    vec3 velocity =      tex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);\n    vec3 params =        tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n    float rotSpeed = params.x;\n    float rotSpeedDiv = paramDiv.y;\n    localVelocity +=    (localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\n    velocity +=         (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\n    rotSpeed +=         (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\n    addInitialVelocity(localVelocity, rndFactor.xyz);\n    outVel = emitterMatrix * localVelocity.xyz + velocity.xyz * emitterScale;\n    outPos = inPos + outVel * delta;\n    outAngle = inAngle + rotSpeed * delta;\n    bool respawn = outLife <= 0.0 || outLife >= lifetime;\n    outPos = respawn? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : outPos;\n    outAngle = respawn? mix(startAngle, startAngle2, rndFactor.x) : outAngle;\n    outVel = respawn? vec3(0.0) : outVel;\n";
pc.shaderChunks.particle_TBNVS = "\n    mat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0,        rotMatrix[1][0], rotMatrix[1][1], 0.0,        0.0, 0.0, 1.0);\n    ParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\n";
pc.shaderChunks.particle_billboardVS = "\n    quadXY = rotate(quadXY, inAngle, rotMatrix);\n    vec3 localPos = billboard(particlePos, quadXY);\n";
pc.shaderChunks.particle_blendAddPS = "\n    rgb *= saturate(gammaCorrectInput(a));\n    if ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\n";
pc.shaderChunks.particle_blendMultiplyPS = "\n    rgb = mix(vec3(1.0), rgb, vec3(a));\n    if (rgb.r + rgb.g + rgb.b > 2.99) discard;\n";
pc.shaderChunks.particle_blendNormalPS = "\n    if (a < 0.01) discard;\n";
pc.shaderChunks.particle_cpuVS = "attribute vec4 particle_vertexData;     // XYZ = world pos, W = life\nattribute vec4 particle_vertexData2;     // X = angle, Y = scale, Z = alpha, W = velocity.x\nattribute vec4 particle_vertexData3;     // XYZ = particle local pos, W = velocity.y\nattribute vec2 particle_vertexData4;     // X = velocity.z, W = particle ID\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\nuniform float numParticles;\nuniform float lifetime;\nuniform float stretch;\n//uniform float graphSampleSize;\n//uniform float graphNumSamples;\nuniform vec3 wrapBounds, emitterScale;\nuniform sampler2D texLifeAndSourcePosOUT;\nuniform sampler2D internalTex0;\nuniform sampler2D internalTex1;\nuniform sampler2D internalTex2;\nuniform vec3 emitterPos;\nvarying vec4 texCoordsAlphaLife;\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\n{\n    float c = cos(pRotation);\n    float s = sin(pRotation);\n    //vec4 rotationMatrix = vec4(c, -s, s, c);\n    mat2 m = mat2(c, -s, s, c);\n    rotMatrix = m;\n    return m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\n{\n    vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n    return pos;\n}\nvoid main(void)\n{\n    vec3 particlePos = particle_vertexData.xyz;\n    vec3 inPos = particlePos;\n    vec3 vertPos = particle_vertexData3.xyz;\n    vec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData4.x);\n    vec2 velocityV = normalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used\n    vec2 quadXY = vertPos.xy;\n    texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\n    mat2 rotMatrix;\n    float inAngle = particle_vertexData2.x;\n    vec3 particlePosMoved = vec3(0.0);\n    vec3 meshLocalPos = particle_vertexData3.xyz;\n";
pc.shaderChunks.particle_cpu_endVS = "\n    localPos *= particle_vertexData2.y * emitterScale;\n    localPos += particlePos;\n    gl_Position = matrix_viewProjection * vec4(localPos, 1.0);\n";
pc.shaderChunks.particle_endPS = "    rgb = addFog(rgb);\n    rgb = toneMap(rgb);\n    rgb = gammaCorrectOutput(rgb);\n    gl_FragColor = vec4(rgb, a);\n}\n";
pc.shaderChunks.particle_endVS = "\n    localPos *= scale * emitterScale;\n    localPos += particlePos;\n    gl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\n";
pc.shaderChunks.particle_halflambertPS = "\n    vec3 negNormal = normal*0.5+0.5;\n    vec3 posNormal = -normal*0.5+0.5;\n    negNormal *= negNormal;\n    posNormal *= posNormal;\n";
pc.shaderChunks.particle_initVS = "attribute vec4 particle_vertexData; // XYZ = particle position, W = particle ID + random factor\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform float numParticles, numParticlesPot;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nuniform float stretch;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale, emitterPos;\nuniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;\nuniform sampler2D particleTexOUT, particleTexIN;\nuniform sampler2D internalTex0;\nuniform sampler2D internalTex1;\nuniform sampler2D internalTex2;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nvarying vec4 texCoordsAlphaLife;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\n";
pc.shaderChunks.particle_lambertPS = "\n    vec3 negNormal = max(normal, vec3(0.0));\n    vec3 posNormal = max(-normal, vec3(0.0));\n";
pc.shaderChunks.particle_lightingPS = "\n    vec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\n                        negNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\n                        negNormal.z*lightCube[4] + posNormal.z*lightCube[5];\n    rgb *= light;\n";
pc.shaderChunks.particle_localShiftVS = "    particlePos += emitterPos;\n";
pc.shaderChunks.particle_meshVS = "\n    vec3 localPos = meshLocalPos;\n    localPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\n    localPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\n    billboard(particlePos, quadXY);\n";
pc.shaderChunks.particle_normalVS = "\n    Normal = normalize(localPos + matrix_viewInverse[2].xyz);\n";
pc.shaderChunks.particle_normalMapPS = "\n    vec3 normalMap         = normalize( texture2D(normalMap, texCoordsAlphaLife.xy).xyz * 2.0 - 1.0 );\n    vec3 normal = ParticleMat * normalMap;\n";
pc.shaderChunks.particle_pointAlongVS = "    inAngle = atan(velocityV.x, velocityV.y); // not the fastest way, but easier to plug in; TODO: create rot matrix right from vectors\n";
pc.shaderChunks.particle_softPS = "\n    float depth = getLinearScreenDepth();\n    float particleDepth = vDepth;\n    float depthDiff = saturate(abs(particleDepth - depth) * softening);\n    a *= depthDiff;\n";
pc.shaderChunks.particle_softVS = "\n    vDepth = getLinearDepth(localPos);\n";
pc.shaderChunks.particle_stretchVS = "    vec3 moveDir = inVel * stretch;\n    vec3 posPrev = inPos - moveDir;\n    posPrev += particlePosMoved;\n    vec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\n    float interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\n    particlePos = mix(particlePos, posPrev, interpolation);\n";
pc.shaderChunks.particle_wrapVS = "\n    vec3 origParticlePos = particlePos;\n    particlePos -= matrix_model[3].xyz;\n    particlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\n    particlePos += matrix_model[3].xyz;\n    particlePosMoved = particlePos - origParticlePos;\n";
pc.shaderChunks.precisionTestPS = "void main(void) {\n    gl_FragColor = vec4(2147483648.0);\n}\n";
pc.shaderChunks.precisionTest2PS = "uniform sampler2D source;\nvec4 packFloat(float depth) {\n    const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n    const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n    vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n    res -= res.xxyz * bit_mask;\n    return res;\n}\nvoid main(void) {\n    float c = texture2D(source, vec2(0.0)).r;\n    float diff = abs(c - 2147483648.0) / 2147483648.0;\n    gl_FragColor = packFloat(diff);\n}\n";
pc.shaderChunks.prefilterCubemapPS = "varying vec2 vUv0;\nuniform samplerCube source;\nuniform vec4 params;\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\nfloat rnd(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233) * 2.0)) * 43758.5453);\n}\nconst float PI = 3.14159265358979;\nvec3 hemisphereSample_cos(vec2 uv, mat3 vecSpace, vec3 cubeDir, float gloss) { // cos + lerped cone size (better than just lerped)\n    float phi = uv.y * 2.0 * PI;\n    float cosTheta = sqrt(1.0 - uv.x);\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    vec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n    return normalize(mix(vecSpace * sampleDir, cubeDir, params.y));\n}\nvec3 hemisphereSample_phong(vec2 uv, mat3 vecSpace, vec3 cubeDir, float specPow) {\n    float phi = uv.y * 2.0 * PI;\n    float cosTheta = pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    vec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n    return vecSpace * sampleDir;\n}\nmat3 matrixFromVector(vec3 n) { // frisvad\n    float a = 1.0 / (1.0 + n.z);\n    float b = -n.x * n.y * a;\n    vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n    vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n    return mat3(b1, b2, n);\n}\nvec4 encodeRGBM(vec3 color) { // modified RGBM\n    vec4 encoded;\n    encoded.rgb = pow(color.rgb, vec3(0.5));\n    encoded.rgb *= 1.0 / 8.0;\n    encoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n    encoded.a = ceil(encoded.a * 255.0) / 255.0;\n    encoded.rgb /= encoded.a;\n    return encoded;\n}\nvoid main(void) {\n    vec2 st = vUv0 * 2.0 - 1.0;\n    if (params.w==1.0 || params.w==3.0) {\n        st = 2.0 * floor(gl_FragCoord.xy) / (params.z - 1.0) - 1.0;\n    }\n    float face = params.x;\n    vec3 vec;\n    if (face==0.0) {\n        vec = vec3(1, -st.y, -st.x);\n    } else if (face==1.0) {\n        vec = vec3(-1, -st.y, st.x);\n    } else if (face==2.0) {\n        vec = vec3(st.x, 1, st.y);\n    } else if (face==3.0) {\n        vec = vec3(st.x, -1, -st.y);\n    } else if (face==4.0) {\n        vec = vec3(st.x, -st.y, 1);\n    } else {\n        vec = vec3(-st.x, -st.y, -1);\n    }\n    mat3 vecSpace = matrixFromVector(normalize(vec));\n    vec3 color = vec3(0.0);\n    const int samples = $NUMSAMPLES;\n    vec3 vect;\n    for(int i=0; i<samples; i++) {\n        float sini = sin(float(i));\n        float cosi = cos(float(i));\n        float rand = rnd(vec2(sini, cosi));\n        vect = hemisphereSample_$METHOD(vec2(float(i) / float(samples), rand), vecSpace, vec, params.y);\n        color += $textureCube(source, vect).rgb;\n    }\n    color /= float(samples);\n    gl_FragColor = params.w < 2.0? vec4(color, 1.0) : encodeRGBM(color);\n}\n";
pc.shaderChunks.reflDirPS = "void getReflDir() {\n    dReflDirW = normalize(-reflect(dViewDirW, dNormalW));\n}\n";
pc.shaderChunks.reflectionCubePS = "uniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvoid addReflection() {\n    vec3 lookupVec = fixSeams(cubeMapProject(dReflDirW));\n    lookupVec.x *= -1.0;\n    dReflection += vec4($textureCubeSAMPLE(texture_cubeMap, lookupVec).rgb, material_reflectivity);\n}\n";
pc.shaderChunks.reflectionDpAtlasPS = "uniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec2 getDpAtlasUv(vec2 uv, float mip) {\n    vec4 rect;\n    float sx = saturate(mip - 2.0);\n    rect.x = sx * 0.5;\n    float t = mip - rect.x * 6.0;\n    float i = 1.0 - rect.x;\n    rect.y = min(t * 0.5, 0.75) * i + rect.x;\n    float st = saturate(t);\n    rect.z = (1.0 - st * 0.5) * i;\n    rect.w = rect.z * 0.5;\n    float rcRectZ = 1.0 / rect.z;\n    float scaleFactor = 0.00390625 * rcRectZ; // 0.0078125 = (256 + 2) / 256 - 1, 0.00390625 same for 512\n    vec2 scale = vec2(scaleFactor, scaleFactor * 2.0);\n    uv = uv * (vec2(1.0) - scale) + scale * 0.5;\n    uv = uv * rect.zw + rect.xy;\n    return uv;\n}\nvoid addReflection() {\n    vec3 reflDir = normalize(cubeMapProject(dReflDirW));\n    // Convert vector to DP coords\n    bool up = reflDir.y > 0.0;\n    float scale = 0.90909090909090909090909090909091;// 1.0 / 1.1;\n    vec3 reflDirWarp = reflDir.xzx * vec3(-0.25, 0.5, 0.25);\n    float reflDirVer = abs(reflDir.y) + 1.0;\n    reflDirWarp /= reflDirVer;\n    reflDirWarp *= scale;\n    reflDirWarp = vec3(0.75, 0.5, 0.25) - reflDirWarp;\n    vec2 tc = up? reflDirWarp.xy : reflDirWarp.zy;\n    float bias = saturate(1.0 - dGlossiness) * 5.0; // multiply by max mip level\n    float mip = floor(bias);\n    vec3 tex1 = $texture2DSAMPLE(texture_sphereMap, getDpAtlasUv(tc, mip)).rgb;\n    mip = min(mip + 1.0, 5.0);\n    vec3 tex2 = $texture2DSAMPLE(texture_sphereMap, getDpAtlasUv(tc, mip)).rgb;\n    tex1 = mix(tex1, tex2, fract(bias));\n    tex1 = processEnvironment(tex1);\n    dReflection += vec4(tex1, material_reflectivity);\n}\n";
pc.shaderChunks.reflectionPrefilteredCubePS = "uniform samplerCube texture_prefilteredCubeMap128;\nuniform samplerCube texture_prefilteredCubeMap64;\nuniform samplerCube texture_prefilteredCubeMap32;\nuniform samplerCube texture_prefilteredCubeMap16;\nuniform samplerCube texture_prefilteredCubeMap8;\n#ifndef PMREM4\n#define PMREM4\nuniform samplerCube texture_prefilteredCubeMap4;\n#endif\nuniform float material_reflectivity;\nvoid addReflection() {\n    // Unfortunately, WebGL doesn't allow us using textureCubeLod. Therefore bunch of nasty workarounds is required.\n    // We fix mip0 to 128x128, so code is rather static.\n    // Mips smaller than 4x4 aren't great even for diffuse. Don't forget that we don't have bilinear filtering between different faces.\n    float bias = saturate(1.0 - dGlossiness) * 5.0; // multiply by max mip level\n    int index1 = int(bias);\n    int index2 = int(min(bias + 1.0, 7.0));\n    vec3 fixedReflDir = fixSeams(cubeMapProject(dReflDirW), bias);\n    fixedReflDir.x *= -1.0;\n    vec4 cubes[6];\n    cubes[0] = textureCube(texture_prefilteredCubeMap128, fixedReflDir);\n    cubes[1] = textureCube(texture_prefilteredCubeMap64, fixedReflDir);\n    cubes[2] = textureCube(texture_prefilteredCubeMap32, fixedReflDir);\n    cubes[3] = textureCube(texture_prefilteredCubeMap16, fixedReflDir);\n    cubes[4] = textureCube(texture_prefilteredCubeMap8, fixedReflDir);\n    cubes[5] = textureCube(texture_prefilteredCubeMap4, fixedReflDir);\n    // Also we don't have dynamic indexing in PS, so...\n    vec4 cube[2];\n    for(int i = 0; i < 6; i++) {\n        if (i == index1) {\n            cube[0] = cubes[i];\n        }\n        if (i == index2) {\n            cube[1] = cubes[i];\n        }\n    }\n    // another variant\n    /*if (index1==0){ cube[0]=cubes[0];\n    }else if (index1==1){ cube[0]=cubes[1];\n    }else if (index1==2){ cube[0]=cubes[2];\n    }else if (index1==3){ cube[0]=cubes[3];\n    }else if (index1==4){ cube[0]=cubes[4];\n    }else if (index1==5){ cube[0]=cubes[5];}\n    if (index2==0){ cube[1]=cubes[0];\n    }else if (index2==1){ cube[1]=cubes[1];\n    }else if (index2==2){ cube[1]=cubes[2];\n    }else if (index2==3){ cube[1]=cubes[3];\n    }else if (index2==4){ cube[1]=cubes[4];\n    }else if (index2==5){ cube[1]=cubes[5];}*/\n    vec4 cubeFinal = mix(cube[0], cube[1], fract(bias));\n    vec3 refl = processEnvironment($DECODE(cubeFinal).rgb);\n    dReflection += vec4(refl, material_reflectivity);\n}\n";
pc.shaderChunks.reflectionPrefilteredCubeLodPS = "\n#ifndef PMREM4\n#define PMREM4\n#extension GL_EXT_shader_texture_lod : enable\nuniform samplerCube texture_prefilteredCubeMap128;\n#endif\nuniform float material_reflectivity;\nvoid addReflection() {\n    float bias = saturate(1.0 - dGlossiness) * 5.0; // multiply by max mip level\n    vec3 fixedReflDir = fixSeams(cubeMapProject(dReflDirW), bias);\n    fixedReflDir.x *= -1.0;\n    vec3 refl = processEnvironment($DECODE( textureCubeLodEXT(texture_prefilteredCubeMap128, fixedReflDir, bias) ).rgb);\n    dReflection += vec4(refl, material_reflectivity);\n}\n";
pc.shaderChunks.reflectionSpherePS = "#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvoid addReflection() {\n    vec3 reflDirV = (mat3(matrix_view) * dReflDirW).xyz;\n    float m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\n    vec2 sphereMapUv = reflDirV.xy / m + 0.5;\n    dReflection += vec4($texture2DSAMPLE(texture_sphereMap, sphereMapUv).rgb, material_reflectivity);\n}\n";
pc.shaderChunks.reflectionSphereLowPS = "uniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvoid addReflection() {\n    vec3 reflDirV = vNormalV;\n    vec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;\n    dReflection += vec4($texture2DSAMPLE(texture_sphereMap, sphereMapUv).rgb, material_reflectivity);\n}\n";
pc.shaderChunks.refractionPS = "uniform float material_refraction, material_refractionIndex;\nvec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {\n    float vn = dot(viewVec, Normal);\n    float k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n    vec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;\n    return refrVec;\n}\nvoid addRefraction() {\n    // use same reflection code with refraction vector\n    vec3 tmp = dReflDirW;\n    vec4 tmp2 = dReflection;\n    dReflection = vec4(0.0);\n    dReflDirW = refract2(-dViewDirW, dNormalW, material_refractionIndex);\n    addReflection();\n    dDiffuseLight = mix(dDiffuseLight, dReflection.rgb * dAlbedo, material_refraction);\n    dReflDirW = tmp;\n    dReflection = tmp2;\n}\n";
pc.shaderChunks.rgbmPS = "vec3 decodeRGBM(vec4 rgbm) {\n    vec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n    return color * color;\n}\nvec3 texture2DRGBM(sampler2D tex, vec2 uv) {\n    return decodeRGBM(texture2D(tex, uv));\n}\nvec3 textureCubeRGBM(samplerCube tex, vec3 uvw) {\n    return decodeRGBM(textureCube(tex, uvw));\n}\n";
pc.shaderChunks.screenDepthPS = "uniform sampler2D uDepthMap;\n#ifndef SCREENSIZE\n#define SCREENSIZE\nuniform vec4 uScreenSize;\n#endif\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params; // 1 / camera_far,      camera_far,     (1 - f / n) / 2,        (1 + f / n) / 2\n#endif\n#ifdef GL2\n    float linearizeDepth(float z) {\n        z = z * 2.0 - 1.0;\n        return 1.0 / (camera_params.z * z + camera_params.w);\n    }\n#else\n    #ifndef UNPACKFLOAT\n    #define UNPACKFLOAT\n    float unpackFloat(vec4 rgbaDepth) {\n        const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n        return dot(rgbaDepth, bitShift);\n    }\n    #endif\n#endif\n// Retrieves rendered linear camera depth by UV\nfloat getLinearScreenDepth(vec2 uv) {\n    #ifdef GL2\n        return linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y;\n    #else\n        return unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y;\n    #endif\n}\n#ifndef VERTEXSHADER\n// Retrieves rendered linear camera depth under the current pixel\nfloat getLinearScreenDepth() {\n    vec2 uv = gl_FragCoord.xy * uScreenSize.zw;\n    return getLinearScreenDepth(uv);\n}\n#endif\n// Generates linear camera depth for the given world position\nfloat getLinearDepth(vec3 pos) {\n    return -(matrix_view * vec4(pos, 1.0)).z;\n}\n";
pc.shaderChunks.shadowCommonPS = "void normalOffsetPointShadow(vec4 shadowParams) {\n    float distScale = length(dLightDirW);\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale; //0.02\n    vec3 dir = wPos - dLightPosW;\n    dLightDirW = dir;\n}\n";
pc.shaderChunks.shadowCoordPS = "void _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n    dShadowCoord = (shadowMatrix * vec4(wPos, 1.0)).xyz;\n    dShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n    #ifdef SHADOWBIAS\n        dShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n    #endif\n}\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n    vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n    projPos.xy /= projPos.w;\n    dShadowCoord.xy = projPos.xy;\n    dShadowCoord.z = length(dLightDirW) * shadowParams.w;\n    #ifdef SHADOWBIAS\n        dShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n    #endif\n}\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n    _getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams) {\n    _getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n    float distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW)); // fov?\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n    _getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0); //0.08\n    _getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n";
pc.shaderChunks.shadowCoordVS = "void getLightDirPoint(vec3 lightPosW) {\n    vec3 lightDirW = vPositionW - lightPosW;\n    dLightDirNormW = normalize(lightDirW);\n    dLightPosW = lightPosW;\n}\nvoid _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n    vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n    vMainShadowUv = projPos;\n}\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n    vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n    vMainShadowUv = projPos;\n}\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n    _getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec3 shadowParams) {\n    _getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n    float distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW)); // fov?\n    vec3 wPos = vPositionW + dNormalW * shadowParams.y * clamp(1.0 - dot(dNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n    _getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n    vec3 wPos = vPositionW + dNormalW * shadowParams.y * clamp(1.0 - dot(dNormalW, -dLightDirNormW), 0.0, 1.0); //0.08\n    _getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n";
pc.shaderChunks.shadowCoordPerspZbufferPS = "void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n    vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n    projPos.xyz /= projPos.w;\n    dShadowCoord = projPos.xyz;\n    // depth bias is already applied on render\n}\nvoid getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n    float distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW)); // fov?\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n    _getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams) {\n    _getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, vPositionW);\n}\n";
pc.shaderChunks.shadowEVSMPS = "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n    vec3 moments = texture2D(tex, texCoords).xyz;\n    return calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";
pc.shaderChunks.shadowEVSMnPS = "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n    float pixelSize = 1.0 / resolution;\n    texCoords -= vec2(pixelSize);\n    vec3 s00 = texture2D(tex, texCoords).xyz;\n    vec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\n    vec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\n    vec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\n    vec2 fr = fract(texCoords * resolution);\n    vec3 h0 = mix(s00, s10, fr.x);\n    vec3 h1 = mix(s01, s11, fr.x);\n    vec3 moments = mix(h0, h1, fr.y);\n    return calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";
pc.shaderChunks.shadowStandardPS = "vec3 lessThan2(vec3 a, vec3 b) {\n    return clamp((b - a)*1000.0, 0.0, 1.0); // softer version\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n    const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n    return dot(rgbaDepth, bitShift);\n}\n#endif\n// ----- Direct/Spot Sampling -----\n#ifdef GL2\n    float _getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n        float z = dShadowCoord.z;\n        vec2 uv = dShadowCoord.xy * shadowParams.x; // 1 unit - 1 texel\n        float shadowMapSizeInv = 1.0 / shadowParams.x;\n        vec2 base_uv = floor(uv + 0.5);\n        float s = (uv.x + 0.5 - base_uv.x);\n        float t = (uv.y + 0.5 - base_uv.y);\n        base_uv -= vec2(0.5);\n        base_uv *= shadowMapSizeInv;\n        float sum = 0.0;\n        float uw0 = (3.0 - 2.0 * s);\n        float uw1 = (1.0 + 2.0 * s);\n        float u0 = (2.0 - s) / uw0 - 1.0;\n        float u1 = s / uw1 + 1.0;\n        float vw0 = (3.0 - 2.0 * t);\n        float vw1 = (1.0 + 2.0 * t);\n        float v0 = (2.0 - t) / vw0 - 1.0;\n        float v1 = t / vw1 + 1.0;\n        u0 = u0 * shadowMapSizeInv + base_uv.x;\n        v0 = v0 * shadowMapSizeInv + base_uv.y;\n        u1 = u1 * shadowMapSizeInv + base_uv.x;\n        v1 = v1 * shadowMapSizeInv + base_uv.y;\n        sum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n        sum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n        sum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n        sum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n        sum *= 1.0f / 16.0;\n        return sum;\n    }\n    float getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n        return _getShadowPCF3x3(shadowMap, shadowParams);\n    }\n    float getShadowSpotPCF3x3(sampler2DShadow shadowMap, vec4 shadowParams) {\n        return _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n    }\n#else\n    float _xgetShadowPCF3x3(mat3 depthKernel, sampler2D shadowMap, vec3 shadowParams) {\n        mat3 shadowKernel;\n        vec3 shadowCoord = dShadowCoord;\n        vec3 shadowZ = vec3(shadowCoord.z);\n        shadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));\n        shadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));\n        shadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));\n        vec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );\n        shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n        shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n        vec4 shadowValues;\n        shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n        shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n        shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n        shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n        return dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n    }\n    float _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n        vec3 shadowCoord = dShadowCoord;\n        float xoffset = 1.0 / shadowParams.x; // 1/shadow map width\n        float dx0 = -xoffset;\n        float dx1 = xoffset;\n        mat3 depthKernel;\n        depthKernel[0][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));\n        depthKernel[0][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));\n        depthKernel[0][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));\n        depthKernel[1][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));\n        depthKernel[1][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy));\n        depthKernel[1][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));\n        depthKernel[2][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));\n        depthKernel[2][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));\n        depthKernel[2][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));\n        return _xgetShadowPCF3x3(depthKernel, shadowMap, shadowParams);\n    }\n    float getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n        return _getShadowPCF3x3(shadowMap, shadowParams);\n    }\n    float getShadowSpotPCF3x3(sampler2D shadowMap, vec4 shadowParams) {\n        return _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n    }\n#endif\n// ----- Point Sampling -----\nfloat _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {\n    vec3 tc = normalize(dir);\n    vec3 tcAbs = abs(tc);\n    vec4 dirX = vec4(1,0,0, tc.x);\n    vec4 dirY = vec4(0,1,0, tc.y);\n    float majorAxisLength = tc.z;\n    if ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {\n        dirX = vec4(0,0,1, tc.z);\n        dirY = vec4(0,1,0, tc.y);\n        majorAxisLength = tc.x;\n    } else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {\n        dirX = vec4(1,0,0, tc.x);\n        dirY = vec4(0,0,1, tc.z);\n        majorAxisLength = tc.y;\n    }\n    float shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);\n    vec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);\n    vec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);\n    vec3 dx0 = -xoffset;\n    vec3 dy0 = -yoffset;\n    vec3 dx1 = xoffset;\n    vec3 dy1 = yoffset;\n    mat3 shadowKernel;\n    mat3 depthKernel;\n    depthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));\n    depthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));\n    depthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));\n    depthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));\n    depthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));\n    depthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));\n    depthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));\n    depthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));\n    depthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));\n    vec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);\n    shadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));\n    shadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));\n    shadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));\n    vec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;\n    vec2 fractionalCoord = fract( uv * shadowParams.x );\n    shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n    shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n    vec4 shadowValues;\n    shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n    shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n    shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n    shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n    return 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat getShadowPointPCF3x3(samplerCube shadowMap, vec4 shadowParams) {\n    return _getShadowPoint(shadowMap, shadowParams, dLightDirW);\n}\n";
pc.shaderChunks.shadowStandardGL2PS = "float _getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n    // http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/\n    float z = dShadowCoord.z;\n    vec2 uv = dShadowCoord.xy * shadowParams.x; // 1 unit - 1 texel\n    float shadowMapSizeInv = 1.0 / shadowParams.x;\n    vec2 base_uv = floor(uv + 0.5);\n    float s = (uv.x + 0.5 - base_uv.x);\n    float t = (uv.y + 0.5 - base_uv.y);\n    base_uv -= vec2(0.5);\n    base_uv *= shadowMapSizeInv;\n    float uw0 = (4.0 - 3.0 * s);\n    float uw1 = 7.0;\n    float uw2 = (1.0 + 3.0 * s);\n    float u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n    float u1 = (3.0 + s) / uw1;\n    float u2 = s / uw2 + 2.0;\n    float vw0 = (4.0 - 3.0 * t);\n    float vw1 = 7.0;\n    float vw2 = (1.0 + 3.0 * t);\n    float v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n    float v1 = (3.0 + t) / vw1;\n    float v2 = t / vw2 + 2.0;\n    float sum = 0.0;\n    u0 = u0 * shadowMapSizeInv + base_uv.x;\n    v0 = v0 * shadowMapSizeInv + base_uv.y;\n    u1 = u1 * shadowMapSizeInv + base_uv.x;\n    v1 = v1 * shadowMapSizeInv + base_uv.y;\n    u2 = u2 * shadowMapSizeInv + base_uv.x;\n    v2 = v2 * shadowMapSizeInv + base_uv.y;\n    sum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n    sum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n    sum += uw2 * vw0 * texture(shadowMap, vec3(u2, v0, z));\n    sum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n    sum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n    sum += uw2 * vw1 * texture(shadowMap, vec3(u2, v1, z));\n    sum += uw0 * vw2 * texture(shadowMap, vec3(u0, v2, z));\n    sum += uw1 * vw2 * texture(shadowMap, vec3(u1, v2, z));\n    sum += uw2 * vw2 * texture(shadowMap, vec3(u2, v2, z));\n    sum *= 1.0f / 144.0;\n    sum = gammaCorrectInput(sum); // gives softer gradient\n    sum = saturate(sum);\n    return sum;\n}\nfloat getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n    return _getShadowPCF5x5(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF5x5(sampler2DShadow shadowMap, vec4 shadowParams) {\n    return _getShadowPCF5x5(shadowMap, shadowParams.xyz);\n}\n";
pc.shaderChunks.shadowStandardGL2VSPS = "float getShadowPCF5x5VS(sampler2DShadow shadowMap, vec3 shadowParams) {\n    dShadowCoord = vMainShadowUv.xyz;\n    dShadowCoord.z = saturate(dShadowCoord.z) - 0.0001; // prevent going to dark after the far plane\n    return _getShadowPCF5x5(shadowMap, shadowParams);\n}\n";
pc.shaderChunks.shadowStandardVSPS = "#ifdef GL2\n#define SHADOW_SAMPLERVS sampler2DShadow\n#else\n#define SHADOW_SAMPLERVS sampler2D\n#endif\nfloat getShadowPCF3x3VS(SHADOW_SAMPLERVS shadowMap, vec3 shadowParams) {\n    dShadowCoord = vMainShadowUv.xyz;\n    dShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n    #ifdef SHADOWBIAS\n        dShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n    #endif\n    return _getShadowPCF3x3(shadowMap, shadowParams);\n}\n";
pc.shaderChunks.shadowVSM8PS = "float calculateVSM8(vec3 moments, float Z, float vsmBias) {\n    float VSMBias = vsmBias;//0.01 * 0.25;\n    float depthScale = VSMBias * Z;\n    float minVariance1 = depthScale * depthScale;\n    return chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);\n}\nfloat decodeFloatRG(vec2 rg) {\n    return rg.y*(1.0/255.0) + rg.x;\n}\nfloat VSM8(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n    vec4 c = texture2D(tex, texCoords);\n    vec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);\n    return calculateVSM8(moments, Z, vsmBias);\n}\nfloat getShadowVSM8(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    return VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, 0.0);\n}\nfloat getShadowSpotVSM8(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n    return VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);\n}\n";
pc.shaderChunks.shadowVSMVSPS = "float getShadowVSM$VS(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    dShadowCoord = vMainShadowUv.xyz;\n    dShadowCoord.z += shadowParams.z;\n    dShadowCoord.xyz /= vMainShadowUv.w;\n    dShadowCoord.z = min(dShadowCoord.z, 1.0);\n    return $VSM(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\n";
pc.shaderChunks.shadowVSM_commonPS = "float linstep(float a, float b, float v) {\n    return saturate((v - a) / (b - a));\n}\nfloat reduceLightBleeding(float pMax, float amount) {\n  // Remove the [0, amount] tail and linearly rescale (amount, 1].\n   return linstep(amount, 1.0, pMax);\n}\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\n    // Compute variance\n    float variance = moments.y - (moments.x * moments.x);\n    variance = max(variance, minVariance);\n    // Compute probabilistic upper bound\n    float d = mean - moments.x;\n    float pMax = variance / (variance + (d * d));\n    pMax = reduceLightBleeding(pMax, lightBleedingReduction);\n    // One-tailed Chebyshev\n    return (mean <= moments.x ? 1.0 : pMax);\n}\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\n    Z = 2.0 * Z - 1.0;\n    float warpedDepth = exp(exponent * Z);\n    moments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\n    float VSMBias = vsmBias;//0.01 * 0.25;\n    float depthScale = VSMBias * exponent * warpedDepth;\n    float minVariance1 = depthScale * depthScale;\n    return chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\n}\n";
pc.shaderChunks.skinBatchConstVS = "attribute float vertex_boneIndices;\nuniform mat4 matrix_pose[BONE_LIMIT];\nmat4 getBoneMatrix(const in float i) {\n    mat4 bone = matrix_pose[int(i)];\n    return bone;\n}\n";
pc.shaderChunks.skinBatchTexVS = "attribute float vertex_boneIndices;\nuniform sampler2D texture_poseMap;\nuniform vec2 texture_poseMapSize;\nmat4 getBoneMatrix(const in float i) {\n    float j = i * 4.0;\n    float x = mod(j, float(texture_poseMapSize.x));\n    float y = floor(j / float(texture_poseMapSize.x));\n    float dx = 1.0 / float(texture_poseMapSize.x);\n    float dy = 1.0 / float(texture_poseMapSize.y);\n    y = dy * (y + 0.5);\n    vec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n    vec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n    vec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n    vec4 v4 = texture2D(texture_poseMap, vec2(dx * (x + 3.5), y));\n    mat4 bone = mat4(v1, v2, v3, v4);\n    return bone;\n}\n";
pc.shaderChunks.skinConstVS = "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform mat4 matrix_pose[BONE_LIMIT];\nmat4 getBoneMatrix(const in float i)\n{\n    mat4 bone = matrix_pose[int(i)];\n    return bone;\n}\n";
pc.shaderChunks.skinTexVS = "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform sampler2D texture_poseMap;\nuniform vec2 texture_poseMapSize;\nmat4 getBoneMatrix(const in float i)\n{\n    float j = i * 4.0;\n    float x = mod(j, float(texture_poseMapSize.x));\n    float y = floor(j / float(texture_poseMapSize.x));\n    float dx = 1.0 / float(texture_poseMapSize.x);\n    float dy = 1.0 / float(texture_poseMapSize.y);\n    y = dy * (y + 0.5);\n    vec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n    vec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n    vec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n    vec4 v4 = texture2D(texture_poseMap, vec2(dx * (x + 3.5), y));\n    mat4 bone = mat4(v1, v2, v3, v4);\n    return bone;\n}\n";
pc.shaderChunks.skyboxPS = "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvoid main(void) {\n    gl_FragColor = textureCube(texture_cubeMap, fixSeams(vViewDir));\n}\n";
pc.shaderChunks.skyboxVS = "attribute vec3 aPosition;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat4 matrix_projection;\nvarying vec3 vViewDir;\nvoid main(void)\n{\n    mat4 view = matrix_view;\n    view[3][0] = view[3][1] = view[3][2] = 0.0;\n    gl_Position = matrix_projection * view * vec4(aPosition, 1.0);\n    // Force skybox to far Z, regardless of the clip planes on the camera\n    // Subtract a tiny fudge factor to ensure floating point errors don't\n    // still push pixels beyond far Z. See:\n    // http://www.opengl.org/discussion_boards/showthread.php/171867-skybox-problem\n    gl_Position.z = gl_Position.w - 0.00001;\n    vViewDir = aPosition;\n    vViewDir.x *= -1.0;\n}\n";
pc.shaderChunks.skyboxHDRPS = "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvoid main(void) {\n    vec3 color = processEnvironment($textureCubeSAMPLE(texture_cubeMap, fixSeamsStatic(vViewDir, $FIXCONST)).rgb);\n    color = toneMap(color);\n    color = gammaCorrectOutput(color);\n    gl_FragColor = vec4(color, 1.0);\n}\n";
pc.shaderChunks.skyboxPrefilteredCubePS = "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvec3 fixSeamsStretch(vec3 vec, float mipmapIndex, float cubemapSize) {\n    float scale = 1.0 - exp2(mipmapIndex) / cubemapSize;\n    float M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n    if (abs(vec.x) != M) vec.x *= scale;\n    if (abs(vec.y) != M) vec.y *= scale;\n    if (abs(vec.z) != M) vec.z *= scale;\n    return vec;\n}\nvoid main(void) {\n    vec3 color = textureCubeRGBM(texture_cubeMap, fixSeamsStretch(vViewDir, 0.0, 128.0));\n    color = toneMap(color);\n    color = gammaCorrectOutput(color);\n    gl_FragColor = vec4(color, 1.0);\n}\n";
pc.shaderChunks.specularPS = "#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_specularMap;\n#endif\nvoid getSpecularity() {\n    dSpecularity = vec3(1.0);\n    #ifdef MAPCOLOR\n        dSpecularity *= material_specular;\n    #endif\n    #ifdef MAPTEXTURE\n        dSpecularity *= texture2D(texture_specularMap, $UV).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        dSpecularity *= saturate(vVertexColor.$VC);\n    #endif\n}\n";
pc.shaderChunks.specularAaNonePS = "float antiAliasGlossiness(float power) {\n    return power;\n}\n";
pc.shaderChunks.specularAaToksvigPS = "float antiAliasGlossiness(float power) {\n    float rlen = 1.0 / saturate(length(dNormalMap));\n    float toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n    return power * toksvig;\n}\n";
pc.shaderChunks.specularAaToksvigFloatPS = "float antiAliasGlossiness(float power) {\n    float rlen = 1.0 / saturate(length(dNormalMap));\n    float toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n    return power * mix(1.0, toksvig, material_bumpiness);\n}\n";
pc.shaderChunks.spotPS = "float getSpotEffect(vec3 lightSpotDirW, float lightInnerConeAngle, float lightOuterConeAngle) {\n    float cosAngle = dot(dLightDirNormW, lightSpotDirW);\n    return smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\n}\n";
pc.shaderChunks.startPS = "\nvoid main(void) {\n    dDiffuseLight = vec3(0);\n    dSpecularLight = vec3(0);\n    dReflection = vec4(0);\n    dSpecularity = vec3(0);\n";
pc.shaderChunks.startVS = "\nvoid main(void) {\n    gl_Position = getPosition();\n";
pc.shaderChunks.storeEVSMPS = "float exponent = VSM_EXPONENT;\ndepth = 2.0 * depth - 1.0;\ndepth =  exp(exponent * depth);\ngl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\n";
pc.shaderChunks.tangentBinormalVS = "\nvec3 getTangent() {\n    return normalize(dNormalMatrix * vertex_tangent.xyz);\n}\nvec3 getBinormal() {\n    return cross(vNormalW, vTangentW) * vertex_tangent.w;\n}\n";
pc.shaderChunks.tonemappingAcesPS = "uniform float exposure;\nvec3 toneMap(vec3 color) {\n    float tA = 2.51;\n    float tB = 0.03;\n    float tC = 2.43;\n    float tD = 0.59;\n    float tE = 0.14;\n    vec3 x = color * exposure;\n    return (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\n}\n";
pc.shaderChunks.tonemappingAces2PS = "uniform float exposure;\n// ACES approximation by Stephen Hill\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\nvec3 RRTAndODTFit(vec3 v) {\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\nvec3 toneMap(vec3 color) {\n    color *= exposure;\n    color = color * ACESInputMat;\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n    return color;\n}\n";
pc.shaderChunks.tonemappingFilmicPS = "const float A =  0.15;\nconst float B =  0.50;\nconst float C =  0.10;\nconst float D =  0.20;\nconst float E =  0.02;\nconst float F =  0.30;\nconst float W =  11.2;\nuniform float exposure;\nvec3 uncharted2Tonemap(vec3 x) {\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\nvec3 toneMap(vec3 color) {\n    color = uncharted2Tonemap(color * exposure);\n    vec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\n    color = color * whiteScale;\n    return color;\n}\n";
pc.shaderChunks.tonemappingHejlPS = "uniform float exposure;\nvec3 toneMap(vec3 color) {\n    color *= exposure;\n    const float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\n    const float Scl = 1.25;\n    vec3 h = max( vec3(0.0), color - vec3(0.004) );\n    return (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\n}\n";
pc.shaderChunks.tonemappingLinearPS = "uniform float exposure;\nvec3 toneMap(vec3 color) {\n    return color * exposure;\n}\n";
pc.shaderChunks.tonemappingNonePS = "vec3 toneMap(vec3 color) {\n    return color;\n}\n";
pc.shaderChunks.transformVS = "#ifdef PIXELSNAP\n    uniform vec4 uScreenSize;\n#endif\n#ifdef NINESLICED\n    #ifndef NINESLICE\n    #define NINESLICE\n    uniform vec4 innerOffset;\n    uniform vec2 outerScale;\n    uniform vec4 atlasRect;\n    varying vec2 vTiledUv;\n    #endif\n#endif\nmat4 getModelMatrix() {\n    #ifdef DYNAMICBATCH\n        return getBoneMatrix(vertex_boneIndices);\n    #elif defined(SKIN)\n        return matrix_model * (getBoneMatrix(vertex_boneIndices.x) * vertex_boneWeights.x +\n               getBoneMatrix(vertex_boneIndices.y) * vertex_boneWeights.y +\n               getBoneMatrix(vertex_boneIndices.z) * vertex_boneWeights.z +\n               getBoneMatrix(vertex_boneIndices.w) * vertex_boneWeights.w);\n    #elif defined(INSTANCING)\n        return mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n    #else\n        return matrix_model;\n    #endif\n}\nvec4 getPosition() {\n    dModelMatrix = getModelMatrix();\n    vec3 localPos = vertex_position;\n    #ifdef NINESLICED\n        // outer and inner vertices are at the same position, scale both\n        localPos.xz *= outerScale;\n        // offset inner vertices inside\n        // (original vertices must be in [-1;1] range)\n        vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n        vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n        localPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n        vTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0; // uv = local pos - inner corner\n        localPos.xz *= -0.5; // move from -1;1 to -0.5;0.5\n        localPos = localPos.xzy;\n    #endif\n    vec4 posW = dModelMatrix * vec4(localPos, 1.0);\n    #ifdef SCREENSPACE\n        posW.zw = vec2(0.0, 1.0);\n    #endif\n    dPositionW = posW.xyz;\n    vec4 screenPos;\n    #ifdef UV1LAYOUT\n        screenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n    #else\n        #ifdef SCREENSPACE\n            screenPos = posW;\n        #else\n            screenPos = matrix_viewProjection * posW;\n        #endif\n        #ifdef PIXELSNAP\n            // snap vertex to a pixel boundary\n            screenPos.xy = (screenPos.xy * 0.5) + 0.5;\n            screenPos.xy *= uScreenSize.xy;\n            screenPos.xy = floor(screenPos.xy);\n            screenPos.xy *= uScreenSize.zw;\n            screenPos.xy = (screenPos.xy * 2.0) - 1.0;\n        #endif\n    #endif\n    return screenPos;\n}\nvec3 getWorldPosition() {\n    return dPositionW;\n}\n";
pc.shaderChunks.transformDeclVS = "attribute vec3 vertex_position;\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\nvec3 dPositionW;\nmat4 dModelMatrix;\n";
pc.shaderChunks.uv0VS = "\nvec2 getUv0() {\n    return vertex_texCoord0;\n}\n";
pc.shaderChunks.uv1VS = "\nvec2 getUv1() {\n    return vertex_texCoord1;\n}\n";
pc.shaderChunks.uv9SliceVS = "#ifndef NINESLICE\n#define NINESLICE\nuniform vec4 innerOffset;\nuniform vec2 outerScale;\nuniform vec4 atlasRect;\nvarying vec2 vTiledUv;\n#endif\nvarying vec2 vMask;\nvec2 getUv0() {\n    vec2 uv = vertex_position.xz;\n    // offset inner vertices inside\n    // (original vertices must be in [-1;1] range)\n    vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n    vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n    uv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n    uv = uv * -0.5 + 0.5;\n    uv = uv * atlasRect.zw + atlasRect.xy;\n    vMask = vertex_texCoord0.xy;\n    return uv;\n}\n";
pc.shaderChunks.viewDirPS = "void getViewDir() {\n    dViewDirW = normalize(view_position - vPositionW);\n}\n";
pc.shaderChunks.viewNormalVS = "\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nvec3 getViewNormal() {\n    return mat3(matrix_view) * vNormalW;\n}\n";
pc.programlib = {gammaCode:function(value) {
  if (value === pc.GAMMA_SRGB || value === pc.GAMMA_SRGBFAST) {
    return pc.shaderChunks.gamma2_2PS;
  } else {
    if (value === pc.GAMMA_SRGBHDR) {
      return "#define HDR\n" + pc.shaderChunks.gamma2_2PS;
    }
  }
  return pc.shaderChunks.gamma1_0PS;
}, tonemapCode:function(value) {
  if (value === pc.TONEMAP_FILMIC) {
    return pc.shaderChunks.tonemappingFilmicPS;
  } else {
    if (value === pc.TONEMAP_LINEAR) {
      return pc.shaderChunks.tonemappingLinearPS;
    } else {
      if (value === pc.TONEMAP_HEJL) {
        return pc.shaderChunks.tonemappingHejlPS;
      } else {
        if (value === pc.TONEMAP_ACES) {
          return pc.shaderChunks.tonemappingAcesPS;
        } else {
          if (value === pc.TONEMAP_ACES2) {
            return pc.shaderChunks.tonemappingAces2PS;
          }
        }
      }
    }
  }
  return pc.shaderChunks.tonemappingNonePS;
}, fogCode:function(value) {
  if (value === "linear") {
    return pc.shaderChunks.fogLinearPS;
  } else {
    if (value === "exp") {
      return pc.shaderChunks.fogExpPS;
    } else {
      if (value === "exp2") {
        return pc.shaderChunks.fogExp2PS;
      }
    }
  }
  return pc.shaderChunks.fogNonePS;
}, skinCode:function(device, chunks) {
  if (!chunks) {
    chunks = pc.shaderChunks;
  }
  if (device.supportsBoneTextures) {
    return chunks.skinTexVS;
  }
  return "#define BONE_LIMIT " + device.getBoneLimit() + "\n" + chunks.skinConstVS;
}, precisionCode:function(device) {
  var pcode = "precision " + device.precision + " float;\n";
  if (device.webgl2) {
    pcode += "#ifdef GL2\nprecision " + device.precision + " sampler2DShadow;\n#endif\n";
  }
  return pcode;
}, versionCode:function(device) {
  return device.webgl2 ? "#version 300 es\n" : "";
}, dummyFragmentCode:function() {
  return "void main(void) {gl_FragColor = vec4(0.0);}";
}, begin:function() {
  return "void main(void)\n{\n";
}, end:function() {
  return "}\n";
}};
pc.programlib.basic = {generateKey:function(device, options) {
  var key = "basic";
  if (options.fog) {
    key += "_fog";
  }
  if (options.alphaTest) {
    key += "_atst";
  }
  if (options.vertexColors) {
    key += "_vcol";
  }
  if (options.diffuseMap) {
    key += "_diff";
  }
  key += "_" + options.pass;
  return key;
}, createShaderDefinition:function(device, options) {
  var attributes = {vertex_position:pc.SEMANTIC_POSITION};
  if (options.skin) {
    attributes.vertex_boneWeights = pc.SEMANTIC_BLENDWEIGHT;
    attributes.vertex_boneIndices = pc.SEMANTIC_BLENDINDICES;
  }
  if (options.vertexColors) {
    attributes.vertex_color = pc.SEMANTIC_COLOR;
  }
  if (options.diffuseMap) {
    attributes.vertex_texCoord0 = pc.SEMANTIC_TEXCOORD0;
  }
  var chunks = pc.shaderChunks;
  var code = "";
  code += chunks.transformDeclVS;
  if (options.skin) {
    code += pc.programlib.skinCode(device);
    code += chunks.transformSkinnedVS;
  } else {
    code += chunks.transformVS;
  }
  if (options.vertexColors) {
    code += "attribute vec4 vertex_color;\n";
    code += "varying vec4 vColor;\n";
  }
  if (options.diffuseMap) {
    code += "attribute vec2 vertex_texCoord0;\n";
    code += "varying vec2 vUv0;\n";
  }
  if (options.pass === pc.SHADER_DEPTH) {
    code += "varying float vDepth;\n";
    code += "#ifndef VIEWMATRIX\n";
    code += "#define VIEWMATRIX\n";
    code += "uniform mat4 matrix_view;\n";
    code += "#endif\n";
    code += "#ifndef CAMERAPLANES\n";
    code += "#define CAMERAPLANES\n";
    code += "uniform vec4 camera_params;\n\n";
    code += "#endif\n";
  }
  code += pc.programlib.begin();
  code += "   gl_Position = getPosition();\n";
  if (options.pass === pc.SHADER_DEPTH) {
    code += "    vDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;\n";
  }
  if (options.vertexColors) {
    code += "    vColor = vertex_color;\n";
  }
  if (options.diffuseMap) {
    code += "    vUv0 = vertex_texCoord0;\n";
  }
  code += pc.programlib.end();
  var vshader = code;
  code = pc.programlib.precisionCode(device);
  if (options.vertexColors) {
    code += "varying vec4 vColor;\n";
  } else {
    code += "uniform vec4 uColor;\n";
  }
  if (options.diffuseMap) {
    code += "varying vec2 vUv0;\n";
    code += "uniform sampler2D texture_diffuseMap;\n";
  }
  if (options.fog) {
    code += pc.programlib.fogCode(options.fog);
  }
  if (options.alphatest) {
    code += chunks.alphaTestPS;
  }
  if (options.pass === pc.SHADER_DEPTH) {
    code += "varying float vDepth;\n";
    code += chunks.packDepthPS;
  }
  code += pc.programlib.begin();
  if (options.vertexColors) {
    code += "    gl_FragColor = vColor;\n";
  } else {
    code += "    gl_FragColor = uColor;\n";
  }
  if (options.diffuseMap) {
    code += "    gl_FragColor *= texture2D(texture_diffuseMap, vUv0);\n";
  }
  if (options.alphatest) {
    code += "   alphaTest(gl_FragColor.a);\n";
  }
  if (options.pass === pc.SHADER_PICK) {
  } else {
    if (options.pass === pc.SHADER_DEPTH) {
      code += "    gl_FragColor = packFloat(vDepth);\n";
    } else {
      if (options.fog) {
        code += "   glFragColor.rgb = addFog(gl_FragColor.rgb);\n";
      }
    }
  }
  code += pc.programlib.end();
  var fshader = code;
  return {attributes:attributes, vshader:vshader, fshader:fshader};
}};
pc.programlib.particle = {generateKey:function(device, options) {
  var key = "particle";
  for (var prop in options) {
    if (options.hasOwnProperty(prop)) {
      key += options[prop];
    }
  }
  return key;
}, _animTex:function(options, chunk) {
  var vshader = "";
  vshader += options.animTexLoop ? chunk.particleAnimFrameLoopVS : chunk.particleAnimFrameClampVS;
  vshader += chunk.particleAnimTexVS;
  return vshader;
}, createShaderDefinition:function(device, options) {
  var chunk = pc.shaderChunks;
  var vshader = "";
  var fshader = pc.programlib.precisionCode(device) + "\n";
  if (device.webgl2) {
    vshader += "#define GL2\n";
    fshader += "#define GL2\n";
  }
  vshader += "#define VERTEXSHADER\n";
  if (options.animTex) {
    vshader += "\nuniform vec4 animTexParams;\n";
  }
  if (options.normal == 2) {
    vshader += "\nvarying mat3 ParticleMat;\n";
  }
  if (options.normal == 1) {
    vshader += "\nvarying vec3 Normal;\n";
  }
  if (options.soft) {
    vshader += "\nvarying float vDepth;\n";
  }
  if (!options.useCpu) {
    vshader += chunk.particle_initVS;
    vshader += options.pack8 ? chunk.particleInputRgba8PS : chunk.particleInputFloatPS;
    if (options.soft > 0) {
      vshader += chunk.screenDepthPS;
    }
    vshader += chunk.particleVS;
    if (options.localSpace) {
      vshader += chunk.particle_localShiftVS;
    }
    if (options.animTex) {
      vshader += this._animTex(options, chunk);
    }
    if (options.wrap) {
      vshader += chunk.particle_wrapVS;
    }
    if (options.alignToMotion) {
      vshader += chunk.particle_pointAlongVS;
    }
    vshader += options.mesh ? chunk.particle_meshVS : chunk.particle_billboardVS;
    if (options.normal == 1) {
      vshader += chunk.particle_normalVS;
    }
    if (options.normal == 2) {
      vshader += chunk.particle_TBNVS;
    }
    if (options.stretch > 0.0) {
      vshader += chunk.particle_stretchVS;
    }
    vshader += chunk.particle_endVS;
    if (options.soft > 0) {
      vshader += chunk.particle_softVS;
    }
  } else {
    if (options.soft > 0) {
      vshader += chunk.screenDepthPS;
    }
    vshader += chunk.particle_cpuVS;
    if (options.localSpace) {
      vshader += chunk.particle_localShiftVS;
    }
    if (options.animTex) {
      vshader += this._animTex(options, chunk);
    }
    if (options.alignToMotion) {
      vshader += chunk.particle_pointAlongVS;
    }
    vshader += options.mesh ? chunk.particle_meshVS : chunk.particle_billboardVS;
    if (options.normal == 1) {
      vshader += chunk.particle_normalVS;
    }
    if (options.normal == 2) {
      vshader += chunk.particle_TBNVS;
    }
    if (options.stretch > 0.0) {
      vshader += chunk.particle_stretchVS;
    }
    vshader += chunk.particle_cpu_endVS;
    if (options.soft > 0) {
      vshader += chunk.particle_softVS;
    }
  }
  vshader += "}\n";
  if (options.normal > 0) {
    if (options.normal == 1) {
      fshader += "\nvarying vec3 Normal;\n";
    } else {
      if (options.normal == 2) {
        fshader += "\nvarying mat3 ParticleMat;\n";
      }
    }
    fshader += "\nuniform vec3 lightCube[6];\n";
  }
  if (options.soft) {
    fshader += "\nvarying float vDepth;\n";
  }
  if (options.normal === 0 && options.fog === "none") {
    options.srgb = false;
  }
  fshader += pc.programlib.gammaCode(options.gamma);
  fshader += pc.programlib.tonemapCode(options.toneMap);
  if (options.fog === "linear") {
    fshader += chunk.fogLinearPS;
  } else {
    if (options.fog === "exp") {
      fshader += chunk.fogExpPS;
    } else {
      if (options.fog === "exp2") {
        fshader += chunk.fogExp2PS;
      } else {
        fshader += chunk.fogNonePS;
      }
    }
  }
  if (options.normal == 2) {
    fshader += "\nuniform sampler2D normalMap;\n";
  }
  if (options.soft > 0) {
    fshader += chunk.screenDepthPS;
  }
  fshader += chunk.particlePS;
  if (options.soft > 0) {
    fshader += chunk.particle_softPS;
  }
  if (options.normal == 1) {
    fshader += "\nvec3 normal = Normal;\n";
  }
  if (options.normal == 2) {
    fshader += chunk.particle_normalMapPS;
  }
  if (options.normal > 0) {
    fshader += options.halflambert ? chunk.particle_halflambertPS : chunk.particle_lambertPS;
  }
  if (options.normal > 0) {
    fshader += chunk.particle_lightingPS;
  }
  if (options.blend == pc.BLEND_NORMAL) {
    fshader += chunk.particle_blendNormalPS;
  } else {
    if (options.blend == pc.BLEND_ADDITIVE) {
      fshader += chunk.particle_blendAddPS;
    } else {
      if (options.blend == pc.BLEND_MULTIPLICATIVE) {
        fshader += chunk.particle_blendMultiplyPS;
      }
    }
  }
  fshader += chunk.particle_endPS;
  var attributes = pc.shaderChunks.collectAttribs(vshader);
  return {attributes:attributes, vshader:vshader, fshader:fshader};
}};
var _oldChunkWarn = function(oldName, newName) {
};
var _oldChunkFloat = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef MAPFLOAT\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkColor = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef MAPCOLOR\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTex = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef MAPTEXTURE\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTexColor = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "#undef MAPTEXTURECOLOR\n#ifdef MAPTEXTURE\n#ifdef MAPCOLOR\n#define MAPTEXTURECOLOR\n#endif\n#endif\n" + "#ifdef MAPTEXTURECOLOR\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTexFloat = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "#undef MAPTEXTUREFLOAT\n#ifdef MAPTEXTURE\n#ifdef MAPFLOAT\n#define MAPTEXTUREFLOAT\n#endif\n#endif\n" + "#ifdef MAPTEXTUREFLOAT\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkVert = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef MAPVERTEX\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkVertColor = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "#undef MAPVERTEXCOLOR\n#ifdef MAPVERTEX\n#ifdef MAPCOLOR\n#define MAPVERTEXCOLOR\n#endif\n#endif\n" + "#ifdef MAPVERTEXCOLOR\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkVertFloat = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "#undef MAPVERTEXFLOAT\n#ifdef MAPVERTEX\n#ifdef MAPFLOAT\n#define MAPVERTEXFLOAT\n#endif\n#endif\n" + "#ifdef MAPVERTEXFLOAT\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTransformSkin = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef SKIN\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTransformDynbatch = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef DYNAMICBATCH\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTransformInstanced = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef INSTANCING\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTransformPixelSnap = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef PIXELSNAP\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTransformScreenSpace = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef SCREENSPACE\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTransformScreenSpaceBatch = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "#undef SCREENSPACEBATCH\n#ifdef SCREENSPACE\n#ifdef BATCH\n#define SCREENSPACEBATCH\n#endif\n#endif\n" + "#ifdef SCREENSPACEBATCH\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTransformUv1 = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef UV1LAYOUT\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
pc.programlib.standard = {_oldChunkToNew:{aoTexPS:{n:"aoPS", f:_oldChunkTex}, aoVertPS:{n:"aoPS", f:_oldChunkVert}, diffuseConstPS:{n:"diffusePS", f:_oldChunkColor}, diffuseTexPS:{n:"diffusePS", f:_oldChunkTex}, diffuseTexConstPS:{n:"diffusePS", f:_oldChunkTexColor}, diffuseVertPS:{n:"diffusePS", f:_oldChunkVert}, diffuseVertConstPS:{n:"diffusePS", f:_oldChunkVertColor}, emissiveConstPS:{n:"emissivePS", f:_oldChunkColor}, emissiveTexPS:{n:"emissivePS", f:_oldChunkTex}, emissiveTexConstPS:{n:"emissivePS", 
f:_oldChunkTexColor}, emissiveTexConstFloatPS:{n:"emissivePS", f:_oldChunkTexFloat}, emissiveVertPS:{n:"emissivePS", f:_oldChunkVert}, emissiveVertConstPS:{n:"emissivePS", f:_oldChunkVertColor}, emissiveVertConstFloatPS:{n:"emissivePS", f:_oldChunkVertFloat}, glossConstPS:{n:"glossPS", f:_oldChunkFloat}, glossTexPS:{n:"glossPS", f:_oldChunkTex}, glossTexConstPS:{n:"glossPS", f:_oldChunkTexFloat}, glossVertPS:{n:"glossPS", f:_oldChunkVert}, glossVertConstPS:{n:"glossPS", f:_oldChunkVertFloat}, metalnessConstPS:{n:"metalnessPS", 
f:_oldChunkFloat}, metalnessTexPS:{n:"metalnessPS", f:_oldChunkTex}, metalnessTexConstPS:{n:"metalnessPS", f:_oldChunkTexFloat}, metalnessVertPS:{n:"metalnessPS", f:_oldChunkVert}, metalnessVertConstPS:{n:"metalnessPS", f:_oldChunkVertFloat}, opacityConstPS:{n:"opacityPS", f:_oldChunkFloat}, opacityTexPS:{n:"opacityPS", f:_oldChunkTex}, opacityTexConstPS:{n:"opacityPS", f:_oldChunkTexFloat}, opacityVertPS:{n:"opacityPS", f:_oldChunkVert}, opacityVertConstPS:{n:"opacityPS", f:_oldChunkVertFloat}, 
specularConstPS:{n:"specularPS", f:_oldChunkColor}, specularTexPS:{n:"specularPS", f:_oldChunkTex}, specularTexConstPS:{n:"specularPS", f:_oldChunkTexColor}, specularVertPS:{n:"specularPS", f:_oldChunkVert}, specularVertConstPS:{n:"specularPS", f:_oldChunkVertColor}, transformBatchSkinnedVS:{n:"transformVS", f:_oldChunkTransformDynbatch}, transformInstancedVS:{n:"transformVS", f:_oldChunkTransformInstanced}, transformPixelSnapVS:{n:"transformVS", f:_oldChunkTransformPixelSnap}, transformScreenSpaceVS:{n:"transformVS", 
f:_oldChunkTransformScreenSpace}, transformScreenSpaceBatchSkinned:{n:"transformVS", f:_oldChunkTransformScreenSpaceBatch}, transformSkinned:{n:"transformVS", f:_oldChunkTransformSkin}, transformUv1:{n:"transformVS", f:_oldChunkTransformUv1}}, generateKey:function(device, options) {
  var prop, props = [];
  var key = "standard";
  var light;
  for (prop in options) {
    if (options.hasOwnProperty(prop)) {
      if (prop === "chunks") {
        for (var p in options[prop]) {
          if (options[prop].hasOwnProperty(p)) {
            props.push(p + options.chunks[p]);
          }
        }
      } else {
        if (options[prop]) {
          props.push(prop);
        }
      }
    }
  }
  props.sort();
  for (prop in props) {
    if (props.hasOwnProperty(prop)) {
      key += props[prop] + options[props[prop]];
    }
  }
  if (options.lights) {
    for (var i = 0;i < options.lights.length;i++) {
      light = options.lights[i];
      key += light.key;
    }
  }
  return pc.hashCode(key);
}, _correctChannel:function(p, chan) {
  if (pc._matTex2D[p] > 0) {
    if (pc._matTex2D[p] < chan.length) {
      return chan.substring(0, pc._matTex2D[p]);
    } else {
      if (pc._matTex2D[p] > chan.length) {
        var str = chan;
        var chr = str.charAt(str.length - 1);
        var addLen = pc._matTex2D[p] - str.length;
        for (var i = 0;i < addLen;i++) {
          str += chr;
        }
        return str;
      }
    }
    return chan;
  }
}, _setMapTransform:function(codes, name, id, uv) {
  codes[0] += "uniform vec4 texture_" + name + "MapTransform;\n";
  var checkId = id + uv * 100;
  if (!codes[3][checkId]) {
    codes[1] += "varying vec2 vUV" + uv + "_" + id + ";\n";
    codes[2] += "   vUV" + uv + "_" + id + " = uv" + uv + " * texture_" + name + "MapTransform.xy + texture_" + name + "MapTransform.zw;\n";
    codes[3][checkId] = true;
  }
  return codes;
}, _uvSource:function(id, uv) {
  return id === 0 ? "vUv" + uv : "vUV" + uv + "_" + id;
}, _addMapDef:function(name, enabled) {
  var s = "\n#undef " + name + "\n";
  if (enabled) {
    s += " #define " + name + "\n";
  }
  return s;
}, _addMapDefs:function(float, color, vertex, map) {
  var s = "";
  s += this._addMapDef("MAPFLOAT", float);
  s += this._addMapDef("MAPCOLOR", color);
  s += this._addMapDef("MAPVERTEX", vertex);
  s += this._addMapDef("MAPTEXTURE", map);
  return s;
}, _addMap:function(p, options, chunks, uvOffset, subCode, format) {
  var mname = p + "Map";
  var tint = options[p + "Tint"];
  var vert = options[p + "VertexColor"];
  var tex = options[mname];
  if (!subCode) {
    subCode = chunks[p + "PS"];
  }
  if (tex) {
    var uname = mname + "Uv";
    var tname = mname + "Transform";
    var cname = mname + "Channel";
    var uv = this._uvSource(options[tname], options[uname]) + uvOffset;
    subCode = subCode.replace(/\$UV/g, uv).replace(/\$CH/g, options[cname]);
    if (format !== undefined) {
      var fmt = format === 0 ? "texture2DSRGB" : format === 1 ? "texture2DRGBM" : "texture2D";
      subCode = subCode.replace(/\$texture2DSAMPLE/g, fmt);
    }
  }
  if (vert) {
    var vcname = p + "VertexColorChannel";
    subCode = subCode.replace(/\$VC/g, options[vcname]);
  }
  subCode = this._addMapDefs(tint === 1, tint === 3, vert, tex) + subCode;
  return subCode.replace(/\$/g, "");
}, _nonPointShadowMapProjection:function(device, light, shadowCoordArgs) {
  if (!light._normalOffsetBias || light._isVsm) {
    if (light._type === pc.LIGHTTYPE_SPOT) {
      if (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {
        return "       getShadowCoordPerspZbuffer" + shadowCoordArgs;
      }
      return "       getShadowCoordPersp" + shadowCoordArgs;
    }
    return "       getShadowCoordOrtho" + shadowCoordArgs;
  }
  if (light._type === pc.LIGHTTYPE_SPOT) {
    if (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {
      return "       getShadowCoordPerspZbufferNormalOffset" + shadowCoordArgs;
    }
    return "       getShadowCoordPerspNormalOffset" + shadowCoordArgs;
  }
  return "       getShadowCoordOrthoNormalOffset" + shadowCoordArgs;
}, _addVaryingIfNeeded:function(code, type, name) {
  return code.indexOf(name) >= 0 ? "varying " + type + " " + name + ";\n" : "";
}, createShaderDefinition:function(device, options) {
  var i, p;
  var lighting = options.lights.length > 0;
  if (options.dirLightMap) {
    lighting = true;
    options.useSpecular = true;
  }
  if (options.shadingModel === pc.SPECULAR_PHONG) {
    options.fresnelModel = 0;
    options.specularAntialias = false;
    options.prefilteredCubemap = false;
    options.dpAtlas = false;
    options.ambientSH = false;
  } else {
    options.fresnelModel = options.fresnelModel === 0 ? pc.FRESNEL_SCHLICK : options.fresnelModel;
  }
  var cubemapReflection = (options.cubeMap || options.prefilteredCubemap && options.useSpecular) && !options.sphereMap && !options.dpAtlas;
  var reflections = options.sphereMap || cubemapReflection || options.dpAtlas;
  var useTangents = pc.precalculatedTangents;
  var useTexCubeLod = options.useTexCubeLod;
  if (options.cubeMap) {
    options.sphereMap = null;
  }
  if (options.dpAtlas) {
    options.prefilteredCubemap = null;
  }
  if (!options.useSpecular) {
    options.specularMap = options.glossMap = null;
  }
  var needsNormal = lighting || reflections || options.ambientSH || options.prefilteredCubemap || options.heightMap;
  var shadowPass = options.pass >= pc.SHADER_SHADOW && options.pass <= 17;
  this.options = options;
  var code = "";
  var codeBody = "";
  var varyings = "";
  var chunks = pc.shaderChunks;
  var lightType;
  var shadowCoordArgs;
  var chunk;
  var attributes = {vertex_position:pc.SEMANTIC_POSITION};
  if (options.chunks) {
    var customChunks = {};
    var newP;
    for (p in chunks) {
      if (chunks.hasOwnProperty(p)) {
        if (!options.chunks[p]) {
          customChunks[p] = chunks[p];
        } else {
          chunk = options.chunks[p];
          if (chunk.indexOf("vertex_normal") >= 0) {
            attributes.vertex_normal = pc.SEMANTIC_NORMAL;
          }
          if (chunk.indexOf("vertex_tangent") >= 0) {
            attributes.vertex_tangent = pc.SEMANTIC_TANGENT;
          }
          if (chunk.indexOf("vertex_texCoord0") >= 0) {
            attributes.vertex_texCoord0 = pc.SEMANTIC_TEXCOORD0;
          }
          if (chunk.indexOf("vertex_texCoord1") >= 0) {
            attributes.vertex_texCoord1 = pc.SEMANTIC_TEXCOORD1;
          }
          if (chunk.indexOf("vertex_color") >= 0) {
            attributes.vertex_color = pc.SEMANTIC_COLOR;
          }
          if (chunk.indexOf("vertex_boneWeights") >= 0) {
            attributes.vertex_boneWeights = pc.SEMANTIC_BLENDWEIGHT;
          }
          if (chunk.indexOf("vertex_boneIndices") >= 0) {
            attributes.vertex_boneIndices = pc.SEMANTIC_BLENDINDICES;
          }
          customChunks[p] = chunk;
        }
      }
    }
    for (p in options.chunks) {
      newP = this._oldChunkToNew[p];
      if (newP) {
        customChunks[newP.n] = newP.f(options.chunks[p], newP.n, p);
      }
    }
    chunks = customChunks;
  }
  code += chunks.baseVS;
  var mainShadowLight = -1;
  if (!options.noShadow && !options.twoSidedLighting) {
    for (i = 0;i < options.lights.length;i++) {
      lightType = options.lights[i]._type;
      if (options.lights[i].castShadows) {
        if (lightType === pc.LIGHTTYPE_DIRECTIONAL) {
          code += "uniform mat4 light" + i + "_shadowMatrixVS;\n";
          code += "uniform vec3 light" + i + "_shadowParamsVS;\n";
          code += "uniform vec3 light" + i + (lightType === pc.LIGHTTYPE_DIRECTIONAL ? "_directionVS" : "_positionVS") + ";\n";
          mainShadowLight = i;
          break;
        }
      }
    }
    if (mainShadowLight >= 0) {
      code += chunks.shadowCoordVS;
    }
  }
  codeBody += "   vPositionW    = getWorldPosition();\n";
  if (options.pass === pc.SHADER_DEPTH) {
    code += "varying float vDepth;\n";
    code += "#ifndef VIEWMATRIX\n";
    code += "#define VIEWMATRIX\n";
    code += "uniform mat4 matrix_view;\n";
    code += "#endif\n";
    code += "#ifndef CAMERAPLANES\n";
    code += "#define CAMERAPLANES\n";
    code += "uniform vec4 camera_params;\n\n";
    code += "#endif\n";
    codeBody += "    vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n";
  }
  if (options.useInstancing) {
    attributes.instance_line1 = pc.SEMANTIC_TEXCOORD2;
    attributes.instance_line2 = pc.SEMANTIC_TEXCOORD3;
    attributes.instance_line3 = pc.SEMANTIC_TEXCOORD4;
    attributes.instance_line4 = pc.SEMANTIC_TEXCOORD5;
    code += chunks.instancingVS;
  }
  if (needsNormal) {
    attributes.vertex_normal = pc.SEMANTIC_NORMAL;
    codeBody += "   vNormalW    = dNormalW = getNormal();\n";
    if (options.sphereMap && device.fragmentUniformsCount <= 16) {
      code += chunks.viewNormalVS;
      codeBody += "   vNormalV    = getViewNormal();\n";
    }
    if ((options.heightMap || options.normalMap) && useTangents) {
      attributes.vertex_tangent = pc.SEMANTIC_TANGENT;
      code += chunks.tangentBinormalVS;
      codeBody += "   vTangentW   = getTangent();\n";
      codeBody += "   vBinormalW  = getBinormal();\n";
    }
    if (mainShadowLight >= 0) {
      lightType = options.lights[mainShadowLight]._type;
      if (lightType === pc.LIGHTTYPE_DIRECTIONAL) {
        codeBody += "   dLightDirNormW = light" + mainShadowLight + "_directionVS;\n";
      } else {
        codeBody += "   getLightDirPoint(light" + mainShadowLight + "_positionVS);\n";
      }
      shadowCoordArgs = "(light" + mainShadowLight + "_shadowMatrixVS, light" + mainShadowLight + "_shadowParamsVS);\n";
      codeBody += this._nonPointShadowMapProjection(device, options.lights[mainShadowLight], shadowCoordArgs);
    }
  }
  var useUv = [];
  var useUnmodifiedUv = [];
  var maxUvSets = 2;
  var cname, mname, tname, uname;
  for (p in pc._matTex2D) {
    mname = p + "Map";
    if (options[p + "VertexColor"]) {
      cname = p + "VertexColorChannel";
      options[cname] = this._correctChannel(p, options[cname]);
    }
    if (options[mname]) {
      cname = mname + "Channel";
      tname = mname + "Transform";
      uname = mname + "Uv";
      options[uname] = Math.min(options[uname], maxUvSets - 1);
      options[cname] = this._correctChannel(p, options[cname]);
      var uvSet = options[uname];
      useUv[uvSet] = true;
      useUnmodifiedUv[uvSet] = useUnmodifiedUv[uvSet] || options[mname] && !options[tname];
    }
  }
  if (options.forceUv1) {
    useUv[1] = true;
  }
  for (i = 0;i < maxUvSets;i++) {
    if (useUv[i]) {
      attributes["vertex_texCoord" + i] = pc["SEMANTIC_TEXCOORD" + i];
      code += chunks["uv" + i + "VS"];
      codeBody += "   vec2 uv" + i + " = getUv" + i + "();\n";
    }
    if (useUnmodifiedUv[i]) {
      codeBody += "   vUv" + i + " = uv" + i + ";\n";
    }
  }
  var codes = [code, varyings, codeBody, []];
  for (p in pc._matTex2D) {
    mname = p + "Map";
    if (options[mname]) {
      tname = mname + "Transform";
      if (options[tname]) {
        uname = mname + "Uv";
        this._setMapTransform(codes, p, options[tname], options[uname]);
      }
    }
  }
  code = codes[0];
  varyings = codes[1];
  codeBody = codes[2];
  if (options.vertexColors) {
    attributes.vertex_color = pc.SEMANTIC_COLOR;
    codeBody += "   vVertexColor = vertex_color;\n";
  }
  if (options.skin) {
    attributes.vertex_boneWeights = pc.SEMANTIC_BLENDWEIGHT;
    attributes.vertex_boneIndices = pc.SEMANTIC_BLENDINDICES;
    code += pc.programlib.skinCode(device, chunks);
    code += "#define SKIN\n";
  } else {
    if (options.useInstancing) {
      code += "#define INSTANCING\n";
    }
  }
  if (options.screenSpace) {
    code += "#define SCREENSPACE\n";
  }
  if (options.pixelSnap) {
    code += "#define PIXELSNAP\n";
  }
  code += chunks.transformVS;
  if (needsNormal) {
    code += chunks.normalVS;
  }
  code += "\n";
  code += chunks.startVS;
  code += codeBody;
  code += "}";
  var vshader = code;
  var oldVars = varyings;
  varyings = "";
  varyings += this._addVaryingIfNeeded(code, "vec4", "vMainShadowUv");
  varyings += this._addVaryingIfNeeded(code, "vec4", "vVertexColor");
  varyings += this._addVaryingIfNeeded(code, "vec3", "vPositionW");
  varyings += this._addVaryingIfNeeded(code, "vec3", "vNormalV");
  varyings += this._addVaryingIfNeeded(code, "vec3", "vNormalW");
  varyings += this._addVaryingIfNeeded(code, "vec3", "vTangentW");
  varyings += this._addVaryingIfNeeded(code, "vec3", "vBinormalW");
  varyings += this._addVaryingIfNeeded(code, "vec2", "vUv0");
  varyings += this._addVaryingIfNeeded(code, "vec2", "vUv1");
  varyings += oldVars;
  vshader = varyings + vshader;
  var startCode = "";
  if (device.webgl2) {
    startCode = pc.programlib.versionCode(device);
    if (chunks.extensionVS) {
      startCode += chunks.extensionVS + "\n";
    }
    vshader = startCode + chunks.gles3VS + vshader;
  } else {
    if (chunks.extensionVS) {
      startCode = chunks.extensionVS + "\n";
    }
    vshader = startCode + vshader;
  }
  if (options.forceFragmentPrecision && options.forceFragmentPrecision != "highp" && options.forceFragmentPrecision !== "mediump" && options.forceFragmentPrecision !== "lowp") {
    options.forceFragmentPrecision = null;
  }
  if (options.forceFragmentPrecision) {
    if (options.forceFragmentPrecision === "highp" && device.maxPrecision !== "highp") {
      options.forceFragmentPrecision = "mediump";
    }
    if (options.forceFragmentPrecision === "mediump" && device.maxPrecision === "lowp") {
      options.forceFragmentPrecision = "lowp";
    }
  }
  var fshader;
  code = "";
  if (device.webgl2) {
    code += pc.programlib.versionCode(device);
  }
  if (device.extStandardDerivatives && !device.webgl2) {
    code += "#extension GL_OES_standard_derivatives : enable\n\n";
  }
  if (chunks.extensionPS) {
    code += chunks.extensionPS + "\n";
  }
  if (device.webgl2) {
    code += chunks.gles3PS;
  }
  code += options.forceFragmentPrecision ? "precision " + options.forceFragmentPrecision + " float;\n\n" : pc.programlib.precisionCode(device);
  if (options.pass === pc.SHADER_PICK) {
    code += "uniform vec4 uColor;";
    code += varyings;
    if (options.alphaTest) {
      code += "float dAlpha;\n";
      code += this._addMap("opacity", options, chunks, "");
      code += chunks.alphaTestPS;
    }
    code += pc.programlib.begin();
    if (options.alphaTest) {
      code += "   getOpacity();\n";
      code += "   alphaTest(dAlpha);\n";
    }
    code += "    gl_FragColor = uColor;\n";
    code += pc.programlib.end();
    return {attributes:attributes, vshader:vshader, fshader:code};
  } else {
    if (options.pass === pc.SHADER_DEPTH) {
      code += "varying float vDepth;\n";
      code += varyings;
      code += chunks.packDepthPS;
      if (options.alphaTest) {
        code += "float dAlpha;\n";
        code += this._addMap("opacity", options, chunks, "");
        code += chunks.alphaTestPS;
      }
      code += pc.programlib.begin();
      if (options.alphaTest) {
        code += "   getOpacity();\n";
        code += "   alphaTest(dAlpha);\n";
      }
      code += "    gl_FragColor = packFloat(vDepth);\n";
      code += pc.programlib.end();
      return {attributes:attributes, vshader:vshader, fshader:code};
    } else {
      if (shadowPass) {
        var smode = options.pass - pc.SHADER_SHADOW;
        var numShadowModes = 5;
        lightType = Math.floor(smode / numShadowModes);
        var shadowType = smode - lightType * numShadowModes;
        if (device.extStandardDerivatives && !device.webgl2) {
          code += "uniform vec2 polygonOffset;\n";
        }
        if (shadowType === pc.SHADOW_VSM32) {
          if (device.extTextureFloatHighPrecision) {
            code += "#define VSM_EXPONENT 15.0\n\n";
          } else {
            code += "#define VSM_EXPONENT 5.54\n\n";
          }
        } else {
          if (shadowType === pc.SHADOW_VSM16) {
            code += "#define VSM_EXPONENT 5.54\n\n";
          }
        }
        if (lightType !== pc.LIGHTTYPE_DIRECTIONAL) {
          code += "uniform vec3 view_position;\n";
          code += "uniform float light_radius;\n";
        }
        code += varyings;
        if (options.alphaTest) {
          code += "float dAlpha;\n";
          code += this._addMap("opacity", options, chunks, "");
          code += chunks.alphaTestPS;
        }
        if (shadowType === pc.SHADOW_PCF3 && (!device.webgl2 || lightType === pc.LIGHTTYPE_POINT)) {
          code += chunks.packDepthPS;
        } else {
          if (shadowType === pc.SHADOW_VSM8) {
            code += "vec2 encodeFloatRG( float v ) {\n";
            code += "    vec2 enc = vec2(1.0, 255.0) * v;\n";
            code += "    enc = fract(enc);\n";
            code += "    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n";
            code += "    return enc;\n";
            code += "}\n\n";
          }
        }
        code += pc.programlib.begin();
        if (options.alphaTest) {
          code += "   getOpacity();\n";
          code += "   alphaTest(dAlpha);\n";
        }
        var isVsm = shadowType === pc.SHADOW_VSM8 || shadowType === pc.SHADOW_VSM16 || shadowType === pc.SHADOW_VSM32;
        if (lightType === pc.LIGHTTYPE_POINT || isVsm && lightType !== pc.LIGHTTYPE_DIRECTIONAL) {
          code += "   float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n";
        } else {
          code += "   float depth = gl_FragCoord.z;\n";
        }
        if (shadowType === pc.SHADOW_PCF3 && (!device.webgl2 || lightType === pc.LIGHTTYPE_POINT)) {
          if (device.extStandardDerivatives && !device.webgl2) {
            code += "   float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\n";
            code += "   depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\n";
            code += "   gl_FragColor = packFloat(depth);\n";
          } else {
            code += "   gl_FragColor = packFloat(depth);\n";
          }
        } else {
          if (shadowType === pc.SHADOW_PCF3 || shadowType === pc.SHADOW_PCF5) {
            code += "   gl_FragColor = vec4(1.0);\n";
          } else {
            if (shadowType === pc.SHADOW_VSM8) {
              code += "   gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n";
            } else {
              code += chunks.storeEVSMPS;
            }
          }
        }
        code += pc.programlib.end();
        return {attributes:attributes, vshader:vshader, fshader:code};
      }
    }
  }
  if (options.customFragmentShader) {
    fshader = code + options.customFragmentShader;
    return {attributes:attributes, vshader:vshader, fshader:fshader, tag:pc.SHADERTAG_MATERIAL};
  }
  code += varyings;
  code += chunks.basePS;
  var codeBegin = code;
  code = "";
  var numShadowLights = 0;
  var shadowTypeUsed = [];
  var useVsm = false;
  var usePerspZbufferShadow = false;
  var light;
  for (i = 0;i < options.lights.length;i++) {
    light = options.lights[i];
    lightType = light._type;
    code += "uniform vec3 light" + i + "_color;\n";
    if (lightType === pc.LIGHTTYPE_DIRECTIONAL) {
      code += "uniform vec3 light" + i + "_direction;\n";
    } else {
      code += "uniform vec3 light" + i + "_position;\n";
      code += "uniform float light" + i + "_radius;\n";
      if (lightType === pc.LIGHTTYPE_SPOT) {
        code += "uniform vec3 light" + i + "_direction;\n";
        code += "uniform float light" + i + "_innerConeAngle;\n";
        code += "uniform float light" + i + "_outerConeAngle;\n";
      }
    }
    if (light.castShadows && !options.noShadow) {
      code += "uniform mat4 light" + i + "_shadowMatrix;\n";
      if (lightType !== pc.LIGHTTYPE_DIRECTIONAL) {
        code += "uniform vec4 light" + i + "_shadowParams;\n";
      } else {
        code += "uniform vec3 light" + i + "_shadowParams;\n";
      }
      if (lightType === pc.LIGHTTYPE_POINT) {
        code += "uniform samplerCube light" + i + "_shadowMap;\n";
      } else {
        if (light._isPcf && device.webgl2) {
          code += "uniform sampler2DShadow light" + i + "_shadowMap;\n";
        } else {
          code += "uniform sampler2D light" + i + "_shadowMap;\n";
        }
      }
      numShadowLights++;
      shadowTypeUsed[light._shadowType] = true;
      if (light._isVsm) {
        useVsm = true;
      }
      if (light._isPcf && (device.webgl2 || device.extStandardDerivatives) && lightType === pc.LIGHTTYPE_SPOT) {
        usePerspZbufferShadow = true;
      }
    }
    if (light._cookie) {
      if (light._cookie._cubemap) {
        if (lightType === pc.LIGHTTYPE_POINT) {
          code += "uniform samplerCube light" + i + "_cookie;\n";
          code += "uniform float light" + i + "_cookieIntensity;\n";
          if (!light.castShadows || options.noShadow) {
            code += "uniform mat4 light" + i + "_shadowMatrix;\n";
          }
        }
      } else {
        if (lightType === pc.LIGHTTYPE_SPOT) {
          code += "uniform sampler2D light" + i + "_cookie;\n";
          code += "uniform float light" + i + "_cookieIntensity;\n";
          if (!light.castShadows || options.noShadow) {
            code += "uniform mat4 light" + i + "_shadowMatrix;\n";
          }
          if (light._cookieTransform) {
            code += "uniform vec4 light" + i + "_cookieMatrix;\n";
            code += "uniform vec2 light" + i + "_cookieOffset;\n";
          }
        }
      }
    }
  }
  code += "\n";
  var uvOffset = options.heightMap ? " + dUvOffset" : "";
  var tbn = options.fastTbn ? chunks.TBNfastPS : chunks.TBNPS;
  if (needsNormal) {
    if (options.normalMap && useTangents) {
      code += options.packedNormal ? chunks.normalXYPS : chunks.normalXYZPS;
      var uv = this._uvSource(options.normalMapTransform, options.normalMapUv) + uvOffset;
      if (options.needsNormalFloat) {
        code += (options.fastTbn ? chunks.normalMapFloatTBNfastPS : chunks.normalMapFloatPS).replace(/\$UV/g, uv);
      } else {
        code += chunks.normalMapPS.replace(/\$UV/g, uv);
      }
      code += tbn;
    } else {
      code += chunks.normalVertexPS;
    }
  }
  code += pc.programlib.gammaCode(options.gamma);
  code += pc.programlib.tonemapCode(options.toneMap);
  code += pc.programlib.fogCode(options.fog);
  if (options.useRgbm) {
    code += chunks.rgbmPS;
  }
  if (cubemapReflection || options.prefilteredCubemap) {
    code += options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS;
  }
  if (needsNormal) {
    code += options.cubeMapProjection > 0 ? chunks.cubeMapProjectBoxPS : chunks.cubeMapProjectNonePS;
    code += options.skyboxIntensity ? chunks.envMultiplyPS : chunks.envConstPS;
  }
  code += this._addMap("diffuse", options, chunks, uvOffset);
  if (options.blendType !== pc.BLEND_NONE || options.alphaTest || options.alphaToCoverage) {
    code += this._addMap("opacity", options, chunks, uvOffset);
  }
  code += this._addMap("emissive", options, chunks, uvOffset, null, options.emissiveFormat);
  if (options.useSpecular && (lighting || reflections)) {
    if (options.specularAntialias && options.normalMap) {
      if (options.needsNormalFloat && needsNormal) {
        code += chunks.specularAaToksvigFloatPS;
      } else {
        code += chunks.specularAaToksvigPS;
      }
    } else {
      code += chunks.specularAaNonePS;
    }
    code += this._addMap(options.useMetalness ? "metalness" : "specular", options, chunks, uvOffset);
    code += this._addMap("gloss", options, chunks, uvOffset);
    if (options.fresnelModel > 0) {
      if (options.fresnelModel === pc.FRESNEL_SIMPLE) {
        code += chunks.fresnelSimplePS;
      } else {
        if (options.fresnelModel === pc.FRESNEL_SCHLICK) {
          code += chunks.fresnelSchlickPS;
        } else {
          if (options.fresnelModel === pc.FRESNEL_COMPLEX) {
            code += chunks.fresnelComplexPS;
          }
        }
      }
    }
  }
  if (options.heightMap) {
    if (!options.normalMap) {
      code += tbn;
    }
    code += this._addMap("height", options, chunks, "", chunks.parallaxPS);
  }
  var useAo = options.aoMap || options.aoVertexColor;
  if (useAo) {
    code += this._addMap("ao", options, chunks, uvOffset, options.aoVertexColor ? chunks.aoVertPS : chunks.aoTexPS);
    if (options.occludeSpecular) {
      if (options.occludeSpecular === pc.SPECOCC_AO) {
        code += options.occludeSpecularFloat ? chunks.aoSpecOccSimplePS : chunks.aoSpecOccConstSimplePS;
      } else {
        code += options.occludeSpecularFloat ? chunks.aoSpecOccPS : chunks.aoSpecOccConstPS;
      }
    }
  }
  var reflectionDecode = options.rgbmReflection ? "decodeRGBM" : options.hdrReflection ? "" : "gammaCorrectInput";
  if (options.sphereMap) {
    var scode = device.fragmentUniformsCount > 16 ? chunks.reflectionSpherePS : chunks.reflectionSphereLowPS;
    scode = scode.replace(/\$texture2DSAMPLE/g, options.rgbmReflection ? "texture2DRGBM" : options.hdrReflection ? "texture2D" : "texture2DSRGB");
    code += scode;
  } else {
    if (cubemapReflection) {
      if (options.prefilteredCubemap) {
        if (useTexCubeLod) {
          code += chunks.reflectionPrefilteredCubeLodPS.replace(/\$DECODE/g, reflectionDecode);
        } else {
          code += chunks.reflectionPrefilteredCubePS.replace(/\$DECODE/g, reflectionDecode);
        }
      } else {
        code += chunks.reflectionCubePS.replace(/\$textureCubeSAMPLE/g, options.rgbmReflection ? "textureCubeRGBM" : options.hdrReflection ? "textureCube" : "textureCubeSRGB");
      }
    } else {
      if (options.dpAtlas) {
        code += chunks.reflectionDpAtlasPS.replace(/\$texture2DSAMPLE/g, options.rgbmReflection ? "texture2DRGBM" : options.hdrReflection ? "texture2D" : "texture2DSRGB");
      }
    }
  }
  if ((cubemapReflection || options.sphereMap || options.dpAtlas) && options.refraction) {
    code += chunks.refractionPS;
  }
  if (numShadowLights > 0) {
    if (shadowTypeUsed[pc.SHADOW_PCF3]) {
      code += chunks.shadowStandardPS;
    }
    if (shadowTypeUsed[pc.SHADOW_PCF5]) {
      code += chunks.shadowStandardGL2PS;
    }
    if (useVsm) {
      code += chunks.shadowVSM_commonPS;
      if (shadowTypeUsed[pc.SHADOW_VSM8]) {
        code += chunks.shadowVSM8PS;
      }
      if (shadowTypeUsed[pc.SHADOW_VSM16]) {
        code += device.extTextureHalfFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "16") : chunks.shadowEVSMnPS.replace(/\$/g, "16");
      }
      if (shadowTypeUsed[pc.SHADOW_VSM32]) {
        code += device.extTextureFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "32") : chunks.shadowEVSMnPS.replace(/\$/g, "32");
      }
    }
    if (device.webgl2 || device.extStandardDerivatives) {
    } else {
      code += chunks.biasConstPS;
    }
    code += chunks.shadowCoordPS + chunks.shadowCommonPS;
    if (usePerspZbufferShadow) {
      code += chunks.shadowCoordPerspZbufferPS;
    }
    if (mainShadowLight >= 0) {
      if (shadowTypeUsed[pc.SHADOW_PCF3]) {
        code += chunks.shadowStandardVSPS;
      }
      if (shadowTypeUsed[pc.SHADOW_PCF5]) {
        code += chunks.shadowStandardGL2VSPS;
      }
      if (useVsm) {
        if (shadowTypeUsed[pc.SHADOW_VSM8]) {
          code += chunks.shadowVSMVSPS.replace(/\$VSM/g, "VSM8").replace(/\$/g, "8");
        }
        if (shadowTypeUsed[pc.SHADOW_VSM16]) {
          code += chunks.shadowVSMVSPS.replace(/\$VSM/g, "VSM16").replace(/\$/g, "16");
        }
        if (shadowTypeUsed[pc.SHADOW_VSM32]) {
          code += chunks.shadowVSMVSPS.replace(/\$VSM/g, "VSM32").replace(/\$/g, "32");
        }
      }
    }
  }
  if (lighting) {
    code += chunks.lightDiffuseLambertPS;
  }
  var useOldAmbient = false;
  if (options.useSpecular) {
    if (lighting) {
      code += options.shadingModel === pc.SPECULAR_PHONG ? chunks.lightSpecularPhongPS : chunks.lightSpecularBlinnPS;
    }
    if (options.sphereMap || cubemapReflection || options.dpAtlas || options.fresnelModel > 0) {
      if (options.fresnelModel > 0) {
        if (options.conserveEnergy) {
          code += chunks.combineDiffuseSpecularPS;
        } else {
          code += chunks.combineDiffuseSpecularNoConservePS;
        }
      } else {
        code += chunks.combineDiffuseSpecularOldPS;
      }
    } else {
      if (options.diffuseMap) {
        code += chunks.combineDiffuseSpecularNoReflPS;
      } else {
        code += chunks.combineDiffuseSpecularNoReflSeparateAmbientPS;
        useOldAmbient = true;
      }
    }
  } else {
    code += chunks.combineDiffusePS;
  }
  var addAmbient = true;
  if (options.lightMap || options.lightVertexColor) {
    code += this._addMap("light", options, chunks, uvOffset, options.dirLightMap ? chunks.lightmapDirPS : chunks.lightmapSinglePS, options.lightMapFormat);
    addAmbient = options.lightMapWithoutAmbient;
  }
  if (addAmbient) {
    var ambientDecode = options.rgbmAmbient ? "decodeRGBM" : options.hdrAmbient ? "" : "gammaCorrectInput";
    if (options.ambientSH) {
      code += chunks.ambientSHPS;
    } else {
      if (options.prefilteredCubemap) {
        if (useTexCubeLod) {
          code += chunks.ambientPrefilteredCubeLodPS.replace(/\$DECODE/g, ambientDecode);
        } else {
          code += chunks.ambientPrefilteredCubePS.replace(/\$DECODE/g, ambientDecode);
        }
      } else {
        code += chunks.ambientConstantPS;
      }
    }
  }
  if (options.ambientTint && !useOldAmbient) {
    code += "uniform vec3 material_ambient;\n";
  }
  if (options.alphaTest) {
    code += chunks.alphaTestPS;
  }
  if (options.msdf) {
    code += chunks.msdfPS;
  }
  if (needsNormal) {
    code += chunks.viewDirPS;
    if (options.useSpecular) {
      code += chunks.reflDirPS;
    }
  }
  var hasPointLights = false;
  var usesLinearFalloff = false;
  var usesInvSquaredFalloff = false;
  var usesSpot = false;
  var usesCookie = false;
  var usesCookieNow;
  code += chunks.startPS;
  if (needsNormal) {
    if (options.twoSidedLighting) {
      code += "   dVertexNormalW = gl_FrontFacing ? vNormalW : -vNormalW;\n";
    } else {
      code += "   dVertexNormalW = vNormalW;\n";
    }
    if (options.heightMap || options.normalMap) {
      if (options.twoSidedLighting) {
        code += "   dTangentW = gl_FrontFacing ? vTangentW : -vTangentW;\n";
        code += "   dBinormalW = gl_FrontFacing ? vBinormalW : -vBinormalW;\n";
      } else {
        code += "   dTangentW = vTangentW;\n";
        code += "   dBinormalW = vBinormalW;\n";
      }
    }
  }
  var opacityParallax = false;
  if (options.blendType === pc.BLEND_NONE && !options.alphaTest && !options.alphaToCoverage) {
    code += "   dAlpha = 1.0;\n";
  } else {
    if (options.heightMap && options.opacityMap) {
      opacityParallax = true;
    } else {
      code += "   getOpacity();\n";
      if (options.alphaTest) {
        code += "   alphaTest(dAlpha);\n";
      }
    }
  }
  if (needsNormal) {
    code += "   getViewDir();\n";
    if (options.heightMap || options.normalMap) {
      code += "   getTBN();\n";
    }
    if (options.heightMap) {
      code += "   getParallax();\n";
    }
    if (opacityParallax) {
      code += "   getOpacity();\n";
      if (options.alphaTest) {
        code += "   alphaTest(dAlpha);\n";
      }
    }
    code += "   getNormal();\n";
    if (options.useSpecular) {
      code += "   getReflDir();\n";
    }
  }
  code += "   getAlbedo();\n";
  if (lighting && options.useSpecular || reflections) {
    code += "   getSpecularity();\n";
    code += "   getGlossiness();\n";
    if (options.fresnelModel > 0) {
      code += "   getFresnel();\n";
    }
  }
  if (addAmbient) {
    code += "   addAmbient();\n";
  }
  if (options.ambientTint && !useOldAmbient) {
    code += "   dDiffuseLight *= material_ambient;\n";
  }
  if (useAo && !options.occludeDirect) {
    code += "    applyAO();\n";
  }
  if (options.lightMap || options.lightVertexColor) {
    code += "   addLightMap();\n";
  }
  if (lighting || reflections) {
    if (cubemapReflection || options.sphereMap || options.dpAtlas) {
      code += "   addReflection();\n";
    }
    if (options.dirLightMap) {
      code += "   addDirLightMap();\n";
    }
    for (i = 0;i < options.lights.length;i++) {
      light = options.lights[i];
      lightType = light._type;
      usesCookieNow = false;
      if (lightType === pc.LIGHTTYPE_DIRECTIONAL) {
        code += "   dLightDirNormW = light" + i + "_direction;\n";
        code += "   dAtten = 1.0;\n";
      } else {
        if (light._cookie) {
          if (lightType === pc.LIGHTTYPE_SPOT && !light._cookie._cubemap) {
            usesCookie = true;
            usesCookieNow = true;
          } else {
            if (lightType === pc.LIGHTTYPE_POINT && light._cookie._cubemap) {
              usesCookie = true;
              usesCookieNow = true;
            }
          }
        }
        code += "   getLightDirPoint(light" + i + "_position);\n";
        hasPointLights = true;
        if (usesCookieNow) {
          if (lightType === pc.LIGHTTYPE_SPOT) {
            code += "   dAtten3 = getCookie2D" + (light._cookieFalloff ? "" : "Clip") + (light._cookieTransform ? "Xform" : "") + "(light" + i + "_cookie, light" + i + "_shadowMatrix, light" + i + "_cookieIntensity" + (light._cookieTransform ? ", light" + i + "_cookieMatrix, light" + i + "_cookieOffset" : "") + ")." + light._cookieChannel + ";\n";
          } else {
            code += "   dAtten3 = getCookieCube(light" + i + "_cookie, light" + i + "_shadowMatrix, light" + i + "_cookieIntensity)." + light._cookieChannel + ";\n";
          }
        }
        if (light._falloffMode === pc.LIGHTFALLOFF_LINEAR) {
          code += "   dAtten = getFalloffLinear(light" + i + "_radius);\n";
          usesLinearFalloff = true;
        } else {
          code += "   dAtten = getFalloffInvSquared(light" + i + "_radius);\n";
          usesInvSquaredFalloff = true;
        }
        code += "   if (dAtten > 0.00001) {\n";
        if (lightType === pc.LIGHTTYPE_SPOT) {
          if (!(usesCookieNow && !light._cookieFalloff)) {
            code += "       dAtten *= getSpotEffect(light" + i + "_direction, light" + i + "_innerConeAngle, light" + i + "_outerConeAngle);\n";
            usesSpot = true;
          }
        }
      }
      code += "       dAtten *= getLightDiffuse();\n";
      if (light.castShadows && !options.noShadow) {
        var shadowReadMode = null;
        var evsmExp;
        if (light._shadowType === pc.SHADOW_VSM8) {
          shadowReadMode = "VSM8";
          evsmExp = "0.0";
        } else {
          if (light._shadowType === pc.SHADOW_VSM16) {
            shadowReadMode = "VSM16";
            evsmExp = "5.54";
          } else {
            if (light._shadowType === pc.SHADOW_VSM32) {
              shadowReadMode = "VSM32";
              if (device.extTextureFloatHighPrecision) {
                evsmExp = "15.0";
              } else {
                evsmExp = "5.54";
              }
            } else {
              if (light._shadowType === pc.SHADOW_PCF5) {
                shadowReadMode = "PCF5x5";
              } else {
                shadowReadMode = "PCF3x3";
              }
            }
          }
        }
        if (shadowReadMode !== null) {
          if (lightType === pc.LIGHTTYPE_POINT) {
            shadowCoordArgs = "(light" + i + "_shadowMap, light" + i + "_shadowParams);\n";
            if (light._normalOffsetBias) {
              code += "       normalOffsetPointShadow(light" + i + "_shadowParams);\n";
            }
            code += "       dAtten *= getShadowPoint" + shadowReadMode + shadowCoordArgs;
          } else {
            if (mainShadowLight === i) {
              shadowReadMode += "VS";
            } else {
              shadowCoordArgs = "(light" + i + "_shadowMatrix, light" + i + "_shadowParams);\n";
              code += this._nonPointShadowMapProjection(device, options.lights[i], shadowCoordArgs);
            }
            if (lightType === pc.LIGHTTYPE_SPOT) {
              shadowReadMode = "Spot" + shadowReadMode;
            }
            code += "       dAtten *= getShadow" + shadowReadMode + "(light" + i + "_shadowMap, light" + i + "_shadowParams" + (light._isVsm ? ", " + evsmExp : "") + ");\n";
          }
        }
      }
      code += "       dDiffuseLight += dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
      if (options.useSpecular) {
        code += "       dAtten *= getLightSpecular();\n";
        code += "       dSpecularLight += dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
      }
      if (lightType !== pc.LIGHTTYPE_DIRECTIONAL) {
        code += "   }\n";
      }
      code += "\n";
    }
    if ((cubemapReflection || options.sphereMap || options.dpAtlas) && options.refraction) {
      code += "   addRefraction();\n";
    }
  }
  code += "\n";
  if (useAo) {
    if (options.occludeDirect) {
      code += "    applyAO();\n";
    }
    if (options.occludeSpecular) {
      code += "    occludeSpecular();\n";
    }
  }
  code += chunks.endPS;
  if (options.blendType === pc.BLEND_NORMAL || options.blendType === pc.BLEND_ADDITIVEALPHA || options.alphaToCoverage) {
    code += chunks.outputAlphaPS;
  } else {
    if (options.blendType === pc.BLEND_PREMULTIPLIED) {
      code += chunks.outputAlphaPremulPS;
    } else {
      code += chunks.outputAlphaOpaquePS;
    }
  }
  if (options.msdf) {
    code += "   gl_FragColor = applyMsdf(gl_FragColor);\n";
  }
  code += "\n";
  code += pc.programlib.end();
  if (hasPointLights) {
    code = chunks.lightDirPointPS + code;
  }
  if (usesLinearFalloff) {
    code = chunks.falloffLinearPS + code;
  }
  if (usesInvSquaredFalloff) {
    code = chunks.falloffInvSquaredPS + code;
  }
  if (usesSpot) {
    code = chunks.spotPS + code;
  }
  if (usesCookie) {
    code = chunks.cookiePS + code;
  }
  var structCode = "";
  if (code.includes("dReflection")) {
    structCode += "vec4 dReflection;\n";
  }
  if (code.includes("dTBN")) {
    structCode += "mat3 dTBN;\n";
  }
  if (code.includes("dAlbedo")) {
    structCode += "vec3 dAlbedo;\n";
  }
  if (code.includes("dEmission")) {
    structCode += "vec3 dEmission;\n";
  }
  if (code.includes("dNormalW")) {
    structCode += "vec3 dNormalW;\n";
  }
  if (code.includes("dVertexNormalW")) {
    structCode += "vec3 dVertexNormalW;\n";
  }
  if (code.includes("dTangentW")) {
    structCode += "vec3 dTangentW;\n";
  }
  if (code.includes("dBinormalW")) {
    structCode += "vec3 dBinormalW;\n";
  }
  if (code.includes("dViewDirW")) {
    structCode += "vec3 dViewDirW;\n";
  }
  if (code.includes("dReflDirW")) {
    structCode += "vec3 dReflDirW;\n";
  }
  if (code.includes("dDiffuseLight")) {
    structCode += "vec3 dDiffuseLight;\n";
  }
  if (code.includes("dSpecularLight")) {
    structCode += "vec3 dSpecularLight;\n";
  }
  if (code.includes("dLightDirNormW")) {
    structCode += "vec3 dLightDirNormW;\n";
  }
  if (code.includes("dLightDirW")) {
    structCode += "vec3 dLightDirW;\n";
  }
  if (code.includes("dLightPosW")) {
    structCode += "vec3 dLightPosW;\n";
  }
  if (code.includes("dShadowCoord")) {
    structCode += "vec3 dShadowCoord;\n";
  }
  if (code.includes("dNormalMap")) {
    structCode += "vec3 dNormalMap;\n";
  }
  if (code.includes("dSpecularity")) {
    structCode += "vec3 dSpecularity;\n";
  }
  if (code.includes("dUvOffset")) {
    structCode += "vec2 dUvOffset;\n";
  }
  if (code.includes("dGlossiness")) {
    structCode += "float dGlossiness;\n";
  }
  if (code.includes("dAlpha")) {
    structCode += "float dAlpha;\n";
  }
  if (code.includes("dAtten")) {
    structCode += "float dAtten;\n";
  }
  if (code.includes("dAtten3")) {
    structCode += "vec3 dAtten3;\n";
  }
  if (code.includes("dAo")) {
    structCode += "float dAo;\n";
  }
  if (code.includes("dMsdf")) {
    structCode += "vec4 dMsdf;\n";
  }
  code = codeBegin + structCode + code;
  fshader = code;
  return {attributes:attributes, vshader:vshader, fshader:fshader, tag:pc.SHADERTAG_MATERIAL};
}};
pc.programlib.skybox = {generateKey:function(device, options) {
  var key = "skybox" + options.rgbm + " " + options.hdr + " " + options.fixSeams + "" + options.toneMapping + "" + options.gamma + "" + options.useIntensity + "" + options.mip;
  return key;
}, createShaderDefinition:function(device, options) {
  var chunks = pc.shaderChunks;
  var mip2size = [128, 64, 16, 8, 4, 2];
  return {attributes:{aPosition:pc.SEMANTIC_POSITION}, vshader:chunks.skyboxVS, fshader:pc.programlib.precisionCode(device) + (options.mip ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS) + (options.useIntensity ? chunks.envMultiplyPS : chunks.envConstPS) + pc.programlib.gammaCode(options.gamma) + pc.programlib.tonemapCode(options.toneMapping) + chunks.rgbmPS + chunks.skyboxHDRPS.replace(/\$textureCubeSAMPLE/g, options.rgbm ? "textureCubeRGBM" : options.hdr ? "textureCube" : "textureCubeSRGB").replace(/\$FIXCONST/g, 
  1.0 - 1.0 / mip2size[options.mip] + "")};
}};
Object.assign(pc, function() {
  var primitive = {type:pc.PRIMITIVE_TRISTRIP, base:0, count:4, indexed:false};
  var PostEffect = function(graphicsDevice) {
    this.device = graphicsDevice;
    this.shader = null;
    this.depthMap = null;
    this.vertexBuffer = pc.createFullscreenQuad(graphicsDevice);
    this.needsDepthBuffer = false;
  };
  Object.assign(PostEffect.prototype, {render:function(inputTarget, outputTarget, rect) {
  }});
  function createFullscreenQuad(device) {
    var vertexFormat = new pc.VertexFormat(device, [{semantic:pc.SEMANTIC_POSITION, components:2, type:pc.TYPE_FLOAT32}]);
    var vertexBuffer = new pc.VertexBuffer(device, vertexFormat, 4);
    var iterator = new pc.VertexIterator(vertexBuffer);
    iterator.element[pc.SEMANTIC_POSITION].set(-1.0, -1.0);
    iterator.next();
    iterator.element[pc.SEMANTIC_POSITION].set(1.0, -1.0);
    iterator.next();
    iterator.element[pc.SEMANTIC_POSITION].set(-1.0, 1.0);
    iterator.next();
    iterator.element[pc.SEMANTIC_POSITION].set(1.0, 1.0);
    iterator.end();
    return vertexBuffer;
  }
  function drawFullscreenQuad(device, target, vertexBuffer, shader, rect) {
    device.setRenderTarget(target);
    device.updateBegin();
    var w = target !== null ? target.width : device.width;
    var h = target !== null ? target.height : device.height;
    var x = 0;
    var y = 0;
    if (rect) {
      x = rect.x * w;
      y = rect.y * h;
      w *= rect.z;
      h *= rect.w;
    }
    device.setViewport(x, y, w, h);
    device.setScissor(x, y, w, h);
    var oldBlending = device.getBlending();
    var oldDepthTest = device.getDepthTest();
    var oldDepthWrite = device.getDepthWrite();
    var oldCullMode = device.getCullMode();
    var oldWR = device.writeRed;
    var oldWG = device.writeGreen;
    var oldWB = device.writeBlue;
    var oldWA = device.writeAlpha;
    device.setBlending(false);
    device.setDepthTest(false);
    device.setDepthWrite(false);
    device.setCullMode(pc.CULLFACE_BACK);
    device.setColorWrite(true, true, true, true);
    device.setVertexBuffer(vertexBuffer, 0);
    device.setShader(shader);
    device.draw(primitive);
    device.setBlending(oldBlending);
    device.setDepthTest(oldDepthTest);
    device.setDepthWrite(oldDepthWrite);
    device.setCullMode(oldCullMode);
    device.setColorWrite(oldWR, oldWG, oldWB, oldWA);
    device.updateEnd();
  }
  return {PostEffect:PostEffect, createFullscreenQuad:createFullscreenQuad, drawFullscreenQuad:drawFullscreenQuad};
}());
(function() {
  var enums = {BLEND_SUBTRACTIVE:0, BLEND_ADDITIVE:1, BLEND_NORMAL:2, BLEND_NONE:3, BLEND_PREMULTIPLIED:4, BLEND_MULTIPLICATIVE:5, BLEND_ADDITIVEALPHA:6, BLEND_MULTIPLICATIVE2X:7, BLEND_SCREEN:8, BLEND_MIN:9, BLEND_MAX:10, FOG_NONE:"none", FOG_LINEAR:"linear", FOG_EXP:"exp", FOG_EXP2:"exp2", FRESNEL_NONE:0, FRESNEL_SCHLICK:2, LAYER_HUD:0, LAYER_GIZMO:1, LAYER_FX:2, LAYER_WORLD:15, LAYERID_WORLD:0, LAYERID_DEPTH:1, LAYERID_SKYBOX:2, LAYERID_IMMEDIATE:3, LAYERID_UI:4, LIGHTTYPE_DIRECTIONAL:0, LIGHTTYPE_POINT:1, 
  LIGHTTYPE_SPOT:2, LIGHTFALLOFF_LINEAR:0, LIGHTFALLOFF_INVERSESQUARED:1, SHADOW_PCF3:0, SHADOW_DEPTH:0, SHADOW_VSM8:1, SHADOW_VSM16:2, SHADOW_VSM32:3, SHADOW_PCF5:4, BLUR_BOX:0, BLUR_GAUSSIAN:1, PARTICLESORT_NONE:0, PARTICLESORT_DISTANCE:1, PARTICLESORT_NEWER_FIRST:2, PARTICLESORT_OLDER_FIRST:3, PARTICLEMODE_GPU:0, PARTICLEMODE_CPU:1, EMITTERSHAPE_BOX:0, EMITTERSHAPE_SPHERE:1, PROJECTION_PERSPECTIVE:0, PROJECTION_ORTHOGRAPHIC:1, RENDERSTYLE_SOLID:0, RENDERSTYLE_WIREFRAME:1, RENDERSTYLE_POINTS:2, 
  CUBEPROJ_NONE:0, CUBEPROJ_BOX:1, SPECULAR_PHONG:0, SPECULAR_BLINN:1, GAMMA_NONE:0, GAMMA_SRGB:1, GAMMA_SRGBFAST:2, GAMMA_SRGBHDR:3, TONEMAP_LINEAR:0, TONEMAP_FILMIC:1, TONEMAP_HEJL:2, TONEMAP_ACES:3, TONEMAP_ACES2:4, SPECOCC_NONE:0, SPECOCC_AO:1, SPECOCC_GLOSSDEPENDENT:2, SHADERDEF_NOSHADOW:1, SHADERDEF_SKIN:2, SHADERDEF_UV0:4, SHADERDEF_UV1:8, SHADERDEF_VCOLOR:16, SHADERDEF_INSTANCING:32, SHADERDEF_LM:64, SHADERDEF_DIRLM:128, SHADERDEF_SCREENSPACE:256, LINEBATCH_WORLD:0, LINEBATCH_OVERLAY:1, LINEBATCH_GIZMO:2, 
  SHADOWUPDATE_NONE:0, SHADOWUPDATE_THISFRAME:1, SHADOWUPDATE_REALTIME:2, SORTKEY_FORWARD:0, SORTKEY_DEPTH:1, MASK_DYNAMIC:1, MASK_BAKED:2, MASK_LIGHTMAP:4, SHADER_FORWARD:0, SHADER_FORWARDHDR:1, SHADER_DEPTH:2, SHADER_SHADOW:3, SHADER_PICK:18, BAKE_COLOR:0, BAKE_COLORDIR:1, VIEW_CENTER:0, VIEW_LEFT:1, VIEW_RIGHT:2, SORTMODE_NONE:0, SORTMODE_MANUAL:1, SORTMODE_MATERIALMESH:2, SORTMODE_BACK2FRONT:3, SORTMODE_FRONT2BACK:4, COMPUPDATED_INSTANCES:1, COMPUPDATED_LIGHTS:2, COMPUPDATED_CAMERAS:4, COMPUPDATED_BLEND:8, 
  ASPECT_AUTO:0, ASPECT_MANUAL:1, ORIENTATION_HORIZONTAL:0, ORIENTATION_VERTICAL:1};
  Object.assign(pc, enums);
  pc.scene = {};
  Object.assign(pc.scene, enums);
})();
Object.assign(pc, function() {
  var Scene = function Scene() {
    this.root = null;
    this._gravity = new pc.Vec3(0, -9.8, 0);
    this._layers = null;
    this._fog = pc.FOG_NONE;
    this.fogColor = new pc.Color(0, 0, 0);
    this.fogStart = 1;
    this.fogEnd = 1000;
    this.fogDensity = 0;
    this.ambientLight = new pc.Color(0, 0, 0);
    this._gammaCorrection = pc.GAMMA_NONE;
    this._toneMapping = 0;
    this.exposure = 1.0;
    this._skyboxPrefiltered = [null, null, null, null, null, null];
    this._skyboxCubeMap = null;
    this.skyboxModel = null;
    this._skyboxIntensity = 1;
    this._skyboxMip = 0;
    this.lightmapSizeMultiplier = 1;
    this.lightmapMaxResolution = 2048;
    this.lightmapMode = pc.BAKE_COLORDIR;
    this._stats = {meshInstances:0, lights:0, dynamicLights:0, bakedLights:0, lastStaticPrepareFullTime:0, lastStaticPrepareSearchTime:0, lastStaticPrepareWriteTime:0, lastStaticPrepareTriAabbTime:0, lastStaticPrepareCombineTime:0, updateShadersTime:0};
    this.updateShaders = true;
    this.updateSkybox = true;
    this._shaderVersion = 0;
    this._statsUpdated = false;
    this._models = [];
    pc.events.attach(this);
  };
  Object.defineProperty(Scene.prototype, "fog", {get:function() {
    return this._fog;
  }, set:function(type) {
    if (type !== this._fog) {
      this._fog = type;
      this.updateShaders = true;
    }
  }});
  Object.defineProperty(Scene.prototype, "gammaCorrection", {get:function() {
    return this._gammaCorrection;
  }, set:function(value) {
    if (value !== this._gammaCorrection) {
      this._gammaCorrection = value;
      this.updateShaders = true;
    }
  }});
  Object.defineProperty(Scene.prototype, "toneMapping", {get:function() {
    return this._toneMapping;
  }, set:function(value) {
    if (value !== this._toneMapping) {
      this._toneMapping = value;
      this.updateShaders = true;
    }
  }});
  Object.defineProperty(Scene.prototype, "skybox", {get:function() {
    return this._skyboxCubeMap;
  }, set:function(value) {
    this._skyboxCubeMap = value;
    this._resetSkyboxModel();
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "skyboxIntensity", {get:function() {
    return this._skyboxIntensity;
  }, set:function(value) {
    this._skyboxIntensity = value;
    this._resetSkyboxModel();
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "skyboxMip", {get:function() {
    return this._skyboxMip;
  }, set:function(value) {
    this._skyboxMip = value;
    this._resetSkyboxModel();
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "skyboxPrefiltered128", {get:function() {
    return this._skyboxPrefiltered[0];
  }, set:function(value) {
    if (this._skyboxPrefiltered[0] === value) {
      return;
    }
    this._skyboxPrefiltered[0] = value;
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "skyboxPrefiltered64", {get:function() {
    return this._skyboxPrefiltered[1];
  }, set:function(value) {
    if (this._skyboxPrefiltered[1] === value) {
      return;
    }
    this._skyboxPrefiltered[1] = value;
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "skyboxPrefiltered32", {get:function() {
    return this._skyboxPrefiltered[2];
  }, set:function(value) {
    if (this._skyboxPrefiltered[2] === value) {
      return;
    }
    this._skyboxPrefiltered[2] = value;
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "skyboxPrefiltered16", {get:function() {
    return this._skyboxPrefiltered[3];
  }, set:function(value) {
    if (this._skyboxPrefiltered[3] === value) {
      return;
    }
    this._skyboxPrefiltered[3] = value;
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "skyboxPrefiltered8", {get:function() {
    return this._skyboxPrefiltered[4];
  }, set:function(value) {
    if (this._skyboxPrefiltered[4] === value) {
      return;
    }
    this._skyboxPrefiltered[4] = value;
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "skyboxPrefiltered4", {get:function() {
    return this._skyboxPrefiltered[5];
  }, set:function(value) {
    if (this._skyboxPrefiltered[5] === value) {
      return;
    }
    this._skyboxPrefiltered[5] = value;
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "drawCalls", {get:function() {
    var drawCalls = this.layers._meshInstances;
    if (!drawCalls.length) {
      this.layers._update();
      drawCalls = this.layers._meshInstances;
    }
    return drawCalls;
  }, set:function(value) {
  }});
  Object.defineProperty(Scene.prototype, "layers", {get:function() {
    return this._layers;
  }, set:function(layers) {
    var prev = this._layers;
    this._layers = layers;
    this.fire("set:layers", prev, layers);
  }});
  Scene.prototype.applySettings = function(settings) {
    this._gravity.set(settings.physics.gravity[0], settings.physics.gravity[1], settings.physics.gravity[2]);
    this.ambientLight.set(settings.render.global_ambient[0], settings.render.global_ambient[1], settings.render.global_ambient[2]);
    this._fog = settings.render.fog;
    this.fogColor.set(settings.render.fog_color[0], settings.render.fog_color[1], settings.render.fog_color[2]);
    this.fogStart = settings.render.fog_start;
    this.fogEnd = settings.render.fog_end;
    this.fogDensity = settings.render.fog_density;
    this._gammaCorrection = settings.render.gamma_correction;
    this._toneMapping = settings.render.tonemapping;
    this.lightmapSizeMultiplier = settings.render.lightmapSizeMultiplier;
    this.lightmapMaxResolution = settings.render.lightmapMaxResolution;
    this.lightmapMode = settings.render.lightmapMode;
    this.exposure = settings.render.exposure;
    this._skyboxIntensity = settings.render.skyboxIntensity === undefined ? 1 : settings.render.skyboxIntensity;
    this._skyboxMip = settings.render.skyboxMip === undefined ? 0 : settings.render.skyboxMip;
    this._resetSkyboxModel();
    this.updateShaders = true;
  };
  Scene.prototype._updateSkybox = function(device) {
    if (this._skyboxCubeMap && !this.skyboxModel) {
      var material = new pc.Material;
      var scene = this;
      material.updateShader = function(dev, sc, defs, staticLightList, pass) {
        var library = device.getProgramLibrary();
        var shader = library.getProgram("skybox", {rgbm:scene._skyboxCubeMap.rgbm, hdr:scene._skyboxCubeMap.rgbm || scene._skyboxCubeMap.format === pc.PIXELFORMAT_RGBA32F, useIntensity:scene.skyboxIntensity !== 1, mip:scene._skyboxCubeMap.fixCubemapSeams ? scene.skyboxMip : 0, fixSeams:scene._skyboxCubeMap.fixCubemapSeams, gamma:pass === pc.SHADER_FORWARDHDR ? scene.gammaCorrection ? pc.GAMMA_SRGBHDR : pc.GAMMA_NONE : scene.gammaCorrection, toneMapping:pass === pc.SHADER_FORWARDHDR ? pc.TONEMAP_LINEAR : 
        scene.toneMapping});
        this.setShader(shader);
      };
      material.updateShader();
      var usedTex;
      if (!this._skyboxCubeMap.fixCubemapSeams || !scene._skyboxMip) {
        usedTex = this._skyboxCubeMap;
      } else {
        var mip2tex = [null, "64", "16", "8", "4"];
        var mipTex = this["skyboxPrefiltered" + mip2tex[scene._skyboxMip]];
        if (mipTex) {
          usedTex = mipTex;
        }
      }
      material.setParameter("texture_cubeMap", usedTex);
      material.cull = pc.CULLFACE_NONE;
      var skyLayer = this.layers.getLayerById(pc.LAYERID_SKYBOX);
      if (skyLayer) {
        var node = new pc.GraphNode;
        var mesh = pc.createBox(device);
        var meshInstance = new pc.MeshInstance(node, mesh, material);
        meshInstance.cull = false;
        meshInstance._noDepthDrawGl1 = true;
        var model = new pc.Model;
        model.graph = node;
        model.meshInstances = [meshInstance];
        this.skyboxModel = model;
        skyLayer.addMeshInstances(model.meshInstances);
        skyLayer.enabled = true;
        this.skyLayer = skyLayer;
        this.fire("set:skybox", usedTex);
      }
    }
  };
  Scene.prototype._resetSkyboxModel = function() {
    if (this.skyboxModel) {
      this.skyLayer.removeMeshInstances(this.skyboxModel.meshInstances);
      this.skyLayer.enabled = false;
    }
    this.skyboxModel = null;
    this.updateSkybox = true;
  };
  Scene.prototype.setSkybox = function(cubemaps) {
    var i;
    if (!cubemaps) {
      cubemaps = [null, null, null, null, null, null, null];
    }
    var different = false;
    if (this._skyboxCubeMap !== cubemaps[0]) {
      different = true;
    }
    if (!different) {
      for (i = 0;i < 6 && !different;i++) {
        if (this._skyboxPrefiltered[i] !== cubemaps[i + 1]) {
          different = true;
        }
      }
    }
    if (!different) {
      return;
    }
    for (i = 0;i < 6;i++) {
      this._skyboxPrefiltered[i] = cubemaps[i + 1];
    }
    this.skybox = cubemaps[0];
  };
  Scene.prototype.destroy = function() {
    this.skybox = null;
  };
  Scene.prototype.addModel = function(model) {
    if (this.containsModel(model)) {
      return;
    }
    var layer = this.layers.getLayerById(pc.LAYERID_WORLD);
    if (!layer) {
      return;
    }
    layer.addMeshInstances(model.meshInstances);
    this._models.push(model);
  };
  Scene.prototype.addShadowCaster = function(model) {
    var layer = this.layers.getLayerById(pc.LAYERID_WORLD);
    if (!layer) {
      return;
    }
    layer.addShadowCasters(model.meshInstances);
  };
  Scene.prototype.removeModel = function(model) {
    var index = this._models.indexOf(model);
    if (index !== -1) {
      var layer = this.layers.getLayerById(pc.LAYERID_WORLD);
      if (!layer) {
        return;
      }
      layer.removeMeshInstances(model.meshInstances);
      this._models.splice(index, 1);
    }
  };
  Scene.prototype.removeShadowCasters = function(model) {
    var layer = this.layers.getLayerById(pc.LAYERID_WORLD);
    if (!layer) {
      return;
    }
    layer.removeShadowCasters(model.meshInstances);
  };
  Scene.prototype.containsModel = function(model) {
    return this._models.indexOf(model) >= 0;
  };
  Scene.prototype.getModels = function(model) {
    return this._models;
  };
  return {Scene:Scene};
}());
Object.assign(pc, function() {
  var scaleShift = (new pc.Mat4).mul2((new pc.Mat4).setTranslate(0.5, 0.5, 0.5), (new pc.Mat4).setScale(0.5, 0.5, 0.5));
  var opChanId = {r:1, g:2, b:3, a:4};
  var pointLightRotations = [(new pc.Quat).setFromEulerAngles(0, 90, 180), (new pc.Quat).setFromEulerAngles(0, -90, 180), (new pc.Quat).setFromEulerAngles(90, 0, 0), (new pc.Quat).setFromEulerAngles(-90, 0, 0), (new pc.Quat).setFromEulerAngles(0, 180, 180), (new pc.Quat).setFromEulerAngles(0, 0, 180)];
  var numShadowModes = 5;
  var shadowMapCache = [{}, {}, {}, {}, {}];
  var directionalShadowEpsilon = 0.01;
  var pixelOffset = new pc.Vec2;
  var blurScissorRect = {x:1, y:1, z:0, w:0};
  var shadowCamView = new pc.Mat4;
  var shadowCamViewProj = new pc.Mat4;
  var c2sc = new pc.Mat4;
  var viewInvMat = new pc.Mat4;
  var viewMat = new pc.Mat4;
  var viewMat3 = new pc.Mat3;
  var viewProjMat = new pc.Mat4;
  var projMat;
  var viewInvL = new pc.Mat4;
  var viewInvR = new pc.Mat4;
  var viewL = new pc.Mat4;
  var viewR = new pc.Mat4;
  var viewPosL = new pc.Vec3;
  var viewPosR = new pc.Vec3;
  var projL, projR;
  var viewMat3L = new pc.Mat4;
  var viewMat3R = new pc.Mat4;
  var viewProjMatL = new pc.Mat4;
  var viewProjMatR = new pc.Mat4;
  var frustumDiagonal = new pc.Vec3;
  var tempSphere = {center:null, radius:0};
  var meshPos;
  var visibleSceneAabb = new pc.BoundingBox;
  var boneTextureSize = [0, 0];
  var boneTexture, instancingData, modelMatrix, normalMatrix;
  var shadowMapCubeCache = {};
  var maxBlurSize = 25;
  var keyA, keyB;
  var frustumPoints = [];
  for (var fp = 0;fp < 8;fp++) {
    frustumPoints.push(new pc.Vec3);
  }
  function _getFrustumPoints(camera, farClip, points) {
    var nearClip = camera._nearClip;
    var fov = camera._fov * Math.PI / 180.0;
    var aspect = camera._aspect;
    var projection = camera._projection;
    var x, y;
    if (projection === pc.PROJECTION_PERSPECTIVE) {
      y = Math.tan(fov / 2.0) * nearClip;
    } else {
      y = camera._orthoHeight;
    }
    x = y * aspect;
    points[0].x = x;
    points[0].y = -y;
    points[0].z = -nearClip;
    points[1].x = x;
    points[1].y = y;
    points[1].z = -nearClip;
    points[2].x = -x;
    points[2].y = y;
    points[2].z = -nearClip;
    points[3].x = -x;
    points[3].y = -y;
    points[3].z = -nearClip;
    if (projection === pc.PROJECTION_PERSPECTIVE) {
      y = Math.tan(fov / 2.0) * farClip;
      x = y * aspect;
    }
    points[4].x = x;
    points[4].y = -y;
    points[4].z = -farClip;
    points[5].x = x;
    points[5].y = y;
    points[5].z = -farClip;
    points[6].x = -x;
    points[6].y = y;
    points[6].z = -farClip;
    points[7].x = -x;
    points[7].y = -y;
    points[7].z = -farClip;
    return points;
  }
  var _sceneAABB_LS = [new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3];
  function _getZFromAABBSimple(w2sc, aabbMin, aabbMax, lcamMinX, lcamMaxX, lcamMinY, lcamMaxY) {
    _sceneAABB_LS[0].x = _sceneAABB_LS[1].x = _sceneAABB_LS[2].x = _sceneAABB_LS[3].x = aabbMin.x;
    _sceneAABB_LS[1].y = _sceneAABB_LS[3].y = _sceneAABB_LS[7].y = _sceneAABB_LS[5].y = aabbMin.y;
    _sceneAABB_LS[2].z = _sceneAABB_LS[3].z = _sceneAABB_LS[6].z = _sceneAABB_LS[7].z = aabbMin.z;
    _sceneAABB_LS[4].x = _sceneAABB_LS[5].x = _sceneAABB_LS[6].x = _sceneAABB_LS[7].x = aabbMax.x;
    _sceneAABB_LS[0].y = _sceneAABB_LS[2].y = _sceneAABB_LS[4].y = _sceneAABB_LS[6].y = aabbMax.y;
    _sceneAABB_LS[0].z = _sceneAABB_LS[1].z = _sceneAABB_LS[4].z = _sceneAABB_LS[5].z = aabbMax.z;
    var minz = 9999999999;
    var maxz = -9999999999;
    var z;
    for (var i = 0;i < 8;++i) {
      w2sc.transformPoint(_sceneAABB_LS[i], _sceneAABB_LS[i]);
      z = _sceneAABB_LS[i].z;
      if (z < minz) {
        minz = z;
      }
      if (z > maxz) {
        maxz = z;
      }
    }
    return {min:minz, max:maxz};
  }
  function getShadowFormat(device, shadowType) {
    if (shadowType === pc.SHADOW_VSM32) {
      return pc.PIXELFORMAT_RGBA32F;
    } else {
      if (shadowType === pc.SHADOW_VSM16) {
        return pc.PIXELFORMAT_RGBA16F;
      } else {
        if (shadowType === pc.SHADOW_PCF5) {
          return pc.PIXELFORMAT_DEPTH;
        } else {
          if (shadowType === pc.SHADOW_PCF3 && device.webgl2) {
            return pc.PIXELFORMAT_DEPTH;
          }
        }
      }
    }
    return pc.PIXELFORMAT_R8_G8_B8_A8;
  }
  function getShadowFiltering(device, shadowType) {
    if (shadowType === pc.SHADOW_PCF3 && !device.webgl2) {
      return pc.FILTER_NEAREST;
    } else {
      if (shadowType === pc.SHADOW_VSM32) {
        return device.extTextureFloatLinear ? pc.FILTER_LINEAR : pc.FILTER_NEAREST;
      } else {
        if (shadowType === pc.SHADOW_VSM16) {
          return device.extTextureHalfFloatLinear ? pc.FILTER_LINEAR : pc.FILTER_NEAREST;
        }
      }
    }
    return pc.FILTER_LINEAR;
  }
  function createShadowMap(device, width, height, shadowType) {
    var format = getShadowFormat(device, shadowType);
    var filter = getShadowFiltering(device, shadowType);
    var shadowMap = new pc.Texture(device, {format:format, width:width, height:height, mipmaps:false, minFilter:filter, magFilter:filter, addressU:pc.ADDRESS_CLAMP_TO_EDGE, addressV:pc.ADDRESS_CLAMP_TO_EDGE});
    if (shadowType === pc.SHADOW_PCF5 || shadowType === pc.SHADOW_PCF3 && device.webgl2) {
      shadowMap.compareOnRead = true;
      shadowMap.compareFunc = pc.FUNC_LESS;
      return new pc.RenderTarget({depthBuffer:shadowMap});
    }
    return new pc.RenderTarget({colorBuffer:shadowMap, depth:true});
  }
  function createShadowCubeMap(device, size) {
    var cubemap = new pc.Texture(device, {format:pc.PIXELFORMAT_R8_G8_B8_A8, width:size, height:size, cubemap:true, mipmaps:false, minFilter:pc.FILTER_NEAREST, magFilter:pc.FILTER_NEAREST, addressU:pc.ADDRESS_CLAMP_TO_EDGE, addressV:pc.ADDRESS_CLAMP_TO_EDGE});
    var targets = [];
    var target;
    for (var i = 0;i < 6;i++) {
      target = new pc.RenderTarget({colorBuffer:cubemap, face:i, depth:true});
      targets.push(target);
    }
    return targets;
  }
  function gauss(x, sigma) {
    return Math.exp(-(x * x) / (2.0 * sigma * sigma));
  }
  function gaussWeights(kernelSize) {
    if (kernelSize > maxBlurSize) {
      kernelSize = maxBlurSize;
    }
    var sigma = (kernelSize - 1) / (2 * 3);
    var i, values, sum, halfWidth;
    halfWidth = (kernelSize - 1) * 0.5;
    values = new Array(kernelSize);
    sum = 0.0;
    for (i = 0;i < kernelSize;++i) {
      values[i] = gauss(i - halfWidth, sigma);
      sum += values[i];
    }
    for (i = 0;i < kernelSize;++i) {
      values[i] /= sum;
    }
    return values;
  }
  function createShadowCamera(device, shadowType, type) {
    var flags = pc.CLEARFLAG_DEPTH;
    var hwPcf = shadowType === pc.SHADOW_PCF5 || shadowType === pc.SHADOW_PCF3 && device.webgl2;
    if (type === pc.LIGHTTYPE_POINT) {
      hwPcf = false;
    }
    if (!hwPcf) {
      flags |= pc.CLEARFLAG_COLOR;
    }
    var shadowCam = new pc.Camera;
    if (shadowType >= pc.SHADOW_VSM8 && shadowType <= pc.SHADOW_VSM32) {
      shadowCam.clearColor[0] = 0;
      shadowCam.clearColor[1] = 0;
      shadowCam.clearColor[2] = 0;
      shadowCam.clearColor[3] = 0;
    } else {
      shadowCam.clearColor[0] = 1;
      shadowCam.clearColor[1] = 1;
      shadowCam.clearColor[2] = 1;
      shadowCam.clearColor[3] = 1;
    }
    shadowCam.clearDepth = 1;
    shadowCam.clearFlags = flags;
    shadowCam.clearStencil = null;
    shadowCam._node = new pc.GraphNode;
    return shadowCam;
  }
  function getShadowMapFromCache(device, res, mode, layer) {
    if (!layer) {
      layer = 0;
    }
    var id = layer * 10000 + res;
    var shadowBuffer = shadowMapCache[mode][id];
    if (!shadowBuffer) {
      shadowBuffer = createShadowMap(device, res, res, mode ? mode : pc.SHADOW_PCF3);
      shadowMapCache[mode][id] = shadowBuffer;
    }
    return shadowBuffer;
  }
  function createShadowBuffer(device, light) {
    var shadowBuffer;
    if (light._type === pc.LIGHTTYPE_POINT) {
      if (light._shadowType > pc.SHADOW_PCF3) {
        light._shadowType = pc.SHADOW_PCF3;
      }
      if (light._cacheShadowMap) {
        shadowBuffer = shadowMapCubeCache[light._shadowResolution];
        if (!shadowBuffer) {
          shadowBuffer = createShadowCubeMap(device, light._shadowResolution);
          shadowMapCubeCache[light._shadowResolution] = shadowBuffer;
        }
      } else {
        shadowBuffer = createShadowCubeMap(device, light._shadowResolution);
      }
      light._shadowCamera.renderTarget = shadowBuffer[0];
      light._shadowCubeMap = shadowBuffer;
    } else {
      if (light._cacheShadowMap) {
        shadowBuffer = getShadowMapFromCache(device, light._shadowResolution, light._shadowType);
      } else {
        shadowBuffer = createShadowMap(device, light._shadowResolution, light._shadowResolution, light._shadowType);
      }
      light._shadowCamera.renderTarget = shadowBuffer;
    }
    light._isCachedShadowMap = light._cacheShadowMap;
  }
  function getDepthKey(meshInstance) {
    var material = meshInstance.material;
    var x = meshInstance.skinInstance ? 10 : 0;
    var y = 0;
    if (material.opacityMap) {
      var opChan = material.opacityMapChannel;
      if (opChan) {
        y = opChanId[opChan];
      }
    }
    return x + y;
  }
  function ForwardRenderer(graphicsDevice) {
    this.device = graphicsDevice;
    var device = this.device;
    this._shadowDrawCalls = 0;
    this._forwardDrawCalls = 0;
    this._skinDrawCalls = 0;
    this._camerasRendered = 0;
    this._materialSwitches = 0;
    this._shadowMapUpdates = 0;
    this._shadowMapTime = 0;
    this._depthMapTime = 0;
    this._forwardTime = 0;
    this._cullTime = 0;
    this._sortTime = 0;
    this._skinTime = 0;
    this._morphTime = 0;
    this._instancingTime = 0;
    var library = device.getProgramLibrary();
    this.library = library;
    this.frontToBack = false;
    var scope = device.scope;
    this.projId = scope.resolve("matrix_projection");
    this.viewId = scope.resolve("matrix_view");
    this.viewId3 = scope.resolve("matrix_view3");
    this.viewInvId = scope.resolve("matrix_viewInverse");
    this.viewProjId = scope.resolve("matrix_viewProjection");
    this.viewPosId = scope.resolve("view_position");
    this.nearClipId = scope.resolve("camera_near");
    this.farClipId = scope.resolve("camera_far");
    this.cameraParamsId = scope.resolve("camera_params");
    this.shadowMapLightRadiusId = scope.resolve("light_radius");
    this.fogColorId = scope.resolve("fog_color");
    this.fogStartId = scope.resolve("fog_start");
    this.fogEndId = scope.resolve("fog_end");
    this.fogDensityId = scope.resolve("fog_density");
    this.modelMatrixId = scope.resolve("matrix_model");
    this.normalMatrixId = scope.resolve("matrix_normal");
    this.poseMatrixId = scope.resolve("matrix_pose[0]");
    this.boneTextureId = scope.resolve("texture_poseMap");
    this.boneTextureSizeId = scope.resolve("texture_poseMapSize");
    this.alphaTestId = scope.resolve("alpha_ref");
    this.opacityMapId = scope.resolve("texture_opacityMap");
    this.ambientId = scope.resolve("light_globalAmbient");
    this.exposureId = scope.resolve("exposure");
    this.skyboxIntensityId = scope.resolve("skyboxIntensity");
    this.lightColorId = [];
    this.lightDirId = [];
    this.lightShadowMapId = [];
    this.lightShadowMatrixId = [];
    this.lightShadowParamsId = [];
    this.lightShadowMatrixVsId = [];
    this.lightShadowParamsVsId = [];
    this.lightDirVsId = [];
    this.lightRadiusId = [];
    this.lightPosId = [];
    this.lightInAngleId = [];
    this.lightOutAngleId = [];
    this.lightPosVsId = [];
    this.lightCookieId = [];
    this.lightCookieIntId = [];
    this.lightCookieMatrixId = [];
    this.lightCookieOffsetId = [];
    this.depthMapId = scope.resolve("uDepthMap");
    this.screenSizeId = scope.resolve("uScreenSize");
    this._screenSize = new pc.Vec4;
    this.sourceId = scope.resolve("source");
    this.pixelOffsetId = scope.resolve("pixelOffset");
    this.weightId = scope.resolve("weight[0]");
    var chunks = pc.shaderChunks;
    this.blurVsmShaderCode = [chunks.blurVSMPS, "#define GAUSS\n" + chunks.blurVSMPS];
    var packed = "#define PACKED\n";
    this.blurPackedVsmShaderCode = [packed + this.blurVsmShaderCode[0], packed + this.blurVsmShaderCode[1]];
    this.blurVsmShader = [{}, {}];
    this.blurPackedVsmShader = [{}, {}];
    this.blurVsmWeights = {};
    this.polygonOffsetId = scope.resolve("polygonOffset");
    this.polygonOffset = new Float32Array(2);
    this.fogColor = new Float32Array(3);
    this.ambientColor = new Float32Array(3);
  }
  function mat3FromMat4(m3, m4) {
    m3.data[0] = m4.data[0];
    m3.data[1] = m4.data[1];
    m3.data[2] = m4.data[2];
    m3.data[3] = m4.data[4];
    m3.data[4] = m4.data[5];
    m3.data[5] = m4.data[6];
    m3.data[6] = m4.data[8];
    m3.data[7] = m4.data[9];
    m3.data[8] = m4.data[10];
  }
  Object.assign(ForwardRenderer.prototype, {sortCompare:function(drawCallA, drawCallB) {
    if (drawCallA.layer === drawCallB.layer) {
      if (drawCallA.drawOrder && drawCallB.drawOrder) {
        return drawCallA.drawOrder - drawCallB.drawOrder;
      } else {
        if (drawCallA.zdist && drawCallB.zdist) {
          return drawCallB.zdist - drawCallA.zdist;
        } else {
          if (drawCallA.zdist2 && drawCallB.zdist2) {
            return drawCallA.zdist2 - drawCallB.zdist2;
          }
        }
      }
    }
    return drawCallB._key[pc.SORTKEY_FORWARD] - drawCallA._key[pc.SORTKEY_FORWARD];
  }, sortCompareMesh:function(drawCallA, drawCallB) {
    if (drawCallA.layer === drawCallB.layer) {
      if (drawCallA.drawOrder && drawCallB.drawOrder) {
        return drawCallA.drawOrder - drawCallB.drawOrder;
      } else {
        if (drawCallA.zdist && drawCallB.zdist) {
          return drawCallB.zdist - drawCallA.zdist;
        }
      }
    }
    keyA = drawCallA._key[pc.SORTKEY_FORWARD];
    keyB = drawCallB._key[pc.SORTKEY_FORWARD];
    if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
      return drawCallB.mesh.id - drawCallA.mesh.id;
    }
    return keyB - keyA;
  }, depthSortCompare:function(drawCallA, drawCallB) {
    keyA = drawCallA._key[pc.SORTKEY_DEPTH];
    keyB = drawCallB._key[pc.SORTKEY_DEPTH];
    if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
      return drawCallB.mesh.id - drawCallA.mesh.id;
    }
    return keyB - keyA;
  }, lightCompare:function(lightA, lightB) {
    return lightA.key - lightB.key;
  }, _isVisible:function(camera, meshInstance) {
    if (!meshInstance.visible) {
      return false;
    }
    meshPos = meshInstance.aabb.center;
    if (meshInstance._aabb._radiusVer !== meshInstance._aabbVer) {
      meshInstance._aabb._radius = meshInstance._aabb.halfExtents.length();
      meshInstance._aabb._radiusVer = meshInstance._aabbVer;
    }
    tempSphere.radius = meshInstance._aabb._radius;
    tempSphere.center = meshPos;
    return camera.frustum.containsSphere(tempSphere);
  }, getShadowCamera:function(device, light) {
    var shadowCam = light._shadowCamera;
    var shadowBuffer;
    if (shadowCam === null) {
      shadowCam = light._shadowCamera = createShadowCamera(device, light._shadowType, light._type);
      createShadowBuffer(device, light);
    } else {
      shadowBuffer = shadowCam.renderTarget;
      if (shadowBuffer.width !== light._shadowResolution || shadowBuffer.height !== light._shadowResolution) {
        createShadowBuffer(device, light);
      }
    }
    return shadowCam;
  }, updateCameraFrustum:function(camera) {
    if (camera.vrDisplay && camera.vrDisplay.presenting) {
      projMat = camera.vrDisplay.combinedProj;
      var parent = camera._node.getParent();
      if (parent) {
        viewMat.copy(parent.getWorldTransform()).mul(camera.vrDisplay.combinedViewInv).invert();
      } else {
        viewMat.copy(camera.vrDisplay.combinedView);
      }
      viewInvMat.copy(viewMat).invert();
      this.viewInvId.setValue(viewInvMat.data);
      camera.frustum.update(projMat, viewMat);
      return;
    }
    projMat = camera.getProjectionMatrix();
    if (camera.overrideCalculateProjection) {
      camera.calculateProjection(projMat, pc.VIEW_CENTER);
    }
    if (camera.overrideCalculateTransform) {
      camera.calculateTransform(viewInvMat, pc.VIEW_CENTER);
    } else {
      var pos = camera._node.getPosition();
      var rot = camera._node.getRotation();
      viewInvMat.setTRS(pos, rot, pc.Vec3.ONE);
      this.viewInvId.setValue(viewInvMat.data);
    }
    viewMat.copy(viewInvMat).invert();
    camera.frustum.update(projMat, viewMat);
  }, setCamera:function(camera, target, clear, cullBorder) {
    var vrDisplay = camera.vrDisplay;
    if (!vrDisplay || !vrDisplay.presenting) {
      projMat = camera.getProjectionMatrix();
      if (camera.overrideCalculateProjection) {
        camera.calculateProjection(projMat, pc.VIEW_CENTER);
      }
      this.projId.setValue(projMat.data);
      if (camera.overrideCalculateTransform) {
        camera.calculateTransform(viewInvMat, pc.VIEW_CENTER);
      } else {
        var pos = camera._node.getPosition();
        var rot = camera._node.getRotation();
        viewInvMat.setTRS(pos, rot, pc.Vec3.ONE);
      }
      this.viewInvId.setValue(viewInvMat.data);
      viewMat.copy(viewInvMat).invert();
      this.viewId.setValue(viewMat.data);
      mat3FromMat4(viewMat3, viewMat);
      this.viewId3.setValue(viewMat3.data);
      viewProjMat.mul2(projMat, viewMat);
      this.viewProjId.setValue(viewProjMat.data);
      this.viewPosId.setValue(camera._node.getPosition().data);
      camera.frustum.update(projMat, viewMat);
    } else {
      projL = vrDisplay.leftProj;
      projR = vrDisplay.rightProj;
      projMat = vrDisplay.combinedProj;
      if (camera.overrideCalculateProjection) {
        camera.calculateProjection(projL, pc.VIEW_LEFT);
        camera.calculateProjection(projR, pc.VIEW_RIGHT);
        camera.calculateProjection(projMat, pc.VIEW_CENTER);
      }
      if (camera.overrideCalculateTransform) {
        camera.calculateTransform(viewInvL, pc.VIEW_LEFT);
        camera.calculateTransform(viewInvR, pc.VIEW_RIGHT);
        camera.calculateTransform(viewInvMat, pc.VIEW_CENTER);
        viewL.copy(viewInvL).invert();
        viewR.copy(viewInvR).invert();
        viewMat.copy(viewInvMat).invert();
      } else {
        var parent = camera._node.getParent();
        if (parent) {
          var transform = parent.getWorldTransform();
          viewInvL.mul2(transform, vrDisplay.leftViewInv);
          viewInvR.mul2(transform, vrDisplay.rightViewInv);
          viewL.copy(viewInvL).invert();
          viewR.copy(viewInvR).invert();
          viewMat.copy(parent.getWorldTransform()).mul(vrDisplay.combinedViewInv).invert();
        } else {
          viewInvL.copy(vrDisplay.leftViewInv);
          viewInvR.copy(vrDisplay.rightViewInv);
          viewL.copy(vrDisplay.leftView);
          viewR.copy(vrDisplay.rightView);
          viewMat.copy(vrDisplay.combinedView);
        }
      }
      mat3FromMat4(viewMat3L, viewL);
      mat3FromMat4(viewMat3R, viewR);
      viewProjMatL.mul2(projL, viewL);
      viewProjMatR.mul2(projR, viewR);
      viewPosL.data[0] = viewInvL.data[12];
      viewPosL.data[1] = viewInvL.data[13];
      viewPosL.data[2] = viewInvL.data[14];
      viewPosR.data[0] = viewInvR.data[12];
      viewPosR.data[1] = viewInvR.data[13];
      viewPosR.data[2] = viewInvR.data[14];
      camera.frustum.update(projMat, viewMat);
    }
    this.nearClipId.setValue(camera._nearClip);
    this.farClipId.setValue(camera._farClip);
    this.cameraParamsId.setValue(camera._shaderParams.data);
    var device = this.device;
    device.setRenderTarget(target);
    device.updateBegin();
    var rect = camera.getRect();
    var pixelWidth = target ? target.width : device.width;
    var pixelHeight = target ? target.height : device.height;
    var x = Math.floor(rect.x * pixelWidth);
    var y = Math.floor(rect.y * pixelHeight);
    var w = Math.floor(rect.width * pixelWidth);
    var h = Math.floor(rect.height * pixelHeight);
    device.setViewport(x, y, w, h);
    device.setScissor(x, y, w, h);
    if (clear) {
      device.clear(camera._clearOptions);
    }
    rect = camera._scissorRect;
    x = Math.floor(rect.x * pixelWidth);
    y = Math.floor(rect.y * pixelHeight);
    w = Math.floor(rect.width * pixelWidth);
    h = Math.floor(rect.height * pixelHeight);
    device.setScissor(x, y, w, h);
    if (cullBorder) {
      device.setScissor(1, 1, pixelWidth - 2, pixelHeight - 2);
    }
  }, dispatchGlobalLights:function(scene) {
    var i;
    this.mainLight = -1;
    this.ambientColor[0] = scene.ambientLight.data[0];
    this.ambientColor[1] = scene.ambientLight.data[1];
    this.ambientColor[2] = scene.ambientLight.data[2];
    if (scene.gammaCorrection) {
      for (i = 0;i < 3;i++) {
        this.ambientColor[i] = Math.pow(this.ambientColor[i], 2.2);
      }
    }
    this.ambientId.setValue(this.ambientColor);
    this.exposureId.setValue(scene.exposure);
    if (scene.skyboxModel) {
      this.skyboxIntensityId.setValue(scene.skyboxIntensity);
    }
  }, _resolveLight:function(scope, i) {
    var light = "light" + i;
    this.lightColorId[i] = scope.resolve(light + "_color");
    this.lightDirId[i] = scope.resolve(light + "_direction");
    this.lightShadowMapId[i] = scope.resolve(light + "_shadowMap");
    this.lightShadowMatrixId[i] = scope.resolve(light + "_shadowMatrix");
    this.lightShadowParamsId[i] = scope.resolve(light + "_shadowParams");
    this.lightShadowMatrixVsId[i] = scope.resolve(light + "_shadowMatrixVS");
    this.lightShadowParamsVsId[i] = scope.resolve(light + "_shadowParamsVS");
    this.lightDirVsId[i] = scope.resolve(light + "_directionVS");
    this.lightRadiusId[i] = scope.resolve(light + "_radius");
    this.lightPosId[i] = scope.resolve(light + "_position");
    this.lightInAngleId[i] = scope.resolve(light + "_innerConeAngle");
    this.lightOutAngleId[i] = scope.resolve(light + "_outerConeAngle");
    this.lightPosVsId[i] = scope.resolve(light + "_positionVS");
    this.lightCookieId[i] = scope.resolve(light + "_cookie");
    this.lightCookieIntId[i] = scope.resolve(light + "_cookieIntensity");
    this.lightCookieMatrixId[i] = scope.resolve(light + "_cookieMatrix");
    this.lightCookieOffsetId[i] = scope.resolve(light + "_cookieOffset");
  }, dispatchDirectLights:function(dirs, scene, mask) {
    var numDirs = dirs.length;
    var i;
    var directional, wtm;
    var cnt = 0;
    this.mainLight = -1;
    var scope = this.device.scope;
    for (i = 0;i < numDirs;i++) {
      if (!(dirs[i]._mask & mask)) {
        continue;
      }
      directional = dirs[i];
      wtm = directional._node.getWorldTransform();
      if (!this.lightColorId[cnt]) {
        this._resolveLight(scope, cnt);
      }
      this.lightColorId[cnt].setValue(scene.gammaCorrection ? directional._linearFinalColor.data : directional._finalColor.data);
      wtm.getY(directional._direction).scale(-1);
      this.lightDirId[cnt].setValue(directional._direction.normalize().data);
      if (directional.castShadows) {
        var shadowMap = directional._isPcf && this.device.webgl2 ? directional._shadowCamera.renderTarget.depthBuffer : directional._shadowCamera.renderTarget.colorBuffer;
        var bias;
        if (directional._isVsm) {
          bias = -0.00001 * 20;
        } else {
          bias = directional.shadowBias / directional._shadowCamera._farClip * 100;
          if (!this.device.webgl2 && this.device.extStandardDerivatives) {
            bias *= -100;
          }
        }
        var normalBias = directional._isVsm ? directional.vsmBias / (directional._shadowCamera._farClip / 7.0) : directional._normalOffsetBias;
        this.lightShadowMapId[cnt].setValue(shadowMap);
        this.lightShadowMatrixId[cnt].setValue(directional._shadowMatrix.data);
        var params = directional._rendererParams;
        if (params.length !== 3) {
          params.length = 3;
        }
        params[0] = directional._shadowResolution;
        params[1] = normalBias;
        params[2] = bias;
        this.lightShadowParamsId[cnt].setValue(params);
        if (this.mainLight < 0) {
          this.lightShadowMatrixVsId[cnt].setValue(directional._shadowMatrix.data);
          this.lightShadowParamsVsId[cnt].setValue(params);
          this.lightDirVsId[cnt].setValue(directional._direction.normalize().data);
          this.mainLight = i;
        }
      }
      cnt++;
    }
    return cnt;
  }, dispatchPointLight:function(scene, scope, point, cnt) {
    var wtm = point._node.getWorldTransform();
    if (!this.lightColorId[cnt]) {
      this._resolveLight(scope, cnt);
    }
    this.lightRadiusId[cnt].setValue(point.attenuationEnd);
    this.lightColorId[cnt].setValue(scene.gammaCorrection ? point._linearFinalColor.data : point._finalColor.data);
    wtm.getTranslation(point._position);
    this.lightPosId[cnt].setValue(point._position.data);
    if (point.castShadows) {
      var shadowMap = point._shadowCamera.renderTarget.colorBuffer;
      this.lightShadowMapId[cnt].setValue(shadowMap);
      var params = point._rendererParams;
      if (params.length !== 4) {
        params.length = 4;
      }
      params[0] = point._shadowResolution;
      params[1] = point._normalOffsetBias;
      params[2] = point.shadowBias;
      params[3] = 1.0 / point.attenuationEnd;
      this.lightShadowParamsId[cnt].setValue(params);
    }
    if (point._cookie) {
      this.lightCookieId[cnt].setValue(point._cookie);
      this.lightShadowMatrixId[cnt].setValue(wtm.data);
      this.lightCookieIntId[cnt].setValue(point.cookieIntensity);
    }
  }, dispatchSpotLight:function(scene, scope, spot, cnt) {
    var wtm = spot._node.getWorldTransform();
    if (!this.lightColorId[cnt]) {
      this._resolveLight(scope, cnt);
    }
    this.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);
    this.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);
    this.lightRadiusId[cnt].setValue(spot.attenuationEnd);
    this.lightColorId[cnt].setValue(scene.gammaCorrection ? spot._linearFinalColor.data : spot._finalColor.data);
    wtm.getTranslation(spot._position);
    this.lightPosId[cnt].setValue(spot._position.data);
    wtm.getY(spot._direction).scale(-1);
    this.lightDirId[cnt].setValue(spot._direction.normalize().data);
    if (spot.castShadows) {
      var bias;
      if (spot._isVsm) {
        bias = -0.00001 * 20;
      } else {
        bias = spot.shadowBias * 20;
        if (!this.device.webgl2 && this.device.extStandardDerivatives) {
          bias *= -100;
        }
      }
      var normalBias = spot._isVsm ? spot.vsmBias / (spot.attenuationEnd / 7.0) : spot._normalOffsetBias;
      var shadowMap = spot._isPcf && this.device.webgl2 ? spot._shadowCamera.renderTarget.depthBuffer : spot._shadowCamera.renderTarget.colorBuffer;
      this.lightShadowMapId[cnt].setValue(shadowMap);
      this.lightShadowMatrixId[cnt].setValue(spot._shadowMatrix.data);
      var params = spot._rendererParams;
      if (params.length !== 4) {
        params.length = 4;
      }
      params[0] = spot._shadowResolution;
      params[1] = normalBias;
      params[2] = bias;
      params[3] = 1.0 / spot.attenuationEnd;
      this.lightShadowParamsId[cnt].setValue(params);
    }
    if (spot._cookie) {
      this.lightCookieId[cnt].setValue(spot._cookie);
      if (!spot.castShadows) {
        var shadowCam = this.getShadowCamera(this.device, spot);
        var shadowCamNode = shadowCam._node;
        shadowCamNode.setPosition(spot._node.getPosition());
        shadowCamNode.setRotation(spot._node.getRotation());
        shadowCamNode.rotateLocal(-90, 0, 0);
        shadowCam.projection = pc.PROJECTION_PERSPECTIVE;
        shadowCam.aspectRatio = 1;
        shadowCam.fov = spot._outerConeAngle * 2;
        shadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), pc.Vec3.ONE).invert();
        shadowCamViewProj.mul2(shadowCam.getProjectionMatrix(), shadowCamView);
        spot._shadowMatrix.mul2(scaleShift, shadowCamViewProj);
      }
      this.lightShadowMatrixId[cnt].setValue(spot._shadowMatrix.data);
      this.lightCookieIntId[cnt].setValue(spot.cookieIntensity);
      if (spot._cookieTransform) {
        this.lightCookieMatrixId[cnt].setValue(spot._cookieTransform.data);
        this.lightCookieOffsetId[cnt].setValue(spot._cookieOffset.data);
      }
    }
  }, dispatchLocalLights:function(sortedLights, scene, mask, usedDirLights, staticLightList) {
    var i;
    var point, spot;
    var pnts = sortedLights[pc.LIGHTTYPE_POINT];
    var spts = sortedLights[pc.LIGHTTYPE_SPOT];
    var numDirs = usedDirLights;
    var numPnts = pnts.length;
    var numSpts = spts.length;
    var cnt = numDirs;
    var scope = this.device.scope;
    for (i = 0;i < numPnts;i++) {
      point = pnts[i];
      if (!(point._mask & mask)) {
        continue;
      }
      if (point.isStatic) {
        continue;
      }
      this.dispatchPointLight(scene, scope, point, cnt);
      cnt++;
    }
    var staticId = 0;
    if (staticLightList) {
      point = staticLightList[staticId];
      while (point && point._type === pc.LIGHTTYPE_POINT) {
        this.dispatchPointLight(scene, scope, point, cnt);
        cnt++;
        staticId++;
        point = staticLightList[staticId];
      }
    }
    for (i = 0;i < numSpts;i++) {
      spot = spts[i];
      if (!(spot._mask & mask)) {
        continue;
      }
      if (spot.isStatic) {
        continue;
      }
      this.dispatchSpotLight(scene, scope, spot, cnt);
      cnt++;
    }
    if (staticLightList) {
      spot = staticLightList[staticId];
      while (spot && spot._type === pc.LIGHTTYPE_SPOT) {
        this.dispatchSpotLight(scene, scope, spot, cnt);
        cnt++;
        staticId++;
        spot = staticLightList[staticId];
      }
    }
  }, cull:function(camera, drawCalls, visibleList) {
    var visibleLength = 0;
    var i, drawCall, visible;
    var drawCallsCount = drawCalls.length;
    var cullingMask = camera.cullingMask || 4294967295;
    if (!camera.frustumCulling) {
      for (i = 0;i < drawCallsCount;i++) {
        drawCall = drawCalls[i];
        if (!drawCall.visible && !drawCall.command) {
          continue;
        }
        if (drawCall.mask && (drawCall.mask & cullingMask) === 0) {
          continue;
        }
        visibleList[visibleLength] = drawCall;
        visibleLength++;
        drawCall.visibleThisFrame = true;
      }
      return visibleLength;
    }
    for (i = 0;i < drawCallsCount;i++) {
      drawCall = drawCalls[i];
      if (!drawCall.command) {
        if (!drawCall.visible) {
          continue;
        }
        visible = true;
        if (drawCall.mask && (drawCall.mask & cullingMask) === 0) {
          continue;
        }
        if (drawCall.cull) {
          visible = this._isVisible(camera, drawCall);
        }
        if (visible) {
          visibleList[visibleLength] = drawCall;
          visibleLength++;
          drawCall.visibleThisFrame = true;
        }
      } else {
        visibleList[visibleLength] = drawCall;
        visibleLength++;
        drawCall.visibleThisFrame = true;
      }
    }
    return visibleLength;
  }, cullLights:function(camera, lights) {
    var i, light, type;
    for (i = 0;i < lights.length;i++) {
      light = lights[i];
      type = light._type;
      if (light.castShadows && light._enabled && light.shadowUpdateMode !== pc.SHADOWUPDATE_NONE) {
        if (type !== pc.LIGHTTYPE_DIRECTIONAL) {
          light.getBoundingSphere(tempSphere);
          if (!camera.frustum.containsSphere(tempSphere)) {
            continue;
          }
          light.visibleThisFrame = true;
        }
      }
    }
  }, updateCpuSkinMatrices:function(drawCalls) {
    var drawCallsCount = drawCalls.length;
    if (drawCallsCount === 0) {
      return;
    }
    var i, skin;
    for (i = 0;i < drawCallsCount;i++) {
      skin = drawCalls[i].skinInstance;
      if (skin) {
        skin.updateMatrices(drawCalls[i].node);
        skin._dirty = true;
      }
    }
  }, updateGpuSkinMatrices:function(drawCalls) {
    var i, skin;
    var drawCallsCount = drawCalls.length;
    for (i = 0;i < drawCallsCount;i++) {
      if (!drawCalls[i].visibleThisFrame) {
        continue;
      }
      skin = drawCalls[i].skinInstance;
      if (skin) {
        if (skin._dirty) {
          skin.updateMatrixPalette();
          skin._dirty = false;
        }
      }
    }
  }, updateMorphedBounds:function(drawCalls) {
    var i, morph;
    var drawCallsCount = drawCalls.length;
    for (i = 0;i < drawCallsCount;i++) {
      morph = drawCalls[i].morphInstance;
      if (morph && morph._dirty) {
        morph.updateBounds(drawCalls[i].mesh);
      }
    }
  }, updateMorphing:function(drawCalls) {
    var i, morph;
    var drawCallsCount = drawCalls.length;
    for (i = 0;i < drawCallsCount;i++) {
      if (!drawCalls[i].visibleThisFrame) {
        continue;
      }
      morph = drawCalls[i].morphInstance;
      if (morph && morph._dirty) {
        morph.update(drawCalls[i].mesh);
        morph._dirty = false;
      }
    }
  }, setBaseConstants:function(device, material) {
    device.setCullMode(material.cull);
    if (material.opacityMap) {
      this.opacityMapId.setValue(material.opacityMap);
      this.alphaTestId.setValue(material.alphaTest);
    }
  }, setSkinning:function(device, meshInstance, material) {
    if (meshInstance.skinInstance) {
      this._skinDrawCalls++;
      if (device.supportsBoneTextures) {
        boneTexture = meshInstance.skinInstance.boneTexture;
        this.boneTextureId.setValue(boneTexture);
        boneTextureSize[0] = boneTexture.width;
        boneTextureSize[1] = boneTexture.height;
        this.boneTextureSizeId.setValue(boneTextureSize);
      } else {
        this.poseMatrixId.setValue(meshInstance.skinInstance.matrixPalette);
      }
    }
  }, drawInstance:function(device, meshInstance, mesh, style, normal) {
    instancingData = meshInstance.instancingData;
    if (instancingData) {
      this._instancedDrawCalls++;
      this._removedByInstancing += instancingData.count;
      device.setVertexBuffer(instancingData._buffer, 1, instancingData.offset);
      device.draw(mesh.primitive[style], instancingData.count);
      if (instancingData._buffer === pc._autoInstanceBuffer) {
        meshInstance.instancingData = null;
        return instancingData.count - 1;
      }
    } else {
      modelMatrix = meshInstance.node.worldTransform;
      this.modelMatrixId.setValue(modelMatrix.data);
      if (normal) {
        normalMatrix = meshInstance.node.normalMatrix;
        if (meshInstance.node._dirtyNormal) {
          modelMatrix.invertTo3x3(normalMatrix);
          normalMatrix.transpose();
          meshInstance.node._dirtyNormal = false;
        }
        this.normalMatrixId.setValue(normalMatrix.data);
      }
      device.draw(mesh.primitive[style]);
      return 0;
    }
  }, drawInstance2:function(device, meshInstance, mesh, style) {
    instancingData = meshInstance.instancingData;
    if (instancingData) {
      this._instancedDrawCalls++;
      this._removedByInstancing += instancingData.count;
      device.setVertexBuffer(instancingData._buffer, 1, instancingData.offset);
      device.draw(mesh.primitive[style], instancingData.count);
      if (instancingData._buffer === pc._autoInstanceBuffer) {
        meshInstance.instancingData = null;
        return instancingData.count - 1;
      }
    } else {
      device.draw(mesh.primitive[style]);
      return 0;
    }
  }, renderShadows:function(lights, cameraPass) {
    var device = this.device;
    var i, j, light, shadowShader, type, shadowCam, shadowCamNode, pass, passes, shadowType, smode;
    var numInstances;
    var meshInstance, mesh, material;
    var style;
    var settings;
    var visibleList, visibleLength;
    var passFlag = 1 << pc.SHADER_SHADOW;
    var paramName, parameter, parameters;
    for (i = 0;i < lights.length;i++) {
      light = lights[i];
      type = light._type;
      if (!light.castShadows || !light._enabled) {
        continue;
      }
      if (!light._shadowCamera) {
        this.getShadowCamera(device, light);
      }
      if (light.shadowUpdateMode !== pc.SHADOWUPDATE_NONE && light.visibleThisFrame) {
        shadowCam = this.getShadowCamera(device, light);
        shadowCamNode = shadowCam._node;
        pass = 0;
        passes = 1;
        if (type === pc.LIGHTTYPE_DIRECTIONAL) {
          if (light._visibleLength[cameraPass] < 0) {
            continue;
          }
          settings = light._visibleCameraSettings[cameraPass];
          shadowCamNode.setPosition(settings.x, settings.y, settings.z);
          shadowCam.orthoHeight = settings.orthoHeight;
          shadowCam.farClip = settings.farClip;
          pass = cameraPass;
        } else {
          if (type === pc.LIGHTTYPE_SPOT) {
            this.viewPosId.setValue(shadowCamNode.getPosition().data);
            this.shadowMapLightRadiusId.setValue(light.attenuationEnd);
          } else {
            if (type === pc.LIGHTTYPE_POINT) {
              this.viewPosId.setValue(shadowCamNode.getPosition().data);
              this.shadowMapLightRadiusId.setValue(light.attenuationEnd);
              passes = 6;
            }
          }
        }
        if (type !== pc.LIGHTTYPE_POINT) {
          shadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), pc.Vec3.ONE).invert();
          shadowCamViewProj.mul2(shadowCam.getProjectionMatrix(), shadowCamView);
          light._shadowMatrix.mul2(scaleShift, shadowCamViewProj);
        }
        if (device.webgl2) {
          if (type === pc.LIGHTTYPE_POINT) {
            device.setDepthBias(false);
          } else {
            device.setDepthBias(true);
            device.setDepthBiasValues(light.shadowBias * -1000.0, light.shadowBias * -1000.0);
          }
        } else {
          if (device.extStandardDerivatives) {
            if (type === pc.LIGHTTYPE_POINT) {
              this.polygonOffset[0] = 0;
              this.polygonOffset[1] = 0;
              this.polygonOffsetId.setValue(this.polygonOffset);
            } else {
              this.polygonOffset[0] = light.shadowBias * -1000.0;
              this.polygonOffset[1] = light.shadowBias * -1000.0;
              this.polygonOffsetId.setValue(this.polygonOffset);
            }
          }
        }
        if (light.shadowUpdateMode === pc.SHADOWUPDATE_THISFRAME) {
          light.shadowUpdateMode = pc.SHADOWUPDATE_NONE;
        }
        this._shadowMapUpdates += passes;
        device.setBlending(false);
        device.setDepthWrite(true);
        device.setDepthTest(true);
        if (light._isPcf && device.webgl2 && type !== pc.LIGHTTYPE_POINT) {
          device.setColorWrite(false, false, false, false);
        } else {
          device.setColorWrite(true, true, true, true);
        }
        if (pass) {
          passes = pass + 1;
        } else {
          pass = 0;
        }
        while (pass < passes) {
          if (type === pc.LIGHTTYPE_POINT) {
            shadowCamNode.setRotation(pointLightRotations[pass]);
            shadowCam.renderTarget = light._shadowCubeMap[pass];
          }
          this.setCamera(shadowCam, shadowCam.renderTarget, true, type !== pc.LIGHTTYPE_POINT);
          visibleList = light._visibleList[pass];
          visibleLength = light._visibleLength[pass];
          shadowType = light._shadowType;
          smode = shadowType + type * numShadowModes;
          for (j = 0, numInstances = visibleLength;j < numInstances;j++) {
            meshInstance = visibleList[j];
            mesh = meshInstance.mesh;
            material = meshInstance.material;
            this.setBaseConstants(device, material);
            this.setSkinning(device, meshInstance, material);
            if (material.chunks) {
              parameters = material.parameters;
              for (paramName in parameters) {
                parameter = parameters[paramName];
                if (parameter.passFlags & passFlag) {
                  if (!parameter.scopeId) {
                    parameter.scopeId = device.scope.resolve(paramName);
                  }
                  parameter.scopeId.setValue(parameter.data);
                }
              }
              parameters = meshInstance.parameters;
              for (paramName in parameters) {
                parameter = parameters[paramName];
                if (parameter.passFlags & passFlag) {
                  if (!parameter.scopeId) {
                    parameter.scopeId = device.scope.resolve(paramName);
                  }
                  parameter.scopeId.setValue(parameter.data);
                }
              }
            }
            shadowShader = meshInstance._shader[pc.SHADER_SHADOW + smode];
            if (!shadowShader) {
              this.updateShader(meshInstance, meshInstance._shaderDefs, null, pc.SHADER_SHADOW + smode);
              shadowShader = meshInstance._shader[pc.SHADER_SHADOW + smode];
              meshInstance._key[pc.SORTKEY_DEPTH] = getDepthKey(meshInstance);
            }
            device.setShader(shadowShader);
            style = meshInstance.renderStyle;
            device.setVertexBuffer(meshInstance.morphInstance && meshInstance.morphInstance._vertexBuffer ? meshInstance.morphInstance._vertexBuffer : mesh.vertexBuffer, 0);
            device.setIndexBuffer(mesh.indexBuffer[style]);
            j += this.drawInstance(device, meshInstance, mesh, style);
            this._shadowDrawCalls++;
          }
          pass++;
          if (type === pc.LIGHTTYPE_DIRECTIONAL) {
            light._visibleLength[cameraPass] = -1;
          }
        }
        if (light._isVsm) {
          var filterSize = light._vsmBlurSize;
          if (filterSize > 1) {
            var origShadowMap = shadowCam.renderTarget;
            var tempRt = getShadowMapFromCache(device, light._shadowResolution, light._shadowType, 1);
            var isVsm8 = light._shadowType === pc.SHADOW_VSM8;
            var blurMode = light.vsmBlurMode;
            var blurShader = (isVsm8 ? this.blurPackedVsmShader : this.blurVsmShader)[blurMode][filterSize];
            if (!blurShader) {
              this.blurVsmWeights[filterSize] = gaussWeights(filterSize);
              var blurVS = pc.shaderChunks.fullscreenQuadVS;
              var blurFS = "#define SAMPLES " + filterSize + "\n";
              if (isVsm8) {
                blurFS += this.blurPackedVsmShaderCode[blurMode];
              } else {
                blurFS += this.blurVsmShaderCode[blurMode];
              }
              var blurShaderName = "blurVsm" + blurMode + "" + filterSize + "" + isVsm8;
              blurShader = pc.shaderChunks.createShaderFromCode(this.device, blurVS, blurFS, blurShaderName);
              if (isVsm8) {
                this.blurPackedVsmShader[blurMode][filterSize] = blurShader;
              } else {
                this.blurVsmShader[blurMode][filterSize] = blurShader;
              }
            }
            blurScissorRect.z = light._shadowResolution - 2;
            blurScissorRect.w = blurScissorRect.z;
            this.sourceId.setValue(origShadowMap.colorBuffer);
            pixelOffset.x = 1.0 / light._shadowResolution;
            pixelOffset.y = 0.0;
            this.pixelOffsetId.setValue(pixelOffset.data);
            if (blurMode === pc.BLUR_GAUSSIAN) {
              this.weightId.setValue(this.blurVsmWeights[filterSize]);
            }
            pc.drawQuadWithShader(device, tempRt, blurShader, null, blurScissorRect);
            this.sourceId.setValue(tempRt.colorBuffer);
            pixelOffset.y = pixelOffset.x;
            pixelOffset.x = 0.0;
            this.pixelOffsetId.setValue(pixelOffset.data);
            pc.drawQuadWithShader(device, origShadowMap, blurShader, null, blurScissorRect);
          }
        }
      }
    }
    if (device.webgl2) {
      device.setDepthBias(false);
    } else {
      if (device.extStandardDerivatives) {
        this.polygonOffset[0] = 0;
        this.polygonOffset[1] = 0;
        this.polygonOffsetId.setValue(this.polygonOffset);
      }
    }
  }, updateShader:function(meshInstance, objDefs, staticLightList, pass, sortedLights) {
    meshInstance.material._scene = this.scene;
    meshInstance.material.updateShader(this.device, this.scene, objDefs, staticLightList, pass, sortedLights);
    meshInstance._shader[pass] = meshInstance.material.shader;
  }, renderForward:function(camera, drawCalls, drawCallsCount, sortedLights, pass, cullingMask, drawCallback, layer) {
    var device = this.device;
    var scene = this.scene;
    var vrDisplay = camera.vrDisplay;
    var passFlag = 1 << pass;
    var lightHash = layer ? layer._lightHash : 0;
    var i, drawCall, mesh, material, objDefs, variantKey, lightMask, style, usedDirLights;
    var prevMaterial = null, prevObjDefs, prevLightMask, prevStatic;
    var paramName, parameter, parameters;
    var stencilFront, stencilBack;
    var halfWidth = device.width * 0.5;
    for (i = 0;i < drawCallsCount;i++) {
      drawCall = drawCalls[i];
      if (cullingMask && drawCall.mask && !(cullingMask & drawCall.mask)) {
        continue;
      }
      if (drawCall.command) {
        drawCall.command();
      } else {
        mesh = drawCall.mesh;
        material = drawCall.material;
        objDefs = drawCall._shaderDefs;
        lightMask = drawCall.mask;
        this.setSkinning(device, drawCall, material);
        if (material && material === prevMaterial && objDefs !== prevObjDefs) {
          prevMaterial = null;
        }
        if (drawCall.isStatic || prevStatic) {
          prevMaterial = null;
        }
        if (material !== prevMaterial) {
          this._materialSwitches++;
          if (!drawCall._shader[pass] || drawCall._shaderDefs !== objDefs || drawCall._lightHash !== lightHash) {
            if (!drawCall.isStatic) {
              variantKey = pass + "_" + objDefs + "_" + lightHash;
              drawCall._shader[pass] = material.variants[variantKey];
              if (!drawCall._shader[pass]) {
                this.updateShader(drawCall, objDefs, null, pass, sortedLights);
                material.variants[variantKey] = drawCall._shader[pass];
              }
            } else {
              this.updateShader(drawCall, objDefs, drawCall._staticLightList, pass, sortedLights);
            }
            drawCall._shaderDefs = objDefs;
            drawCall._lightHash = lightHash;
          }
          device.setShader(drawCall._shader[pass]);
          parameters = material.parameters;
          for (paramName in parameters) {
            parameter = parameters[paramName];
            if (parameter.passFlags & passFlag) {
              if (!parameter.scopeId) {
                parameter.scopeId = device.scope.resolve(paramName);
              }
              parameter.scopeId.setValue(parameter.data);
            }
          }
          if (!prevMaterial || lightMask !== prevLightMask) {
            usedDirLights = this.dispatchDirectLights(sortedLights[pc.LIGHTTYPE_DIRECTIONAL], scene, lightMask);
            this.dispatchLocalLights(sortedLights, scene, lightMask, usedDirLights, drawCall._staticLightList);
          }
          this.alphaTestId.setValue(material.alphaTest);
          device.setBlending(material.blend);
          if (material.blend) {
            if (material.separateAlphaBlend) {
              device.setBlendFunctionSeparate(material.blendSrc, material.blendDst, material.blendSrcAlpha, material.blendDstAlpha);
              device.setBlendEquationSeparate(material.blendEquation, material.blendAlphaEquation);
            } else {
              device.setBlendFunction(material.blendSrc, material.blendDst);
              device.setBlendEquation(material.blendEquation);
            }
          }
          device.setColorWrite(material.redWrite, material.greenWrite, material.blueWrite, material.alphaWrite);
          if (camera._cullFaces) {
            if (camera._flipFaces) {
              device.setCullMode(material.cull > 0 ? material.cull === pc.CULLFACE_FRONT ? pc.CULLFACE_BACK : pc.CULLFACE_FRONT : 0);
            } else {
              device.setCullMode(material.cull);
            }
          } else {
            device.setCullMode(pc.CULLFACE_NONE);
          }
          device.setDepthWrite(material.depthWrite);
          device.setDepthTest(material.depthTest);
          device.setAlphaToCoverage(material.alphaToCoverage);
          if (material.depthBias || material.slopeDepthBias) {
            device.setDepthBias(true);
            device.setDepthBiasValues(material.depthBias, material.slopeDepthBias);
          } else {
            device.setDepthBias(false);
          }
        }
        stencilFront = drawCall.stencilFront || material.stencilFront;
        stencilBack = drawCall.stencilBack || material.stencilBack;
        if (stencilFront || stencilBack) {
          device.setStencilTest(true);
          if (stencilFront === stencilBack) {
            device.setStencilFunc(stencilFront.func, stencilFront.ref, stencilFront.readMask);
            device.setStencilOperation(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
          } else {
            if (stencilFront) {
              device.setStencilFuncFront(stencilFront.func, stencilFront.ref, stencilFront.readMask);
              device.setStencilOperationFront(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
            } else {
              device.setStencilFuncFront(pc.FUNC_ALWAYS, 0, 255);
              device.setStencilOperationFront(pc.STENCILOP_KEEP, pc.STENCILOP_KEEP, pc.STENCILOP_KEEPP, 255);
            }
            if (stencilBack) {
              device.setStencilFuncBack(stencilBack.func, stencilBack.ref, stencilBack.readMask);
              device.setStencilOperationBack(stencilBack.fail, stencilBack.zfail, stencilBack.zpass, stencilBack.writeMask);
            } else {
              device.setStencilFuncBack(pc.FUNC_ALWAYS, 0, 255);
              device.setStencilOperationBack(pc.STENCILOP_KEEP, pc.STENCILOP_KEEP, pc.STENCILOP_KEEP, 255);
            }
          }
        } else {
          device.setStencilTest(false);
        }
        parameters = drawCall.parameters;
        for (paramName in parameters) {
          parameter = parameters[paramName];
          if (parameter.passFlags & passFlag) {
            if (!parameter.scopeId) {
              parameter.scopeId = device.scope.resolve(paramName);
            }
            parameter.scopeId.setValue(parameter.data);
          }
        }
        device.setVertexBuffer(drawCall.morphInstance && drawCall.morphInstance._vertexBuffer ? drawCall.morphInstance._vertexBuffer : mesh.vertexBuffer, 0);
        style = drawCall.renderStyle;
        device.setIndexBuffer(mesh.indexBuffer[style]);
        if (drawCallback) {
          drawCallback(drawCall, i);
        }
        if (vrDisplay && vrDisplay.presenting) {
          device.setViewport(0, 0, halfWidth, device.height);
          this.projId.setValue(projL.data);
          this.viewInvId.setValue(viewInvL.data);
          this.viewId.setValue(viewL.data);
          this.viewId3.setValue(viewMat3L.data);
          this.viewProjId.setValue(viewProjMatL.data);
          this.viewPosId.setValue(viewPosL.data);
          i += this.drawInstance(device, drawCall, mesh, style, true);
          this._forwardDrawCalls++;
          device.setViewport(halfWidth, 0, halfWidth, device.height);
          this.projId.setValue(projR.data);
          this.viewInvId.setValue(viewInvR.data);
          this.viewId.setValue(viewR.data);
          this.viewId3.setValue(viewMat3R.data);
          this.viewProjId.setValue(viewProjMatR.data);
          this.viewPosId.setValue(viewPosR.data);
          i += this.drawInstance2(device, drawCall, mesh, style);
          this._forwardDrawCalls++;
        } else {
          i += this.drawInstance(device, drawCall, mesh, style, true);
          this._forwardDrawCalls++;
        }
        if (i < drawCallsCount - 1 && drawCalls[i + 1].material === material) {
          for (paramName in parameters) {
            parameter = material.parameters[paramName];
            if (parameter) {
              if (!parameter.scopeId) {
                parameter.scopeId = device.scope.resolve(paramName);
              }
              parameter.scopeId.setValue(parameter.data);
            }
          }
        }
        prevMaterial = material;
        prevObjDefs = objDefs;
        prevLightMask = lightMask;
        prevStatic = drawCall.isStatic;
      }
    }
    device.updateEnd();
  }, setupInstancing:function(device) {
    if (!pc._instanceVertexFormat) {
      var formatDesc = [{semantic:pc.SEMANTIC_TEXCOORD2, components:4, type:pc.TYPE_FLOAT32}, {semantic:pc.SEMANTIC_TEXCOORD3, components:4, type:pc.TYPE_FLOAT32}, {semantic:pc.SEMANTIC_TEXCOORD4, components:4, type:pc.TYPE_FLOAT32}, {semantic:pc.SEMANTIC_TEXCOORD5, components:4, type:pc.TYPE_FLOAT32}];
      pc._instanceVertexFormat = new pc.VertexFormat(device, formatDesc);
    }
    if (device.enableAutoInstancing) {
      if (!pc._autoInstanceBuffer) {
        pc._autoInstanceBuffer = new pc.VertexBuffer(device, pc._instanceVertexFormat, device.autoInstancingMaxObjects, pc.BUFFER_DYNAMIC);
        pc._autoInstanceBufferData = new Float32Array(pc._autoInstanceBuffer.lock());
      }
    }
  }, revertStaticMeshes:function(meshInstances) {
    var i;
    var drawCalls = meshInstances;
    var drawCallsCount = drawCalls.length;
    var drawCall;
    var newDrawCalls = [];
    var prevStaticSource;
    for (i = 0;i < drawCallsCount;i++) {
      drawCall = drawCalls[i];
      if (drawCall._staticSource) {
        if (drawCall._staticSource !== prevStaticSource) {
          newDrawCalls.push(drawCall._staticSource);
          prevStaticSource = drawCall._staticSource;
        }
      } else {
        newDrawCalls.push(drawCall);
      }
    }
    meshInstances.length = newDrawCalls.length;
    for (i = 0;i < newDrawCalls.length;i++) {
      meshInstances[i] = newDrawCalls[i];
    }
  }, prepareStaticMeshes:function(meshInstances, lights) {
    var i, j, k, v, s, index;
    var device = this.device;
    var scene = this.scene;
    var drawCalls = meshInstances;
    var drawCallsCount = drawCalls.length;
    var drawCall, light;
    var newDrawCalls = [];
    var mesh;
    var indices, verts, numTris, elems, vertSize, offsetP, baseIndex;
    var _x, _y, _z;
    var minx, miny, minz, maxx, maxy, maxz;
    var minv, maxv;
    var minVec = new pc.Vec3;
    var maxVec = new pc.Vec3;
    var localLightBounds = new pc.BoundingBox;
    var invMatrix = new pc.Mat4;
    var triLightComb = [];
    var triLightCombUsed;
    var indexBuffer, vertexBuffer;
    var combIndices, combIbName, combIb;
    var lightTypePass;
    var lightAabb = [];
    var aabb;
    var triBounds = [];
    var staticLights = [];
    var bit;
    var lht;
    for (i = 0;i < drawCallsCount;i++) {
      drawCall = drawCalls[i];
      if (!drawCall.isStatic) {
        newDrawCalls.push(drawCall);
      } else {
        aabb = drawCall.aabb;
        staticLights.length = 0;
        for (lightTypePass = pc.LIGHTTYPE_POINT;lightTypePass <= pc.LIGHTTYPE_SPOT;lightTypePass++) {
          for (j = 0;j < lights.length;j++) {
            light = lights[j];
            if (light._type !== lightTypePass) {
              continue;
            }
            if (light._enabled) {
              if (light._mask & drawCall.mask) {
                if (light.isStatic) {
                  if (!lightAabb[j]) {
                    lightAabb[j] = new pc.BoundingBox;
                    light._node.getWorldTransform();
                    light.getBoundingSphere(tempSphere);
                    lightAabb[j].center.copy(tempSphere.center);
                    lightAabb[j].halfExtents.x = tempSphere.radius;
                    lightAabb[j].halfExtents.y = tempSphere.radius;
                    lightAabb[j].halfExtents.z = tempSphere.radius;
                  }
                  if (!lightAabb[j].intersects(aabb)) {
                    continue;
                  }
                  staticLights.push(j);
                }
              }
            }
          }
        }
        if (staticLights.length === 0) {
          newDrawCalls.push(drawCall);
          continue;
        }
        mesh = drawCall.mesh;
        vertexBuffer = mesh.vertexBuffer;
        indexBuffer = mesh.indexBuffer[drawCall.renderStyle];
        indices = indexBuffer.bytesPerIndex === 2 ? new Uint16Array(indexBuffer.lock()) : new Uint32Array(indexBuffer.lock());
        numTris = mesh.primitive[drawCall.renderStyle].count / 3;
        baseIndex = mesh.primitive[drawCall.renderStyle].base;
        elems = vertexBuffer.format.elements;
        vertSize = vertexBuffer.format.size / 4;
        verts = new Float32Array(vertexBuffer.storage);
        for (k = 0;k < elems.length;k++) {
          if (elems[k].name === pc.SEMANTIC_POSITION) {
            offsetP = elems[k].offset / 4;
          }
        }
        triLightComb.length = numTris;
        for (k = 0;k < numTris;k++) {
          triLightComb[k] = 0;
        }
        triLightCombUsed = false;
        triBounds.length = numTris * 6;
        for (k = 0;k < numTris;k++) {
          minx = Number.MAX_VALUE;
          miny = Number.MAX_VALUE;
          minz = Number.MAX_VALUE;
          maxx = -Number.MAX_VALUE;
          maxy = -Number.MAX_VALUE;
          maxz = -Number.MAX_VALUE;
          for (v = 0;v < 3;v++) {
            index = indices[k * 3 + v + baseIndex];
            index = index * vertSize + offsetP;
            _x = verts[index];
            _y = verts[index + 1];
            _z = verts[index + 2];
            if (_x < minx) {
              minx = _x;
            }
            if (_y < miny) {
              miny = _y;
            }
            if (_z < minz) {
              minz = _z;
            }
            if (_x > maxx) {
              maxx = _x;
            }
            if (_y > maxy) {
              maxy = _y;
            }
            if (_z > maxz) {
              maxz = _z;
            }
          }
          index = k * 6;
          triBounds[index] = minx;
          triBounds[index + 1] = miny;
          triBounds[index + 2] = minz;
          triBounds[index + 3] = maxx;
          triBounds[index + 4] = maxy;
          triBounds[index + 5] = maxz;
        }
        for (s = 0;s < staticLights.length;s++) {
          j = staticLights[s];
          light = lights[j];
          invMatrix.copy(drawCall.node.worldTransform).invert();
          localLightBounds.setFromTransformedAabb(lightAabb[j], invMatrix);
          minv = localLightBounds.getMin().data;
          maxv = localLightBounds.getMax().data;
          bit = 1 << s;
          for (k = 0;k < numTris;k++) {
            index = k * 6;
            if (triBounds[index] <= maxv[0] && triBounds[index + 3] >= minv[0] && triBounds[index + 1] <= maxv[1] && triBounds[index + 4] >= minv[1] && triBounds[index + 2] <= maxv[2] && triBounds[index + 5] >= minv[2]) {
              triLightComb[k] |= bit;
              triLightCombUsed = true;
            }
          }
        }
        if (triLightCombUsed) {
          combIndices = {};
          for (k = 0;k < numTris;k++) {
            j = k * 3 + baseIndex;
            combIbName = triLightComb[k];
            if (!combIndices[combIbName]) {
              combIndices[combIbName] = [];
            }
            combIb = combIndices[combIbName];
            combIb.push(indices[j]);
            combIb.push(indices[j + 1]);
            combIb.push(indices[j + 2]);
          }
          for (combIbName in combIndices) {
            combIb = combIndices[combIbName];
            var ib = new pc.IndexBuffer(device, indexBuffer.format, combIb.length, indexBuffer.usage);
            var ib2 = ib.bytesPerIndex === 2 ? new Uint16Array(ib.lock()) : new Uint32Array(ib.lock());
            ib2.set(combIb);
            ib.unlock();
            minx = Number.MAX_VALUE;
            miny = Number.MAX_VALUE;
            minz = Number.MAX_VALUE;
            maxx = -Number.MAX_VALUE;
            maxy = -Number.MAX_VALUE;
            maxz = -Number.MAX_VALUE;
            for (k = 0;k < combIb.length;k++) {
              index = combIb[k];
              _x = verts[index * vertSize + offsetP];
              _y = verts[index * vertSize + offsetP + 1];
              _z = verts[index * vertSize + offsetP + 2];
              if (_x < minx) {
                minx = _x;
              }
              if (_y < miny) {
                miny = _y;
              }
              if (_z < minz) {
                minz = _z;
              }
              if (_x > maxx) {
                maxx = _x;
              }
              if (_y > maxy) {
                maxy = _y;
              }
              if (_z > maxz) {
                maxz = _z;
              }
            }
            minVec.set(minx, miny, minz);
            maxVec.set(maxx, maxy, maxz);
            var chunkAabb = new pc.BoundingBox;
            chunkAabb.setMinMax(minVec, maxVec);
            var mesh2 = new pc.Mesh;
            mesh2.vertexBuffer = vertexBuffer;
            mesh2.indexBuffer[0] = ib;
            mesh2.primitive[0].type = pc.PRIMITIVE_TRIANGLES;
            mesh2.primitive[0].base = 0;
            mesh2.primitive[0].count = combIb.length;
            mesh2.primitive[0].indexed = true;
            mesh2.aabb = chunkAabb;
            var instance = new pc.MeshInstance(drawCall.node, mesh2, drawCall.material);
            instance.isStatic = drawCall.isStatic;
            instance.visible = drawCall.visible;
            instance.layer = drawCall.layer;
            instance.castShadow = drawCall.castShadow;
            instance._receiveShadow = drawCall._receiveShadow;
            instance.cull = drawCall.cull;
            instance.pick = drawCall.pick;
            instance.mask = drawCall.mask;
            instance.parameters = drawCall.parameters;
            instance._shaderDefs = drawCall._shaderDefs;
            instance._staticSource = drawCall;
            if (drawCall._staticLightList) {
              instance._staticLightList = drawCall._staticLightList;
            } else {
              instance._staticLightList = [];
            }
            for (k = 0;k < staticLights.length;k++) {
              bit = 1 << k;
              if (combIbName & bit) {
                lht = lights[staticLights[k]];
                if (instance._staticLightList.indexOf(lht) < 0) {
                  instance._staticLightList.push(lht);
                }
              }
            }
            instance._staticLightList.sort(this.lightCompare);
            newDrawCalls.push(instance);
          }
        } else {
          newDrawCalls.push(drawCall);
        }
      }
    }
    meshInstances.length = newDrawCalls.length;
    for (i = 0;i < newDrawCalls.length;i++) {
      meshInstances[i] = newDrawCalls[i];
    }
  }, updateShaders:function(drawCalls) {
    var i;
    var materials = [];
    for (i = 0;i < drawCalls.length;i++) {
      var drawCall = drawCalls[i];
      if (drawCall.material !== undefined) {
        if (materials.indexOf(drawCall.material) === -1) {
          materials.push(drawCall.material);
        }
      }
    }
    for (i = 0;i < materials.length;i++) {
      var mat = materials[i];
      if (mat.updateShader !== pc.Material.prototype.updateShader) {
        mat.clearVariants();
        mat.shader = null;
      }
    }
  }, beginFrame:function(comp) {
    var device = this.device;
    var scene = this.scene;
    var meshInstances = comp._meshInstances;
    var lights = comp._lights;
    if (scene.updateSkybox) {
      scene._updateSkybox(device);
      scene.updateSkybox = false;
    }
    if (scene.updateShaders) {
      this.updateShaders(meshInstances);
      scene.updateShaders = false;
      scene._shaderVersion++;
    }
    this.updateCpuSkinMatrices(meshInstances);
    this.updateMorphedBounds(meshInstances);
    var i;
    var len = meshInstances.length;
    for (i = 0;i < len;i++) {
      meshInstances[i].visibleThisFrame = false;
    }
    len = lights.length;
    for (i = 0;i < len;i++) {
      lights[i].visibleThisFrame = lights[i]._type === pc.LIGHTTYPE_DIRECTIONAL;
    }
  }, beginLayers:function(comp) {
    var scene = this.scene;
    var len = comp.layerList.length;
    var layer;
    var i, j;
    var shaderVersion = this.scene._shaderVersion;
    for (i = 0;i < len;i++) {
      comp.layerList[i]._postRenderCounter = 0;
    }
    var transparent;
    for (i = 0;i < len;i++) {
      layer = comp.layerList[i];
      layer._shaderVersion = shaderVersion;
      layer._preRenderCalledForCameras = 0;
      layer._postRenderCalledForCameras = 0;
      transparent = comp.subLayerList[i];
      if (transparent) {
        layer._postRenderCounter |= 2;
      } else {
        layer._postRenderCounter |= 1;
      }
      layer._postRenderCounterMax = layer._postRenderCounter;
      for (j = 0;j < layer.cameras.length;j++) {
        if (!layer.instances.visibleOpaque[j]) {
          layer.instances.visibleOpaque[j] = new pc.VisibleInstanceList;
        }
        if (!layer.instances.visibleTransparent[j]) {
          layer.instances.visibleTransparent[j] = new pc.VisibleInstanceList;
        }
        layer.instances.visibleOpaque[j].done = false;
        layer.instances.visibleTransparent[j].done = false;
      }
      if (layer._needsStaticPrepare && layer._staticLightHash) {
        if (layer._staticPrepareDone) {
          this.revertStaticMeshes(layer.opaqueMeshInstances);
          this.revertStaticMeshes(layer.transparentMeshInstances);
        }
        this.prepareStaticMeshes(layer.opaqueMeshInstances, layer._lights);
        this.prepareStaticMeshes(layer.transparentMeshInstances, layer._lights);
        comp._dirty = true;
        scene.updateShaders = true;
        layer._needsStaticPrepare = false;
        layer._staticPrepareDone = true;
      }
    }
  }, cullLocalShadowmap:function(light, drawCalls) {
    var i, type, shadowCam, shadowCamNode, passes, pass, numInstances, meshInstance, visibleList, vlen, visible;
    var lightNode;
    type = light._type;
    if (type === pc.LIGHTTYPE_DIRECTIONAL) {
      return;
    }
    light.visibleThisFrame = true;
    shadowCam = this.getShadowCamera(this.device, light);
    shadowCam.projection = pc.PROJECTION_PERSPECTIVE;
    shadowCam.nearClip = light.attenuationEnd / 1000;
    shadowCam.farClip = light.attenuationEnd;
    shadowCam.aspectRatio = 1;
    if (type === pc.LIGHTTYPE_SPOT) {
      shadowCam.fov = light._outerConeAngle * 2;
      passes = 1;
    } else {
      shadowCam.fov = 90;
      passes = 6;
    }
    shadowCamNode = shadowCam._node;
    lightNode = light._node;
    shadowCamNode.setPosition(lightNode.getPosition());
    if (type === pc.LIGHTTYPE_SPOT) {
      shadowCamNode.setRotation(lightNode.getRotation());
      shadowCamNode.rotateLocal(-90, 0, 0);
    }
    for (pass = 0;pass < passes;pass++) {
      if (type === pc.LIGHTTYPE_POINT) {
        shadowCamNode.setRotation(pointLightRotations[pass]);
        shadowCam.renderTarget = light._shadowCubeMap[pass];
      }
      this.updateCameraFrustum(shadowCam);
      visibleList = light._visibleList[pass];
      if (!visibleList) {
        visibleList = light._visibleList[pass] = [];
      }
      light._visibleLength[pass] = 0;
      vlen = 0;
      for (i = 0, numInstances = drawCalls.length;i < numInstances;i++) {
        meshInstance = drawCalls[i];
        visible = true;
        if (meshInstance.cull) {
          visible = this._isVisible(shadowCam, meshInstance);
        }
        if (visible) {
          visibleList[vlen] = meshInstance;
          vlen++;
          meshInstance.visibleThisFrame = true;
        }
      }
      light._visibleLength[pass] = vlen;
      if (visibleList.length !== vlen) {
        visibleList.length = vlen;
      }
      visibleList.sort(this.depthSortCompare);
    }
  }, cullDirectionalShadowmap:function(light, drawCalls, camera, pass) {
    var i, shadowCam, shadowCamNode, lightNode, frustumSize, vlen, visibleList;
    var unitPerTexel, delta, p;
    var minx, miny, minz, maxx, maxy, maxz, centerx, centery;
    var visible, numInstances;
    var meshInstance;
    var emptyAabb;
    var drawCallAabb;
    var device = this.device;
    light.visibleThisFrame = true;
    shadowCam = this.getShadowCamera(device, light);
    shadowCamNode = shadowCam._node;
    lightNode = light._node;
    shadowCamNode.setPosition(lightNode.getPosition());
    shadowCamNode.setRotation(lightNode.getRotation());
    shadowCamNode.rotateLocal(-90, 0, 0);
    _getFrustumPoints(camera, light.shadowDistance || camera._farClip, frustumPoints);
    frustumSize = frustumDiagonal.sub2(frustumPoints[0], frustumPoints[6]).length();
    frustumSize = Math.max(frustumSize, frustumDiagonal.sub2(frustumPoints[4], frustumPoints[6]).length());
    shadowCamView.copy(shadowCamNode.getWorldTransform()).invert();
    c2sc.copy(shadowCamView).mul(camera._node.worldTransform);
    for (i = 0;i < 8;i++) {
      c2sc.transformPoint(frustumPoints[i], frustumPoints[i]);
    }
    minx = miny = minz = 1000000;
    maxx = maxy = maxz = -1000000;
    for (i = 0;i < 8;i++) {
      p = frustumPoints[i];
      if (p.x < minx) {
        minx = p.x;
      }
      if (p.x > maxx) {
        maxx = p.x;
      }
      if (p.y < miny) {
        miny = p.y;
      }
      if (p.y > maxy) {
        maxy = p.y;
      }
      if (p.z < minz) {
        minz = p.z;
      }
      if (p.z > maxz) {
        maxz = p.z;
      }
    }
    unitPerTexel = frustumSize / light._shadowResolution;
    delta = (frustumSize - (maxx - minx)) * 0.5;
    minx = Math.floor((minx - delta) / unitPerTexel) * unitPerTexel;
    delta = (frustumSize - (maxy - miny)) * 0.5;
    miny = Math.floor((miny - delta) / unitPerTexel) * unitPerTexel;
    maxx = minx + frustumSize;
    maxy = miny + frustumSize;
    centerx = (maxx + minx) * 0.5;
    centery = (maxy + miny) * 0.5;
    shadowCamNode.translateLocal(centerx, centery, 100000);
    shadowCam.projection = pc.PROJECTION_ORTHOGRAPHIC;
    shadowCam.nearClip = 0;
    shadowCam.farClip = 200000;
    shadowCam.aspectRatio = 1;
    shadowCam.orthoHeight = frustumSize * 0.5;
    this.updateCameraFrustum(shadowCam);
    emptyAabb = true;
    visibleList = light._visibleList[pass];
    if (!visibleList) {
      visibleList = light._visibleList[pass] = [];
    }
    vlen = light._visibleLength[pass] = 0;
    for (i = 0, numInstances = drawCalls.length;i < numInstances;i++) {
      meshInstance = drawCalls[i];
      visible = true;
      if (meshInstance.cull) {
        visible = this._isVisible(shadowCam, meshInstance);
      }
      if (visible) {
        visibleList[vlen] = meshInstance;
        vlen++;
        meshInstance.visibleThisFrame = true;
        drawCallAabb = meshInstance.aabb;
        if (emptyAabb) {
          visibleSceneAabb.copy(drawCallAabb);
          emptyAabb = false;
        } else {
          visibleSceneAabb.add(drawCallAabb);
        }
      }
    }
    light._visibleLength[pass] = vlen;
    if (visibleList.length !== vlen) {
      visibleList.length = vlen;
    }
    visibleList.sort(this.depthSortCompare);
    var z = _getZFromAABBSimple(shadowCamView, visibleSceneAabb.getMin(), visibleSceneAabb.getMax(), minx, maxx, miny, maxy);
    maxz = z.max;
    if (z.min > minz) {
      minz = z.min;
    }
    shadowCamNode.setPosition(lightNode.getPosition());
    shadowCamNode.translateLocal(centerx, centery, maxz + directionalShadowEpsilon);
    shadowCam.farClip = maxz - minz;
    var settings = light._visibleCameraSettings[pass];
    if (!settings) {
      settings = light._visibleCameraSettings[pass] = {};
    }
    var lpos = shadowCamNode.getPosition().data;
    settings.x = lpos[0];
    settings.y = lpos[1];
    settings.z = lpos[2];
    settings.orthoHeight = shadowCam.orthoHeight;
    settings.farClip = shadowCam.farClip;
  }, gpuUpdate:function(drawCalls) {
    this.updateGpuSkinMatrices(drawCalls);
    this.updateMorphing(drawCalls);
  }, clearView:function(camera, target, options) {
    camera = camera.camera;
    var device = this.device;
    device.setRenderTarget(target);
    device.updateBegin();
    device.setColorWrite(true, true, true, true);
    device.setDepthWrite(true);
    var rect = camera.getRect();
    var pixelWidth = target ? target.width : device.width;
    var pixelHeight = target ? target.height : device.height;
    var x = Math.floor(rect.x * pixelWidth);
    var y = Math.floor(rect.y * pixelHeight);
    var w = Math.floor(rect.width * pixelWidth);
    var h = Math.floor(rect.height * pixelHeight);
    device.setViewport(x, y, w, h);
    device.setScissor(x, y, w, h);
    device.clear(options ? options : camera._clearOptions);
  }, setSceneConstants:function() {
    var i;
    var device = this.device;
    var scene = this.scene;
    this.dispatchGlobalLights(scene);
    if (scene.fog !== pc.FOG_NONE) {
      this.fogColor[0] = scene.fogColor.data[0];
      this.fogColor[1] = scene.fogColor.data[1];
      this.fogColor[2] = scene.fogColor.data[2];
      if (scene.gammaCorrection) {
        for (i = 0;i < 3;i++) {
          this.fogColor[i] = Math.pow(this.fogColor[i], 2.2);
        }
      }
      this.fogColorId.setValue(this.fogColor);
      if (scene.fog === pc.FOG_LINEAR) {
        this.fogStartId.setValue(scene.fogStart);
        this.fogEndId.setValue(scene.fogEnd);
      } else {
        this.fogDensityId.setValue(scene.fogDensity);
      }
    }
    this._screenSize.x = device.width;
    this._screenSize.y = device.height;
    this._screenSize.z = 1.0 / device.width;
    this._screenSize.w = 1.0 / device.height;
    this.screenSizeId.setValue(this._screenSize.data);
  }, renderComposition:function(comp) {
    var device = this.device;
    var camera;
    var renderedRt = comp._renderedRt;
    var renderedByCam = comp._renderedByCam;
    var renderedLayer = comp._renderedLayer;
    var i, layer, transparent, cameras, j, rt, k, processedThisCamera, processedThisCameraAndLayer, processedThisCameraAndRt;
    this.beginLayers(comp);
    var updated = comp._update();
    if (updated & pc.COMPUPDATED_LIGHTS) {
      this.scene.updateShaders = true;
    }
    this.beginFrame(comp);
    this.setSceneConstants();
    var renderedLength = 0;
    var objects, drawCalls, visible;
    for (i = 0;i < comp.layerList.length;i++) {
      layer = comp.layerList[i];
      if (!layer.enabled || !comp.subLayerEnabled[i]) {
        continue;
      }
      transparent = comp.subLayerList[i];
      objects = layer.instances;
      cameras = layer.cameras;
      for (j = 0;j < cameras.length;j++) {
        camera = cameras[j];
        if (!camera) {
          continue;
        }
        camera.frameBegin(layer.renderTarget);
        drawCalls = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;
        processedThisCamera = false;
        processedThisCameraAndLayer = false;
        for (k = 0;k < renderedLength;k++) {
          if (renderedByCam[k] === camera) {
            processedThisCamera = true;
            if (renderedLayer[k] === layer) {
              processedThisCameraAndLayer = true;
              break;
            }
          }
        }
        if (!processedThisCamera) {
          this.updateCameraFrustum(camera.camera);
          this._camerasRendered++;
        }
        if (!processedThisCameraAndLayer) {
          this.cullLights(camera.camera, layer._lights);
        }
        if (!processedThisCamera || !processedThisCameraAndLayer) {
          renderedByCam[renderedLength] = camera;
          renderedLayer[renderedLength] = layer;
          renderedLength++;
        }
        visible = transparent ? objects.visibleTransparent[j] : objects.visibleOpaque[j];
        if (!visible.done) {
          if (layer.onPreCull) {
            layer.onPreCull(j);
          }
          visible.length = this.cull(camera.camera, drawCalls, visible.list);
          visible.done = true;
          if (layer.onPostCull) {
            layer.onPostCull(j);
          }
        }
        camera.frameEnd();
      }
    }
    var light, casters;
    for (i = 0;i < comp._lights.length;i++) {
      light = comp._lights[i];
      if (!light.visibleThisFrame) {
        continue;
      }
      if (light._type === pc.LIGHTTYPE_DIRECTIONAL) {
        continue;
      }
      if (!light.castShadows || !light._enabled || light.shadowUpdateMode === pc.SHADOWUPDATE_NONE) {
        continue;
      }
      casters = comp._lightShadowCasters[i];
      this.cullLocalShadowmap(light, casters);
    }
    renderedLength = 0;
    var globalLightCounter = -1;
    for (i = 0;i < comp._lights.length;i++) {
      light = comp._lights[i];
      if (light._type !== pc.LIGHTTYPE_DIRECTIONAL) {
        continue;
      }
      globalLightCounter++;
      if (!light.castShadows || !light._enabled || light.shadowUpdateMode === pc.SHADOWUPDATE_NONE) {
        continue;
      }
      casters = comp._lightShadowCasters[i];
      cameras = comp._globalLightCameras[globalLightCounter];
      for (j = 0;j < cameras.length;j++) {
        this.cullDirectionalShadowmap(light, casters, cameras[j].camera, comp._globalLightCameraIds[globalLightCounter][j]);
      }
    }
    this.gpuUpdate(comp._meshInstances);
    this.renderShadows(comp._sortedLights[pc.LIGHTTYPE_SPOT]);
    this.renderShadows(comp._sortedLights[pc.LIGHTTYPE_POINT]);
    renderedLength = 0;
    var cameraPass;
    var sortTime, draws, drawTime;
    for (i = 0;i < comp._renderList.length;i++) {
      layer = comp.layerList[comp._renderList[i]];
      if (!layer.enabled || !comp.subLayerEnabled[comp._renderList[i]]) {
        continue;
      }
      objects = layer.instances;
      transparent = comp.subLayerList[comp._renderList[i]];
      cameraPass = comp._renderListCamera[i];
      camera = layer.cameras[cameraPass];
      if (camera) {
        camera.frameBegin(layer.renderTarget);
      }
      if (!transparent && layer.onPreRenderOpaque) {
        layer.onPreRenderOpaque(cameraPass);
      } else {
        if (transparent && layer.onPreRenderTransparent) {
          layer.onPreRenderTransparent(cameraPass);
        }
      }
      if (!(layer._preRenderCalledForCameras & 1 << cameraPass)) {
        if (layer.onPreRender) {
          layer.onPreRender(cameraPass);
        }
        layer._preRenderCalledForCameras |= 1 << cameraPass;
        if (layer.overrideClear) {
          this.clearView(camera, layer.renderTarget, layer._clearOptions);
        }
      }
      if (camera) {
        rt = layer.renderTarget;
        processedThisCameraAndRt = false;
        for (k = 0;k < renderedLength;k++) {
          if (renderedRt[k] === rt && renderedByCam[k] === camera) {
            processedThisCameraAndRt = true;
            break;
          }
        }
        if (!processedThisCameraAndRt) {
          if (!layer.overrideClear) {
            this.clearView(camera, layer.renderTarget);
          }
          renderedRt[renderedLength] = rt;
          renderedByCam[renderedLength] = camera;
          renderedLength++;
        }
        this.renderShadows(layer._sortedLights[pc.LIGHTTYPE_DIRECTIONAL], cameraPass);
        layer._sortVisible(transparent, camera.node, cameraPass);
        visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];
        this.scene._activeCamera = camera.camera;
        this.setCamera(camera.camera, layer.renderTarget);
        this.renderForward(camera.camera, visible.list, visible.length, layer._sortedLights, layer.shaderPass, layer.cullingMask, layer.onDrawCall, layer);
        device.setColorWrite(true, true, true, true);
        device.setStencilTest(false);
        device.setAlphaToCoverage(false);
        device.setDepthBias(false);
        camera.frameEnd();
      }
      if (!transparent && layer.onPostRenderOpaque) {
        layer.onPostRenderOpaque(cameraPass);
      } else {
        if (transparent && layer.onPostRenderTransparent) {
          layer.onPostRenderTransparent(cameraPass);
        }
      }
      if (layer.onPostRender && !(layer._postRenderCalledForCameras & 1 << cameraPass)) {
        layer._postRenderCounter &= ~(transparent ? 2 : 1);
        if (layer._postRenderCounter === 0) {
          layer.onPostRender(cameraPass);
          layer._postRenderCalledForCameras |= 1 << cameraPass;
          layer._postRenderCounter = layer._postRenderCounterMax;
        }
      }
    }
  }});
  return {ForwardRenderer:ForwardRenderer, gaussWeights:gaussWeights};
}());
Object.assign(pc, function() {
  var scaleCompensatePosTransform = new pc.Mat4;
  var scaleCompensatePos = new pc.Vec3;
  var scaleCompensateRot = new pc.Quat;
  var scaleCompensateRot2 = new pc.Quat;
  var scaleCompensateScale = new pc.Vec3;
  var scaleCompensateScaleForParent = new pc.Vec3;
  var GraphNode = function GraphNode(name) {
    this.name = typeof name === "string" ? name : "Untitled";
    this.tags = new pc.Tags(this);
    this._labels = {};
    this.localPosition = new pc.Vec3(0, 0, 0);
    this.localRotation = new pc.Quat(0, 0, 0, 1);
    this.localScale = new pc.Vec3(1, 1, 1);
    this.localEulerAngles = new pc.Vec3(0, 0, 0);
    this.position = new pc.Vec3(0, 0, 0);
    this.rotation = new pc.Quat(0, 0, 0, 1);
    this.eulerAngles = new pc.Vec3(0, 0, 0);
    this.localTransform = new pc.Mat4;
    this._dirtyLocal = false;
    this._aabbVer = 0;
    this.worldTransform = new pc.Mat4;
    this._dirtyWorld = false;
    this.normalMatrix = new pc.Mat3;
    this._dirtyNormal = true;
    this._right = new pc.Vec3;
    this._up = new pc.Vec3;
    this._forward = new pc.Vec3;
    this._parent = null;
    this._children = [];
    this._graphDepth = 0;
    this._enabled = true;
    this._enabledInHierarchy = false;
    this.scaleCompensation = false;
  };
  Object.defineProperty(GraphNode.prototype, "right", {get:function() {
    return this.getWorldTransform().getX(this._right).normalize();
  }});
  Object.defineProperty(GraphNode.prototype, "up", {get:function() {
    return this.getWorldTransform().getY(this._up).normalize();
  }});
  Object.defineProperty(GraphNode.prototype, "forward", {get:function() {
    return this.getWorldTransform().getZ(this._forward).normalize().scale(-1);
  }});
  Object.defineProperty(GraphNode.prototype, "enabled", {get:function() {
    return this._enabled && this._enabledInHierarchy;
  }, set:function(enabled) {
    if (this._enabled !== enabled) {
      this._enabled = enabled;
      if (!this._parent || this._parent.enabled) {
        this._notifyHierarchyStateChanged(this, enabled);
      }
    }
  }});
  Object.defineProperty(GraphNode.prototype, "parent", {get:function() {
    return this._parent;
  }});
  Object.defineProperty(GraphNode.prototype, "root", {get:function() {
    var parent = this._parent;
    if (!parent) {
      return this;
    }
    while (parent._parent) {
      parent = parent._parent;
    }
    return parent;
  }});
  Object.defineProperty(GraphNode.prototype, "children", {get:function() {
    return this._children;
  }});
  Object.defineProperty(GraphNode.prototype, "graphDepth", {get:function() {
    return this._graphDepth;
  }});
  Object.assign(GraphNode.prototype, {_notifyHierarchyStateChanged:function(node, enabled) {
    node._onHierarchyStateChanged(enabled);
    var c = node._children;
    for (var i = 0, len = c.length;i < len;i++) {
      if (c[i]._enabled) {
        this._notifyHierarchyStateChanged(c[i], enabled);
      }
    }
  }, _onHierarchyStateChanged:function(enabled) {
    this._enabledInHierarchy = enabled;
  }, _cloneInternal:function(clone) {
    clone.name = this.name;
    var tags = this.tags._list;
    for (var i = 0;i < tags.length;i++) {
      clone.tags.add(tags[i]);
    }
    clone._labels = Object.assign({}, this._labels);
    clone.localPosition.copy(this.localPosition);
    clone.localRotation.copy(this.localRotation);
    clone.localScale.copy(this.localScale);
    clone.localEulerAngles.copy(this.localEulerAngles);
    clone.position.copy(this.position);
    clone.rotation.copy(this.rotation);
    clone.eulerAngles.copy(this.eulerAngles);
    clone.localTransform.copy(this.localTransform);
    clone._dirtyLocal = this._dirtyLocal;
    clone.worldTransform.copy(this.worldTransform);
    clone._dirtyWorld = this._dirtyWorld;
    clone._dirtyNormal = this._dirtyNormal;
    clone._aabbVer = this._aabbVer + 1;
    clone._enabled = this._enabled;
    clone.scaleCompensation = this.scaleCompensation;
    clone._enabledInHierarchy = false;
  }, clone:function() {
    var clone = new pc.GraphNode;
    this._cloneInternal(clone);
    return clone;
  }, find:function(attr, value) {
    var results = [];
    var len = this._children.length;
    var i, descendants;
    if (attr instanceof Function) {
      var fn = attr;
      for (i = 0;i < len;i++) {
        if (fn(this._children[i])) {
          results.push(this._children[i]);
        }
        descendants = this._children[i].find(fn);
        if (descendants.length) {
          results = results.concat(descendants);
        }
      }
    } else {
      var testValue;
      if (this[attr]) {
        if (this[attr] instanceof Function) {
          testValue = this[attr]();
        } else {
          testValue = this[attr];
        }
        if (testValue === value) {
          results.push(this);
        }
      }
      for (i = 0;i < len;++i) {
        descendants = this._children[i].find(attr, value);
        if (descendants.length) {
          results = results.concat(descendants);
        }
      }
    }
    return results;
  }, findOne:function(attr, value) {
    var i;
    var len = this._children.length;
    var result = null;
    if (attr instanceof Function) {
      var fn = attr;
      result = fn(this);
      if (result) {
        return this;
      }
      for (i = 0;i < len;i++) {
        result = this._children[i].findOne(fn);
        if (result) {
          return this._children[i];
        }
      }
    } else {
      var testValue;
      if (this[attr]) {
        if (this[attr] instanceof Function) {
          testValue = this[attr]();
        } else {
          testValue = this[attr];
        }
        if (testValue === value) {
          return this;
        }
      }
      for (i = 0;i < len;i++) {
        result = this._children[i].findOne(attr, value);
        if (result !== null) {
          return result;
        }
      }
    }
    return null;
  }, findByTag:function() {
    var tags = this.tags._processArguments(arguments);
    return this._findByTag(tags);
  }, _findByTag:function(tags) {
    var result = [];
    var i, len = this._children.length;
    var descendants;
    for (i = 0;i < len;i++) {
      if (this._children[i].tags._has(tags)) {
        result.push(this._children[i]);
      }
      descendants = this._children[i]._findByTag(tags);
      if (descendants.length) {
        result = result.concat(descendants);
      }
    }
    return result;
  }, findByName:function(name) {
    if (this.name === name) {
      return this;
    }
    for (var i = 0;i < this._children.length;i++) {
      var found = this._children[i].findByName(name);
      if (found !== null) {
        return found;
      }
    }
    return null;
  }, findByPath:function(path) {
    var parts = path.split("/");
    var currentParent = this;
    var result = null;
    for (var i = 0, imax = parts.length;i < imax && currentParent;i++) {
      var part = parts[i];
      result = null;
      var children = currentParent._children;
      for (var j = 0, jmax = children.length;j < jmax;j++) {
        if (children[j].name == part) {
          result = children[j];
          break;
        }
      }
      currentParent = result;
    }
    return result;
  }, getPath:function() {
    var parent = this._parent;
    if (parent) {
      var path = this.name;
      var format = "{0}/{1}";
      while (parent && parent._parent) {
        path = pc.string.format(format, parent.name, path);
        parent = parent._parent;
      }
      return path;
    }
    return "";
  }, getRoot:function() {
    var parent = this._parent;
    if (!parent) {
      return this;
    }
    while (parent._parent) {
      parent = parent._parent;
    }
    return parent;
  }, getParent:function() {
    return this._parent;
  }, isDescendantOf:function(node) {
    var parent = this._parent;
    while (parent) {
      if (parent === node) {
        return true;
      }
      parent = parent._parent;
    }
    return false;
  }, isAncestorOf:function(node) {
    return node.isDescendantOf(this);
  }, getChildren:function() {
    return this._children;
  }, getEulerAngles:function() {
    this.getWorldTransform().getEulerAngles(this.eulerAngles);
    return this.eulerAngles;
  }, getLocalEulerAngles:function() {
    this.localRotation.getEulerAngles(this.localEulerAngles);
    return this.localEulerAngles;
  }, getLocalPosition:function() {
    return this.localPosition;
  }, getLocalRotation:function() {
    return this.localRotation;
  }, getLocalScale:function() {
    return this.localScale;
  }, getLocalTransform:function() {
    if (this._dirtyLocal) {
      this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
      this._dirtyLocal = false;
    }
    return this.localTransform;
  }, getName:function() {
    return this.name;
  }, getPosition:function() {
    this.getWorldTransform().getTranslation(this.position);
    return this.position;
  }, getRotation:function() {
    this.rotation.setFromMat4(this.getWorldTransform());
    return this.rotation;
  }, getWorldTransform:function() {
    if (!this._dirtyLocal && !this._dirtyWorld) {
      return this.worldTransform;
    }
    if (this._parent) {
      this._parent.getWorldTransform();
    }
    this._sync();
    return this.worldTransform;
  }, reparent:function(parent, index) {
    var current = this._parent;
    if (current) {
      current.removeChild(this);
    }
    if (parent) {
      if (index >= 0) {
        parent.insertChild(this, index);
      } else {
        parent.addChild(this);
      }
    }
  }, setLocalEulerAngles:function(x, y, z) {
    if (x instanceof pc.Vec3) {
      this.localRotation.setFromEulerAngles(x.data[0], x.data[1], x.data[2]);
    } else {
      this.localRotation.setFromEulerAngles(x, y, z);
    }
    if (!this._dirtyLocal) {
      this._dirtify(true);
    }
  }, setLocalPosition:function(x, y, z) {
    if (x instanceof pc.Vec3) {
      this.localPosition.copy(x);
    } else {
      this.localPosition.set(x, y, z);
    }
    if (!this._dirtyLocal) {
      this._dirtify(true);
    }
  }, setLocalRotation:function(x, y, z, w) {
    if (x instanceof pc.Quat) {
      this.localRotation.copy(x);
    } else {
      this.localRotation.set(x, y, z, w);
    }
    if (!this._dirtyLocal) {
      this._dirtify(true);
    }
  }, setLocalScale:function(x, y, z) {
    if (x instanceof pc.Vec3) {
      this.localScale.copy(x);
    } else {
      this.localScale.set(x, y, z);
    }
    if (!this._dirtyLocal) {
      this._dirtify(true);
    }
  }, setName:function(name) {
    this.name = name;
  }, _dirtify:function(local) {
    if ((!local || local && this._dirtyLocal) && this._dirtyWorld) {
      return;
    }
    if (local) {
      this._dirtyLocal = true;
    }
    if (!this._dirtyWorld) {
      this._dirtyWorld = true;
      var i = this._children.length;
      while (i--) {
        if (this._children[i]._dirtyWorld) {
          continue;
        }
        this._children[i]._dirtify();
      }
    }
    this._dirtyNormal = true;
    this._aabbVer++;
  }, setPosition:function() {
    var position = new pc.Vec3;
    var invParentWtm = new pc.Mat4;
    return function(x, y, z) {
      if (x instanceof pc.Vec3) {
        position.copy(x);
      } else {
        position.set(x, y, z);
      }
      if (this._parent === null) {
        this.localPosition.copy(position);
      } else {
        invParentWtm.copy(this._parent.getWorldTransform()).invert();
        invParentWtm.transformPoint(position, this.localPosition);
      }
      if (!this._dirtyLocal) {
        this._dirtify(true);
      }
    };
  }(), setRotation:function() {
    var rotation = new pc.Quat;
    var invParentRot = new pc.Quat;
    return function(x, y, z, w) {
      if (x instanceof pc.Quat) {
        rotation.copy(x);
      } else {
        rotation.set(x, y, z, w);
      }
      if (this._parent === null) {
        this.localRotation.copy(rotation);
      } else {
        var parentRot = this._parent.getRotation();
        invParentRot.copy(parentRot).invert();
        this.localRotation.copy(invParentRot).mul(rotation);
      }
      if (!this._dirtyLocal) {
        this._dirtify(true);
      }
    };
  }(), setEulerAngles:function() {
    var invParentRot = new pc.Quat;
    return function(x, y, z) {
      if (x instanceof pc.Vec3) {
        this.localRotation.setFromEulerAngles(x.data[0], x.data[1], x.data[2]);
      } else {
        this.localRotation.setFromEulerAngles(x, y, z);
      }
      if (this._parent !== null) {
        var parentRot = this._parent.getRotation();
        invParentRot.copy(parentRot).invert();
        this.localRotation.mul2(invParentRot, this.localRotation);
      }
      if (!this._dirtyLocal) {
        this._dirtify(true);
      }
    };
  }(), addChild:function(node) {
    if (node._parent !== null) {
      throw new Error("GraphNode is already parented");
    }
    this._children.push(node);
    this._onInsertChild(node);
  }, addChildAndSaveTransform:function(node) {
    var wPos = node.getPosition();
    var wRot = node.getRotation();
    var current = node._parent;
    if (current) {
      current.removeChild(node);
    }
    if (this.tmpMat4 === undefined) {
      this.tmpMat4 = new pc.Mat4;
      this.tmpQuat = new pc.Quat;
    }
    node.setPosition(this.tmpMat4.copy(this.worldTransform).invert().transformPoint(wPos));
    node.setRotation(this.tmpQuat.copy(this.getRotation()).invert().mul(wRot));
    this._children.push(node);
    this._onInsertChild(node);
  }, insertChild:function(node, index) {
    if (node._parent !== null) {
      throw new Error("GraphNode is already parented");
    }
    this._children.splice(index, 0, node);
    this._onInsertChild(node);
  }, _onInsertChild:function(node) {
    node._parent = this;
    var enabledInHierarchy = node._enabled && this.enabled;
    if (node._enabledInHierarchy !== enabledInHierarchy) {
      node._enabledInHierarchy = enabledInHierarchy;
      node._notifyHierarchyStateChanged(node, enabledInHierarchy);
    }
    node._updateGraphDepth();
    node._dirtify();
    if (node.fire) {
      node.fire("insert", this);
    }
    if (this.fire) {
      this.fire("childinsert", node);
    }
  }, _updateGraphDepth:function() {
    if (this._parent) {
      this._graphDepth = this._parent._graphDepth + 1;
    } else {
      this._graphDepth = 0;
    }
    for (var i = 0, len = this._children.length;i < len;i++) {
      this._children[i]._updateGraphDepth();
    }
  }, removeChild:function(child) {
    var i;
    var length = this._children.length;
    for (i = 0;i < length;++i) {
      if (this._children[i] === child) {
        this._children.splice(i, 1);
        child._parent = null;
        if (this.fire) {
          this.fire("childremove", child);
        }
        return;
      }
    }
  }, addLabel:function(label) {
    this._labels[label] = true;
  }, getLabels:function() {
    return Object.keys(this._labels);
  }, hasLabel:function(label) {
    return !!this._labels[label];
  }, removeLabel:function(label) {
    delete this._labels[label];
  }, findByLabel:function(label, results) {
    var i, length = this._children.length;
    results = results || [];
    if (this.hasLabel(label)) {
      results.push(this);
    }
    for (i = 0;i < length;++i) {
      results = this._children[i].findByLabel(label, results);
    }
    return results;
  }, _sync:function() {
    if (this._dirtyLocal) {
      this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
      this._dirtyLocal = false;
    }
    if (this._dirtyWorld) {
      if (this._parent === null) {
        this.worldTransform.copy(this.localTransform);
      } else {
        if (this.scaleCompensation) {
          var parentWorldScale;
          var parent = this._parent;
          var scale = this.localScale;
          var parentToUseScaleFrom = parent;
          if (parentToUseScaleFrom) {
            while (parentToUseScaleFrom && parentToUseScaleFrom.scaleCompensation) {
              parentToUseScaleFrom = parentToUseScaleFrom._parent;
            }
            if (parentToUseScaleFrom) {
              parentToUseScaleFrom = parentToUseScaleFrom._parent;
              if (parentToUseScaleFrom) {
                parentWorldScale = parentToUseScaleFrom.worldTransform.getScale();
                scaleCompensateScale.mul2(parentWorldScale, this.localScale);
                scale = scaleCompensateScale;
              }
            }
          }
          scaleCompensateRot2.setFromMat4(parent.worldTransform);
          scaleCompensateRot.mul2(scaleCompensateRot2, this.localRotation);
          var tmatrix = parent.worldTransform;
          if (parent.scaleCompensation) {
            scaleCompensateScaleForParent.mul2(parentWorldScale, parent.getLocalScale());
            scaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos), scaleCompensateRot2, scaleCompensateScaleForParent);
            tmatrix = scaleCompensatePosTransform;
          }
          tmatrix.transformPoint(this.localPosition, scaleCompensatePos);
          this.worldTransform.setTRS(scaleCompensatePos, scaleCompensateRot, scale);
        } else {
          this.worldTransform.mul2(this._parent.worldTransform, this.localTransform);
        }
      }
      this._dirtyWorld = false;
    }
  }, syncHierarchy:function() {
    if (!this._enabled) {
      return;
    }
    if (this._dirtyLocal || this._dirtyWorld) {
      this._sync();
    }
    var children = this._children;
    for (var i = 0, len = children.length;i < len;i++) {
      children[i].syncHierarchy();
    }
  }, lookAt:function() {
    var matrix = new pc.Mat4;
    var target = new pc.Vec3;
    var up = new pc.Vec3;
    var rotation = new pc.Quat;
    return function(tx, ty, tz, ux, uy, uz) {
      if (tx instanceof pc.Vec3) {
        target.copy(tx);
        if (ty instanceof pc.Vec3) {
          up.copy(ty);
        } else {
          up.copy(pc.Vec3.UP);
        }
      } else {
        if (tz === undefined) {
          return;
        } else {
          target.set(tx, ty, tz);
          if (ux !== undefined) {
            up.set(ux, uy, uz);
          } else {
            up.copy(pc.Vec3.UP);
          }
        }
      }
      matrix.setLookAt(this.getPosition(), target, up);
      rotation.setFromMat4(matrix);
      this.setRotation(rotation);
    };
  }(), translate:function() {
    var translation = new pc.Vec3;
    return function(x, y, z) {
      if (x instanceof pc.Vec3) {
        translation.copy(x);
      } else {
        translation.set(x, y, z);
      }
      translation.add(this.getPosition());
      this.setPosition(translation);
    };
  }(), translateLocal:function() {
    var translation = new pc.Vec3;
    return function(x, y, z) {
      if (x instanceof pc.Vec3) {
        translation.copy(x);
      } else {
        translation.set(x, y, z);
      }
      this.localRotation.transformVector(translation, translation);
      this.localPosition.add(translation);
      if (!this._dirtyLocal) {
        this._dirtify(true);
      }
    };
  }(), rotate:function() {
    var quaternion = new pc.Quat;
    var invParentRot = new pc.Quat;
    return function(x, y, z) {
      if (x instanceof pc.Vec3) {
        quaternion.setFromEulerAngles(x.data[0], x.data[1], x.data[2]);
      } else {
        quaternion.setFromEulerAngles(x, y, z);
      }
      if (this._parent === null) {
        this.localRotation.mul2(quaternion, this.localRotation);
      } else {
        var rot = this.getRotation();
        var parentRot = this._parent.getRotation();
        invParentRot.copy(parentRot).invert();
        quaternion.mul2(invParentRot, quaternion);
        this.localRotation.mul2(quaternion, rot);
      }
      if (!this._dirtyLocal) {
        this._dirtify(true);
      }
    };
  }(), rotateLocal:function() {
    var quaternion = new pc.Quat;
    return function(x, y, z) {
      if (x instanceof pc.Vec3) {
        quaternion.setFromEulerAngles(x.data[0], x.data[1], x.data[2]);
      } else {
        quaternion.setFromEulerAngles(x, y, z);
      }
      this.localRotation.mul(quaternion);
      if (!this._dirtyLocal) {
        this._dirtify(true);
      }
    };
  }()});
  return {GraphNode:GraphNode};
}());
Object.assign(pc, function() {
  var _deviceCoord = new pc.Vec3;
  var _far = new pc.Vec3;
  var _farW = new pc.Vec3;
  var _invViewProjMat = new pc.Mat4;
  var Camera = function() {
    this._projection = pc.PROJECTION_PERSPECTIVE;
    this._nearClip = 0.1;
    this._farClip = 10000;
    this._shaderParams = new pc.Vec4;
    this._fov = 45;
    this._orthoHeight = 10;
    this._aspect = 16 / 9;
    this._aspectRatioMode = pc.ASPECT_AUTO;
    this._horizontalFov = false;
    this.frustumCulling = false;
    this.cullingMask = 4294967295;
    this._renderDepthRequests = 0;
    this._projMatDirty = true;
    this._projMat = new pc.Mat4;
    this._viewMat = new pc.Mat4;
    this._viewProjMat = new pc.Mat4;
    this.vrDisplay = null;
    this._rect = {x:0, y:0, width:1, height:1};
    this._scissorRect = {x:0, y:0, width:1, height:1};
    this.frustum = new pc.Frustum(this._projMat, this._viewMat);
    this.renderTarget = null;
    this._depthTarget = null;
    this._clearOptions = {color:[0.5, 0.5, 0.5, 1.0], depth:1.0, stencil:0, flags:pc.CLEARFLAG_COLOR | pc.CLEARFLAG_DEPTH | pc.CLEARFLAG_STENCIL};
    this._node = null;
    this.calculateTransform = null;
    this.overrideCalculateTransform = false;
    this.calculateProjection = null;
    this.overrideCalculateProjection = false;
    this._cullFaces = true;
    this._flipFaces = false;
    this._component = null;
  };
  Object.assign(Camera.prototype, {clone:function() {
    var clone = new pc.Camera;
    clone.projection = this._projection;
    clone.nearClip = this._nearClip;
    clone.farClip = this._farClip;
    clone._shaderParams = this._shaderParams.clone();
    clone.fov = this._fov;
    clone.aspectRatio = this._aspect;
    clone._aspectRatioMode = this._aspectRatioMode;
    clone.renderTarget = this.renderTarget;
    clone.setClearOptions(this.getClearOptions());
    clone.frustumCulling = this.frustumCulling;
    clone.cullingMask = this.cullingMask;
    return clone;
  }, worldToScreen:function(worldCoord, cw, ch, screenCoord) {
    if (screenCoord === undefined) {
      screenCoord = new pc.Vec3;
    }
    var projMat = this.getProjectionMatrix();
    var wtm = this._node.getWorldTransform();
    this._viewMat.copy(wtm).invert();
    this._viewProjMat.mul2(projMat, this._viewMat);
    this._viewProjMat.transformPoint(worldCoord, screenCoord);
    var wp = worldCoord.data;
    var vpm = this._viewProjMat.data;
    var w = wp[0] * vpm[3] + wp[1] * vpm[7] + wp[2] * vpm[11] + 1 * vpm[15];
    screenCoord.x = (screenCoord.x / w + 1) * 0.5 * cw;
    screenCoord.y = (1 - screenCoord.y / w) * 0.5 * ch;
    return screenCoord;
  }, screenToWorld:function(x, y, z, cw, ch, worldCoord) {
    if (worldCoord === undefined) {
      worldCoord = new pc.Vec3;
    }
    var projMat = this.getProjectionMatrix();
    var wtm = this._node.getWorldTransform();
    this._viewMat.copy(wtm).invert();
    this._viewProjMat.mul2(projMat, this._viewMat);
    _invViewProjMat.copy(this._viewProjMat).invert();
    if (this._projection === pc.PROJECTION_PERSPECTIVE) {
      _far.set(x / cw * 2 - 1, (ch - y) / ch * 2 - 1, 1);
      _invViewProjMat.transformPoint(_far, _farW);
      var w = _far.x * _invViewProjMat.data[3] + _far.y * _invViewProjMat.data[7] + _far.z * _invViewProjMat.data[11] + _invViewProjMat.data[15];
      _farW.scale(1 / w);
      var alpha = z / this._farClip;
      worldCoord.lerp(this._node.getPosition(), _farW, alpha);
    } else {
      var range = this._farClip - this._nearClip;
      _deviceCoord.set(x / cw, (ch - y) / ch, z / range);
      _deviceCoord.scale(2);
      _deviceCoord.sub(pc.Vec3.ONE);
      _invViewProjMat.transformPoint(_deviceCoord, worldCoord);
    }
    return worldCoord;
  }, getClearOptions:function() {
    return this._clearOptions;
  }, getProjectionMatrix:function() {
    if (this._projMatDirty) {
      if (this._projection === pc.PROJECTION_PERSPECTIVE) {
        this._projMat.setPerspective(this._fov, this._aspect, this._nearClip, this._farClip, this._horizontalFov);
      } else {
        var y = this._orthoHeight;
        var x = y * this._aspect;
        this._projMat.setOrtho(-x, x, -y, y, this._nearClip, this._farClip);
      }
      var n = this._nearClip;
      var f = this._farClip;
      this._shaderParams.x = 1 / f;
      this._shaderParams.y = f;
      this._shaderParams.z = (1 - f / n) / 2;
      this._shaderParams.w = (1 + f / n) / 2;
      this._projMatDirty = false;
    }
    return this._projMat;
  }, getRect:function() {
    return this._rect;
  }, setClearOptions:function(options) {
    this._clearOptions.color[0] = options.color[0];
    this._clearOptions.color[1] = options.color[1];
    this._clearOptions.color[2] = options.color[2];
    this._clearOptions.color[3] = options.color[3];
    this._clearOptions.depth = options.depth;
    this._clearOptions.stencil = options.stencil;
    this._clearOptions.flags = options.flags;
  }, setRect:function(x, y, width, height) {
    this._rect.x = x;
    this._rect.y = y;
    this._rect.width = width;
    this._rect.height = height;
  }, setScissorRect:function(x, y, width, height) {
    this._scissorRect.x = x;
    this._scissorRect.y = y;
    this._scissorRect.width = width;
    this._scissorRect.height = height;
  }, requestDepthMap:function() {
    this._renderDepthRequests++;
  }, releaseDepthMap:function() {
    this._renderDepthRequests--;
  }});
  Object.defineProperty(Camera.prototype, "aspectRatio", {get:function() {
    return this._aspect;
  }, set:function(v) {
    if (this._aspect !== v) {
      this._aspect = v;
      this._projMatDirty = true;
    }
  }});
  Object.defineProperty(Camera.prototype, "projection", {get:function() {
    return this._projection;
  }, set:function(v) {
    if (this._projection !== v) {
      this._projection = v;
      this._projMatDirty = true;
    }
  }});
  Object.defineProperty(Camera.prototype, "nearClip", {get:function() {
    return this._nearClip;
  }, set:function(v) {
    if (this._nearClip !== v) {
      this._nearClip = v;
      this._projMatDirty = true;
    }
  }});
  Object.defineProperty(Camera.prototype, "farClip", {get:function() {
    return this._farClip;
  }, set:function(v) {
    if (this._farClip !== v) {
      this._farClip = v;
      this._projMatDirty = true;
    }
  }});
  Object.defineProperty(Camera.prototype, "fov", {get:function() {
    return this._fov;
  }, set:function(v) {
    if (this._fov !== v) {
      this._fov = v;
      this._projMatDirty = true;
    }
  }});
  Object.defineProperty(Camera.prototype, "horizontalFov", {get:function() {
    return this._horizontalFov;
  }, set:function(v) {
    if (this._horizontalFov !== v) {
      this._horizontalFov = v;
      this._projMatDirty = true;
    }
  }});
  Object.defineProperty(Camera.prototype, "orthoHeight", {get:function() {
    return this._orthoHeight;
  }, set:function(v) {
    if (this._orthoHeight !== v) {
      this._orthoHeight = v;
      this._projMatDirty = true;
    }
  }});
  Object.defineProperty(Camera.prototype, "clearColor", {get:function() {
    return this._clearOptions.color;
  }, set:function(v) {
    this._clearOptions.color[0] = v[0];
    this._clearOptions.color[1] = v[1];
    this._clearOptions.color[2] = v[2];
    this._clearOptions.color[3] = v[3];
  }});
  Object.defineProperty(Camera.prototype, "clearDepth", {get:function() {
    return this._clearOptions.depth;
  }, set:function(v) {
    this._clearOptions.depth = v;
  }});
  Object.defineProperty(Camera.prototype, "clearStencil", {get:function() {
    return this._clearOptions.stencil;
  }, set:function(v) {
    this._clearOptions.stencil = v;
  }});
  Object.defineProperty(Camera.prototype, "clearFlags", {get:function() {
    return this._clearOptions.flags;
  }, set:function(v) {
    this._clearOptions.flags = v;
  }});
  return {Camera:Camera};
}());
Object.assign(pc, function() {
  var spotCenter = new pc.Vec3;
  var spotEndPoint = new pc.Vec3;
  var tmpVec = new pc.Vec3;
  var chanId = {r:0, g:1, b:2, a:3};
  var Light = function Light() {
    this._type = pc.LIGHTTYPE_DIRECTIONAL;
    this._color = new pc.Color(0.8, 0.8, 0.8);
    this._intensity = 1;
    this._castShadows = false;
    this._enabled = false;
    this._mask = 1;
    this.isStatic = false;
    this.key = 0;
    this.bakeDir = true;
    this.attenuationStart = 10;
    this.attenuationEnd = 10;
    this._falloffMode = 0;
    this._shadowType = pc.SHADOW_PCF3;
    this._vsmBlurSize = 11;
    this.vsmBlurMode = pc.BLUR_GAUSSIAN;
    this.vsmBias = 0.01 * 0.25;
    this._cookie = null;
    this.cookieIntensity = 1;
    this._cookieFalloff = true;
    this._cookieChannel = "rgb";
    this._cookieTransform = null;
    this._cookieOffset = null;
    this._cookieTransformSet = false;
    this._cookieOffsetSet = false;
    this._innerConeAngle = 40;
    this._outerConeAngle = 45;
    this._finalColor = new pc.Vec3(0.8, 0.8, 0.8);
    var c = Math.pow(this._finalColor.data[0], 2.2);
    this._linearFinalColor = new pc.Vec3(c, c, c);
    this._position = new pc.Vec3(0, 0, 0);
    this._direction = new pc.Vec3(0, 0, 0);
    this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);
    this._outerConeAngleCos = Math.cos(this._outerConeAngle * Math.PI / 180);
    this._shadowCamera = null;
    this._shadowMatrix = new pc.Mat4;
    this.shadowDistance = 40;
    this._shadowResolution = 1024;
    this.shadowBias = -0.0005;
    this._normalOffsetBias = 0.0;
    this.shadowUpdateMode = pc.SHADOWUPDATE_REALTIME;
    this._scene = null;
    this._node = null;
    this._rendererParams = [];
    this._isVsm = false;
    this._isPcf = true;
    this._cacheShadowMap = false;
    this._isCachedShadowMap = false;
    this._visibleLength = [0];
    this._visibleList = [[]];
    this._visibleCameraSettings = [];
  };
  Object.assign(Light.prototype, {destroy:function() {
    this._destroyShadowMap();
  }, clone:function() {
    var clone = new pc.Light;
    clone.type = this._type;
    clone.setColor(this._color);
    clone.intensity = this._intensity;
    clone.castShadows = this.castShadows;
    clone.enabled = this._enabled;
    clone.attenuationStart = this.attenuationStart;
    clone.attenuationEnd = this.attenuationEnd;
    clone.falloffMode = this._falloffMode;
    clone.shadowType = this._shadowType;
    clone.vsmBlurSize = this._vsmBlurSize;
    clone.vsmBlurMode = this.vsmBlurMode;
    clone.vsmBias = this.vsmBias;
    clone.shadowUpdateMode = this.shadowUpdateMode;
    clone.mask = this._mask;
    clone.innerConeAngle = this._innerConeAngle;
    clone.outerConeAngle = this._outerConeAngle;
    clone.shadowBias = this.shadowBias;
    clone.normalOffsetBias = this._normalOffsetBias;
    clone.shadowResolution = this._shadowResolution;
    clone.shadowDistance = this.shadowDistance;
    return clone;
  }, getColor:function() {
    return this._color;
  }, getBoundingSphere:function(sphere) {
    if (this._type === pc.LIGHTTYPE_SPOT) {
      var range = this.attenuationEnd;
      var angle = this._outerConeAngle;
      var f = Math.cos(angle * pc.math.DEG_TO_RAD);
      var node = this._node;
      spotCenter.copy(node.up);
      spotCenter.scale(-range * 0.5 * f);
      spotCenter.add(node.getPosition());
      sphere.center = spotCenter;
      spotEndPoint.copy(node.up);
      spotEndPoint.scale(-range);
      tmpVec.copy(node.right);
      tmpVec.scale(Math.sin(angle * pc.math.DEG_TO_RAD) * range);
      spotEndPoint.add(tmpVec);
      sphere.radius = spotEndPoint.length() * 0.5;
    } else {
      if (this._type === pc.LIGHTTYPE_POINT) {
        sphere.center = this._node.getPosition();
        sphere.radius = this.attenuationEnd;
      }
    }
  }, getBoundingBox:function(box) {
    if (this._type === pc.LIGHTTYPE_SPOT) {
      var range = this.attenuationEnd;
      var angle = this._outerConeAngle;
      var node = this._node;
      var scl = Math.abs(Math.sin(angle * pc.math.DEG_TO_RAD) * range);
      box.center.set(0, -range * 0.5, 0);
      box.halfExtents.set(scl, range * 0.5, scl);
      box.setFromTransformedAabb(box, node.getWorldTransform());
    } else {
      if (this._type === pc.LIGHTTYPE_POINT) {
        box.center.copy(this._node.getPosition());
        box.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd);
      }
    }
  }, setColor:function() {
    var r, g, b;
    if (arguments.length === 1) {
      r = arguments[0].r;
      g = arguments[0].g;
      b = arguments[0].b;
    } else {
      if (arguments.length === 3) {
        r = arguments[0];
        g = arguments[1];
        b = arguments[2];
      }
    }
    this._color.set(r, g, b);
    var i = this._intensity;
    this._finalColor.set(r * i, g * i, b * i);
    for (var c = 0;c < 3;c++) {
      if (i >= 1) {
        this._linearFinalColor.data[c] = Math.pow(this._finalColor.data[c] / i, 2.2) * i;
      } else {
        this._linearFinalColor.data[c] = Math.pow(this._finalColor.data[c], 2.2);
      }
    }
  }, _destroyShadowMap:function() {
    if (this._shadowCamera) {
      if (!this._isCachedShadowMap) {
        var rt = this._shadowCamera.renderTarget;
        var i;
        if (rt) {
          if (rt.length) {
            for (i = 0;i < rt.length;i++) {
              if (rt[i].colorBuffer) {
                rt[i].colorBuffer.destroy();
              }
              rt[i].destroy();
            }
          } else {
            if (rt.colorBuffer) {
              rt.colorBuffer.destroy();
            }
            if (rt.depthBuffer) {
              rt.depthBuffer.destroy();
            }
            rt.destroy();
          }
        }
      }
      this._shadowCamera.renderTarget = null;
      this._shadowCamera = null;
      this._shadowCubeMap = null;
      if (this.shadowUpdateMode === pc.SHADOWUPDATE_NONE) {
        this.shadowUpdateMode = pc.SHADOWUPDATE_THISFRAME;
      }
    }
  }, updateShadow:function() {
    if (this.shadowUpdateMode !== pc.SHADOWUPDATE_REALTIME) {
      this.shadowUpdateMode = pc.SHADOWUPDATE_THISFRAME;
    }
  }, updateKey:function() {
    var key = this._type << 29 | (this._castShadows ? 1 : 0) << 28 | this._shadowType << 25 | this._falloffMode << 23 | (this._normalOffsetBias !== 0.0 ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | chanId[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12;
    if (this._cookieChannel.length === 3) {
      key |= chanId[this._cookieChannel.charAt(1)] << 16;
      key |= chanId[this._cookieChannel.charAt(2)] << 14;
    }
    this.key = key;
  }});
  Object.defineProperty(Light.prototype, "enabled", {get:function() {
    return this._type;
  }, set:function(value) {
    if (this._type === value) {
      return;
    }
    this._enabled = value;
    if (this._scene !== null) {
      this._scene.updateShaders = true;
    }
  }});
  Object.defineProperty(Light.prototype, "type", {get:function() {
    return this._type;
  }, set:function(value) {
    if (this._type === value) {
      return;
    }
    this._type = value;
    this._destroyShadowMap();
    if (this._scene !== null) {
      this._scene.updateShaders = true;
    }
    this.updateKey();
    var stype = this._shadowType;
    this._shadowType = null;
    this.shadowType = stype;
    if (this._scene !== null) {
      this._scene.layers._dirtyLights = true;
    }
  }});
  Object.defineProperty(Light.prototype, "mask", {get:function() {
    return this._mask;
  }, set:function(value) {
    if (this._mask === value) {
      return;
    }
    this._mask = value;
    if (this._scene !== null) {
      this._scene.updateShaders = true;
    }
  }});
  Object.defineProperty(Light.prototype, "shadowType", {get:function() {
    return this._shadowType;
  }, set:function(value) {
    if (this._shadowType === value) {
      return;
    }
    var device = pc.Application.getApplication().graphicsDevice;
    if (this._type === pc.LIGHTTYPE_POINT) {
      value = pc.SHADOW_PCF3;
    }
    if (value === pc.SHADOW_PCF5 && !device.webgl2) {
      value = pc.SHADOW_PCF3;
    }
    if (value === pc.SHADOW_VSM32 && !device.extTextureFloatRenderable) {
      value = pc.SHADOW_VSM16;
    }
    if (value === pc.SHADOW_VSM16 && !device.extTextureHalfFloatRenderable) {
      value = pc.SHADOW_VSM8;
    }
    this._isVsm = value >= pc.SHADOW_VSM8 && value <= pc.SHADOW_VSM32;
    this._isPcf = value === pc.SHADOW_PCF5 || value === pc.SHADOW_PCF3;
    this._shadowType = value;
    this._destroyShadowMap();
    if (this._scene !== null) {
      this._scene.updateShaders = true;
    }
    this.updateKey();
  }});
  Object.defineProperty(Light.prototype, "castShadows", {get:function() {
    return this._castShadows && this._mask !== pc.MASK_LIGHTMAP && this._mask !== 0;
  }, set:function(value) {
    if (this._castShadows === value) {
      return;
    }
    this._castShadows = value;
    if (this._scene !== null) {
      this._scene.updateShaders = true;
    }
    this.updateKey();
  }});
  Object.defineProperty(Light.prototype, "shadowResolution", {get:function() {
    return this._shadowResolution;
  }, set:function(value) {
    if (this._shadowResolution === value) {
      return;
    }
    var device = pc.Application.getApplication().graphicsDevice;
    if (this._type === pc.LIGHTTYPE_POINT) {
      value = Math.min(value, device.maxCubeMapSize);
    } else {
      value = Math.min(value, device.maxTextureSize);
    }
    this._shadowResolution = value;
  }});
  Object.defineProperty(Light.prototype, "vsmBlurSize", {get:function() {
    return this._vsmBlurSize;
  }, set:function(value) {
    if (this._vsmBlurSize === value) {
      return;
    }
    if (value % 2 === 0) {
      value++;
    }
    this._vsmBlurSize = value;
  }});
  Object.defineProperty(Light.prototype, "normalOffsetBias", {get:function() {
    return this._normalOffsetBias;
  }, set:function(value) {
    if (this._normalOffsetBias === value) {
      return;
    }
    if (!this._normalOffsetBias && value || this._normalOffsetBias && !value) {
      if (this._scene !== null) {
        this._scene.updateShaders = true;
      }
      this.updateKey();
    }
    this._normalOffsetBias = value;
  }});
  Object.defineProperty(Light.prototype, "falloffMode", {get:function() {
    return this._falloffMode;
  }, set:function(value) {
    if (this._falloffMode === value) {
      return;
    }
    this._falloffMode = value;
    if (this._scene !== null) {
      this._scene.updateShaders = true;
    }
    this.updateKey();
  }});
  Object.defineProperty(Light.prototype, "innerConeAngle", {get:function() {
    return this._innerConeAngle;
  }, set:function(value) {
    if (this._innerConeAngle === value) {
      return;
    }
    this._innerConeAngle = value;
    this._innerConeAngleCos = Math.cos(value * Math.PI / 180);
  }});
  Object.defineProperty(Light.prototype, "outerConeAngle", {get:function() {
    return this._outerConeAngle;
  }, set:function(value) {
    if (this._outerConeAngle === value) {
      return;
    }
    this._outerConeAngle = value;
    this._outerConeAngleCos = Math.cos(value * Math.PI / 180);
  }});
  Object.defineProperty(Light.prototype, "intensity", {get:function() {
    return this._intensity;
  }, set:function(value) {
    if (this._intensity === value) {
      return;
    }
    this._intensity = value;
    var c = this._color.data;
    var r = c[0];
    var g = c[1];
    var b = c[2];
    var i = this._intensity;
    this._finalColor.set(r * i, g * i, b * i);
    for (var j = 0;j < 3;j++) {
      if (i >= 1) {
        this._linearFinalColor.data[j] = Math.pow(this._finalColor.data[j] / i, 2.2) * i;
      } else {
        this._linearFinalColor.data[j] = Math.pow(this._finalColor.data[j], 2.2);
      }
    }
  }});
  Object.defineProperty(Light.prototype, "cookie", {get:function() {
    return this._cookie;
  }, set:function(value) {
    if (this._cookie === value) {
      return;
    }
    this._cookie = value;
    if (this._scene !== null) {
      this._scene.updateShaders = true;
    }
    this.updateKey();
  }});
  Object.defineProperty(Light.prototype, "cookieFalloff", {get:function() {
    return this._cookieFalloff;
  }, set:function(value) {
    if (this._cookieFalloff === value) {
      return;
    }
    this._cookieFalloff = value;
    if (this._scene !== null) {
      this._scene.updateShaders = true;
    }
    this.updateKey();
  }});
  Object.defineProperty(Light.prototype, "cookieChannel", {get:function() {
    return this._cookieChannel;
  }, set:function(value) {
    if (this._cookieChannel === value) {
      return;
    }
    if (value.length < 3) {
      var chr = value.charAt(value.length - 1);
      var addLen = 3 - value.length;
      for (var i = 0;i < addLen;i++) {
        value += chr;
      }
    }
    this._cookieChannel = value;
    if (this._scene !== null) {
      this._scene.updateShaders = true;
    }
    this.updateKey();
  }});
  Object.defineProperty(Light.prototype, "cookieTransform", {get:function() {
    return this._cookieTransform;
  }, set:function(value) {
    if (this._cookieTransform === value) {
      return;
    }
    var xformOld = !!(this._cookieTransformSet || this._cookieOffsetSet);
    var xformNew = !!(value || this._cookieOffsetSet);
    if (xformOld !== xformNew) {
      if (this._scene !== null) {
        this._scene.updateShaders = true;
      }
    }
    this._cookieTransform = value;
    this._cookieTransformSet = !!value;
    if (value && !this._cookieOffset) {
      this.cookieOffset = new pc.Vec2;
      this._cookieOffsetSet = false;
    }
    this.updateKey();
  }});
  Object.defineProperty(Light.prototype, "cookieOffset", {get:function() {
    return this._cookieOffset;
  }, set:function(value) {
    if (this._cookieOffset === value) {
      return;
    }
    var xformOld = !!(this._cookieTransformSet || this._cookieOffsetSet);
    var xformNew = !!(this._cookieTransformSet || value);
    if (xformOld !== xformNew) {
      if (this._scene !== null) {
        this._scene.updateShaders = true;
      }
    }
    if (xformNew && !value && this._cookieOffset) {
      this._cookieOffset.set(0, 0);
    } else {
      this._cookieOffset = value;
    }
    this._cookieOffsetSet = !!value;
    if (value && !this._cookieTransform) {
      this.cookieTransform = new pc.Vec4(1, 1, 0, 0);
      this._cookieTransformSet = false;
    }
    this.updateKey();
  }});
  return {Light:Light};
}());
Object.assign(pc, function() {
  var id = 0;
  var Material = function Material() {
    this.name = "Untitled";
    this.id = id++;
    this._shader = null;
    this.variants = {};
    this.parameters = {};
    this.alphaTest = 0;
    this.alphaToCoverage = false;
    this.blend = false;
    this.blendSrc = pc.BLENDMODE_ONE;
    this.blendDst = pc.BLENDMODE_ZERO;
    this.blendEquation = pc.BLENDEQUATION_ADD;
    this.separateAlphaBlend = false;
    this.blendSrcAlpha = pc.BLENDMODE_ONE;
    this.blendDstAlpha = pc.BLENDMODE_ZERO;
    this.blendAlphaEquation = pc.BLENDEQUATION_ADD;
    this.cull = pc.CULLFACE_BACK;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilFront = null;
    this.stencilBack = null;
    this.depthBias = 0;
    this.slopeDepthBias = 0;
    this.redWrite = true;
    this.greenWrite = true;
    this.blueWrite = true;
    this.alphaWrite = true;
    this.meshInstances = [];
    this._shaderVersion = 0;
    this._scene = null;
    this._dirtyBlend = false;
  };
  Object.defineProperty(Material.prototype, "shader", {get:function() {
    return this._shader;
  }, set:function(shader) {
    this.setShader(shader);
  }});
  Object.defineProperty(Material.prototype, "blendType", {get:function() {
    if (!this.blend && this.blendSrc === pc.BLENDMODE_ONE && this.blendDst === pc.BLENDMODE_ZERO && this.blendEquation === pc.BLENDEQUATION_ADD) {
      return pc.BLEND_NONE;
    } else {
      if (this.blend && this.blendSrc === pc.BLENDMODE_SRC_ALPHA && this.blendDst === pc.BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === pc.BLENDEQUATION_ADD) {
        return pc.BLEND_NORMAL;
      } else {
        if (this.blend && this.blendSrc === pc.BLENDMODE_ONE && this.blendDst === pc.BLENDMODE_ONE && this.blendEquation === pc.BLENDEQUATION_ADD) {
          return pc.BLEND_ADDITIVE;
        } else {
          if (this.blend && this.blendSrc === pc.BLENDMODE_SRC_ALPHA && this.blendDst === pc.BLENDMODE_ONE && this.blendEquation === pc.BLENDEQUATION_ADD) {
            return pc.BLEND_ADDITIVEALPHA;
          } else {
            if (this.blend && this.blendSrc === pc.BLENDMODE_DST_COLOR && this.blendDst === pc.BLENDMODE_SRC_COLOR && this.blendEquation === pc.BLENDEQUATION_ADD) {
              return pc.BLEND_MULTIPLICATIVE2X;
            } else {
              if (this.blend && this.blendSrc === pc.BLENDMODE_ONE_MINUS_DST_COLOR && this.blendDst === pc.BLENDMODE_ONE && this.blendEquation === pc.BLENDEQUATION_ADD) {
                return pc.BLEND_SCREEN;
              } else {
                if (this.blend && this.blendSrc === pc.BLENDMODE_ONE && this.blendDst === pc.BLENDMODE_ONE && this.blendEquation === pc.BLENDEQUATION_MIN) {
                  return pc.BLEND_MIN;
                } else {
                  if (this.blend && this.blendSrc === pc.BLENDMODE_ONE && this.blendDst === pc.BLENDMODE_ONE && this.blendEquation === pc.BLENDEQUATION_MAX) {
                    return pc.BLEND_MAX;
                  } else {
                    if (this.blend && this.blendSrc === pc.BLENDMODE_DST_COLOR && this.blendDst === pc.BLENDMODE_ZERO && this.blendEquation === pc.BLENDEQUATION_ADD) {
                      return pc.BLEND_MULTIPLICATIVE;
                    } else {
                      if (this.blend && this.blendSrc === pc.BLENDMODE_ONE && this.blendDst === pc.BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === pc.BLENDEQUATION_ADD) {
                        return pc.BLEND_PREMULTIPLIED;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return pc.BLEND_NORMAL;
  }, set:function(type) {
    var prevBlend = this.blend !== pc.BLEND_NONE;
    switch(type) {
      case pc.BLEND_NONE:
        this.blend = false;
        this.blendSrc = pc.BLENDMODE_ONE;
        this.blendDst = pc.BLENDMODE_ZERO;
        this.blendEquation = pc.BLENDEQUATION_ADD;
        break;
      case pc.BLEND_NORMAL:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_SRC_ALPHA;
        this.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        this.blendEquation = pc.BLENDEQUATION_ADD;
        break;
      case pc.BLEND_PREMULTIPLIED:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_ONE;
        this.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        this.blendEquation = pc.BLENDEQUATION_ADD;
        break;
      case pc.BLEND_ADDITIVE:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_ONE;
        this.blendDst = pc.BLENDMODE_ONE;
        this.blendEquation = pc.BLENDEQUATION_ADD;
        break;
      case pc.BLEND_ADDITIVEALPHA:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_SRC_ALPHA;
        this.blendDst = pc.BLENDMODE_ONE;
        this.blendEquation = pc.BLENDEQUATION_ADD;
        break;
      case pc.BLEND_MULTIPLICATIVE2X:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_DST_COLOR;
        this.blendDst = pc.BLENDMODE_SRC_COLOR;
        this.blendEquation = pc.BLENDEQUATION_ADD;
        break;
      case pc.BLEND_SCREEN:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_ONE_MINUS_DST_COLOR;
        this.blendDst = pc.BLENDMODE_ONE;
        this.blendEquation = pc.BLENDEQUATION_ADD;
        break;
      case pc.BLEND_MULTIPLICATIVE:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_DST_COLOR;
        this.blendDst = pc.BLENDMODE_ZERO;
        this.blendEquation = pc.BLENDEQUATION_ADD;
        break;
      case pc.BLEND_MIN:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_ONE;
        this.blendDst = pc.BLENDMODE_ONE;
        this.blendEquation = pc.BLENDEQUATION_MIN;
        break;
      case pc.BLEND_MAX:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_ONE;
        this.blendDst = pc.BLENDMODE_ONE;
        this.blendEquation = pc.BLENDEQUATION_MAX;
        break;
    }
    if (prevBlend !== (this.blend !== pc.BLEND_NONE)) {
      if (this._scene) {
        this._scene.layers._dirtyBlend = true;
      } else {
        this._dirtyBlend = true;
      }
    }
    this._updateMeshInstanceKeys();
  }});
  Material.prototype._cloneInternal = function(clone) {
    clone.name = this.name;
    clone.id = id++;
    clone.variants = {};
    clone.shader = this.shader;
    clone.parameters = {};
    for (var parameterName in this.parameters) {
      if (this.parameters.hasOwnProperty(parameterName)) {
        clone.parameters[parameterName] = {scopeId:null, data:this.parameters[parameterName].data, passFlags:this.parameters[parameterName].passFlags};
      }
    }
    clone.alphaTest = this.alphaTest;
    clone.alphaToCoverage = this.alphaToCoverage;
    clone.blend = this.blend;
    clone.blendSrc = this.blendSrc;
    clone.blendDst = this.blendDst;
    clone.blendEquation = this.blendEquation;
    clone.separateAlphaBlend = this.separateAlphaBlend;
    clone.blendSrcAlpha = this.blendSrcAlpha;
    clone.blendDstAlpha = this.blendDstAlpha;
    clone.blendAlphaEquation = this.blendAlphaEquation;
    clone.cull = this.cull;
    clone.depthTest = this.depthTest;
    clone.depthWrite = this.depthWrite;
    clone.depthBias = this.depthBias;
    clone.slopeDepthBias = this.slopeDepthBias;
    if (this.stencilFront) {
      clone.stencilFront = this.stencilFront.clone();
    }
    if (this.stencilBack) {
      if (this.stencilFront === this.stencilBack) {
        clone.stencilBack = clone.stencilFront;
      } else {
        clone.stencilBack = this.stencilBack.clone();
      }
    }
    clone.redWrite = this.redWrite;
    clone.greenWrite = this.greenWrite;
    clone.blueWrite = this.blueWrite;
    clone.alphaWrite = this.alphaWrite;
    clone.meshInstances = [];
  };
  Material.prototype.clone = function() {
    var clone = new pc.Material;
    this._cloneInternal(clone);
    return clone;
  };
  Material.prototype._updateMeshInstanceKeys = function() {
    var i, meshInstances = this.meshInstances;
    for (i = 0;i < meshInstances.length;i++) {
      meshInstances[i].updateKey();
    }
  };
  Material.prototype.updateShader = function(device, scene, objDefs) {
  };
  Material.prototype.clearParameters = function() {
    this.parameters = {};
  };
  Material.prototype.getParameters = function() {
    return this.parameters;
  };
  Material.prototype.clearVariants = function() {
    var meshInstance;
    for (var s in this.variants) {
      if (this.variants.hasOwnProperty(s)) {
        this.variants[s]._refCount--;
      }
    }
    this.variants = {};
    var j;
    for (var i = 0;i < this.meshInstances.length;i++) {
      meshInstance = this.meshInstances[i];
      for (j = 0;j < meshInstance._shader.length;j++) {
        meshInstance._shader[j] = null;
      }
    }
  };
  Material.prototype.getParameter = function(name) {
    return this.parameters[name];
  };
  Material.prototype.setParameter = function(name, data, passFlags) {
    if (passFlags === undefined) {
      passFlags = -524285;
    }
    if (data === undefined && typeof name === "object") {
      var uniformObject = name;
      if (uniformObject.length) {
        for (var i = 0;i < uniformObject.length;i++) {
          this.setParameter(uniformObject[i]);
        }
        return;
      }
      name = uniformObject.name;
      data = uniformObject.value;
    }
    var param = this.parameters[name];
    if (param) {
      param.data = data;
      param.passFlags = passFlags;
    } else {
      this.parameters[name] = {scopeId:null, data:data, passFlags:passFlags};
    }
  };
  Material.prototype.deleteParameter = function(name) {
    if (this.parameters[name]) {
      delete this.parameters[name];
    }
  };
  Material.prototype.setParameters = function() {
    for (var paramName in this.parameters) {
      var parameter = this.parameters[paramName];
      parameter.scopeId.setValue(parameter.data);
    }
  };
  Material.prototype.update = function() {
    throw Error("Not Implemented in base class");
  };
  Material.prototype.init = function(data) {
    throw Error("Not Implemented in base class");
  };
  Material.prototype.getName = function() {
    return this.name;
  };
  Material.prototype.setName = function(name) {
    this.name = name;
  };
  Material.prototype.getShader = function() {
    return this.shader;
  };
  Material.prototype.setShader = function(shader) {
    if (this._shader) {
      this._shader._refCount--;
    }
    this._shader = shader;
    if (shader) {
      shader._refCount++;
    }
  };
  Material.prototype.destroy = function() {
    if (this.shader) {
      this.shader._refCount--;
      if (this.shader._refCount < 1) {
        this.shader.destroy();
      }
    }
    var variant;
    for (var s in this.variants) {
      if (this.variants.hasOwnProperty(s)) {
        variant = this.variants[s];
        if (variant === this.shader) {
          continue;
        }
        variant._refCount--;
        if (variant._refCount < 1) {
          variant.destroy();
        }
      }
    }
    this.variants = {};
    this.shader = null;
    var meshInstance, j;
    for (var i = 0;i < this.meshInstances.length;i++) {
      meshInstance = this.meshInstances[i];
      for (j = 0;j < meshInstance._shader.length;j++) {
        meshInstance._shader[j] = null;
      }
      meshInstance._material = null;
      if (this !== pc.Scene.defaultMaterial) {
        meshInstance.material = pc.Scene.defaultMaterial;
      }
    }
  };
  return {Material:Material};
}());
Object.assign(pc, function() {
  var BasicMaterial = function() {
    pc.Material.call(this);
    this.color = new pc.Color(1, 1, 1, 1);
    this.colorMap = null;
    this.vertexColors = false;
    this.update();
  };
  BasicMaterial.prototype = Object.create(pc.Material.prototype);
  BasicMaterial.prototype.constructor = BasicMaterial;
  Object.assign(BasicMaterial.prototype, {clone:function() {
    var clone = new pc.BasicMaterial;
    pc.Material.prototype._cloneInternal.call(this, clone);
    clone.color.copy(this.color);
    clone.colorMap = this.colorMap;
    clone.vertexColors = this.vertexColors;
    clone.update();
    return clone;
  }, update:function() {
    this.clearParameters();
    this.setParameter("uColor", this.color.data);
    if (this.colorMap) {
      this.setParameter("texture_diffuseMap", this.colorMap);
    }
  }, updateShader:function(device, scene, objDefs, staticLightList, pass, sortedLights) {
    var options = {skin:!!this.meshInstances[0].skinInstance, vertexColors:this.vertexColors, diffuseMap:this.colorMap, pass:pass};
    var library = device.getProgramLibrary();
    this.shader = library.getProgram("basic", options);
  }});
  return {BasicMaterial:BasicMaterial};
}());
Object.assign(pc, function() {
  var DepthMaterial = function() {
    pc.Material.call(this);
  };
  DepthMaterial.prototype = Object.create(pc.Material.prototype);
  DepthMaterial.prototype.constructor = DepthMaterial;
  Object.assign(DepthMaterial.prototype, {clone:function() {
    var clone = new pc.DepthMaterial;
    pc.Material.prototype._cloneInternal.call(this, clone);
    clone.update();
    return clone;
  }, update:function() {
  }, updateShader:function(device) {
    var options = {skin:!!this.meshInstances[0].skinInstance};
    var library = device.getProgramLibrary();
    this.shader = library.getProgram("depth", options);
  }});
  return {DepthMaterial:DepthMaterial};
}());
Object.assign(pc, function() {
  var StandardMaterial = function() {
    pc.Material.call(this);
    this.reset();
    this.update();
  };
  StandardMaterial.prototype = Object.create(pc.Material.prototype);
  StandardMaterial.prototype.constructor = StandardMaterial;
  var _createTexture = function(param) {
    return param.data instanceof pc.Texture ? param.data : null;
  };
  var _createCubemap = function(param) {
    return param.data instanceof pc.Texture ? param.data : null;
  };
  var _createVec2 = function(param) {
    return new pc.Vec2(param.data[0], param.data[1]);
  };
  var _createBoundingBox = function(param) {
    var center, halfExtents;
    if (param.data && param.data.center) {
      center = new pc.Vec3(param.data.center[0], param.data.center[1], param.data.center[2]);
    } else {
      center = new pc.Vec3(0, 0, 0);
    }
    if (param.data && param.data.halfExtents) {
      halfExtents = new pc.Vec3(param.data.halfExtents[0], param.data.halfExtents[1], param.data.halfExtents[2]);
    } else {
      halfExtents = new pc.Vec3(0.5, 0.5, 0.5);
    }
    return new pc.BoundingBox(center, halfExtents);
  };
  var _createRgb = function(param) {
    return new pc.Color(param.data[0], param.data[1], param.data[2]);
  };
  var _propsSerial = [];
  var _propsSerialDefaultVal = [];
  var _propsInternalNull = [];
  var _propsInternalVec3 = [];
  var _prop2Uniform = {};
  var _defineTex2D = function(obj, name, uv, channels, defChannel) {
    var privMap = "_" + name + "Map";
    var privMapTiling = privMap + "Tiling";
    var privMapOffset = privMap + "Offset";
    var mapTransform = privMap.substring(1) + "Transform";
    var privMapUv = privMap + "Uv";
    var privMapChannel = privMap + "Channel";
    var privMapVertexColor = "_" + name + "VertexColor";
    var privMapVertexColorChannel = "_" + name + "VertexColorChannel";
    obj[privMap] = null;
    obj[privMapTiling] = new pc.Vec2(1, 1);
    obj[privMapOffset] = new pc.Vec2(0, 0);
    obj[mapTransform] = null;
    obj[privMapUv] = uv;
    if (channels > 0) {
      var channel = defChannel ? defChannel : channels > 1 ? "rgb" : "g";
      obj[privMapChannel] = channel;
      obj[privMapVertexColorChannel] = channel;
    }
    obj[privMapVertexColor] = false;
    if (!pc._matTex2D) {
      pc._matTex2D = [];
    }
    pc._matTex2D[name] = channels;
    Object.defineProperty(StandardMaterial.prototype, privMap.substring(1), {get:function() {
      return this[privMap];
    }, set:function(value) {
      var oldVal = this[privMap];
      if (!!oldVal ^ !!value) {
        this.dirtyShader = true;
      }
      if (oldVal && value) {
        if (oldVal.rgbm !== value.rgbm || oldVal.fixCubemapSeams !== value.fixCubemapSeams || oldVal.format !== value.format) {
          this.dirtyShader = true;
        }
      }
      this[privMap] = value;
    }});
    var mapTiling = privMapTiling.substring(1);
    var mapOffset = privMapOffset.substring(1);
    Object.defineProperty(StandardMaterial.prototype, mapTiling, {get:function() {
      return this[privMapTiling];
    }, set:function(value) {
      this.dirtyShader = true;
      this[privMapTiling] = value;
    }});
    _prop2Uniform[mapTiling] = function(mat, val, changeMat) {
      var tform = mat._updateMapTransform(changeMat ? mat[mapTransform] : null, val, mat[privMapOffset]);
      return {name:"texture_" + mapTransform, value:tform.data};
    };
    Object.defineProperty(StandardMaterial.prototype, mapOffset, {get:function() {
      return this[privMapOffset];
    }, set:function(value) {
      this.dirtyShader = true;
      this[privMapOffset] = value;
    }});
    _prop2Uniform[mapOffset] = function(mat, val, changeMat) {
      var tform = mat._updateMapTransform(changeMat ? mat[mapTransform] : null, mat[privMapTiling], val);
      return {name:"texture_" + mapTransform, value:tform.data};
    };
    Object.defineProperty(StandardMaterial.prototype, privMapUv.substring(1), {get:function() {
      return this[privMapUv];
    }, set:function(value) {
      if (this[privMapUv] !== value) {
        this.dirtyShader = true;
      }
      this[privMapUv] = value;
    }});
    Object.defineProperty(StandardMaterial.prototype, privMapChannel.substring(1), {get:function() {
      return this[privMapChannel];
    }, set:function(value) {
      if (this[privMapChannel] !== value) {
        this.dirtyShader = true;
      }
      this[privMapChannel] = value;
    }});
    Object.defineProperty(StandardMaterial.prototype, privMapVertexColor.substring(1), {get:function() {
      return this[privMapVertexColor];
    }, set:function(value) {
      this.dirtyShader = true;
      this[privMapVertexColor] = value;
    }});
    Object.defineProperty(StandardMaterial.prototype, privMapVertexColorChannel.substring(1), {get:function() {
      return this[privMapVertexColorChannel];
    }, set:function(value) {
      if (this[privMapVertexColorChannel] !== value) {
        this.dirtyShader = true;
      }
      this[privMapVertexColorChannel] = value;
    }});
    _propsSerial.push(privMap.substring(1));
    _propsSerial.push(privMapTiling.substring(1));
    _propsSerial.push(privMapOffset.substring(1));
    _propsSerial.push(privMapUv.substring(1));
    _propsSerial.push(privMapChannel.substring(1));
    _propsSerial.push(privMapVertexColor.substring(1));
    _propsSerial.push(privMapVertexColorChannel.substring(1));
    _propsInternalNull.push(mapTransform);
  };
  var _propsColor = [];
  var _defineColor = function(obj, name, defaultValue, hasMultiplier) {
    var priv = "_" + name;
    var uform = name + "Uniform";
    var mult = name + "Intensity";
    var pmult = "_" + mult;
    obj[priv] = defaultValue;
    obj[uform] = new Float32Array(3);
    Object.defineProperty(StandardMaterial.prototype, name, {get:function() {
      this.dirtyColor = true;
      this.dirtyShader = true;
      return this[priv];
    }, set:function(value) {
      var oldVal = this[priv];
      var wasBw = oldVal.data[0] === 0 && oldVal.data[1] === 0 && oldVal.data[2] === 0 || oldVal.data[0] === 1 && oldVal.data[1] === 1 && oldVal.data[2] === 1;
      var isBw = value.data[0] === 0 && value.data[1] === 0 && value.data[2] === 0 || value.data[0] === 1 && value.data[1] === 1 && value.data[2] === 1;
      if (wasBw ^ isBw) {
        this.dirtyShader = true;
      }
      this.dirtyColor = true;
      this[priv] = value;
    }});
    _propsSerial.push(name);
    _propsInternalVec3.push(uform);
    _propsColor.push(name);
    _prop2Uniform[name] = function(mat, val, changeMat) {
      var arr = changeMat ? mat[uform] : new Float32Array(3);
      var gammaCorrection = false;
      if (mat.useGammaTonemap) {
        var scene = mat._scene || pc.Application.getApplication().scene;
        gammaCorrection = scene.gammaCorrection;
      }
      for (var c = 0;c < 3;c++) {
        if (gammaCorrection) {
          arr[c] = Math.pow(val.data[c], 2.2);
        } else {
          arr[c] = val.data[c];
        }
        if (hasMultiplier) {
          arr[c] *= mat[pmult];
        }
      }
      return {name:"material_" + name, value:arr};
    };
    if (hasMultiplier) {
      obj[pmult] = 1;
      Object.defineProperty(StandardMaterial.prototype, mult, {get:function() {
        return this[pmult];
      }, set:function(value) {
        var oldVal = this[pmult];
        var wasBw = oldVal === 0 || oldVal === 1;
        var isBw = value === 0 || value === 1;
        if (wasBw ^ isBw) {
          this.dirtyShader = true;
        }
        this.dirtyColor = true;
        this[pmult] = value;
      }});
      _propsSerial.push(mult);
      _prop2Uniform[mult] = function(mat, val, changeMat) {
        var arr = changeMat ? mat[uform] : new Float32Array(3);
        var gammaCorrection = false;
        if (mat.useGammaTonemap) {
          var scene = mat._scene || pc.Application.getApplication().scene;
          gammaCorrection = scene.gammaCorrection;
        }
        for (var c = 0;c < 3;c++) {
          if (gammaCorrection) {
            arr[c] = Math.pow(mat[priv].data[c], 2.2);
          } else {
            arr[c] = mat[priv].data[c];
          }
          arr[c] *= mat[pmult];
        }
        return {name:"material_" + name, value:arr};
      };
    }
  };
  var _defineFloat = function(obj, name, defaultValue, func) {
    var priv = "_" + name;
    obj[priv] = defaultValue;
    Object.defineProperty(StandardMaterial.prototype, name, {get:function() {
      return this[priv];
    }, set:function(value) {
      var oldVal = this[priv];
      var wasBw = oldVal === 0 || oldVal === 1;
      var isBw = value === 0 || value === 1;
      if (wasBw ^ isBw) {
        this.dirtyShader = true;
      }
      this[priv] = value;
    }});
    _propsSerial.push(name);
    _prop2Uniform[name] = func !== undefined ? func : function(mat, val, changeMat) {
      return {name:"material_" + name, value:val};
    };
  };
  var _defineObject = function(obj, name, func) {
    var priv = "_" + name;
    obj[priv] = null;
    Object.defineProperty(StandardMaterial.prototype, name, {get:function() {
      return this[priv];
    }, set:function(value) {
      var oldVal = this[priv];
      if (!!oldVal ^ !!value) {
        this.dirtyShader = true;
      }
      this[priv] = value;
    }});
    _propsSerial.push(name);
    _prop2Uniform[name] = func;
  };
  var _defineAlias = function(obj, newName, oldName) {
    Object.defineProperty(StandardMaterial.prototype, oldName, {get:function() {
      return this[newName];
    }, set:function(value) {
      this[newName] = value;
    }});
  };
  var _defineChunks = function(obj) {
    Object.defineProperty(StandardMaterial.prototype, "chunks", {get:function() {
      this.dirtyShader = true;
      return this._chunks;
    }, set:function(value) {
      this.dirtyShader = true;
      this._chunks = value;
    }});
    _propsSerial.push("chunks");
  };
  var _defineFlag = function(obj, name, defaultValue) {
    var priv = "_" + name;
    obj[priv] = defaultValue;
    Object.defineProperty(StandardMaterial.prototype, name, {get:function() {
      return this[priv];
    }, set:function(value) {
      if (this[priv] !== value) {
        this.dirtyShader = true;
      }
      this[priv] = value;
    }});
    _propsSerial.push(name);
  };
  var Chunks = function() {
  };
  Chunks.prototype.copy = function(from) {
    for (var p in from) {
      if (from.hasOwnProperty(p) && p !== "copy") {
        this[p] = from[p];
      }
    }
  };
  Object.assign(StandardMaterial.prototype, {reset:function() {
    this.blendType = pc.BLEND_NONE;
    var i;
    for (i = 0;i < _propsSerial.length;i++) {
      var defVal = _propsSerialDefaultVal[i];
      this[_propsSerial[i]] = defVal ? defVal.clone ? defVal.clone() : defVal : defVal;
    }
    for (i = 0;i < _propsInternalNull.length;i++) {
      this[_propsInternalNull[i]] = null;
    }
    for (i = 0;i < _propsInternalVec3.length;i++) {
      this[_propsInternalVec3[i]] = new Float32Array(3);
    }
    this._chunks = new Chunks;
    this.cubeMapMinUniform = new Float32Array(3);
    this.cubeMapMaxUniform = new Float32Array(3);
  }, clone:function() {
    var clone = new pc.StandardMaterial;
    pc.Material.prototype._cloneInternal.call(this, clone);
    var pname;
    for (var i = 0;i < _propsSerial.length;i++) {
      pname = _propsSerial[i];
      if (this[pname] !== undefined) {
        if (this[pname] && this[pname].copy) {
          if (clone[pname]) {
            clone[pname].copy(this[pname]);
          } else {
            clone[pname] = this[pname].clone();
          }
        } else {
          clone[pname] = this[pname];
        }
      }
    }
    if (!clone.shader) {
      clone.update();
    }
    return clone;
  }, init:function(data) {
    this.reset();
    this.name = data.name;
    if (data.chunks) {
      this.chunks.copy(data.chunks);
    }
    for (var i = 0;i < data.parameters.length;i++) {
      var param = data.parameters[i];
      if (param.type === "vec3") {
        this[param.name] = _createRgb(param);
      } else {
        if (param.type === "vec2") {
          this[param.name] = _createVec2(param);
        } else {
          if (param.type === "texture") {
            this[param.name] = _createTexture(param);
          } else {
            if (param.type === "cubemap") {
              this[param.name] = _createCubemap(param);
            } else {
              if (param.name === "bumpMapFactor") {
                this.bumpiness = param.data;
              } else {
                if (param.type === "boundingbox") {
                  this[param.name] = _createBoundingBox(param);
                } else {
                  this[param.name] = param.data;
                }
              }
            }
          }
        }
      }
    }
    this.update();
  }, _updateMapTransform:function(transform, tiling, offset) {
    transform = transform || new pc.Vec4;
    transform.set(tiling.x, tiling.y, offset.x, offset.y);
    if (transform.x === 1 && transform.y === 1 && transform.z === 0 && transform.w === 0) {
      return null;
    }
    return transform;
  }, _collectLights:function(lType, lights, lightsFiltered, mask, staticLightList) {
    var light;
    var i;
    for (i = 0;i < lights.length;i++) {
      light = lights[i];
      if (light._enabled) {
        if (light._mask & mask) {
          if (lType !== pc.LIGHTTYPE_DIRECTIONAL) {
            if (light.isStatic) {
              continue;
            }
          }
          lightsFiltered.push(light);
        }
      }
    }
    if (staticLightList) {
      for (i = 0;i < staticLightList.length;i++) {
        light = staticLightList[i];
        if (light._type === lType) {
          lightsFiltered.push(light);
        }
      }
    }
  }, _setParameter:function(name, value) {
    this.setParameter(name, value);
    this._propsSet.push(name);
  }, _clearParameters:function() {
    var props = this._propsSet;
    for (var i = 0;i < props.length;i++) {
      delete this.parameters[props[i]];
    }
    this._propsSet = [];
  }, _updateMap:function(p) {
    var mname = p + "Map";
    if (this[mname]) {
      this._setParameter("texture_" + mname, this[mname]);
      var tname = mname + "Transform";
      this[tname] = this._updateMapTransform(this[tname], this[mname + "Tiling"], this[mname + "Offset"]);
      if (this[tname]) {
        this._setParameter("texture_" + tname, this[tname].data);
      }
    }
  }, getUniform:function(varName, value, changeMat) {
    var func = _prop2Uniform[varName];
    if (func) {
      return func(this, value, changeMat);
    }
    return null;
  }, update:function() {
    this._clearParameters();
    this._setParameter("material_ambient", this.ambientUniform);
    if (!this.diffuseMap || this.diffuseTint) {
      this._setParameter("material_diffuse", this.diffuseUniform);
    }
    if (!this.useMetalness) {
      if (!this.specularMap || this.specularTint) {
        this._setParameter("material_specular", this.specularUniform);
      }
    } else {
      if (!this.metalnessMap || this.metalness < 1) {
        this._setParameter("material_metalness", this.metalness);
      }
    }
    this._setParameter(this.getUniform("shininess", this.shininess, true));
    if (!this.emissiveMap || this.emissiveTint) {
      this._setParameter("material_emissive", this.emissiveUniform);
    }
    if (this.emissiveMap) {
      this._setParameter("material_emissiveIntensity", this.emissiveIntensity);
    }
    if (this.refraction > 0) {
      this._setParameter("material_refraction", this.refraction);
      this._setParameter("material_refractionIndex", this.refractionIndex);
    }
    this._setParameter("material_opacity", this.opacity);
    if (this.occludeSpecular) {
      this._setParameter("material_occludeSpecularIntensity", this.occludeSpecularIntensity);
    }
    if (this.cubeMapProjection === pc.CUBEPROJ_BOX) {
      this._setParameter(this.getUniform("cubeMapProjectionBox", this.cubeMapProjectionBox, true));
    }
    for (var p in pc._matTex2D) {
      this._updateMap(p);
    }
    if (this.ambientSH) {
      this._setParameter("ambientSH[0]", this.ambientSH);
    }
    if (this.normalMap) {
      this._setParameter("material_bumpiness", this.bumpiness);
    }
    if (this.heightMap) {
      this._setParameter(this.getUniform("heightMapFactor", this.heightMapFactor, true));
    }
    if (this.cubeMap) {
      this._setParameter("texture_cubeMap", this.cubeMap);
    }
    if (this.prefilteredCubeMap128) {
      this._setParameter("texture_prefilteredCubeMap128", this.prefilteredCubeMap128);
    } else {
      if (this._scene && this._scene._skyboxPrefiltered[0]) {
        this._setParameter("texture_prefilteredCubeMap128", this._scene._skyboxPrefiltered[0]);
      }
    }
    if (this.prefilteredCubeMap64) {
      this._setParameter("texture_prefilteredCubeMap64", this.prefilteredCubeMap64);
    } else {
      if (this._scene && this._scene._skyboxPrefiltered[1]) {
        this._setParameter("texture_prefilteredCubeMap64", this._scene._skyboxPrefiltered[1]);
      }
    }
    if (this.prefilteredCubeMap32) {
      this._setParameter("texture_prefilteredCubeMap32", this.prefilteredCubeMap32);
    } else {
      if (this._scene && this._scene._skyboxPrefiltered[2]) {
        this._setParameter("texture_prefilteredCubeMap32", this._scene._skyboxPrefiltered[2]);
      }
    }
    if (this.prefilteredCubeMap16) {
      this._setParameter("texture_prefilteredCubeMap16", this.prefilteredCubeMap16);
    } else {
      if (this._scene && this._scene._skyboxPrefiltered[3]) {
        this._setParameter("texture_prefilteredCubeMap16", this._scene._skyboxPrefiltered[3]);
      }
    }
    if (this.prefilteredCubeMap8) {
      this._setParameter("texture_prefilteredCubeMap8", this.prefilteredCubeMap8);
    } else {
      if (this._scene && this._scene._skyboxPrefiltered[4]) {
        this._setParameter("texture_prefilteredCubeMap8", this._scene._skyboxPrefiltered[4]);
      }
    }
    if (this.prefilteredCubeMap4) {
      this._setParameter("texture_prefilteredCubeMap4", this.prefilteredCubeMap4);
    } else {
      if (this._scene && this._scene._skyboxPrefiltered[5]) {
        this._setParameter("texture_prefilteredCubeMap4", this._scene._skyboxPrefiltered[5]);
      }
    }
    if (this.sphereMap) {
      this._setParameter("texture_sphereMap", this.sphereMap);
    }
    if (this.dpAtlas) {
      this._setParameter("texture_sphereMap", this.dpAtlas);
    }
    this._setParameter("material_reflectivity", this.reflectivity);
    if (this.dirtyShader || !this._scene) {
      this.shader = null;
      this.clearVariants();
    }
    this._processColor();
  }, _processColor:function() {
    var c, i;
    if (!this.dirtyColor) {
      return;
    }
    if (!this._scene && this.useGammaTonemap) {
      return;
    }
    var gammaCorrection = false;
    if (this.useGammaTonemap) {
      gammaCorrection = this._scene.gammaCorrection;
    }
    for (i = 0;i < _propsColor.length;i++) {
      var clr = this["_" + _propsColor[i]];
      var arr = this[_propsColor[i] + "Uniform"];
      for (c = 0;c < 3;c++) {
        if (gammaCorrection) {
          arr[c] = Math.pow(clr.data[c], 2.2);
        } else {
          arr[c] = clr.data[c];
        }
      }
    }
    for (c = 0;c < 3;c++) {
      this.emissiveUniform[c] *= this.emissiveIntensity;
    }
    this.dirtyColor = false;
  }, _getMapTransformID:function(xform, uv) {
    if (!xform) {
      return 0;
    }
    if (!this._mapXForms[uv]) {
      this._mapXForms[uv] = [];
    }
    var i, j, same;
    for (i = 0;i < this._mapXForms[uv].length;i++) {
      same = true;
      for (j = 0;j < xform.data.length;j++) {
        if (this._mapXForms[uv][i][j] != xform.data[j]) {
          same = false;
          break;
        }
      }
      if (same) {
        return i + 1;
      }
    }
    var newID = this._mapXForms[uv].length;
    this._mapXForms[uv][newID] = [];
    for (j = 0;j < xform.data.length;j++) {
      this._mapXForms[uv][newID][j] = xform.data[j];
    }
    return newID + 1;
  }, updateShader:function(device, scene, objDefs, staticLightList, pass, sortedLights) {
    if (!this._colorProcessed && this._scene) {
      this._colorProcessed = true;
      this._processColor();
    }
    this._mapXForms = [];
    var useTexCubeLod = device.useTexCubeLod;
    var useDp = !device.extTextureLod;
    var globalSky128, globalSky64, globalSky32, globalSky16, globalSky8, globalSky4;
    if (this.useSkybox) {
      globalSky128 = scene._skyboxPrefiltered[0];
      globalSky64 = scene._skyboxPrefiltered[1];
      globalSky32 = scene._skyboxPrefiltered[2];
      globalSky16 = scene._skyboxPrefiltered[3];
      globalSky8 = scene._skyboxPrefiltered[4];
      globalSky4 = scene._skyboxPrefiltered[5];
    }
    var prefilteredCubeMap128 = this.prefilteredCubeMap128 || globalSky128;
    var prefilteredCubeMap64 = this.prefilteredCubeMap64 || globalSky64;
    var prefilteredCubeMap32 = this.prefilteredCubeMap32 || globalSky32;
    var prefilteredCubeMap16 = this.prefilteredCubeMap16 || globalSky16;
    var prefilteredCubeMap8 = this.prefilteredCubeMap8 || globalSky8;
    var prefilteredCubeMap4 = this.prefilteredCubeMap4 || globalSky4;
    if (prefilteredCubeMap128) {
      var allMips = prefilteredCubeMap128 && prefilteredCubeMap64 && prefilteredCubeMap32 && prefilteredCubeMap16 && prefilteredCubeMap8 && prefilteredCubeMap4;
      if (useDp && allMips) {
        if (!prefilteredCubeMap128.dpAtlas) {
          prefilteredCubeMap128.dpAtlas = pc.generateDpAtlas(device, [prefilteredCubeMap128, prefilteredCubeMap64, prefilteredCubeMap32, prefilteredCubeMap16, prefilteredCubeMap8, prefilteredCubeMap4]);
          prefilteredCubeMap128.sh = pc.shFromCubemap(prefilteredCubeMap16);
        }
        this.dpAtlas = prefilteredCubeMap128.dpAtlas;
        this.ambientSH = prefilteredCubeMap128.sh;
        this._setParameter("ambientSH[0]", this.ambientSH);
        this._setParameter("texture_sphereMap", this.dpAtlas);
      } else {
        if (useTexCubeLod) {
          if (prefilteredCubeMap128._levels.length < 6) {
            if (allMips) {
              this._setParameter("texture_prefilteredCubeMap128", prefilteredCubeMap128);
            } else {
              console.log("Can't use prefiltered cubemap: " + allMips + ", " + useTexCubeLod + ", " + prefilteredCubeMap128._levels);
            }
          } else {
            this._setParameter("texture_prefilteredCubeMap128", prefilteredCubeMap128);
          }
        } else {
          if (allMips) {
            this._setParameter("texture_prefilteredCubeMap128", prefilteredCubeMap128);
            this._setParameter("texture_prefilteredCubeMap64", prefilteredCubeMap64);
            this._setParameter("texture_prefilteredCubeMap32", prefilteredCubeMap32);
            this._setParameter("texture_prefilteredCubeMap16", prefilteredCubeMap16);
            this._setParameter("texture_prefilteredCubeMap8", prefilteredCubeMap8);
            this._setParameter("texture_prefilteredCubeMap4", prefilteredCubeMap4);
          } else {
            console.log("Can't use prefiltered cubemap: " + allMips + ", " + useTexCubeLod + ", " + prefilteredCubeMap128._levels);
          }
        }
      }
    }
    var diffuseTint = (this.diffuse.data[0] !== 1 || this.diffuse.data[1] !== 1 || this.diffuse.data[2] !== 1) && (this.diffuseTint || !this.diffuseMap && !this.diffuseVertexColor) ? 3 : 0;
    var specularTint = false;
    var useSpecular = (this.useMetalness ? true : !!this.specularMap) || !!this.sphereMap || !!this.cubeMap || !!this.dpAtlas;
    useSpecular = useSpecular || (this.useMetalness ? true : !(this.specular.data[0] === 0 && this.specular.data[1] === 0 && this.specular.data[2] === 0));
    if (useSpecular) {
      if ((this.specularTint || !this.specularMap && !this.specularVertexColor) && !this.useMetalness) {
        specularTint = this.specular.data[0] !== 1 || this.specular.data[1] !== 1 || this.specular.data[2] !== 1;
      }
    }
    var rgbmAmbient = (prefilteredCubeMap128 ? prefilteredCubeMap128.rgbm : false) || (this.cubeMap ? this.cubeMap.rgbm : false) || (this.dpAtlas ? this.dpAtlas.rgbm : false);
    var hdrAmbient = (prefilteredCubeMap128 ? prefilteredCubeMap128.rgbm || prefilteredCubeMap128.format === pc.PIXELFORMAT_RGBA32F : false) || (this.cubeMap ? this.cubeMap.rgbm || this.cubeMap.format === pc.PIXELFORMAT_RGBA32F : false) || (this.dpAtlas ? this.dpAtlas.rgbm || this.dpAtlas.format === pc.PIXELFORMAT_RGBA32F : false);
    var rgbmReflection = (prefilteredCubeMap128 && !this.cubeMap && !this.sphereMap && !this.dpAtlas ? prefilteredCubeMap128.rgbm : false) || (this.cubeMap ? this.cubeMap.rgbm : false) || (this.sphereMap ? this.sphereMap.rgbm : false) || (this.dpAtlas ? this.dpAtlas.rgbm : false);
    var hdrReflection = (prefilteredCubeMap128 && !this.cubeMap && !this.sphereMap && !this.dpAtlas ? prefilteredCubeMap128.rgbm || prefilteredCubeMap128.format === pc.PIXELFORMAT_RGBA32F : false) || (this.cubeMap ? this.cubeMap.rgbm || this.cubeMap.format === pc.PIXELFORMAT_RGBA32F : false) || (this.sphereMap ? this.sphereMap.rgbm || this.sphereMap.format === pc.PIXELFORMAT_RGBA32F : false) || (this.dpAtlas ? this.dpAtlas.rgbm || this.dpAtlas.format === pc.PIXELFORMAT_RGBA32F : false);
    var emissiveTint = this.emissiveMap ? 0 : 3;
    if (!emissiveTint) {
      emissiveTint = (this.emissive.data[0] !== 1 || this.emissive.data[1] !== 1 || this.emissive.data[2] !== 1 || this.emissiveIntensity !== 1) && this.emissiveTint;
      emissiveTint = emissiveTint ? 3 : this.emissiveIntensity !== 1 ? 1 : 0;
    }
    var options;
    var minimalOptions = pass > pc.SHADER_FORWARDHDR && pass <= pc.SHADER_PICK;
    if (minimalOptions) {
      options = {opacityTint:this.opacity !== 1 && this.blendType !== pc.BLEND_NONE, alphaTest:this.alphaTest > 0, forceFragmentPrecision:this.forceFragmentPrecision, chunks:this.chunks, blendType:this.blendType, forceUv1:this.forceUv1, pass:pass};
    } else {
      options = {fog:this.useFog ? scene.fog : "none", gamma:this.useGammaTonemap ? scene.gammaCorrection : pc.GAMMA_NONE, toneMap:this.useGammaTonemap ? scene.toneMapping : -1, blendMapsWithColors:true, ambientTint:this.ambientTint, diffuseTint:diffuseTint, specularTint:specularTint ? 3 : 0, metalnessTint:this.useMetalness && this.metalness < 1 ? 1 : 0, glossTint:1, emissiveTint:emissiveTint, opacityTint:this.opacity !== 1 && this.blendType !== pc.BLEND_NONE ? 1 : 0, alphaTest:this.alphaTest > 0, 
      alphaToCoverage:this.alphaToCoverage, needsNormalFloat:this.normalizeNormalMap, sphereMap:!!this.sphereMap, cubeMap:!!this.cubeMap, dpAtlas:!!this.dpAtlas, ambientSH:!!this.ambientSH, useSpecular:useSpecular, rgbmAmbient:rgbmAmbient, rgbmReflection:rgbmReflection, hdrAmbient:hdrAmbient, hdrReflection:hdrReflection, fixSeams:prefilteredCubeMap128 ? prefilteredCubeMap128.fixCubemapSeams : this.cubeMap ? this.cubeMap.fixCubemapSeams : false, prefilteredCubemap:!!prefilteredCubeMap128, emissiveFormat:this.emissiveMap ? 
      this.emissiveMap.rgbm ? 1 : this.emissiveMap.format === pc.PIXELFORMAT_RGBA32F ? 2 : 0 : null, lightMapFormat:this.lightMap ? this.lightMap.rgbm ? 1 : this.lightMap.format === pc.PIXELFORMAT_RGBA32F ? 2 : 0 : null, useRgbm:rgbmReflection || rgbmAmbient || (this.emissiveMap ? this.emissiveMap.rgbm : 0) || (this.lightMap ? this.lightMap.rgbm : 0), specularAntialias:this.specularAntialias, conserveEnergy:this.conserveEnergy, occludeSpecular:this.occludeSpecular, occludeSpecularFloat:this.occludeSpecularIntensity !== 
      1.0, occludeDirect:this.occludeDirect, shadingModel:this.shadingModel, fresnelModel:this.fresnelModel, packedNormal:this.normalMap ? this.normalMap.format === pc.PIXELFORMAT_DXT5 : false, forceFragmentPrecision:this.forceFragmentPrecision, fastTbn:this.fastTbn, cubeMapProjection:this.cubeMapProjection, chunks:this.chunks, customFragmentShader:this.customFragmentShader, refraction:!!this.refraction, useMetalness:this.useMetalness, blendType:this.blendType, skyboxIntensity:prefilteredCubeMap128 === 
      globalSky128 && prefilteredCubeMap128 && scene.skyboxIntensity !== 1, forceUv1:this.forceUv1, useTexCubeLod:useTexCubeLod, msdf:!!this.msdfMap, twoSidedLighting:this.twoSidedLighting, pixelSnap:this.pixelSnap, pass:pass};
      if (pass === pc.SHADER_FORWARDHDR) {
        if (options.gamma) {
          options.gamma = pc.GAMMA_SRGBHDR;
        }
        options.toneMap = pc.TONEMAP_LINEAR;
      }
    }
    var hasUv0 = false;
    var hasUv1 = false;
    var hasVcolor = false;
    if (objDefs) {
      if (!minimalOptions) {
        options.noShadow = (objDefs & pc.SHADERDEF_NOSHADOW) !== 0;
        if ((objDefs & pc.SHADERDEF_LM) !== 0) {
          options.lightMapFormat = 1;
          options.lightMap = true;
          options.lightMapChannel = "rgb";
          options.lightMapUv = 1;
          options.lightMapTransform = 0;
          options.lightMapWithoutAmbient = !this.lightMap;
          options.useRgbm = true;
          if ((objDefs & pc.SHADERDEF_DIRLM) !== 0) {
            options.dirLightMap = true;
          }
        }
      }
      options.screenSpace = (objDefs & pc.SHADERDEF_SCREENSPACE) !== 0;
      options.skin = (objDefs & pc.SHADERDEF_SKIN) !== 0;
      options.useInstancing = (objDefs & pc.SHADERDEF_INSTANCING) !== 0;
      hasUv0 = (objDefs & pc.SHADERDEF_UV0) !== 0;
      hasUv1 = (objDefs & pc.SHADERDEF_UV1) !== 0;
      hasVcolor = (objDefs & pc.SHADERDEF_VCOLOR) !== 0;
    }
    var isOpacity;
    for (var p in pc._matTex2D) {
      isOpacity = p === "opacity";
      if (isOpacity && this.blendType === pc.BLEND_NONE && this.alphaTest === 0.0 && !this.alphaToCoverage) {
        continue;
      }
      if (minimalOptions && !isOpacity) {
        continue;
      }
      var cname;
      var mname = p + "Map";
      var vname = p + "VertexColor";
      if (p !== "height" && this[vname]) {
        if (hasVcolor) {
          cname = p + "VertexColorChannel";
          options[vname] = this[vname];
          options[cname] = this[cname];
          options.vertexColors = true;
        }
      }
      if (this[mname]) {
        var uname = mname + "Uv";
        var allow = true;
        if (this[uname] === 0 && !hasUv0) {
          allow = false;
        }
        if (this[uname] === 1 && !hasUv1) {
          allow = false;
        }
        if (allow) {
          options[mname] = !!this[mname];
          var tname = mname + "Transform";
          cname = mname + "Channel";
          options[tname] = this._getMapTransformID(this[tname], this[uname]);
          options[cname] = this[cname];
          options[uname] = this[uname];
        }
      }
    }
    this._mapXForms = null;
    if (this.useLighting && !minimalOptions) {
      var lightsFiltered = [];
      var mask = objDefs ? objDefs >> 16 : 1;
      if (sortedLights) {
        this._collectLights(pc.LIGHTTYPE_DIRECTIONAL, sortedLights[pc.LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);
        this._collectLights(pc.LIGHTTYPE_POINT, sortedLights[pc.LIGHTTYPE_POINT], lightsFiltered, mask, staticLightList);
        this._collectLights(pc.LIGHTTYPE_SPOT, sortedLights[pc.LIGHTTYPE_SPOT], lightsFiltered, mask, staticLightList);
      }
      options.lights = lightsFiltered;
    } else {
      options.lights = [];
    }
    if (!minimalOptions) {
      options.aoMapUv = options.aoMapUv || this.aoUvSet;
      if (options.lights.length === 0) {
        options.noShadow = false;
      }
    }
    if (this.onUpdateShader) {
      options = this.onUpdateShader(options);
    }
    var library = device.getProgramLibrary();
    this.shader = library.getProgram("standard", options);
    if (!objDefs) {
      this.clearVariants();
      this.variants[0] = this.shader;
    }
    this.dirtyShader = false;
  }});
  var _defineMaterialProps = function(obj) {
    obj.dirtyShader = true;
    obj.dirtyColor = true;
    obj._scene = null;
    obj._colorProcessed = false;
    _defineColor(obj, "ambient", new pc.Color(0.7, 0.7, 0.7));
    _defineColor(obj, "diffuse", new pc.Color(1, 1, 1));
    _defineColor(obj, "specular", new pc.Color(0, 0, 0));
    _defineColor(obj, "emissive", new pc.Color(0, 0, 0), true);
    _defineFloat(obj, "shininess", 25, function(mat, shininess) {
      var value;
      if (mat.shadingModel === pc.SPECULAR_PHONG) {
        value = Math.pow(2, shininess * 0.01 * 11);
      } else {
        value = shininess * 0.01;
      }
      return {name:"material_shininess", value:value};
    });
    _defineFloat(obj, "heightMapFactor", 1, function(mat, height) {
      return {name:"material_heightMapFactor", value:height * 0.025};
    });
    _defineFloat(obj, "opacity", 1);
    _defineFloat(obj, "alphaTest", 0);
    _defineFloat(obj, "bumpiness", 1);
    _defineFloat(obj, "reflectivity", 1);
    _defineFloat(obj, "occludeSpecularIntensity", 1);
    _defineFloat(obj, "refraction", 0);
    _defineFloat(obj, "refractionIndex", 1.0 / 1.5);
    _defineFloat(obj, "metalness", 1);
    _defineFloat(obj, "aoUvSet", 0, null);
    _defineObject(obj, "ambientSH", function(mat, val, changeMat) {
      return {name:"ambientSH[0]", value:val};
    });
    _defineObject(obj, "cubeMapProjectionBox", function(mat, val, changeMat) {
      var bmin = changeMat ? mat.cubeMapMinUniform : new Float32Array(3);
      var bmax = changeMat ? mat.cubeMapMaxUniform : new Float32Array(3);
      bmin[0] = val.center.x - val.halfExtents.x;
      bmin[1] = val.center.y - val.halfExtents.y;
      bmin[2] = val.center.z - val.halfExtents.z;
      bmax[0] = val.center.x + val.halfExtents.x;
      bmax[1] = val.center.y + val.halfExtents.y;
      bmax[2] = val.center.z + val.halfExtents.z;
      return [{name:"envBoxMin", value:bmin}, {name:"envBoxMax", value:bmax}];
    });
    _defineChunks(obj);
    _defineFlag(obj, "ambientTint", false);
    _defineFlag(obj, "diffuseTint", false);
    _defineFlag(obj, "specularTint", false);
    _defineFlag(obj, "emissiveTint", false);
    _defineFlag(obj, "fastTbn", false);
    _defineFlag(obj, "specularAntialias", false);
    _defineFlag(obj, "useMetalness", false);
    _defineFlag(obj, "occludeDirect", false);
    _defineFlag(obj, "normalizeNormalMap", true);
    _defineFlag(obj, "conserveEnergy", true);
    _defineFlag(obj, "occludeSpecular", pc.SPECOCC_AO);
    _defineFlag(obj, "shadingModel", pc.SPECULAR_BLINN);
    _defineFlag(obj, "fresnelModel", pc.FRESNEL_NONE);
    _defineFlag(obj, "cubeMapProjection", pc.CUBEPROJ_NONE);
    _defineFlag(obj, "customFragmentShader", null);
    _defineFlag(obj, "forceFragmentPrecision", null);
    _defineFlag(obj, "useFog", true);
    _defineFlag(obj, "useLighting", true);
    _defineFlag(obj, "useGammaTonemap", true);
    _defineFlag(obj, "useSkybox", true);
    _defineFlag(obj, "forceUv1", false);
    _defineFlag(obj, "pixelSnap", false);
    _defineFlag(obj, "twoSidedLighting", false);
    _defineTex2D(obj, "diffuse", 0, 3);
    _defineTex2D(obj, "specular", 0, 3);
    _defineTex2D(obj, "emissive", 0, 3);
    _defineTex2D(obj, "normal", 0, -1);
    _defineTex2D(obj, "metalness", 0, 1);
    _defineTex2D(obj, "gloss", 0, 1);
    _defineTex2D(obj, "opacity", 0, 1, "a");
    _defineTex2D(obj, "height", 0, 1);
    _defineTex2D(obj, "ao", 0, 1);
    _defineTex2D(obj, "light", 1, 3);
    _defineTex2D(obj, "msdf", 0, 3);
    _defineObject(obj, "cubeMap");
    _defineObject(obj, "sphereMap");
    _defineObject(obj, "dpAtlas");
    _defineObject(obj, "prefilteredCubeMap128");
    _defineObject(obj, "prefilteredCubeMap64");
    _defineObject(obj, "prefilteredCubeMap32");
    _defineObject(obj, "prefilteredCubeMap16");
    _defineObject(obj, "prefilteredCubeMap8");
    _defineObject(obj, "prefilteredCubeMap4");
    _defineAlias(obj, "diffuseTint", "diffuseMapTint");
    _defineAlias(obj, "specularTint", "specularMapTint");
    _defineAlias(obj, "emissiveTint", "emissiveMapTint");
    _defineAlias(obj, "aoVertexColor", "aoMapVertexColor");
    _defineAlias(obj, "diffuseVertexColor", "diffuseMapVertexColor");
    _defineAlias(obj, "specularVertexColor", "specularMapVertexColor");
    _defineAlias(obj, "emissiveVertexColor", "emissiveMapVertexColor");
    _defineAlias(obj, "metalnessVertexColor", "metalnessMapVertexColor");
    _defineAlias(obj, "glossVertexColor", "glossMapVertexColor");
    _defineAlias(obj, "opacityVertexColor", "opacityMapVertexColor");
    _defineAlias(obj, "lightVertexColor", "lightMapVertexColor");
    for (var i = 0;i < _propsSerial.length;i++) {
      _propsSerialDefaultVal[i] = obj[_propsSerial[i]];
    }
    obj._propsSet = [];
  };
  _defineMaterialProps(StandardMaterial.prototype);
  return {StandardMaterial:StandardMaterial};
}());
Object.assign(pc, function() {
  var id = 0;
  var _tmpAabb = new pc.BoundingBox;
  var Mesh = function() {
    this._refCount = 0;
    this.id = id++;
    this.vertexBuffer = null;
    this.indexBuffer = [null];
    this.primitive = [{type:0, base:0, count:0}];
    this.skin = null;
    this.morph = null;
    this._aabb = new pc.BoundingBox;
    this.boneAabb = null;
  };
  Object.defineProperty(Mesh.prototype, "aabb", {get:function() {
    return this.morph ? this.morph.aabb : this._aabb;
  }, set:function(aabb) {
    if (this.morph) {
      this._aabb = this.morph._baseAabb = aabb;
      this.morph._calculateAabb();
    } else {
      this._aabb = aabb;
    }
  }});
  var MeshInstance = function MeshInstance(node, mesh, material) {
    this._key = [0, 0];
    this._shader = [null, null, null];
    this.isStatic = false;
    this._staticLightList = null;
    this._staticSource = null;
    this.node = node;
    this._mesh = mesh;
    mesh._refCount++;
    this.material = material;
    this._shaderDefs = pc.MASK_DYNAMIC << 16;
    this._shaderDefs |= mesh.vertexBuffer.format.hasUv0 ? pc.SHADERDEF_UV0 : 0;
    this._shaderDefs |= mesh.vertexBuffer.format.hasUv1 ? pc.SHADERDEF_UV1 : 0;
    this._shaderDefs |= mesh.vertexBuffer.format.hasColor ? pc.SHADERDEF_VCOLOR : 0;
    this._lightHash = 0;
    this.visible = true;
    this.layer = pc.LAYER_WORLD;
    this.renderStyle = pc.RENDERSTYLE_SOLID;
    this.castShadow = false;
    this._receiveShadow = true;
    this._screenSpace = false;
    this._noDepthDrawGl1 = false;
    this.cull = true;
    this.pick = true;
    this._updateAabb = true;
    this._updateAabbFunc = null;
    this.updateKey();
    this._skinInstance = null;
    this.morphInstance = null;
    this.instancingData = null;
    this.aabb = new pc.BoundingBox;
    this._boneAabb = null;
    this._aabbVer = -1;
    this.drawOrder = 0;
    this.visibleThisFrame = 0;
    this.parameters = {};
    this.stencilFront = null;
    this.stencilBack = null;
  };
  Object.defineProperty(MeshInstance.prototype, "mesh", {get:function() {
    return this._mesh;
  }, set:function(mesh) {
    if (this._mesh) {
      this._mesh._refCount--;
    }
    this._mesh = mesh;
    if (mesh) {
      mesh._refCount++;
    }
  }});
  Object.defineProperty(MeshInstance.prototype, "aabb", {get:function() {
    var aabb;
    if (!this._updateAabb) {
      return this._aabb;
    }
    if (this._updateAabbFunc) {
      return this._updateAabbFunc(this._aabb);
    }
    if (this.skinInstance) {
      var numBones = this.mesh.skin.boneNames.length;
      var boneUsed, i;
      if (!this.mesh.boneAabb) {
        this.mesh.boneAabb = [];
        this.mesh.boneUsed = [];
        var elems = this.mesh.vertexBuffer.format.elements;
        var numVerts = this.mesh.vertexBuffer.numVertices;
        var vertSize = this.mesh.vertexBuffer.format.size;
        var index;
        var offsetP, offsetI, offsetW;
        var j, k, l;
        for (i = 0;i < elems.length;i++) {
          if (elems[i].name === pc.SEMANTIC_POSITION) {
            offsetP = elems[i].offset;
          } else {
            if (elems[i].name === pc.SEMANTIC_BLENDINDICES) {
              offsetI = elems[i].offset;
            } else {
              if (elems[i].name === pc.SEMANTIC_BLENDWEIGHT) {
                offsetW = elems[i].offset;
              }
            }
          }
        }
        var data8 = new Uint8Array(this.mesh.vertexBuffer.storage);
        var dataF = new Float32Array(this.mesh.vertexBuffer.storage);
        var offsetPF = offsetP / 4;
        var offsetWF = offsetW / 4;
        var vertSizeF = vertSize / 4;
        var bMax, bMin;
        var x, y, z;
        var boneMin = [];
        var boneMax = [];
        boneUsed = this.mesh.boneUsed;
        for (i = 0;i < numBones;i++) {
          boneMin[i] = new pc.Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
          boneMax[i] = new pc.Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        }
        for (j = 0;j < numVerts;j++) {
          for (k = 0;k < 4;k++) {
            if (dataF[j * vertSizeF + offsetWF + k] > 0) {
              index = data8[j * vertSize + offsetI + k];
              x = dataF[j * vertSizeF + offsetPF];
              y = dataF[j * vertSizeF + offsetPF + 1];
              z = dataF[j * vertSizeF + offsetPF + 2];
              bMax = boneMax[index];
              bMin = boneMin[index];
              if (bMin.x > x) {
                bMin.x = x;
              }
              if (bMin.y > y) {
                bMin.y = y;
              }
              if (bMin.z > z) {
                bMin.z = z;
              }
              if (bMax.x < x) {
                bMax.x = x;
              }
              if (bMax.y < y) {
                bMax.y = y;
              }
              if (bMax.z < z) {
                bMax.z = z;
              }
              boneUsed[index] = true;
            }
          }
        }
        if (this.morphInstance) {
          var vertIndex;
          var targets = this.morphInstance.morph._targets;
          var minMorphedPos = new Float32Array(numVerts * 3);
          var maxMorphedPos = new Float32Array(numVerts * 3);
          var m, dx, dy, dz;
          var target, mtIndices, mtIndicesLength, deltaPos;
          for (j = 0;j < numVerts;j++) {
            minMorphedPos[j * 3] = maxMorphedPos[j * 3] = dataF[j * vertSizeF + offsetPF];
            minMorphedPos[j * 3 + 1] = maxMorphedPos[j * 3 + 1] = dataF[j * vertSizeF + offsetPF + 1];
            minMorphedPos[j * 3 + 2] = maxMorphedPos[j * 3 + 2] = dataF[j * vertSizeF + offsetPF + 2];
          }
          for (l = 0;l < targets.length;l++) {
            target = targets[l];
            mtIndices = target.indices;
            mtIndicesLength = mtIndices.length;
            deltaPos = target.deltaPositions;
            for (k = 0;k < mtIndicesLength;k++) {
              vertIndex = mtIndices[k];
              dx = deltaPos[k * 3];
              dy = deltaPos[k * 3 + 1];
              dz = deltaPos[k * 3 + 2];
              if (dx < 0) {
                minMorphedPos[vertIndex * 3] += dx;
              } else {
                maxMorphedPos[vertIndex * 3] += dx;
              }
              if (dy < 0) {
                minMorphedPos[vertIndex * 3 + 1] += dy;
              } else {
                maxMorphedPos[vertIndex * 3 + 1] += dy;
              }
              if (dz < 0) {
                minMorphedPos[vertIndex * 3 + 2] += dz;
              } else {
                maxMorphedPos[vertIndex * 3 + 2] += dz;
              }
            }
          }
          for (l = 0;l < targets.length;l++) {
            target = targets[l];
            mtIndices = target.indices;
            mtIndicesLength = mtIndices.length;
            deltaPos = target.deltaPositions;
            for (k = 0;k < mtIndicesLength;k++) {
              vertIndex = mtIndices[k];
              for (m = 0;m < 4;m++) {
                if (dataF[vertIndex * vertSizeF + offsetWF + m] > 0) {
                  index = data8[vertIndex * vertSize + offsetI + m];
                  bMax = boneMax[index];
                  bMin = boneMin[index];
                  x = minMorphedPos[vertIndex * 3];
                  y = minMorphedPos[vertIndex * 3 + 1];
                  z = minMorphedPos[vertIndex * 3 + 2];
                  if (bMin.x > x) {
                    bMin.x = x;
                  }
                  if (bMin.y > y) {
                    bMin.y = y;
                  }
                  if (bMin.z > z) {
                    bMin.z = z;
                  }
                  x = maxMorphedPos[vertIndex * 3];
                  y = maxMorphedPos[vertIndex * 3 + 1];
                  z = maxMorphedPos[vertIndex * 3 + 2];
                  if (bMax.x < x) {
                    bMax.x = x;
                  }
                  if (bMax.y < y) {
                    bMax.y = y;
                  }
                  if (bMax.z < z) {
                    bMax.z = z;
                  }
                }
              }
            }
          }
        }
        for (i = 0;i < numBones;i++) {
          aabb = new pc.BoundingBox;
          aabb.setMinMax(boneMin[i], boneMax[i]);
          this.mesh.boneAabb.push(aabb);
        }
      }
      if (!this._boneAabb) {
        this._boneAabb = [];
        for (i = 0;i < this.mesh.boneAabb.length;i++) {
          this._boneAabb[i] = new pc.BoundingBox;
        }
      }
      boneUsed = this.mesh.boneUsed;
      for (i = 0;i < this.mesh.boneAabb.length;i++) {
        if (!boneUsed[i]) {
          continue;
        }
        this._boneAabb[i].setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);
      }
      var rootNodeTransform = this.node.getWorldTransform();
      var first = true;
      for (i = 0;i < this.mesh.boneAabb.length;i++) {
        if (!boneUsed[i]) {
          continue;
        }
        if (first) {
          _tmpAabb.center.copy(this._boneAabb[i].center);
          _tmpAabb.halfExtents.copy(this._boneAabb[i].halfExtents);
          first = false;
        } else {
          _tmpAabb.add(this._boneAabb[i]);
        }
      }
      this._aabb.setFromTransformedAabb(_tmpAabb, rootNodeTransform);
    } else {
      if (this.node._aabbVer !== this._aabbVer) {
        aabb = this.mesh ? this.mesh.aabb : this._aabb;
        if (!this.mesh) {
          aabb.center.set(0, 0, 0);
          aabb.halfExtents.set(0, 0, 0);
        }
        this._aabb.setFromTransformedAabb(aabb, this.node.getWorldTransform());
        this._aabbVer = this.node._aabbVer;
      }
    }
    return this._aabb;
  }, set:function(aabb) {
    this._aabb = aabb;
  }});
  Object.defineProperty(MeshInstance.prototype, "material", {get:function() {
    return this._material;
  }, set:function(material) {
    var i;
    for (i = 0;i < this._shader.length;i++) {
      this._shader[i] = null;
    }
    if (this._material) {
      var meshInstances = this._material.meshInstances;
      i = meshInstances.indexOf(this);
      if (i !== -1) {
        meshInstances.splice(i, 1);
      }
    }
    var prevBlend = this._material ? this._material.blendType !== pc.BLEND_NONE : false;
    var prevMat = this._material;
    this._material = material;
    if (this._material) {
      this._material.meshInstances.push(this);
      this.updateKey();
    }
    if (material) {
      if (material.blendType !== pc.BLEND_NONE !== prevBlend) {
        var scene = material._scene;
        if (!scene && prevMat && prevMat._scene) {
          scene = prevMat._scene;
        }
        if (scene) {
          scene.layers._dirtyBlend = true;
        } else {
          material._dirtyBlend = true;
        }
      }
    }
  }});
  Object.defineProperty(MeshInstance.prototype, "layer", {get:function() {
    return this._layer;
  }, set:function(layer) {
    this._layer = layer;
    this.updateKey();
  }});
  Object.defineProperty(MeshInstance.prototype, "receiveShadow", {get:function() {
    return this._receiveShadow;
  }, set:function(val) {
    this._receiveShadow = val;
    this._shaderDefs = val ? this._shaderDefs & ~pc.SHADERDEF_NOSHADOW : this._shaderDefs | pc.SHADERDEF_NOSHADOW;
    this._shader[pc.SHADER_FORWARD] = null;
    this._shader[pc.SHADER_FORWARDHDR] = null;
  }});
  Object.defineProperty(MeshInstance.prototype, "skinInstance", {get:function() {
    return this._skinInstance;
  }, set:function(val) {
    this._skinInstance = val;
    this._shaderDefs = val ? this._shaderDefs | pc.SHADERDEF_SKIN : this._shaderDefs & ~pc.SHADERDEF_SKIN;
    for (var i = 0;i < this._shader.length;i++) {
      this._shader[i] = null;
    }
  }});
  Object.defineProperty(MeshInstance.prototype, "screenSpace", {get:function() {
    return this._screenSpace;
  }, set:function(val) {
    this._screenSpace = val;
    this._shaderDefs = val ? this._shaderDefs | pc.SHADERDEF_SCREENSPACE : this._shaderDefs & ~pc.SHADERDEF_SCREENSPACE;
    this._shader[pc.SHADER_FORWARD] = null;
  }});
  Object.defineProperty(MeshInstance.prototype, "key", {get:function() {
    return this._key[pc.SORTKEY_FORWARD];
  }, set:function(val) {
    this._key[pc.SORTKEY_FORWARD] = val;
  }});
  Object.defineProperty(MeshInstance.prototype, "mask", {get:function() {
    return this._shaderDefs >> 16;
  }, set:function(val) {
    var toggles = this._shaderDefs & 65535;
    this._shaderDefs = toggles | val << 16;
    this._shader[pc.SHADER_FORWARD] = null;
    this._shader[pc.SHADER_FORWARDHDR] = null;
  }});
  Object.assign(MeshInstance.prototype, {syncAabb:function() {
  }, updateKey:function() {
    var material = this.material;
    this._key[pc.SORTKEY_FORWARD] = getKey(this.layer, material.alphaToCoverage || material.alphaTest ? pc.BLEND_NORMAL : material.blendType, false, material.id);
  }, setParameter:pc.Material.prototype.setParameter, setParameters:pc.Material.prototype.setParameters, deleteParameter:pc.Material.prototype.deleteParameter, getParameter:pc.Material.prototype.getParameter, getParameters:pc.Material.prototype.getParameters, clearParameters:pc.Material.prototype.clearParameters});
  var Command = function(layer, blendType, command) {
    this._key = [];
    this._key[pc.SORTKEY_FORWARD] = getKey(layer, blendType, true, 0);
    this.command = command;
  };
  Object.defineProperty(Command.prototype, "key", {get:function() {
    return this._key[pc.SORTKEY_FORWARD];
  }, set:function(val) {
    this._key[pc.SORTKEY_FORWARD] = val;
  }});
  var InstancingData = function(numObjects, dynamic, instanceSize) {
    instanceSize = instanceSize || 16;
    this.buffer = new Float32Array(numObjects * instanceSize);
    this.count = numObjects;
    this.offset = 0;
    this.usage = dynamic ? pc.BUFFER_DYNAMIC : pc.BUFFER_STATIC;
    this._buffer = null;
  };
  Object.assign(InstancingData.prototype, {update:function() {
    if (this._buffer) {
      this._buffer.setData(this.buffer);
    }
  }});
  function getKey(layer, blendType, isCommand, materialId) {
    return (layer & 15) << 27 | (blendType === pc.BLEND_NONE ? 1 : 0) << 26 | (isCommand ? 1 : 0) << 25 | (materialId & 33554431) << 0;
  }
  return {Command:Command, Mesh:Mesh, MeshInstance:MeshInstance, InstancingData:InstancingData, _getDrawcallSortKey:getKey};
}());
Object.assign(pc, function() {
  var _invMatrix = new pc.Mat4;
  var Skin = function(graphicsDevice, ibp, boneNames) {
    this.device = graphicsDevice;
    this.inverseBindPose = ibp;
    this.boneNames = boneNames;
  };
  var SkinInstance = function(skin) {
    this.skin = skin;
    this._dirty = true;
    this.bones = [];
    var numBones = skin.inverseBindPose.length;
    var device = skin.device;
    if (device.supportsBoneTextures) {
      var size;
      if (numBones > 256) {
        size = 64;
      } else {
        if (numBones > 64) {
          size = 32;
        } else {
          if (numBones > 16) {
            size = 16;
          } else {
            size = 8;
          }
        }
      }
      this.boneTexture = new pc.Texture(device, {width:size, height:size, format:pc.PIXELFORMAT_RGBA32F, mipmaps:false, minFilter:pc.FILTER_NEAREST, magFilter:pc.FILTER_NEAREST});
      this.matrixPalette = this.boneTexture.lock();
    } else {
      this.matrixPalette = new Float32Array(numBones * 16);
    }
    this.matrices = [];
    for (var i = 0;i < numBones;i++) {
      this.matrices[i] = new pc.Mat4;
    }
  };
  Object.assign(SkinInstance.prototype, {updateMatrices:function(rootNode) {
    _invMatrix.copy(rootNode.getWorldTransform()).invert();
    for (var i = this.bones.length - 1;i >= 0;i--) {
      this.matrices[i].mul2(_invMatrix, this.bones[i].getWorldTransform());
      this.matrices[i].mul2(this.matrices[i], this.skin.inverseBindPose[i]);
    }
  }, updateMatrixPalette:function() {
    var pe;
    var mp = this.matrixPalette;
    var base;
    for (var i = this.bones.length - 1;i >= 0;i--) {
      pe = this.matrices[i].data;
      base = i * 16;
      mp[base] = pe[0];
      mp[base + 1] = pe[1];
      mp[base + 2] = pe[2];
      mp[base + 3] = pe[3];
      mp[base + 4] = pe[4];
      mp[base + 5] = pe[5];
      mp[base + 6] = pe[6];
      mp[base + 7] = pe[7];
      mp[base + 8] = pe[8];
      mp[base + 9] = pe[9];
      mp[base + 10] = pe[10];
      mp[base + 11] = pe[11];
      mp[base + 12] = pe[12];
      mp[base + 13] = pe[13];
      mp[base + 14] = pe[14];
      mp[base + 15] = pe[15];
    }
    if (this.skin.device.supportsBoneTextures) {
      this.boneTexture.lock();
      this.boneTexture.unlock();
    }
  }});
  return {Skin:Skin, SkinInstance:SkinInstance};
}());
Object.assign(pc, function() {
  function PartitionedVertex() {
    this.index = 0;
    this.boneIndices = [0, 0, 0, 0];
  }
  function SkinPartition() {
    this.partition = 0;
    this.vertexStart = 0;
    this.vertexCount = 0;
    this.indexStart = 0;
    this.indexCount = 0;
    this.boneIndices = [];
    this.vertices = [];
    this.indices = [];
    this.indexMap = {};
  }
  Object.assign(SkinPartition.prototype, {addVertex:function(vertex, idx, vertexArray) {
    var remappedIndex = -1;
    if (this.indexMap[idx] !== undefined) {
      remappedIndex = this.indexMap[idx];
      this.indices.push(remappedIndex);
    } else {
      for (var influence = 0;influence < 4;influence++) {
        if (vertexArray.blendWeight.data[idx * 4 + influence] === 0) {
          continue;
        }
        var originalBoneIndex = vertexArray.blendIndices.data[vertex.index * 4 + influence];
        vertex.boneIndices[influence] = this.getBoneRemap(originalBoneIndex);
      }
      remappedIndex = this.vertices.length;
      this.indices.push(remappedIndex);
      this.vertices.push(vertex);
      this.indexMap[idx] = remappedIndex;
    }
  }, addPrimitive:function(vertices, vertexIndices, vertexArray, boneLimit) {
    var i, j;
    var bonesToAdd = [];
    var bonesToAddCount = 0;
    var vertexCount = vertices.length;
    for (i = 0;i < vertexCount;i++) {
      var vertex = vertices[i];
      var idx = vertex.index;
      for (var influence = 0;influence < 4;influence++) {
        if (vertexArray.blendWeight.data[idx * 4 + influence] > 0) {
          var boneIndex = vertexArray.blendIndices.data[idx * 4 + influence];
          var needToAdd = true;
          for (j = 0;j < bonesToAddCount;j++) {
            if (bonesToAdd[j] == boneIndex) {
              needToAdd = false;
              break;
            }
          }
          if (needToAdd) {
            bonesToAdd[bonesToAddCount] = boneIndex;
            var boneRemap = this.getBoneRemap(boneIndex);
            bonesToAddCount += boneRemap === -1 ? 1 : 0;
          }
        }
      }
    }
    if (this.boneIndices.length + bonesToAddCount > boneLimit) {
      return false;
    }
    for (i = 0;i < bonesToAddCount;i++) {
      this.boneIndices.push(bonesToAdd[i]);
    }
    for (i = 0;i < vertexCount;i++) {
      this.addVertex(vertices[i], vertexIndices[i], vertexArray);
    }
    return true;
  }, getBoneRemap:function(boneIndex) {
    for (var i = 0;i < this.boneIndices.length;i++) {
      if (this.boneIndices[i] === boneIndex) {
        return i;
      }
    }
    return -1;
  }});
  function indicesToReferences(model) {
    var i;
    var vertices = model.vertices;
    var skins = model.skins;
    var meshes = model.meshes;
    var meshInstances = model.meshInstances;
    for (i = 0;i < meshes.length;i++) {
      meshes[i].vertices = vertices[meshes[i].vertices];
      if (meshes[i].skin !== undefined) {
        meshes[i].skin = skins[meshes[i].skin];
      }
    }
    for (i = 0;i < meshInstances.length;i++) {
      meshInstances[i].mesh = meshes[meshInstances[i].mesh];
    }
  }
  function referencesToIndices(model) {
    var i;
    var vertices = model.vertices;
    var skins = model.skins;
    var meshes = model.meshes;
    var meshInstances = model.meshInstances;
    for (i = 0;i < meshes.length;i++) {
      meshes[i].vertices = vertices.indexOf(meshes[i].vertices);
      if (meshes[i].skin !== undefined) {
        meshes[i].skin = skins.indexOf(meshes[i].skin);
      }
    }
    for (i = 0;i < meshInstances.length;i++) {
      meshInstances[i].mesh = meshes.indexOf(meshInstances[i].mesh);
    }
  }
  function partitionSkin(model, materialMappings, boneLimit) {
    var i, j, k, index;
    indicesToReferences(model);
    var vertexArrays = model.vertices;
    var skins = model.skins;
    var mesh;
    var meshes = model.meshes;
    var meshInstances = model.meshInstances;
    var getVertex = function(idx) {
      var vert = new PartitionedVertex;
      vert.index = idx;
      return vert;
    };
    for (i = skins.length - 1;i >= 0;i--) {
      if (skins[i].boneNames.length > boneLimit) {
        var skin = skins.splice(i, 1)[0];
        var meshesToSplit = [];
        for (j = 0;j < meshes.length;j++) {
          if (meshes[j].skin === skin) {
            meshesToSplit.push(meshes[j]);
          }
        }
        for (j = 0;j < meshesToSplit.length;j++) {
          index = meshes.indexOf(meshesToSplit[j]);
          if (index !== -1) {
            meshes.splice(index, 1);
          }
        }
        if (meshesToSplit.length === 0) {
          throw new Error("partitionSkin: There should be at least one mesh that references a skin");
        }
        var vertexArray = meshesToSplit[0].vertices;
        for (j = 1;j < meshesToSplit.length;j++) {
          if (meshesToSplit[j].vertices !== vertexArray) {
            throw new Error("partitionSkin: All meshes that share a skin should also share the same vertex buffer");
          }
        }
        var partition;
        var partitions = [];
        var primitiveVertices = [];
        var primitiveIndices = [];
        var basePartition = 0;
        for (j = 0;j < meshesToSplit.length;j++) {
          mesh = meshesToSplit[j];
          var indices = mesh.indices;
          for (var iIndex = mesh.base;iIndex < mesh.base + mesh.count;) {
            index = indices[iIndex++];
            primitiveVertices[0] = getVertex(index);
            primitiveIndices[0] = index;
            index = indices[iIndex++];
            primitiveVertices[1] = getVertex(index);
            primitiveIndices[1] = index;
            index = indices[iIndex++];
            primitiveVertices[2] = getVertex(index);
            primitiveIndices[2] = index;
            var added = false;
            for (var iBonePartition = basePartition;iBonePartition < partitions.length;iBonePartition++) {
              partition = partitions[iBonePartition];
              if (partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit)) {
                added = true;
                break;
              }
            }
            if (!added) {
              partition = new SkinPartition;
              partition.originalMesh = mesh;
              partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit);
              partitions.push(partition);
            }
          }
          basePartition = partitions.length;
        }
        var partitionedVertices = [];
        var partitionedIndices = [];
        for (j = 0;j < partitions.length;j++) {
          partition = partitions[j];
          if (partition.vertices.length && partition.indices.length) {
            var vertexStart = partitionedVertices.length;
            var vertexCount = partition.vertices.length;
            var indexStart = partitionedIndices.length;
            var indexCount = partition.indices.length;
            partition.partition = j;
            partition.vertexStart = vertexStart;
            partition.vertexCount = vertexCount;
            partition.indexStart = indexStart;
            partition.indexCount = indexCount;
            var iSour;
            var iDest;
            iSour = 0;
            iDest = vertexStart;
            while (iSour < vertexCount) {
              partitionedVertices[iDest++] = partition.vertices[iSour++];
            }
            iSour = 0;
            iDest = indexStart;
            while (iSour < indexCount) {
              partitionedIndices[iDest++] = partition.indices[iSour++] + vertexStart;
            }
          }
        }
        var splitSkins = [];
        for (j = 0;j < partitions.length;j++) {
          partition = partitions[j];
          var ibp = [];
          var boneNames = [];
          for (k = 0;k < partition.boneIndices.length;k++) {
            ibp.push(skin.inverseBindMatrices[partition.boneIndices[k]]);
            boneNames.push(skin.boneNames[partition.boneIndices[k]]);
          }
          var splitSkin = {inverseBindMatrices:ibp, boneNames:boneNames};
          splitSkins.push(splitSkin);
          skins.push(splitSkin);
        }
        var attrib, attribName, data, components;
        var splitVertexArray = {};
        for (attribName in vertexArray) {
          splitVertexArray[attribName] = {components:vertexArray[attribName].components, data:[], type:vertexArray[attribName].type};
        }
        for (attribName in vertexArray) {
          if (attribName === "blendIndices") {
            var dstBoneIndices = splitVertexArray[attribName].data;
            for (j = 0;j < partitionedVertices.length;j++) {
              var srcBoneIndices = partitionedVertices[j].boneIndices;
              dstBoneIndices.push(srcBoneIndices[0], srcBoneIndices[1], srcBoneIndices[2], srcBoneIndices[3]);
            }
          } else {
            attrib = vertexArray[attribName];
            data = attrib.data;
            components = attrib.components;
            for (j = 0;j < partitionedVertices.length;j++) {
              index = partitionedVertices[j].index;
              for (k = 0;k < components;k++) {
                splitVertexArray[attribName].data.push(data[index * components + k]);
              }
            }
          }
        }
        vertexArrays[vertexArrays.indexOf(vertexArray)] = splitVertexArray;
        for (j = 0;j < partitions.length;j++) {
          partition = partitions[j];
          mesh = {aabb:{min:[0, 0, 0], max:[0, 0, 0]}, vertices:splitVertexArray, skin:splitSkins[j], indices:partitionedIndices.splice(0, partition.indexCount), type:"triangles", base:0, count:partition.indexCount};
          meshes.push(mesh);
          for (k = meshInstances.length - 1;k >= 0;k--) {
            if (meshInstances[k].mesh === partition.originalMesh) {
              meshInstances.push({mesh:mesh, node:meshInstances[k].node});
              if (materialMappings) {
                materialMappings.push({material:materialMappings[k].material, path:materialMappings[k].path});
              }
            }
          }
        }
        for (j = 0;j < partitions.length;j++) {
          partition = partitions[j];
          for (k = meshInstances.length - 1;k >= 0;k--) {
            if (meshInstances[k].mesh === partition.originalMesh) {
              meshInstances.splice(k, 1);
              if (materialMappings) {
                materialMappings.splice(k, 1);
              }
            }
          }
        }
      }
    }
    referencesToIndices(model);
  }
  return {partitionSkin:partitionSkin};
}());
Object.assign(pc, function() {
  var _morphMin = new pc.Vec3;
  var _morphMax = new pc.Vec3;
  var MorphTarget = function(options) {
    if (options.indices) {
      this.indices = options.indices;
    } else {
      var arr = options.deltaPositions;
      this.indices = [];
      this.indices.length = arr.length;
      for (var i = 0;i < arr.length;i++) {
        this.indices[i] = i;
      }
    }
    this.deltaPositions = options.deltaPositions;
    this.deltaNormals = options.deltaNormals;
    this.deltaTangents = options.deltaTangents;
    this.name = options.name;
    this.aabb = options.aabb;
  };
  var Morph = function(targets) {
    this.aabb = new pc.BoundingBox;
    this._baseBuffer = null;
    this._baseAabb = null;
    this._targets = targets;
    this._dirty = true;
    this._aabbDirty = true;
    this._baseData = null;
    this._offsetPF = 0;
    this._offsetNF = 0;
    this._offsetTF = 0;
    this._vertSizeF = 0;
  };
  Object.assign(Morph.prototype, {_setBaseMesh:function(baseMesh) {
    this._baseBuffer = baseMesh.vertexBuffer;
    this._baseAabb = baseMesh._aabb;
    this._baseData = new Float32Array(this._baseBuffer.storage);
    var offsetP = -1;
    var offsetN = -1;
    var offsetT = -1;
    var elems = this._baseBuffer.format.elements;
    var vertSize = this._baseBuffer.format.size;
    for (var j = 0;j < elems.length;j++) {
      if (elems[j].name === pc.SEMANTIC_POSITION) {
        offsetP = elems[j].offset;
      } else {
        if (elems[j].name === pc.SEMANTIC_NORMAL) {
          offsetN = elems[j].offset;
        } else {
          if (elems[j].name === pc.SEMANTIC_TANGENT) {
            offsetT = elems[j].offset;
          }
        }
      }
    }
    this._offsetPF = offsetP / 4;
    this._offsetNF = offsetN / 4;
    this._offsetTF = offsetT / 4;
    this._vertSizeF = vertSize / 4;
    this._dirty = true;
  }, _calculateAabb:function() {
    if (!this._baseBuffer) {
      return;
    }
    this.aabb.copy(this._baseAabb);
    var numIndices;
    var i, j, target, index, id;
    var x, y, z;
    var vertSizeF = this._vertSizeF;
    var offsetPF = this._offsetPF;
    var baseData = this._baseData;
    for (i = 0;i < this._targets.length;i++) {
      target = this._targets[i];
      if (!target.aabb && target.indices.length > 0) {
        target.aabb = this.aabb.clone();
        _morphMin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        _morphMax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        numIndices = target.indices.length;
        for (j = 0;j < numIndices;j++) {
          index = target.indices[j];
          id = index * vertSizeF + offsetPF;
          x = baseData[id] + target.deltaPositions[j * 3];
          y = baseData[id + 1] + target.deltaPositions[j * 3 + 1];
          z = baseData[id + 2] + target.deltaPositions[j * 3 + 2];
          if (_morphMin.x > x) {
            _morphMin.x = x;
          }
          if (_morphMin.y > y) {
            _morphMin.y = y;
          }
          if (_morphMin.z > z) {
            _morphMin.z = z;
          }
          if (_morphMax.x < x) {
            _morphMax.x = x;
          }
          if (_morphMax.y < y) {
            _morphMax.y = y;
          }
          if (_morphMax.z < z) {
            _morphMax.z = z;
          }
        }
        target.aabb.setMinMax(_morphMin, _morphMax);
      }
      if (target.aabb) {
        this.aabb.add(target.aabb);
      }
    }
    this._aabbDirty = false;
  }, addTarget:function(target) {
    this._targets.push(target);
    this._aabbDirty = true;
  }, removeTarget:function(target) {
    var index = this._targets.indexOf(target);
    if (index !== -1) {
      this._targets.splice(index, 1);
      this._aabbDirty = true;
    }
  }, getTarget:function(index) {
    return this._targets[index];
  }});
  var MorphInstance = function(morph) {
    this.morph = morph;
    this._vertexBuffer = null;
    this._vertexData = null;
    this._weights = [];
    this._dirty = true;
  };
  Object.assign(MorphInstance.prototype, {_setBaseMesh:function(baseMesh) {
    this.destroy();
    this._vertexBuffer = new pc.VertexBuffer(this.morph._baseBuffer.device, this.morph._baseBuffer.format, this.morph._baseBuffer.numVertices, pc.BUFFER_DYNAMIC, this.morph._baseBuffer.storage.slice(0));
    this._vertexData = new Float32Array(this._vertexBuffer.storage);
    this._weights = [];
    this._weights.length = this.morph._targets.length;
    for (var i = 0;i < this.morph._targets.length;i++) {
      this._weights[i] = 0;
    }
    this._dirty = true;
  }, destroy:function() {
    if (this._vertexBuffer) {
      this._vertexBuffer.destroy();
      this._vertexBuffer = null;
    }
  }, getWeight:function(index) {
    return this._weights[index];
  }, setWeight:function(index, weight) {
    this._weights[index] = weight;
    this._dirty = true;
  }, updateBounds:function(mesh) {
    if (this.morph._baseBuffer !== mesh.vertexBuffer) {
      this.morph._setBaseMesh(mesh);
    }
    if (!this._vertexData) {
      this._setBaseMesh(mesh);
    }
    if (this.morph._aabbDirty) {
      this.morph._calculateAabb();
    }
  }, update:function(mesh) {
    if (this.morph._baseBuffer !== mesh.vertexBuffer) {
      this.morph._setBaseMesh(mesh);
    }
    if (!this._vertexData) {
      this._setBaseMesh(mesh);
    }
    var numIndices, index;
    var targets = this.morph._targets;
    var weights = this._weights;
    var target, weight, j, id, j3, j4;
    var vertSizeF = this.morph._vertSizeF;
    var offsetPF = this.morph._offsetPF;
    var offsetNF = this.morph._offsetNF;
    var offsetTF = this.morph._offsetTF;
    var vdata = this._vertexData;
    vdata.set(this.morph._baseData);
    for (var i = 0;i < targets.length;i++) {
      weight = weights[i];
      if (weight === 0) {
        continue;
      }
      target = targets[i];
      numIndices = target.indices.length;
      for (j = 0;j < numIndices;j++) {
        j3 = j * 3;
        index = target.indices[j];
        id = index * vertSizeF + offsetPF;
        vdata[id] += target.deltaPositions[j3] * weight;
        vdata[id + 1] += target.deltaPositions[j3 + 1] * weight;
        vdata[id + 2] += target.deltaPositions[j3 + 2] * weight;
        if (target.deltaNormals) {
          id = index * vertSizeF + offsetNF;
          vdata[id] += target.deltaNormals[j3] * weight;
          vdata[id + 1] += target.deltaNormals[j3 + 1] * weight;
          vdata[id + 2] += target.deltaNormals[j3 + 2] * weight;
          if (target.deltaTangents) {
            j4 = j * 4;
            id = index * vertSizeF + offsetTF;
            vdata[id] += target.deltaTangents[j4] * weight;
            vdata[id + 1] += target.deltaTangents[j4 + 1] * weight;
            vdata[id + 2] += target.deltaTangents[j4 + 2] * weight;
            vdata[id + 3] += target.deltaTangents[j4 + 3] * weight;
            vdata[id + 3] = vdata[id + 3] > 0 ? 1 : -1;
          }
        }
      }
    }
    this._vertexBuffer.unlock();
  }});
  return {MorphTarget:MorphTarget, Morph:Morph, MorphInstance:MorphInstance};
}());
Object.assign(pc, function() {
  var Model = function Model() {
    this.graph = null;
    this.meshInstances = [];
    this.skinInstances = [];
    this.morphInstances = [];
    this.cameras = [];
    this.lights = [];
    this._shadersVersion = 0;
  };
  Object.assign(Model.prototype, {getGraph:function() {
    return this.graph;
  }, setGraph:function(graph) {
    this.graph = graph;
  }, getCameras:function() {
    return this.cameras;
  }, setCameras:function(cameras) {
    this.cameras = cameras;
  }, getLights:function() {
    return this.lights;
  }, setLights:function(lights) {
    this.lights = lights;
  }, getMaterials:function() {
    var i;
    var materials = [];
    for (i = 0;i < this.meshInstances.length;i++) {
      var meshInstance = this.meshInstances[i];
      if (materials.indexOf(meshInstance.material) === -1) {
        materials.push(meshInstance.material);
      }
    }
    return materials;
  }, clone:function() {
    var i, j;
    var srcNodes = [];
    var cloneNodes = [];
    var _duplicate = function(node) {
      var newNode = node.clone();
      srcNodes.push(node);
      cloneNodes.push(newNode);
      for (var idx = 0;idx < node._children.length;idx++) {
        newNode.addChild(_duplicate(node._children[idx]));
      }
      return newNode;
    };
    var cloneGraph = _duplicate(this.graph);
    var cloneMeshInstances = [];
    var cloneSkinInstances = [];
    var cloneMorphInstances = [];
    for (i = 0;i < this.skinInstances.length;i++) {
      var skin = this.skinInstances[i].skin;
      var cloneSkinInstance = new pc.SkinInstance(skin);
      var bones = [];
      for (j = 0;j < skin.boneNames.length;j++) {
        var boneName = skin.boneNames[j];
        var bone = cloneGraph.findByName(boneName);
        bones.push(bone);
      }
      cloneSkinInstance.bones = bones;
      cloneSkinInstances.push(cloneSkinInstance);
    }
    for (i = 0;i < this.morphInstances.length;i++) {
      var morph = this.morphInstances[i].morph;
      var cloneMorphInstance = new pc.MorphInstance(morph);
      cloneMorphInstances.push(cloneMorphInstance);
    }
    for (i = 0;i < this.meshInstances.length;i++) {
      var meshInstance = this.meshInstances[i];
      var nodeIndex = srcNodes.indexOf(meshInstance.node);
      var cloneMeshInstance = new pc.MeshInstance(cloneNodes[nodeIndex], meshInstance.mesh, meshInstance.material);
      if (meshInstance.skinInstance) {
        var skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);
        cloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];
      }
      if (meshInstance.morphInstance) {
        var morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);
        cloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];
      }
      cloneMeshInstances.push(cloneMeshInstance);
    }
    var clone = new pc.Model;
    clone.graph = cloneGraph;
    clone.meshInstances = cloneMeshInstances;
    clone.skinInstances = cloneSkinInstances;
    clone.morphInstances = cloneMorphInstances;
    clone.getGraph().syncHierarchy();
    return clone;
  }, destroy:function() {
    var meshInstances = this.meshInstances;
    var meshInstance, mesh, skin, morph, ib, boneTex, j;
    var device;
    for (var i = 0;i < meshInstances.length;i++) {
      meshInstance = meshInstances[i];
      mesh = meshInstance.mesh;
      if (mesh) {
        mesh._refCount--;
        if (mesh._refCount < 1) {
          if (mesh.vertexBuffer) {
            device = device || mesh.vertexBuffer.device;
            mesh.vertexBuffer.destroy();
            mesh.vertexBuffer = null;
          }
          for (j = 0;j < mesh.indexBuffer.length;j++) {
            device = device || mesh.indexBuffer.device;
            ib = mesh.indexBuffer[j];
            if (!ib) {
              continue;
            }
            ib.destroy();
          }
          mesh.indexBuffer.length = 0;
        }
      }
      skin = meshInstance.skinInstance;
      if (skin) {
        boneTex = skin.boneTexture;
        if (boneTex) {
          boneTex.destroy();
        }
      }
      meshInstance.skinInstance = null;
      morph = meshInstance.morphInstance;
      if (morph) {
        morph.destroy();
      }
      meshInstance.morphInstance = null;
      meshInstance.material = null;
    }
  }, generateWireframe:function() {
    var i, j, k;
    var i1, i2;
    var mesh, base, count, indexBuffer, wireBuffer;
    var srcIndices, dstIndices;
    var meshes = [];
    for (i = 0;i < this.meshInstances.length;i++) {
      mesh = this.meshInstances[i].mesh;
      if (meshes.indexOf(mesh) === -1) {
        meshes.push(mesh);
      }
    }
    var offsets = [[0, 1], [1, 2], [2, 0]];
    for (i = 0;i < meshes.length;i++) {
      mesh = meshes[i];
      base = mesh.primitive[pc.RENDERSTYLE_SOLID].base;
      count = mesh.primitive[pc.RENDERSTYLE_SOLID].count;
      indexBuffer = mesh.indexBuffer[pc.RENDERSTYLE_SOLID];
      srcIndices = new Uint16Array(indexBuffer.lock());
      var uniqueLineIndices = {};
      var lines = [];
      for (j = base;j < base + count;j += 3) {
        for (k = 0;k < 3;k++) {
          i1 = srcIndices[j + offsets[k][0]];
          i2 = srcIndices[j + offsets[k][1]];
          var line = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;
          if (uniqueLineIndices[line] === undefined) {
            uniqueLineIndices[line] = 0;
            lines.push(i1, i2);
          }
        }
      }
      indexBuffer.unlock();
      wireBuffer = new pc.IndexBuffer(indexBuffer.device, pc.INDEXFORMAT_UINT16, lines.length);
      dstIndices = new Uint16Array(wireBuffer.lock());
      dstIndices.set(lines);
      wireBuffer.unlock();
      mesh.primitive[pc.RENDERSTYLE_WIREFRAME] = {type:pc.PRIMITIVE_LINES, base:0, count:lines.length, indexed:true};
      mesh.indexBuffer[pc.RENDERSTYLE_WIREFRAME] = wireBuffer;
    }
  }});
  return {Model:Model};
}());
Object.assign(pc, function() {
  var particleVerts = [[-1, -1], [1, -1], [1, 1], [-1, 1]];
  var _createTexture = function(device, width, height, pixelData, format, mult8Bit, filter) {
    if (!format) {
      format = pc.PIXELFORMAT_RGBA32F;
    }
    var mipFilter = pc.FILTER_NEAREST;
    if (filter && format === pc.PIXELFORMAT_R8_G8_B8_A8) {
      mipFilter = pc.FILTER_LINEAR;
    }
    var texture = new pc.Texture(device, {width:width, height:height, format:format, cubemap:false, mipmaps:false, minFilter:mipFilter, magFilter:mipFilter, addressU:pc.ADDRESS_CLAMP_TO_EDGE, addressV:pc.ADDRESS_CLAMP_TO_EDGE});
    var pixels = texture.lock();
    if (format === pc.PIXELFORMAT_R8_G8_B8_A8) {
      var temp = new Uint8Array(pixelData.length);
      for (var i = 0;i < pixelData.length;i++) {
        temp[i] = pixelData[i] * mult8Bit * 255;
      }
      pixelData = temp;
    }
    pixels.set(pixelData);
    texture.unlock();
    return texture;
  };
  function frac(f) {
    return f - Math.floor(f);
  }
  function encodeFloatRGBA(v) {
    var encX = frac(v);
    var encY = frac(255.0 * v);
    var encZ = frac(65025.0 * v);
    var encW = frac(160581375.0 * v);
    encX -= encY / 255.0;
    encY -= encZ / 255.0;
    encZ -= encW / 255.0;
    encW -= encW / 255.0;
    return [encX, encY, encZ, encW];
  }
  function encodeFloatRG(v) {
    var encX = frac(v);
    var encY = frac(255.0 * v);
    encX -= encY / 255.0;
    encY -= encY / 255.0;
    return [encX, encY];
  }
  function saturate(x) {
    return Math.max(Math.min(x, 1), 0);
  }
  function glMod(x, y) {
    return x - y * Math.floor(x / y);
  }
  var default0Curve = new pc.Curve([0, 0, 1, 0]);
  var default1Curve = new pc.Curve([0, 1, 1, 1]);
  var default0Curve3 = new pc.CurveSet([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]);
  var default1Curve3 = new pc.CurveSet([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);
  var particleTexHeight = 2;
  var particleTexChannels = 4;
  var velocityVec = new pc.Vec3;
  var localVelocityVec = new pc.Vec3;
  var velocityVec2 = new pc.Vec3;
  var localVelocityVec2 = new pc.Vec3;
  var rndFactor3Vec = new pc.Vec3;
  var particlePosPrev = new pc.Vec3;
  var particlePos = new pc.Vec3;
  var particleFinalPos = new pc.Vec3;
  var moveDirVec = new pc.Vec3;
  var rotMat = new pc.Mat4;
  var spawnMatrix3 = new pc.Mat3;
  var emitterMatrix3 = new pc.Mat3;
  var uniformScale = 1;
  var nonUniformScale;
  var spawnMatrix = new pc.Mat4;
  var randomPos = new pc.Vec3;
  var randomPosTformed = new pc.Vec3;
  var tmpVec3 = new pc.Vec3;
  var bMin = new pc.Vec3;
  var bMax = new pc.Vec3;
  var setPropertyTarget;
  var setPropertyOptions;
  function setProperty(pName, defaultVal) {
    if (setPropertyOptions[pName] !== undefined && setPropertyOptions[pName] !== null) {
      setPropertyTarget[pName] = setPropertyOptions[pName];
    } else {
      setPropertyTarget[pName] = defaultVal;
    }
  }
  function pack3NFloats(a, b, c) {
    var packed = a * 255 << 16 | b * 255 << 8 | c * 255;
    return packed / (1 << 24);
  }
  function packTextureXYZ_NXYZ(qXYZ, qXYZ2) {
    var num = qXYZ.length / 3;
    var colors = new Array(num * 4);
    for (var i = 0;i < num;i++) {
      colors[i * 4] = qXYZ[i * 3];
      colors[i * 4 + 1] = qXYZ[i * 3 + 1];
      colors[i * 4 + 2] = qXYZ[i * 3 + 2];
      colors[i * 4 + 3] = pack3NFloats(qXYZ2[i * 3], qXYZ2[i * 3 + 1], qXYZ2[i * 3 + 2]);
    }
    return colors;
  }
  function packTextureRGBA(qRGB, qA) {
    var colors = new Array(qA.length * 4);
    for (var i = 0;i < qA.length;i++) {
      colors[i * 4] = qRGB[i * 3];
      colors[i * 4 + 1] = qRGB[i * 3 + 1];
      colors[i * 4 + 2] = qRGB[i * 3 + 2];
      colors[i * 4 + 3] = qA[i];
    }
    return colors;
  }
  function packTexture5Floats(qA, qB, qC, qD, qE) {
    var colors = new Array(qA.length * 4);
    for (var i = 0;i < qA.length;i++) {
      colors[i * 4] = qA[i];
      colors[i * 4 + 1] = qB[i];
      colors[i * 4 + 2] = 0;
      colors[i * 4 + 3] = pack3NFloats(qC[i], qD[i], qE[i]);
    }
    return colors;
  }
  var ParticleEmitter = function(graphicsDevice, options) {
    this.graphicsDevice = graphicsDevice;
    var gd = graphicsDevice;
    var precision = 32;
    this.precision = precision;
    this._addTimeTime = 0;
    if (!ParticleEmitter.DEFAULT_PARAM_TEXTURE) {
      var resolution = 16;
      var centerPoint = resolution * 0.5 + 0.5;
      var dtex = new Float32Array(resolution * resolution * 4);
      var x, y, xgrad, ygrad, p, c;
      for (y = 0;y < resolution;y++) {
        for (x = 0;x < resolution;x++) {
          xgrad = x + 1 - centerPoint;
          ygrad = y + 1 - centerPoint;
          c = saturate(1 - saturate(Math.sqrt(xgrad * xgrad + ygrad * ygrad) / resolution) - 0.5);
          p = y * resolution + x;
          dtex[p * 4] = 1;
          dtex[p * 4 + 1] = 1;
          dtex[p * 4 + 2] = 1;
          dtex[p * 4 + 3] = c;
        }
      }
      ParticleEmitter.DEFAULT_PARAM_TEXTURE = _createTexture(gd, resolution, resolution, dtex, pc.PIXELFORMAT_R8_G8_B8_A8, 1.0, true);
      ParticleEmitter.DEFAULT_PARAM_TEXTURE.minFilter = pc.FILTER_LINEAR;
      ParticleEmitter.DEFAULT_PARAM_TEXTURE.magFilter = pc.FILTER_LINEAR;
    }
    setPropertyTarget = this;
    setPropertyOptions = options;
    setProperty("numParticles", 1);
    if (this.numParticles > graphicsDevice.maxTextureSize) {
      console.warn("WARNING: can't create more than " + graphicsDevice.maxTextureSize + " particles on this device.");
      this.numParticles = graphicsDevice.maxTextureSize;
    }
    setProperty("rate", 1);
    setProperty("rate2", this.rate);
    setProperty("lifetime", 50);
    setProperty("emitterExtents", new pc.Vec3(0, 0, 0));
    setProperty("emitterRadius", 0);
    setProperty("emitterShape", pc.EMITTERSHAPE_BOX);
    setProperty("initialVelocity", 1);
    setProperty("wrap", false);
    setProperty("localSpace", false);
    setProperty("wrapBounds", null);
    setProperty("colorMap", ParticleEmitter.DEFAULT_PARAM_TEXTURE);
    setProperty("normalMap", null);
    setProperty("loop", true);
    setProperty("preWarm", false);
    setProperty("sort", pc.PARTICLESORT_NONE);
    setProperty("mode", pc.PARTICLEMODE_GPU);
    setProperty("scene", null);
    setProperty("lighting", false);
    setProperty("halfLambert", false);
    setProperty("intensity", 1.0);
    setProperty("stretch", 0.0);
    setProperty("alignToMotion", false);
    setProperty("depthSoftening", 0);
    setProperty("mesh", null);
    setProperty("depthWrite", false);
    setProperty("noFog", false);
    setProperty("blendType", pc.BLEND_NORMAL);
    setProperty("node", null);
    setProperty("startAngle", 0);
    setProperty("startAngle2", this.startAngle);
    setProperty("animTilesX", 1);
    setProperty("animTilesY", 1);
    setProperty("animNumFrames", 1);
    setProperty("animSpeed", 1);
    setProperty("animLoop", true);
    this.frameRandom = new pc.Vec3(0, 0, 0);
    setProperty("colorGraph", default1Curve3);
    setProperty("colorGraph2", this.colorGraph);
    setProperty("scaleGraph", default1Curve);
    setProperty("scaleGraph2", this.scaleGraph);
    setProperty("alphaGraph", default1Curve);
    setProperty("alphaGraph2", this.alphaGraph);
    setProperty("localVelocityGraph", default0Curve3);
    setProperty("localVelocityGraph2", this.localVelocityGraph);
    setProperty("velocityGraph", default0Curve3);
    setProperty("velocityGraph2", this.velocityGraph);
    setProperty("rotationSpeedGraph", default0Curve);
    setProperty("rotationSpeedGraph2", this.rotationSpeedGraph);
    this.constantParticleTexIN = gd.scope.resolve("particleTexIN");
    this.constantParticleTexOUT = gd.scope.resolve("particleTexOUT");
    this.constantEmitterPos = gd.scope.resolve("emitterPos");
    this.constantEmitterScale = gd.scope.resolve("emitterScale");
    this.constantSpawnBounds = gd.scope.resolve("spawnBounds");
    this.constantSpawnBoundsSphere = gd.scope.resolve("spawnBoundsSphere");
    this.constantInitialVelocity = gd.scope.resolve("initialVelocity");
    this.constantFrameRandom = gd.scope.resolve("frameRandom");
    this.constantDelta = gd.scope.resolve("delta");
    this.constantRate = gd.scope.resolve("rate");
    this.constantRateDiv = gd.scope.resolve("rateDiv");
    this.constantLifetime = gd.scope.resolve("lifetime");
    this.constantLightCube = gd.scope.resolve("lightCube[0]");
    this.constantGraphSampleSize = gd.scope.resolve("graphSampleSize");
    this.constantGraphNumSamples = gd.scope.resolve("graphNumSamples");
    this.constantInternalTex0 = gd.scope.resolve("internalTex0");
    this.constantInternalTex1 = gd.scope.resolve("internalTex1");
    this.constantInternalTex2 = gd.scope.resolve("internalTex2");
    this.constantEmitterMatrix = gd.scope.resolve("emitterMatrix");
    this.constantNumParticles = gd.scope.resolve("numParticles");
    this.constantNumParticlesPot = gd.scope.resolve("numParticlesPot");
    this.constantLocalVelocityDivMult = gd.scope.resolve("localVelocityDivMult");
    this.constantVelocityDivMult = gd.scope.resolve("velocityDivMult");
    this.constantRotSpeedDivMult = gd.scope.resolve("rotSpeedDivMult");
    this.constantSeed = gd.scope.resolve("seed");
    this.constantStartAngle = gd.scope.resolve("startAngle");
    this.constantStartAngle2 = gd.scope.resolve("startAngle2");
    this.constantOutBoundsMul = gd.scope.resolve("outBoundsMul");
    this.constantOutBoundsAdd = gd.scope.resolve("outBoundsAdd");
    this.constantInBoundsSize = gd.scope.resolve("inBoundsSize");
    this.constantInBoundsCenter = gd.scope.resolve("inBoundsCenter");
    this.constantMaxVel = gd.scope.resolve("maxVel");
    this.lightCube = new Float32Array(6 * 3);
    this.lightCubeDir = new Array(6);
    this.lightCubeDir[0] = new pc.Vec3(-1, 0, 0);
    this.lightCubeDir[1] = new pc.Vec3(1, 0, 0);
    this.lightCubeDir[2] = new pc.Vec3(0, -1, 0);
    this.lightCubeDir[3] = new pc.Vec3(0, 1, 0);
    this.lightCubeDir[4] = new pc.Vec3(0, 0, -1);
    this.lightCubeDir[5] = new pc.Vec3(0, 0, 1);
    this.animParams = new pc.Vec4;
    this.internalTex0 = null;
    this.internalTex1 = null;
    this.internalTex2 = null;
    this.internalTex3 = null;
    this.vbToSort = null;
    this.vbOld = null;
    this.particleDistance = null;
    this.camera = null;
    this.swapTex = false;
    this.useMesh = true;
    this.useCpu = false;
    this.pack8 = true;
    this.localBounds = new pc.BoundingBox;
    this.worldBoundsNoTrail = new pc.BoundingBox;
    this.worldBoundsTrail = [new pc.BoundingBox, new pc.BoundingBox];
    this.worldBounds = new pc.BoundingBox;
    this.worldBoundsSize = new pc.Vec3;
    this.prevWorldBoundsSize = new pc.Vec3;
    this.prevWorldBoundsCenter = new pc.Vec3;
    this.worldBoundsMul = new pc.Vec3;
    this.worldBoundsAdd = new pc.Vec3;
    this.timeToSwitchBounds = 0;
    this.shaderParticleUpdateRespawn = null;
    this.shaderParticleUpdateNoRespawn = null;
    this.shaderParticleUpdateOnStop = null;
    this.numParticleVerts = 0;
    this.numParticleIndices = 0;
    this.material = null;
    this.meshInstance = null;
    this.seed = 0;
    this.fixedTimeStep = 1.0 / 60;
    this.maxSubSteps = 10;
    this.simTime = 0;
    this.simTimeTotal = 0;
    this.beenReset = false;
    this._layer = null;
    this.rebuild();
  };
  function calcEndTime(emitter) {
    var interval = Math.max(emitter.rate, emitter.rate2) * emitter.numParticles + emitter.lifetime;
    return Date.now() + interval * 1000;
  }
  function subGraph(A, B) {
    var r = new Float32Array(A.length);
    for (var i = 0;i < A.length;i++) {
      r[i] = A[i] - B[i];
    }
    return r;
  }
  function maxUnsignedGraphValue(A, outUMax) {
    var i, j;
    var chans = outUMax.length;
    var values = A.length / chans;
    for (i = 0;i < values;i++) {
      for (j = 0;j < chans;j++) {
        var a = Math.abs(A[i * chans + j]);
        outUMax[j] = Math.max(outUMax[j], a);
      }
    }
  }
  function normalizeGraph(A, uMax) {
    var chans = uMax.length;
    var i, j;
    var values = A.length / chans;
    for (i = 0;i < values;i++) {
      for (j = 0;j < chans;j++) {
        A[i * chans + j] /= uMax[j];
        A[i * chans + j] *= 0.5;
        A[i * chans + j] += 0.5;
      }
    }
  }
  function divGraphFrom2Curves(curve1, curve2, outUMax) {
    var sub = subGraph(curve2, curve1);
    maxUnsignedGraphValue(sub, outUMax);
    normalizeGraph(sub, outUMax);
    return sub;
  }
  function mat4ToMat3(mat4, mat3) {
    mat3.data[0] = mat4.data[0];
    mat3.data[1] = mat4.data[1];
    mat3.data[2] = mat4.data[2];
    mat3.data[3] = mat4.data[4];
    mat3.data[4] = mat4.data[5];
    mat3.data[5] = mat4.data[6];
    mat3.data[6] = mat4.data[8];
    mat3.data[7] = mat4.data[9];
    mat3.data[8] = mat4.data[10];
  }
  Object.assign(ParticleEmitter.prototype, {onChangeCamera:function() {
    this.regenShader();
    this.resetMaterial();
  }, calculateBoundsMad:function() {
    this.worldBoundsMul.x = 1.0 / this.worldBoundsSize.x;
    this.worldBoundsMul.y = 1.0 / this.worldBoundsSize.y;
    this.worldBoundsMul.z = 1.0 / this.worldBoundsSize.z;
    this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).scale(-1);
    this.worldBoundsAdd.x += 0.5;
    this.worldBoundsAdd.y += 0.5;
    this.worldBoundsAdd.z += 0.5;
  }, calculateWorldBounds:function() {
    if (!this.node) {
      return;
    }
    this.prevWorldBoundsSize.copy(this.worldBoundsSize);
    this.prevWorldBoundsCenter.copy(this.worldBounds.center);
    this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.node.getWorldTransform());
    this.worldBoundsTrail[0].add(this.worldBoundsNoTrail);
    var now = this.simTimeTotal;
    if (now > this.timeToSwitchBounds) {
      var tmp = this.worldBoundsTrail[0];
      this.worldBoundsTrail[0] = this.worldBoundsTrail[1];
      this.worldBoundsTrail[1] = tmp;
      this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);
      this.timeToSwitchBounds = now + this.lifetime;
    }
    this.worldBounds.copy(this.worldBoundsTrail[0]);
    this.worldBounds.add(this.worldBoundsTrail[1]);
    this.worldBoundsSize.copy(this.worldBounds.halfExtents).scale(2);
    this.meshInstance.mesh.aabb = this.worldBounds;
    this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;
    if (this.pack8) {
      this.calculateBoundsMad();
    }
  }, calculateLocalBounds:function() {
    var minx = Number.MAX_VALUE;
    var miny = Number.MAX_VALUE;
    var minz = Number.MAX_VALUE;
    var maxx = -Number.MAX_VALUE;
    var maxy = -Number.MAX_VALUE;
    var maxz = -Number.MAX_VALUE;
    var maxScale = 0;
    var stepWeight = this.lifetime / this.precision;
    var vels = [this.qVelocity, this.qVelocity2, this.qLocalVelocity, this.qLocalVelocity2];
    var accumX = [0, 0, 0, 0];
    var accumY = [0, 0, 0, 0];
    var accumZ = [0, 0, 0, 0];
    var i, j;
    var index;
    var x, y, z;
    for (i = 0;i < this.precision + 1;i++) {
      index = Math.min(i, this.precision - 1);
      for (j = 0;j < 4;j++) {
        x = vels[j][index * 3] * stepWeight + accumX[j];
        y = vels[j][index * 3 + 1] * stepWeight + accumY[j];
        z = vels[j][index * 3 + 2] * stepWeight + accumZ[j];
        if (minx > x) {
          minx = x;
        }
        if (miny > y) {
          miny = y;
        }
        if (minz > z) {
          minz = z;
        }
        if (maxx < x) {
          maxx = x;
        }
        if (maxy < y) {
          maxy = y;
        }
        if (maxz < z) {
          maxz = z;
        }
        accumX[j] = x;
        accumY[j] = y;
        accumZ[j] = z;
      }
      maxScale = Math.max(maxScale, this.qScale[index]);
    }
    if (this.emitterShape === pc.EMITTERSHAPE_BOX) {
      x = this.emitterExtents.x * 0.5;
      y = this.emitterExtents.y * 0.5;
      z = this.emitterExtents.z * 0.5;
      if (maxx < x) {
        maxx = x;
      }
      if (maxy < y) {
        maxy = y;
      }
      if (maxz < z) {
        maxz = z;
      }
      x = -x;
      y = -y;
      z = -z;
      if (minx > x) {
        minx = x;
      }
      if (miny > y) {
        miny = y;
      }
      if (minz > z) {
        minz = z;
      }
    } else {
      x = this.emitterRadius;
      y = this.emitterRadius;
      z = this.emitterRadius;
      if (maxx < x) {
        maxx = x;
      }
      if (maxy < y) {
        maxy = y;
      }
      if (maxz < z) {
        maxz = z;
      }
      x = -x;
      y = -y;
      z = -z;
      if (minx > x) {
        minx = x;
      }
      if (miny > y) {
        miny = y;
      }
      if (minz > z) {
        minz = z;
      }
    }
    bMin.x = minx - maxScale;
    bMin.y = miny - maxScale;
    bMin.z = minz - maxScale;
    bMax.x = maxx + maxScale;
    bMax.y = maxy + maxScale;
    bMax.z = maxz + maxScale;
    this.localBounds.setMinMax(bMin, bMax);
  }, rebuild:function() {
    var i;
    var gd = this.graphicsDevice;
    if (this.colorMap === null) {
      this.colorMap = ParticleEmitter.DEFAULT_PARAM_TEXTURE;
    }
    this.spawnBounds = this.emitterShape === pc.EMITTERSHAPE_BOX ? this.emitterExtents : this.emitterRadius;
    this.useCpu = this.useCpu || this.sort > pc.PARTICLESORT_NONE || gd.maxVertexTextures <= 1 || gd.fragmentUniformsCount < 64 || gd.forceCpuParticles || !gd.extTextureFloat;
    this.vertexBuffer = undefined;
    this.pack8 = (this.pack8 || !gd.extTextureFloatRenderable) && !this.useCpu;
    particleTexHeight = this.useCpu || this.pack8 ? 4 : 2;
    this.useMesh = false;
    if (this.mesh) {
      var totalVertCount = this.numParticles * this.mesh.vertexBuffer.numVertices;
      if (totalVertCount > 65535) {
        console.warn("WARNING: particle system can't render mesh particles because numParticles * numVertices is more than 65k. Reverting to quad particles.");
      } else {
        this.useMesh = true;
      }
    }
    this.numParticlesPot = pc.math.nextPowerOfTwo(this.numParticles);
    this.rebuildGraphs();
    this.calculateLocalBounds();
    if (this.node) {
      this.worldBounds.setFromTransformedAabb(this.localBounds, this.node.getWorldTransform());
      this.worldBoundsTrail[0].copy(this.worldBounds);
      this.worldBoundsTrail[1].copy(this.worldBounds);
      this.worldBoundsSize.copy(this.worldBounds.halfExtents).scale(2);
      this.prevWorldBoundsSize.copy(this.worldBoundsSize);
      this.prevWorldBoundsCenter.copy(this.worldBounds.center);
      if (this.pack8) {
        this.calculateBoundsMad();
      }
    }
    this.vbToSort = new Array(this.numParticles);
    this.particleDistance = new Float32Array(this.numParticles);
    this.frameRandom.x = Math.random();
    this.frameRandom.y = Math.random();
    this.frameRandom.z = Math.random();
    this.particleTex = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);
    var emitterPos = this.node === null || this.localSpace ? pc.Vec3.ZERO : this.node.getPosition();
    if (this.emitterShape === pc.EMITTERSHAPE_BOX) {
      if (this.node === null) {
        spawnMatrix.setTRS(pc.Vec3.ZERO, pc.Quat.IDENTITY, this.spawnBounds);
      } else {
        spawnMatrix.setTRS(pc.Vec3.ZERO, this.node.getRotation(), tmpVec3.copy(this.spawnBounds).mul(this.node.localScale));
      }
    }
    for (i = 0;i < this.numParticles;i++) {
      this.calcSpawnPosition(emitterPos, i);
      if (this.useCpu) {
        this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = 1;
      }
    }
    this.particleTexStart = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);
    for (i = 0;i < this.particleTexStart.length;i++) {
      this.particleTexStart[i] = this.particleTex[i];
    }
    if (!this.useCpu) {
      if (this.pack8) {
        this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, pc.PIXELFORMAT_R8_G8_B8_A8, 1, false);
        this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, pc.PIXELFORMAT_R8_G8_B8_A8, 1, false);
        this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart, pc.PIXELFORMAT_R8_G8_B8_A8, 1, false);
      } else {
        this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
        this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
        this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart);
      }
      this.rtParticleTexIN = new pc.RenderTarget(gd, this.particleTexIN, {depth:false});
      this.rtParticleTexOUT = new pc.RenderTarget(gd, this.particleTexOUT, {depth:false});
      this.swapTex = false;
    }
    var chunks = pc.shaderChunks;
    var shaderCodeStart = chunks.particleUpdaterInitPS + (this.pack8 ? chunks.particleInputRgba8PS + chunks.particleOutputRgba8PS : chunks.particleInputFloatPS + chunks.particleOutputFloatPS) + (this.emitterShape === pc.EMITTERSHAPE_BOX ? chunks.particleUpdaterAABBPS : chunks.particleUpdaterSpherePS) + chunks.particleUpdaterStartPS;
    var shaderCodeRespawn = shaderCodeStart + chunks.particleUpdaterRespawnPS + chunks.particleUpdaterEndPS;
    var shaderCodeNoRespawn = shaderCodeStart + chunks.particleUpdaterNoRespawnPS + chunks.particleUpdaterEndPS;
    var shaderCodeOnStop = shaderCodeStart + chunks.particleUpdaterOnStopPS + chunks.particleUpdaterEndPS;
    this.shaderParticleUpdateRespawn = chunks.createShaderFromCode(gd, chunks.fullscreenQuadVS, shaderCodeRespawn, "fsQuad0" + this.emitterShape + "" + this.pack8);
    this.shaderParticleUpdateNoRespawn = chunks.createShaderFromCode(gd, chunks.fullscreenQuadVS, shaderCodeNoRespawn, "fsQuad1" + this.emitterShape + "" + this.pack8);
    this.shaderParticleUpdateOnStop = chunks.createShaderFromCode(gd, chunks.fullscreenQuadVS, shaderCodeOnStop, "fsQuad2" + this.emitterShape + "" + this.pack8);
    this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;
    this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;
    this._allocate(this.numParticles);
    var mesh = new pc.Mesh;
    mesh.vertexBuffer = this.vertexBuffer;
    mesh.indexBuffer[0] = this.indexBuffer;
    mesh.primitive[0].type = pc.PRIMITIVE_TRIANGLES;
    mesh.primitive[0].base = 0;
    mesh.primitive[0].count = this.numParticles * this.numParticleIndices;
    mesh.primitive[0].indexed = true;
    this.material = new pc.Material;
    this.material.cullMode = pc.CULLFACE_NONE;
    this.material.alphaWrite = false;
    this.material.blend = true;
    this.material.blendType = this.blendType;
    this.material.depthWrite = this.depthWrite;
    this.material.emitter = this;
    this.regenShader();
    this.resetMaterial();
    this.meshInstance = new pc.MeshInstance(this.node, mesh, this.material);
    this.meshInstance.pick = false;
    this.meshInstance.updateKey();
    this.meshInstance.cull = true;
    this.meshInstance._noDepthDrawGl1 = true;
    this.meshInstance.aabb = this.worldBounds;
    this.meshInstance._updateAabb = false;
    this._initializeTextures();
    this.addTime(0);
    if (this.preWarm) {
      this.prewarm(this.lifetime);
    }
    this.resetTime();
  }, _isAnimated:function() {
    return this.animNumFrames >= 1 && (this.animTilesX > 1 || this.animTilesY > 1) && (this.colorMap && this.colorMap !== ParticleEmitter.DEFAULT_PARAM_TEXTURE || this.normalMap);
  }, calcSpawnPosition:function(emitterPos, i) {
    var rX = Math.random();
    var rY = Math.random();
    var rZ = Math.random();
    var rW = Math.random();
    if (this.useCpu) {
      this.particleTex[i * particleTexChannels + 0 + this.numParticlesPot * 2 * particleTexChannels] = rX;
      this.particleTex[i * particleTexChannels + 1 + this.numParticlesPot * 2 * particleTexChannels] = rY;
      this.particleTex[i * particleTexChannels + 2 + this.numParticlesPot * 2 * particleTexChannels] = rZ;
    }
    randomPos.data[0] = rX - 0.5;
    randomPos.data[1] = rY - 0.5;
    randomPos.data[2] = rZ - 0.5;
    if (this.emitterShape === pc.EMITTERSHAPE_BOX) {
      randomPosTformed.copy(emitterPos).add(spawnMatrix.transformPoint(randomPos));
    } else {
      randomPos.normalize();
      randomPosTformed.copy(emitterPos).add(randomPos.scale(rW * this.spawnBounds));
    }
    var particleRate, startSpawnTime;
    if (this.pack8) {
      var packX = (randomPosTformed.data[0] - this.worldBounds.center.data[0]) / this.worldBoundsSize.data[0] + 0.5;
      var packY = (randomPosTformed.data[1] - this.worldBounds.center.data[1]) / this.worldBoundsSize.data[1] + 0.5;
      var packZ = (randomPosTformed.data[2] - this.worldBounds.center.data[2]) / this.worldBoundsSize.data[2] + 0.5;
      var packA = pc.math.lerp(this.startAngle * pc.math.DEG_TO_RAD, this.startAngle2 * pc.math.DEG_TO_RAD, rX);
      packA = packA % (Math.PI * 2) / (Math.PI * 2);
      var rg0 = encodeFloatRG(packX);
      this.particleTex[i * particleTexChannels] = rg0[0];
      this.particleTex[i * particleTexChannels + 1] = rg0[1];
      var ba0 = encodeFloatRG(packY);
      this.particleTex[i * particleTexChannels + 2] = ba0[0];
      this.particleTex[i * particleTexChannels + 3] = ba0[1];
      var rg1 = encodeFloatRG(packZ);
      this.particleTex[i * particleTexChannels + 0 + this.numParticlesPot * particleTexChannels] = rg1[0];
      this.particleTex[i * particleTexChannels + 1 + this.numParticlesPot * particleTexChannels] = rg1[1];
      var ba1 = encodeFloatRG(packA);
      this.particleTex[i * particleTexChannels + 2 + this.numParticlesPot * particleTexChannels] = ba1[0];
      this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * particleTexChannels] = ba1[1];
      var a2 = 1.0;
      this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * particleTexChannels * 2] = a2;
      particleRate = pc.math.lerp(this.rate, this.rate2, rX);
      startSpawnTime = -particleRate * i;
      var maxNegLife = Math.max(this.lifetime, (this.numParticles - 1.0) * Math.max(this.rate, this.rate2));
      var maxPosLife = this.lifetime + 1.0;
      startSpawnTime = (startSpawnTime + maxNegLife) / (maxNegLife + maxPosLife);
      var rgba3 = encodeFloatRGBA(startSpawnTime);
      this.particleTex[i * particleTexChannels + 0 + this.numParticlesPot * particleTexChannels * 3] = rgba3[0];
      this.particleTex[i * particleTexChannels + 1 + this.numParticlesPot * particleTexChannels * 3] = rgba3[1];
      this.particleTex[i * particleTexChannels + 2 + this.numParticlesPot * particleTexChannels * 3] = rgba3[2];
      this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * particleTexChannels * 3] = rgba3[3];
    } else {
      this.particleTex[i * particleTexChannels] = randomPosTformed.data[0];
      this.particleTex[i * particleTexChannels + 1] = randomPosTformed.data[1];
      this.particleTex[i * particleTexChannels + 2] = randomPosTformed.data[2];
      this.particleTex[i * particleTexChannels + 3] = pc.math.lerp(this.startAngle * pc.math.DEG_TO_RAD, this.startAngle2 * pc.math.DEG_TO_RAD, rX);
      particleRate = pc.math.lerp(this.rate, this.rate2, rX);
      startSpawnTime = -particleRate * i;
      this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * particleTexChannels] = startSpawnTime;
    }
  }, rebuildGraphs:function() {
    var precision = this.precision;
    var gd = this.graphicsDevice;
    var i;
    this.qLocalVelocity = this.localVelocityGraph.quantize(precision);
    this.qVelocity = this.velocityGraph.quantize(precision);
    this.qColor = this.colorGraph.quantize(precision);
    this.qRotSpeed = this.rotationSpeedGraph.quantize(precision);
    this.qScale = this.scaleGraph.quantize(precision);
    this.qAlpha = this.alphaGraph.quantize(precision);
    this.qLocalVelocity2 = this.localVelocityGraph2.quantize(precision);
    this.qVelocity2 = this.velocityGraph2.quantize(precision);
    this.qColor2 = this.colorGraph2.quantize(precision);
    this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(precision);
    this.qScale2 = this.scaleGraph2.quantize(precision);
    this.qAlpha2 = this.alphaGraph2.quantize(precision);
    for (i = 0;i < precision;i++) {
      this.qRotSpeed[i] *= pc.math.DEG_TO_RAD;
      this.qRotSpeed2[i] *= pc.math.DEG_TO_RAD;
    }
    this.localVelocityUMax = new pc.Vec3(0, 0, 0);
    this.velocityUMax = new pc.Vec3(0, 0, 0);
    this.colorUMax = new pc.Vec3(0, 0, 0);
    this.rotSpeedUMax = [0];
    this.scaleUMax = [0];
    this.alphaUMax = [0];
    this.qLocalVelocityDiv = divGraphFrom2Curves(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax.data);
    this.qVelocityDiv = divGraphFrom2Curves(this.qVelocity, this.qVelocity2, this.velocityUMax.data);
    this.qColorDiv = divGraphFrom2Curves(this.qColor, this.qColor2, this.colorUMax.data);
    this.qRotSpeedDiv = divGraphFrom2Curves(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);
    this.qScaleDiv = divGraphFrom2Curves(this.qScale, this.qScale2, this.scaleUMax);
    this.qAlphaDiv = divGraphFrom2Curves(this.qAlpha, this.qAlpha2, this.alphaUMax);
    if (this.pack8) {
      var umax = [0, 0, 0];
      maxUnsignedGraphValue(this.qVelocity, umax);
      var umax2 = [0, 0, 0];
      maxUnsignedGraphValue(this.qVelocity2, umax2);
      var lumax = [0, 0, 0];
      maxUnsignedGraphValue(this.qLocalVelocity, lumax);
      var lumax2 = [0, 0, 0];
      maxUnsignedGraphValue(this.qLocalVelocity2, lumax2);
      var maxVel = Math.max(umax[0], umax2[0]);
      maxVel = Math.max(maxVel, umax[1]);
      maxVel = Math.max(maxVel, umax2[1]);
      maxVel = Math.max(maxVel, umax[2]);
      maxVel = Math.max(maxVel, umax2[2]);
      var lmaxVel = Math.max(lumax[0], lumax2[0]);
      lmaxVel = Math.max(lmaxVel, lumax[1]);
      lmaxVel = Math.max(lmaxVel, lumax2[1]);
      lmaxVel = Math.max(lmaxVel, lumax[2]);
      lmaxVel = Math.max(lmaxVel, lumax2[2]);
      this.maxVel = maxVel + lmaxVel;
    }
    if (!this.useCpu) {
      this.internalTex0 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qLocalVelocity, this.qLocalVelocityDiv));
      this.internalTex1 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qVelocity, this.qVelocityDiv));
      this.internalTex2 = _createTexture(gd, precision, 1, packTexture5Floats(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv));
    }
    this.internalTex3 = _createTexture(gd, precision, 1, packTextureRGBA(this.qColor, this.qAlpha), pc.PIXELFORMAT_R8_G8_B8_A8, 1.0, true);
  }, _initializeTextures:function() {
    if (this.colorMap) {
      this.material.setParameter("colorMap", this.colorMap);
      if (this.lighting && this.normalMap) {
        this.material.setParameter("normalMap", this.normalMap);
      }
    }
  }, regenShader:function() {
    var programLib = this.graphicsDevice.getProgramLibrary();
    var hasNormal = this.normalMap !== null;
    this.normalOption = 0;
    if (this.lighting) {
      this.normalOption = hasNormal ? 2 : 1;
    }
    this.material.updateShader = function() {
      if (this.emitter.scene) {
        if (this.emitter.camera != this.emitter.scene._activeCamera) {
          this.emitter.camera = this.emitter.scene._activeCamera;
          this.emitter.onChangeCamera();
        }
      }
      var shader = programLib.getProgram("particle", {useCpu:this.emitter.useCpu, normal:this.emitter.normalOption, halflambert:this.emitter.halfLambert, stretch:this.emitter.stretch, alignToMotion:this.emitter.alignToMotion, soft:this.emitter.depthSoftening, mesh:this.emitter.useMesh, gamma:this.emitter.scene ? this.emitter.scene.gammaCorrection : 0, toneMap:this.emitter.scene ? this.emitter.scene.toneMapping : 0, fog:this.emitter.scene && !this.emitter.noFog ? this.emitter.scene.fog : "none", wrap:this.emitter.wrap && 
      this.emitter.wrapBounds, localSpace:this.emitter.localSpace, blend:this.blendType, animTex:this.emitter._isAnimated(), animTexLoop:this.emitter.animLoop, pack8:this.emitter.pack8});
      this.setShader(shader);
    };
    this.material.updateShader();
  }, resetMaterial:function() {
    var material = this.material;
    material.setParameter("stretch", this.stretch);
    if (this._isAnimated()) {
      material.setParameter("animTexParams", this.animParams.data);
    }
    material.setParameter("colorMult", this.intensity);
    if (!this.useCpu) {
      material.setParameter("internalTex0", this.internalTex0);
      material.setParameter("internalTex1", this.internalTex1);
      material.setParameter("internalTex2", this.internalTex2);
    }
    material.setParameter("internalTex3", this.internalTex3);
    material.setParameter("numParticles", this.numParticles);
    material.setParameter("numParticlesPot", this.numParticlesPot);
    material.setParameter("lifetime", this.lifetime);
    material.setParameter("rate", this.rate);
    material.setParameter("rateDiv", this.rate2 - this.rate);
    material.setParameter("seed", this.seed);
    material.setParameter("scaleDivMult", this.scaleUMax[0]);
    material.setParameter("alphaDivMult", this.alphaUMax[0]);
    material.setParameter("graphNumSamples", this.precision);
    material.setParameter("graphSampleSize", 1.0 / this.precision);
    material.setParameter("emitterScale", pc.Vec3.ONE.data);
    if (this.pack8) {
      material.setParameter("inBoundsSize", this.worldBoundsSize.data);
      material.setParameter("inBoundsCenter", this.worldBounds.center.data);
      material.setParameter("maxVel", this.maxVel);
    }
    if (this.wrap && this.wrapBounds) {
      material.setParameter("wrapBounds", this.wrapBounds.data);
    }
    if (this.colorMap) {
      material.setParameter("colorMap", this.colorMap);
    }
    if (this.lighting) {
      if (this.normalMap) {
        material.setParameter("normalMap", this.normalMap);
      }
    }
    if (this.depthSoftening > 0) {
      material.setParameter("softening", 1.0 / (this.depthSoftening * this.depthSoftening * 100));
    }
    if (this.stretch > 0.0) {
      material.cull = pc.CULLFACE_NONE;
    }
  }, _allocate:function(numParticles) {
    var psysVertCount = numParticles * this.numParticleVerts;
    var psysIndexCount = numParticles * this.numParticleIndices;
    var elements, particleFormat;
    var i;
    if (this.vertexBuffer === undefined || this.vertexBuffer.getNumVertices() !== psysVertCount) {
      if (!this.useCpu) {
        elements = [{semantic:pc.SEMANTIC_ATTR0, components:4, type:pc.TYPE_FLOAT32}];
        particleFormat = new pc.VertexFormat(this.graphicsDevice, elements);
        this.vertexBuffer = new pc.VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, pc.BUFFER_DYNAMIC);
        this.indexBuffer = new pc.IndexBuffer(this.graphicsDevice, pc.INDEXFORMAT_UINT16, psysIndexCount);
      } else {
        elements = [{semantic:pc.SEMANTIC_ATTR0, components:4, type:pc.TYPE_FLOAT32}, {semantic:pc.SEMANTIC_ATTR1, components:4, type:pc.TYPE_FLOAT32}, {semantic:pc.SEMANTIC_ATTR2, components:4, type:pc.TYPE_FLOAT32}, {semantic:pc.SEMANTIC_ATTR3, components:2, type:pc.TYPE_FLOAT32}];
        particleFormat = new pc.VertexFormat(this.graphicsDevice, elements);
        this.vertexBuffer = new pc.VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, pc.BUFFER_DYNAMIC);
        this.indexBuffer = new pc.IndexBuffer(this.graphicsDevice, pc.INDEXFORMAT_UINT16, psysIndexCount);
      }
      var data = new Float32Array(this.vertexBuffer.lock());
      var meshData, stride;
      if (this.useMesh) {
        meshData = new Float32Array(this.mesh.vertexBuffer.lock());
        stride = meshData.length / this.mesh.vertexBuffer.numVertices;
      }
      var id;
      for (i = 0;i < psysVertCount;i++) {
        id = Math.floor(i / this.numParticleVerts);
        if (!this.useMesh) {
          var vertID = i % 4;
          data[i * 4] = particleVerts[vertID][0];
          data[i * 4 + 1] = particleVerts[vertID][1];
          data[i * 4 + 2] = 0;
        } else {
          var vert = i % this.numParticleVerts;
          data[i * 4] = meshData[vert * stride];
          data[i * 4 + 1] = meshData[vert * stride + 1];
          data[i * 4 + 2] = meshData[vert * stride + 2];
        }
        data[i * 4 + 3] = id;
      }
      if (this.useCpu) {
        this.vbCPU = new Float32Array(data);
        this.vbOld = new Float32Array(this.vbCPU.length);
      }
      this.vertexBuffer.unlock();
      if (this.useMesh) {
        this.mesh.vertexBuffer.unlock();
      }
      var dst = 0;
      var indices = new Uint16Array(this.indexBuffer.lock());
      if (this.useMesh) {
        meshData = new Uint16Array(this.mesh.indexBuffer[0].lock());
      }
      for (i = 0;i < numParticles;i++) {
        if (!this.useMesh) {
          var baseIndex = i * 4;
          indices[dst++] = baseIndex;
          indices[dst++] = baseIndex + 1;
          indices[dst++] = baseIndex + 2;
          indices[dst++] = baseIndex;
          indices[dst++] = baseIndex + 2;
          indices[dst++] = baseIndex + 3;
        } else {
          for (var j = 0;j < this.numParticleIndices;j++) {
            indices[i * this.numParticleIndices + j] = meshData[j] + i * this.numParticleVerts;
          }
        }
      }
      this.indexBuffer.unlock();
      if (this.useMesh) {
        this.mesh.indexBuffer[0].unlock();
      }
    }
  }, reset:function() {
    this.beenReset = true;
    this.seed = Math.random();
    this.material.setParameter("seed", this.seed);
    if (this.useCpu) {
      for (var i = 0;i < this.particleTexStart.length;i++) {
        this.particleTex[i] = this.particleTexStart[i];
      }
    } else {
      this._initializeTextures();
    }
    this.resetTime();
    var origLoop = this.loop;
    this.loop = true;
    this.addTime(0);
    this.loop = origLoop;
    if (this.preWarm) {
      this.prewarm(this.lifetime);
    }
  }, prewarm:function(time) {
    var lifetimeFraction = time / this.lifetime;
    var iterations = Math.min(Math.floor(lifetimeFraction * this.precision), this.precision);
    var stepDelta = time / iterations;
    for (var i = 0;i < iterations;i++) {
      this.addTime(stepDelta);
    }
  }, resetTime:function() {
    this.endTime = calcEndTime(this);
  }, finishFrame:function() {
    if (this.useCpu) {
      this.vertexBuffer.unlock();
    }
  }, addTime:function(delta, isOnStop) {
    var a, b, c, i, j;
    var device = this.graphicsDevice;
    this.simTimeTotal += delta;
    this.calculateWorldBounds();
    if (this._isAnimated()) {
      var params = this.animParams;
      params.x = 1.0 / this.animTilesX;
      params.y = 1.0 / this.animTilesY;
      params.z = this.animNumFrames * this.animSpeed;
      params.w = this.animNumFrames - 1;
    }
    if (this.scene) {
      if (this.camera != this.scene._activeCamera) {
        this.camera = this.scene._activeCamera;
        this.onChangeCamera();
      }
    }
    if (this.emitterShape === pc.EMITTERSHAPE_BOX) {
      if (this.meshInstance.node === null) {
        spawnMatrix.setTRS(pc.Vec3.ZERO, pc.Quat.IDENTITY, this.emitterExtents);
      } else {
        spawnMatrix.setTRS(pc.Vec3.ZERO, this.meshInstance.node.getRotation(), tmpVec3.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));
      }
    }
    var emitterPos;
    var emitterScale = this.meshInstance.node === null ? pc.Vec3.ONE.data : this.meshInstance.node.localScale.data;
    this.material.setParameter("emitterScale", emitterScale);
    if (this.localSpace && this.meshInstance.node) {
      this.material.setParameter("emitterPos", this.meshInstance.node.getPosition().data);
    }
    if (!this.useCpu) {
      device.setBlending(false);
      device.setColorWrite(true, true, true, true);
      device.setCullMode(pc.CULLFACE_NONE);
      device.setDepthTest(false);
      device.setDepthWrite(false);
      this.frameRandom.x = Math.random();
      this.frameRandom.y = Math.random();
      this.frameRandom.z = Math.random();
      this.constantGraphSampleSize.setValue(1.0 / this.precision);
      this.constantGraphNumSamples.setValue(this.precision);
      this.constantNumParticles.setValue(this.numParticles);
      this.constantNumParticlesPot.setValue(this.numParticlesPot);
      this.constantInternalTex0.setValue(this.internalTex0);
      this.constantInternalTex1.setValue(this.internalTex1);
      this.constantInternalTex2.setValue(this.internalTex2);
      if (this.pack8) {
        this.constantOutBoundsMul.setValue(this.worldBoundsMul.data);
        this.constantOutBoundsAdd.setValue(this.worldBoundsAdd.data);
        this.constantInBoundsSize.setValue(this.prevWorldBoundsSize.data);
        this.constantInBoundsCenter.setValue(this.prevWorldBoundsCenter.data);
        var maxVel = this.maxVel * Math.max(Math.max(emitterScale[0], emitterScale[1]), emitterScale[2]);
        maxVel = Math.max(maxVel, 1);
        this.constantMaxVel.setValue(maxVel);
      }
      emitterPos = this.meshInstance.node === null || this.localSpace ? pc.Vec3.ZERO.data : this.meshInstance.node.getPosition().data;
      var emitterMatrix = this.meshInstance.node === null ? pc.Mat4.IDENTITY : this.meshInstance.node.getWorldTransform();
      if (this.emitterShape === pc.EMITTERSHAPE_BOX) {
        mat4ToMat3(spawnMatrix, spawnMatrix3);
        this.constantSpawnBounds.setValue(spawnMatrix3.data);
      } else {
        this.constantSpawnBoundsSphere.setValue(this.emitterRadius);
      }
      this.constantInitialVelocity.setValue(this.initialVelocity);
      mat4ToMat3(emitterMatrix, emitterMatrix3);
      this.constantEmitterPos.setValue(emitterPos);
      this.constantFrameRandom.setValue(this.frameRandom.data);
      this.constantDelta.setValue(delta);
      this.constantRate.setValue(this.rate);
      this.constantRateDiv.setValue(this.rate2 - this.rate);
      this.constantStartAngle.setValue(this.startAngle * pc.math.DEG_TO_RAD);
      this.constantStartAngle2.setValue(this.startAngle2 * pc.math.DEG_TO_RAD);
      this.constantSeed.setValue(this.seed);
      this.constantLifetime.setValue(this.lifetime);
      this.constantEmitterScale.setValue(emitterScale);
      this.constantEmitterMatrix.setValue(emitterMatrix3.data);
      this.constantLocalVelocityDivMult.setValue(this.localVelocityUMax.data);
      this.constantVelocityDivMult.setValue(this.velocityUMax.data);
      this.constantRotSpeedDivMult.setValue(this.rotSpeedUMax[0]);
      var texIN = this.swapTex ? this.particleTexOUT : this.particleTexIN;
      texIN = this.beenReset ? this.particleTexStart : texIN;
      var texOUT = this.swapTex ? this.particleTexIN : this.particleTexOUT;
      this.constantParticleTexIN.setValue(texIN);
      if (!isOnStop) {
        pc.drawQuadWithShader(device, this.swapTex ? this.rtParticleTexIN : this.rtParticleTexOUT, this.loop ? this.shaderParticleUpdateRespawn : this.shaderParticleUpdateNoRespawn);
      } else {
        pc.drawQuadWithShader(device, this.swapTex ? this.rtParticleTexIN : this.rtParticleTexOUT, this.shaderParticleUpdateOnStop);
      }
      this.constantParticleTexOUT.setValue(texOUT);
      this.material.setParameter("particleTexOUT", texIN);
      this.material.setParameter("particleTexIN", texOUT);
      this.beenReset = false;
      this.swapTex = !this.swapTex;
      device.setDepthTest(true);
      device.setDepthWrite(true);
    } else {
      var data = new Float32Array(this.vertexBuffer.lock());
      if (this.meshInstance.node) {
        var fullMat = this.meshInstance.node.worldTransform;
        for (j = 0;j < 12;j++) {
          rotMat.data[j] = fullMat.data[j];
        }
        nonUniformScale = this.meshInstance.node.localScale;
        uniformScale = Math.max(Math.max(nonUniformScale.x, nonUniformScale.y), nonUniformScale.z);
      }
      emitterPos = this.meshInstance.node === null || this.localSpace ? pc.Vec3.ZERO : this.meshInstance.node.getPosition();
      var posCam = this.camera ? this.camera._node.getPosition() : pc.Vec3.ZERO;
      var vertSize = 14;
      var cf, cc;
      var rotSpeed, rotSpeed2, scale2, alpha, alpha2;
      var precision1 = this.precision - 1;
      for (i = 0;i < this.numParticles;i++) {
        var id = Math.floor(this.vbCPU[i * this.numParticleVerts * 4 + 3]);
        var rndFactor = this.particleTex[id * particleTexChannels + 0 + this.numParticlesPot * 2 * particleTexChannels];
        rndFactor3Vec.data[0] = rndFactor;
        rndFactor3Vec.data[1] = this.particleTex[id * particleTexChannels + 1 + this.numParticlesPot * 2 * particleTexChannels];
        rndFactor3Vec.data[2] = this.particleTex[id * particleTexChannels + 2 + this.numParticlesPot * 2 * particleTexChannels];
        var particleRate = this.rate + (this.rate2 - this.rate) * rndFactor;
        var particleLifetime = this.lifetime;
        var life = this.particleTex[id * particleTexChannels + 3 + this.numParticlesPot * particleTexChannels] + delta;
        var nlife = saturate(life / particleLifetime);
        var scale = 0;
        var alphaDiv = 0;
        var angle = 0;
        var particleEnabled = life > 0.0 && life < particleLifetime;
        if (particleEnabled) {
          c = nlife * precision1;
          cf = Math.floor(c);
          cc = Math.ceil(c);
          c %= 1;
          a = this.qRotSpeed[cf];
          b = this.qRotSpeed[cc];
          rotSpeed = a + (b - a) * c;
          a = this.qRotSpeed2[cf];
          b = this.qRotSpeed2[cc];
          rotSpeed2 = a + (b - a) * c;
          a = this.qScale[cf];
          b = this.qScale[cc];
          scale = a + (b - a) * c;
          a = this.qScale2[cf];
          b = this.qScale2[cc];
          scale2 = a + (b - a) * c;
          a = this.qAlpha[cf];
          b = this.qAlpha[cc];
          alpha = a + (b - a) * c;
          a = this.qAlpha2[cf];
          b = this.qAlpha2[cc];
          alpha2 = a + (b - a) * c;
          cf *= 3;
          cc *= 3;
          a = this.qLocalVelocity[cf];
          b = this.qLocalVelocity[cc];
          localVelocityVec.data[0] = a + (b - a) * c;
          a = this.qLocalVelocity[cf + 1];
          b = this.qLocalVelocity[cc + 1];
          localVelocityVec.data[1] = a + (b - a) * c;
          a = this.qLocalVelocity[cf + 2];
          b = this.qLocalVelocity[cc + 2];
          localVelocityVec.data[2] = a + (b - a) * c;
          a = this.qLocalVelocity2[cf];
          b = this.qLocalVelocity2[cc];
          localVelocityVec2.data[0] = a + (b - a) * c;
          a = this.qLocalVelocity2[cf + 1];
          b = this.qLocalVelocity2[cc + 1];
          localVelocityVec2.data[1] = a + (b - a) * c;
          a = this.qLocalVelocity2[cf + 2];
          b = this.qLocalVelocity2[cc + 2];
          localVelocityVec2.data[2] = a + (b - a) * c;
          a = this.qVelocity[cf];
          b = this.qVelocity[cc];
          velocityVec.data[0] = a + (b - a) * c;
          a = this.qVelocity[cf + 1];
          b = this.qVelocity[cc + 1];
          velocityVec.data[1] = a + (b - a) * c;
          a = this.qVelocity[cf + 2];
          b = this.qVelocity[cc + 2];
          velocityVec.data[2] = a + (b - a) * c;
          a = this.qVelocity2[cf];
          b = this.qVelocity2[cc];
          velocityVec2.data[0] = a + (b - a) * c;
          a = this.qVelocity2[cf + 1];
          b = this.qVelocity2[cc + 1];
          velocityVec2.data[1] = a + (b - a) * c;
          a = this.qVelocity2[cf + 2];
          b = this.qVelocity2[cc + 2];
          velocityVec2.data[2] = a + (b - a) * c;
          localVelocityVec.data[0] += (localVelocityVec2.data[0] - localVelocityVec.data[0]) * rndFactor3Vec.data[0];
          localVelocityVec.data[1] += (localVelocityVec2.data[1] - localVelocityVec.data[1]) * rndFactor3Vec.data[1];
          localVelocityVec.data[2] += (localVelocityVec2.data[2] - localVelocityVec.data[2]) * rndFactor3Vec.data[2];
          if (this.initialVelocity > 0) {
            if (this.emitterShape === pc.EMITTERSHAPE_SPHERE) {
              randomPos.copy(rndFactor3Vec).scale(2).sub(pc.Vec3.ONE).normalize();
              localVelocityVec.add(randomPos.scale(this.initialVelocity));
            } else {
              localVelocityVec.add(pc.Vec3.FORWARD.scale(this.initialVelocity));
            }
          }
          velocityVec.data[0] += (velocityVec2.data[0] - velocityVec.data[0]) * rndFactor3Vec.data[0];
          velocityVec.data[1] += (velocityVec2.data[1] - velocityVec.data[1]) * rndFactor3Vec.data[1];
          velocityVec.data[2] += (velocityVec2.data[2] - velocityVec.data[2]) * rndFactor3Vec.data[2];
          rotSpeed += (rotSpeed2 - rotSpeed) * rndFactor3Vec.data[1];
          scale = (scale + (scale2 - scale) * (rndFactor * 10000.0 % 1.0)) * uniformScale;
          alphaDiv = (alpha2 - alpha) * (rndFactor * 1000.0 % 1.0);
          if (this.meshInstance.node) {
            rotMat.transformPoint(localVelocityVec, localVelocityVec);
          }
          localVelocityVec.add(velocityVec.mul(nonUniformScale));
          moveDirVec.copy(localVelocityVec);
          particlePosPrev.data[0] = this.particleTex[id * particleTexChannels];
          particlePosPrev.data[1] = this.particleTex[id * particleTexChannels + 1];
          particlePosPrev.data[2] = this.particleTex[id * particleTexChannels + 2];
          particlePos.copy(particlePosPrev).add(localVelocityVec.scale(delta));
          particleFinalPos.copy(particlePos);
          this.particleTex[id * particleTexChannels] = particleFinalPos.data[0];
          this.particleTex[id * particleTexChannels + 1] = particleFinalPos.data[1];
          this.particleTex[id * particleTexChannels + 2] = particleFinalPos.data[2];
          this.particleTex[id * particleTexChannels + 3] += rotSpeed * delta;
          if (this.wrap && this.wrapBounds) {
            particleFinalPos.sub(emitterPos);
            particleFinalPos.data[0] = glMod(particleFinalPos.data[0], this.wrapBounds.data[0]) - this.wrapBounds.data[0] * 0.5;
            particleFinalPos.data[1] = glMod(particleFinalPos.data[1], this.wrapBounds.data[1]) - this.wrapBounds.data[1] * 0.5;
            particleFinalPos.data[2] = glMod(particleFinalPos.data[2], this.wrapBounds.data[2]) - this.wrapBounds.data[2] * 0.5;
            particleFinalPos.add(emitterPos);
          }
          if (this.sort > 0) {
            if (this.sort === 1) {
              tmpVec3.copy(particleFinalPos).sub(posCam);
              this.particleDistance[id] = -(tmpVec3.data[0] * tmpVec3.data[0] + tmpVec3.data[1] * tmpVec3.data[1] + tmpVec3.data[2] * tmpVec3.data[2]);
            } else {
              if (this.sort === 2) {
                this.particleDistance[id] = life;
              } else {
                if (this.sort === 3) {
                  this.particleDistance[id] = -life;
                }
              }
            }
          }
        } else {
          this.calcSpawnPosition(emitterPos, id);
        }
        if (isOnStop) {
          if (life < 0) {
            this.particleTex[id * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = -1;
          }
        } else {
          if (life >= particleLifetime) {
            life -= Math.max(particleLifetime, (this.numParticles - 1) * particleRate);
            this.particleTex[id * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = this.loop ? 1 : -1;
          }
          if (life < 0 && this.loop) {
            this.particleTex[id * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = 1;
          }
        }
        if (this.particleTex[id * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] < 0) {
          particleEnabled = false;
        }
        this.particleTex[id * particleTexChannels + 3 + this.numParticlesPot * particleTexChannels] = life;
        for (var v = 0;v < this.numParticleVerts;v++) {
          var quadX = this.vbCPU[i * this.numParticleVerts * 4 + v * 4];
          var quadY = this.vbCPU[i * this.numParticleVerts * 4 + v * 4 + 1];
          var quadZ = this.vbCPU[i * this.numParticleVerts * 4 + v * 4 + 2];
          if (!particleEnabled) {
            quadX = quadY = quadZ = 0;
          }
          var w = i * this.numParticleVerts * vertSize + v * vertSize;
          data[w] = particleFinalPos.data[0];
          data[w + 1] = particleFinalPos.data[1];
          data[w + 2] = particleFinalPos.data[2];
          data[w + 3] = nlife;
          data[w + 4] = this.alignToMotion ? angle : this.particleTex[id * particleTexChannels + 3];
          data[w + 5] = scale;
          data[w + 6] = alphaDiv;
          data[w + 7] = moveDirVec.data[0];
          data[w + 8] = quadX;
          data[w + 9] = quadY;
          data[w + 10] = quadZ;
          data[w + 11] = moveDirVec.data[1];
          data[w + 12] = moveDirVec.data[2];
        }
      }
      if (this.sort > pc.PARTICLESORT_NONE && this.camera) {
        var particleDistance = this.particleDistance;
        for (i = 0;i < this.numParticles;i++) {
          this.vbToSort[i] = [i, particleDistance[Math.floor(this.vbCPU[i * this.numParticleVerts * 4 + 3])]];
        }
        this.vbOld.set(this.vbCPU);
        this.vbToSort.sort(function(p1, p2) {
          return p1[1] - p2[1];
        });
        for (i = 0;i < this.numParticles;i++) {
          var src = this.vbToSort[i][0] * this.numParticleVerts * 4;
          var dest = i * this.numParticleVerts * 4;
          for (j = 0;j < this.numParticleVerts * 4;j++) {
            this.vbCPU[dest + j] = this.vbOld[src + j];
          }
        }
      }
    }
    if (!this.loop) {
      if (Date.now() > this.endTime) {
        if (this.onFinished) {
          this.onFinished();
        }
        this.meshInstance.visible = false;
      }
    }
  }, destroy:function() {
    if (this.particleTexIN) {
      this.particleTexIN.destroy();
    }
    if (this.particleTexOUT) {
      this.particleTexOUT.destroy();
    }
    if (!this.useCpu && this.particleTexStart) {
      this.particleTexStart.destroy();
    }
    if (this.rtParticleTexIN) {
      this.rtParticleTexIN.destroy();
    }
    if (this.rtParticleTexOUT) {
      this.rtParticleTexOUT.destroy();
    }
    this.particleTexIN = null;
    this.particleTexOUT = null;
    this.particleTexStart = null;
    this.rtParticleTexIN = null;
    this.rtParticleTexOUT = null;
    this.shaderParticleUpdateRespawn = null;
    this.shaderParticleUpdateNoRespawn = null;
    this.shaderParticleUpdateOnStop = null;
  }});
  return {ParticleEmitter:ParticleEmitter};
}());
Object.assign(pc, function() {
  var _deviceDeprecationWarning = false;
  var _getSelectionDeprecationWarning = false;
  var _prepareDeprecationWarning = false;
  var Picker = function(app, width, height) {
    if (app instanceof pc.GraphicsDevice) {
      app = pc.Application.getApplication();
      if (!_deviceDeprecationWarning) {
        _deviceDeprecationWarning = true;
      }
    }
    this.app = app;
    this.device = app.graphicsDevice;
    var device = this.device;
    this.library = device.getProgramLibrary();
    this.pickColor = new Float32Array(4);
    this.pickColor[3] = 1;
    this.scene = null;
    this.drawCalls = [];
    this.layer = null;
    this.layerComp = null;
    this.clearOptions = {color:[1, 1, 1, 1], depth:1, flags:pc.CLEARFLAG_COLOR | pc.CLEARFLAG_DEPTH};
    var self = this;
    this._clearDepthOptions = {depth:1.0, flags:pc.CLEARFLAG_DEPTH};
    this.clearDepthCommand = new pc.Command(0, 0, function() {
      device.clear(self._clearDepthOptions);
    });
    this.resize(width, height);
    this._ignoreOpacityFor = null;
  };
  Picker.prototype.getSelection = function(x, y, width, height) {
    var device = this.device;
    if (typeof x === "object") {
      var rect = x;
      x = rect.x;
      y = rect.y;
      width = rect.width;
      height = rect.height;
    } else {
      y = this.layer.renderTarget.height - (y + (height || 1));
    }
    width = width || 1;
    height = height || 1;
    var prevRenderTarget = device.renderTarget;
    device.setRenderTarget(this.layer.renderTarget);
    device.updateBegin();
    var pixels = new Uint8Array(4 * width * height);
    device.readPixels(x, y, width, height, pixels);
    device.updateEnd();
    device.setRenderTarget(prevRenderTarget);
    var selection = [];
    var drawCalls = this.layer.instances.visibleOpaque[0].list;
    var r, g, b, index;
    for (var i = 0;i < width * height;i++) {
      r = pixels[4 * i + 0];
      g = pixels[4 * i + 1];
      b = pixels[4 * i + 2];
      index = r << 16 | g << 8 | b;
      if (index !== 16777215) {
        var selectedMeshInstance = drawCalls[index];
        if (selection.indexOf(selectedMeshInstance) === -1) {
          selection.push(selectedMeshInstance);
        }
      }
    }
    return selection;
  };
  Picker.prototype.prepare = function(camera, scene, arg) {
    var device = this.device;
    var i, j;
    var self = this;
    if (camera instanceof pc.Camera) {
      camera = camera._component;
    }
    this.scene = scene;
    var sourceLayer = null;
    var sourceRt = null;
    if (arg instanceof pc.Layer) {
      sourceLayer = arg;
    } else {
      sourceRt = arg;
    }
    if (!this.layer) {
      var pickColorId = device.scope.resolve("uColor");
      this.layer = new pc.Layer({name:"Picker", shaderPass:pc.SHADER_PICK, opaqueSortMode:pc.SORTMODE_NONE, onEnable:function() {
        if (this.renderTarget) {
          return;
        }
        var colorBuffer = new pc.Texture(device, {format:pc.PIXELFORMAT_R8_G8_B8_A8, width:self.width, height:self.height});
        colorBuffer.minFilter = pc.FILTER_NEAREST;
        colorBuffer.magFilter = pc.FILTER_NEAREST;
        colorBuffer.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
        colorBuffer.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
        this.renderTarget = new pc.RenderTarget(device, colorBuffer, {depth:true});
      }, onDisable:function() {
        if (!this.renderTarget) {
          return;
        }
        this.renderTarget._colorBuffer.destroy();
        this.renderTarget.destroy();
        this.renderTarget = null;
      }, onDrawCall:function(meshInstance, index) {
        self.pickColor[0] = (index >> 16 & 255) / 255;
        self.pickColor[1] = (index >> 8 & 255) / 255;
        self.pickColor[2] = (index & 255) / 255;
        pickColorId.setValue(self.pickColor);
        device.setBlending(false);
      }, onPreCull:function() {
        this.oldAspectMode = this.cameras[0].aspectRatioMode;
        this.oldAspect = this.cameras[0].aspectRatio;
        this.cameras[0].aspectRatioMode = pc.ASPECT_MANUAL;
        var rt = sourceRt ? sourceRt : sourceLayer ? sourceLayer.renderTarget : null;
        this.cameras[0].aspectRatio = this.cameras[0].calculateAspectRatio(rt);
        self.app.renderer.updateCameraFrustum(this.cameras[0].camera);
      }, onPostCull:function() {
        this.cameras[0].aspectRatioMode = this.oldAspectMode;
        this.cameras[0].aspectRatio = this.oldAspect;
      }});
      this.layerComp = new pc.LayerComposition;
      this.layerComp.pushOpaque(this.layer);
      this.meshInstances = this.layer.opaqueMeshInstances;
      this._instancesVersion = -1;
    }
    var instanceList, instanceListLength, drawCall;
    if (!sourceLayer) {
      this.layer.clearMeshInstances();
      var layers = scene.layers.layerList;
      var subLayerEnabled = scene.layers.subLayerEnabled;
      var isTransparent = scene.layers.subLayerList;
      var layer;
      var layerCamId, transparent;
      for (i = 0;i < layers.length;i++) {
        if (layers[i].overrideClear && layers[i]._clearDepthBuffer) {
          layers[i]._pickerCleared = false;
        }
      }
      for (i = 0;i < layers.length;i++) {
        layer = layers[i];
        if (layer.renderTarget !== sourceRt || !layer.enabled || !subLayerEnabled[i]) {
          continue;
        }
        layerCamId = layer.cameras.indexOf(camera);
        if (layerCamId < 0) {
          continue;
        }
        if (layer.overrideClear && layer._clearDepthBuffer && !layer._pickerCleared) {
          this.meshInstances.push(this.clearDepthCommand);
          layer._pickerCleared = true;
        }
        transparent = isTransparent[i];
        instanceList = transparent ? layer.instances.transparentMeshInstances : layer.instances.opaqueMeshInstances;
        instanceListLength = instanceList.length;
        for (j = 0;j < instanceListLength;j++) {
          drawCall = instanceList[j];
          if (drawCall.pick) {
            this.meshInstances.push(drawCall);
          }
        }
      }
    } else {
      if (this._instancesVersion !== sourceLayer._version) {
        this.layer.clearMeshInstances();
        instanceList = sourceLayer.instances.opaqueMeshInstances;
        instanceListLength = instanceList.length;
        for (j = 0;j < instanceListLength;j++) {
          drawCall = instanceList[j];
          if (drawCall.pick) {
            this.meshInstances.push(drawCall);
          }
        }
        instanceList = sourceLayer.instances.transparentMeshInstances;
        instanceListLength = instanceList.length;
        for (j = 0;j < instanceListLength;j++) {
          drawCall = instanceList[j];
          if (drawCall.pick) {
            this.meshInstances.push(drawCall);
          }
        }
        this._instancesVersion = sourceLayer._version;
      }
    }
    if (this.layer.cameras[0] !== camera) {
      this.layer.clearCameras();
      this.layer.addCamera(camera);
    }
    this.onLayerPreRender(this.layer, sourceLayer, sourceRt);
    this.app.renderer.renderComposition(this.layerComp);
    this.onLayerPostRender(this.layer);
  };
  Picker.prototype.onLayerPreRender = function(layer, sourceLayer, sourceRt) {
    if (this.width !== layer.renderTarget.width || this.height !== layer.renderTarget.height) {
      layer.onDisable();
      layer.onEnable();
    }
    layer.oldClear = layer.cameras[0].camera._clearOptions;
    layer.oldAspectMode = layer.cameras[0].aspectRatioMode;
    layer.oldAspect = layer.cameras[0].aspectRatio;
    layer.cameras[0].camera._clearOptions = this.clearOptions;
    layer.cameras[0].aspectRatioMode = pc.ASPECT_MANUAL;
    var rt = sourceRt ? sourceRt : sourceLayer ? sourceLayer.renderTarget : null;
    layer.cameras[0].aspectRatio = layer.cameras[0].calculateAspectRatio(rt);
  };
  Picker.prototype.onLayerPostRender = function(layer) {
    layer.cameras[0].camera._clearOptions = layer.oldClear;
    layer.cameras[0].aspectRatioMode = layer.oldAspectMode;
    layer.cameras[0].aspectRatio = layer.oldAspect;
  };
  Picker.prototype.resize = function(width, height) {
    this.width = width;
    this.height = height;
  };
  Object.defineProperty(Picker.prototype, "renderTarget", {get:function() {
    return this.layer.renderTarget;
  }});
  return {Picker:Picker};
}());
var primitiveUv1Padding = 4.0 / 64;
var primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;
pc.calculateNormals = function(positions, indices) {
  var triangleCount = indices.length / 3;
  var vertexCount = positions.length / 3;
  var i1, i2, i3;
  var i;
  var p1 = new pc.Vec3;
  var p2 = new pc.Vec3;
  var p3 = new pc.Vec3;
  var p1p2 = new pc.Vec3;
  var p1p3 = new pc.Vec3;
  var faceNormal = new pc.Vec3;
  var normals = [];
  for (i = 0;i < positions.length;i++) {
    normals[i] = 0;
  }
  for (i = 0;i < triangleCount;i++) {
    i1 = indices[i * 3];
    i2 = indices[i * 3 + 1];
    i3 = indices[i * 3 + 2];
    p1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
    p2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
    p3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
    p1p2.sub2(p2, p1);
    p1p3.sub2(p3, p1);
    faceNormal.cross(p1p2, p1p3).normalize();
    normals[i1 * 3] += faceNormal.x;
    normals[i1 * 3 + 1] += faceNormal.y;
    normals[i1 * 3 + 2] += faceNormal.z;
    normals[i2 * 3] += faceNormal.x;
    normals[i2 * 3 + 1] += faceNormal.y;
    normals[i2 * 3 + 2] += faceNormal.z;
    normals[i3 * 3] += faceNormal.x;
    normals[i3 * 3 + 1] += faceNormal.y;
    normals[i3 * 3 + 2] += faceNormal.z;
  }
  for (i = 0;i < vertexCount;i++) {
    var nx = normals[i * 3];
    var ny = normals[i * 3 + 1];
    var nz = normals[i * 3 + 2];
    var invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
    normals[i * 3] *= invLen;
    normals[i * 3 + 1] *= invLen;
    normals[i * 3 + 2] *= invLen;
  }
  return normals;
};
pc.calculateTangents = function(positions, normals, uvs, indices) {
  var triangleCount = indices.length / 3;
  var vertexCount = positions.length / 3;
  var i1, i2, i3;
  var x1, x2, y1, y2, z1, z2, s1, s2, t1, t2, r;
  var sdir = new pc.Vec3;
  var tdir = new pc.Vec3;
  var v1 = new pc.Vec3;
  var v2 = new pc.Vec3;
  var v3 = new pc.Vec3;
  var w1 = new pc.Vec2;
  var w2 = new pc.Vec2;
  var w3 = new pc.Vec2;
  var i;
  var tan1 = new Float32Array(vertexCount * 3);
  var tan2 = new Float32Array(vertexCount * 3);
  var tangents = [];
  var area = 0.0;
  for (i = 0;i < triangleCount;i++) {
    i1 = indices[i * 3];
    i2 = indices[i * 3 + 1];
    i3 = indices[i * 3 + 2];
    v1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
    v2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
    v3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
    w1.set(uvs[i1 * 2], uvs[i1 * 2 + 1]);
    w2.set(uvs[i2 * 2], uvs[i2 * 2 + 1]);
    w3.set(uvs[i3 * 2], uvs[i3 * 2 + 1]);
    x1 = v2.x - v1.x;
    x2 = v3.x - v1.x;
    y1 = v2.y - v1.y;
    y2 = v3.y - v1.y;
    z1 = v2.z - v1.z;
    z2 = v3.z - v1.z;
    s1 = w2.x - w1.x;
    s2 = w3.x - w1.x;
    t1 = w2.y - w1.y;
    t2 = w3.y - w1.y;
    area = s1 * t2 - s2 * t1;
    if (area == 0.0) {
      sdir.set(0.0, 1.0, 0.0);
      tdir.set(1.0, 0.0, 0.0);
    } else {
      r = 1.0 / area;
      sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
      tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
    }
    tan1[i1 * 3 + 0] += sdir.x;
    tan1[i1 * 3 + 1] += sdir.y;
    tan1[i1 * 3 + 2] += sdir.z;
    tan1[i2 * 3 + 0] += sdir.x;
    tan1[i2 * 3 + 1] += sdir.y;
    tan1[i2 * 3 + 2] += sdir.z;
    tan1[i3 * 3 + 0] += sdir.x;
    tan1[i3 * 3 + 1] += sdir.y;
    tan1[i3 * 3 + 2] += sdir.z;
    tan2[i1 * 3 + 0] += tdir.x;
    tan2[i1 * 3 + 1] += tdir.y;
    tan2[i1 * 3 + 2] += tdir.z;
    tan2[i2 * 3 + 0] += tdir.x;
    tan2[i2 * 3 + 1] += tdir.y;
    tan2[i2 * 3 + 2] += tdir.z;
    tan2[i3 * 3 + 0] += tdir.x;
    tan2[i3 * 3 + 1] += tdir.y;
    tan2[i3 * 3 + 2] += tdir.z;
  }
  t1 = new pc.Vec3;
  t2 = new pc.Vec3;
  var n = new pc.Vec3;
  var temp = new pc.Vec3;
  for (i = 0;i < vertexCount;i++) {
    n.set(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);
    t1.set(tan1[i * 3], tan1[i * 3 + 1], tan1[i * 3 + 2]);
    t2.set(tan2[i * 3], tan2[i * 3 + 1], tan2[i * 3 + 2]);
    var ndott = n.dot(t1);
    temp.copy(n).scale(ndott);
    temp.sub2(t1, temp).normalize();
    tangents[i * 4] = temp.x;
    tangents[i * 4 + 1] = temp.y;
    tangents[i * 4 + 2] = temp.z;
    temp.cross(n, t1);
    tangents[i * 4 + 3] = temp.dot(t2) < 0.0 ? -1.0 : 1.0;
  }
  return tangents;
};
pc.createMesh = function(device, positions, opts) {
  var normals = opts && opts.normals !== undefined ? opts.normals : null;
  var tangents = opts && opts.tangents !== undefined ? opts.tangents : null;
  var colors = opts && opts.colors !== undefined ? opts.colors : null;
  var uvs = opts && opts.uvs !== undefined ? opts.uvs : null;
  var uvs1 = opts && opts.uvs1 !== undefined ? opts.uvs1 : null;
  var indices = opts && opts.indices !== undefined ? opts.indices : null;
  var blendIndices = opts && opts.blendIndices !== undefined ? opts.blendIndices : null;
  var blendWeights = opts && opts.blendWeights !== undefined ? opts.blendWeights : null;
  var vertexDesc = [{semantic:pc.SEMANTIC_POSITION, components:3, type:pc.TYPE_FLOAT32}];
  if (normals !== null) {
    vertexDesc.push({semantic:pc.SEMANTIC_NORMAL, components:3, type:pc.TYPE_FLOAT32});
  }
  if (tangents !== null) {
    vertexDesc.push({semantic:pc.SEMANTIC_TANGENT, components:4, type:pc.TYPE_FLOAT32});
  }
  if (colors !== null) {
    vertexDesc.push({semantic:pc.SEMANTIC_COLOR, components:4, type:pc.TYPE_UINT8, normalize:true});
  }
  if (uvs !== null) {
    vertexDesc.push({semantic:pc.SEMANTIC_TEXCOORD0, components:2, type:pc.TYPE_FLOAT32});
  }
  if (uvs1 !== null) {
    vertexDesc.push({semantic:pc.SEMANTIC_TEXCOORD1, components:2, type:pc.TYPE_FLOAT32});
  }
  if (blendIndices !== null) {
    vertexDesc.push({semantic:pc.SEMANTIC_BLENDINDICES, components:2, type:pc.TYPE_UINT8});
  }
  if (blendWeights !== null) {
    vertexDesc.push({semantic:pc.SEMANTIC_BLENDWEIGHT, components:2, type:pc.TYPE_FLOAT32});
  }
  var vertexFormat = new pc.VertexFormat(device, vertexDesc);
  var numVertices = positions.length / 3;
  var vertexBuffer = new pc.VertexBuffer(device, vertexFormat, numVertices);
  var iterator = new pc.VertexIterator(vertexBuffer);
  for (var i = 0;i < numVertices;i++) {
    iterator.element[pc.SEMANTIC_POSITION].set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
    if (normals !== null) {
      iterator.element[pc.SEMANTIC_NORMAL].set(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);
    }
    if (tangents !== null) {
      iterator.element[pc.SEMANTIC_TANGENT].set(tangents[i * 4], tangents[i * 4 + 1], tangents[i * 4 + 2], tangents[i * 4 + 3]);
    }
    if (colors !== null) {
      iterator.element[pc.SEMANTIC_COLOR].set(colors[i * 4], colors[i * 4 + 1], colors[i * 4 + 2], colors[i * 4 + 3]);
    }
    if (uvs !== null) {
      iterator.element[pc.SEMANTIC_TEXCOORD0].set(uvs[i * 2], uvs[i * 2 + 1]);
    }
    if (uvs1 !== null) {
      iterator.element[pc.SEMANTIC_TEXCOORD1].set(uvs1[i * 2], uvs1[i * 2 + 1]);
    }
    if (blendIndices !== null) {
      iterator.element[pc.SEMANTIC_BLENDINDICES].set(blendIndices[i * 2], blendIndices[i * 2 + 1]);
    }
    if (blendWeights !== null) {
      iterator.element[pc.SEMANTIC_BLENDWEIGHT].set(blendWeights[i * 2], blendWeights[i * 2 + 1]);
    }
    iterator.next();
  }
  iterator.end();
  var indexBuffer = null;
  var indexed = indices !== null;
  if (indexed) {
    indexBuffer = new pc.IndexBuffer(device, pc.INDEXFORMAT_UINT16, indices.length);
    var dst = new Uint16Array(indexBuffer.lock());
    dst.set(indices);
    indexBuffer.unlock();
  }
  var aabb = new pc.BoundingBox;
  aabb.compute(positions);
  var mesh = new pc.Mesh;
  mesh.vertexBuffer = vertexBuffer;
  mesh.indexBuffer[0] = indexBuffer;
  mesh.primitive[0].type = pc.PRIMITIVE_TRIANGLES;
  mesh.primitive[0].base = 0;
  mesh.primitive[0].count = indexed ? indices.length : numVertices;
  mesh.primitive[0].indexed = indexed;
  mesh.aabb = aabb;
  return mesh;
};
pc.createTorus = function(device, opts) {
  var rc = opts && opts.tubeRadius !== undefined ? opts.tubeRadius : 0.2;
  var rt = opts && opts.ringRadius !== undefined ? opts.ringRadius : 0.3;
  var segments = opts && opts.segments !== undefined ? opts.segments : 30;
  var sides = opts && opts.sides !== undefined ? opts.sides : 20;
  var i, j;
  var x, y, z, nx, ny, nz, u, v;
  var positions = [];
  var normals = [];
  var uvs = [];
  var indices = [];
  for (i = 0;i <= sides;i++) {
    for (j = 0;j <= segments;j++) {
      x = Math.cos(2.0 * Math.PI * j / segments) * (rt + rc * Math.cos(2.0 * Math.PI * i / sides));
      y = Math.sin(2.0 * Math.PI * i / sides) * rc;
      z = Math.sin(2.0 * Math.PI * j / segments) * (rt + rc * Math.cos(2.0 * Math.PI * i / sides));
      nx = Math.cos(2.0 * Math.PI * j / segments) * Math.cos(2.0 * Math.PI * i / sides);
      ny = Math.sin(2.0 * Math.PI * i / sides);
      nz = Math.sin(2.0 * Math.PI * j / segments) * Math.cos(2.0 * Math.PI * i / sides);
      u = i / sides;
      v = 1.0 - j / segments;
      positions.push(x, y, z);
      normals.push(nx, ny, nz);
      uvs.push(u, v);
      if (i < sides && j < segments) {
        var first, second, third, fourth;
        first = i * (segments + 1) + j;
        second = (i + 1) * (segments + 1) + j;
        third = i * (segments + 1) + (j + 1);
        fourth = (i + 1) * (segments + 1) + (j + 1);
        indices.push(first, second, third);
        indices.push(second, fourth, third);
      }
    }
  }
  var options = {normals:normals, uvs:uvs, indices:indices};
  if (pc.precalculatedTangents) {
    options.tangents = pc.calculateTangents(positions, normals, uvs, indices);
  }
  return pc.createMesh(device, positions, options);
};
pc._createConeData = function(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps) {
  var i, j;
  var x, y, z, u, v;
  var pos = new pc.Vec3;
  var bottomToTop = new pc.Vec3;
  var norm = new pc.Vec3;
  var top, bottom, tangent;
  var positions = [];
  var normals = [];
  var uvs = [];
  var uvs1 = [];
  var indices = [];
  var theta, cosTheta, sinTheta;
  var phi, sinPhi, cosPhi;
  var first, second, third, fourth;
  var offset;
  if (height > 0) {
    for (i = 0;i <= heightSegments;i++) {
      for (j = 0;j <= capSegments;j++) {
        theta = j / capSegments * 2.0 * Math.PI - Math.PI;
        sinTheta = Math.sin(theta);
        cosTheta = Math.cos(theta);
        bottom = new pc.Vec3(sinTheta * baseRadius, -height / 2.0, cosTheta * baseRadius);
        top = new pc.Vec3(sinTheta * peakRadius, height / 2.0, cosTheta * peakRadius);
        pos.lerp(bottom, top, i / heightSegments);
        bottomToTop.sub2(top, bottom).normalize();
        tangent = new pc.Vec3(cosTheta, 0.0, -sinTheta);
        norm.cross(tangent, bottomToTop).normalize();
        positions.push(pos.x, pos.y, pos.z);
        normals.push(norm.x, norm.y, norm.z);
        u = j / capSegments;
        v = i / heightSegments;
        uvs.push(u, v);
        var _v = v;
        v = u;
        u = _v;
        u /= 3;
        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
        uvs1.push(u, v);
        if (i < heightSegments && j < capSegments) {
          first = i * (capSegments + 1) + j;
          second = i * (capSegments + 1) + (j + 1);
          third = (i + 1) * (capSegments + 1) + j;
          fourth = (i + 1) * (capSegments + 1) + (j + 1);
          indices.push(first, second, third);
          indices.push(second, fourth, third);
        }
      }
    }
  }
  if (roundedCaps) {
    var lat, lon;
    var latitudeBands = Math.floor(capSegments / 2);
    var longitudeBands = capSegments;
    var capOffset = height / 2;
    for (lat = 0;lat <= latitudeBands;lat++) {
      theta = lat * Math.PI * 0.5 / latitudeBands;
      sinTheta = Math.sin(theta);
      cosTheta = Math.cos(theta);
      for (lon = 0;lon <= longitudeBands;lon++) {
        phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2.0;
        sinPhi = Math.sin(phi);
        cosPhi = Math.cos(phi);
        x = cosPhi * sinTheta;
        y = cosTheta;
        z = sinPhi * sinTheta;
        u = 1.0 - lon / longitudeBands;
        v = 1.0 - lat / latitudeBands;
        positions.push(x * peakRadius, y * peakRadius + capOffset, z * peakRadius);
        normals.push(x, y, z);
        uvs.push(u, v);
        u /= 3;
        v /= 3;
        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
        u += 1.0 / 3;
        uvs1.push(u, v);
      }
    }
    offset = (heightSegments + 1) * (capSegments + 1);
    for (lat = 0;lat < latitudeBands;++lat) {
      for (lon = 0;lon < longitudeBands;++lon) {
        first = lat * (longitudeBands + 1) + lon;
        second = first + longitudeBands + 1;
        indices.push(offset + first + 1, offset + second, offset + first);
        indices.push(offset + first + 1, offset + second + 1, offset + second);
      }
    }
    for (lat = 0;lat <= latitudeBands;lat++) {
      theta = Math.PI * 0.5 + lat * Math.PI * 0.5 / latitudeBands;
      sinTheta = Math.sin(theta);
      cosTheta = Math.cos(theta);
      for (lon = 0;lon <= longitudeBands;lon++) {
        phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2.0;
        sinPhi = Math.sin(phi);
        cosPhi = Math.cos(phi);
        x = cosPhi * sinTheta;
        y = cosTheta;
        z = sinPhi * sinTheta;
        u = 1.0 - lon / longitudeBands;
        v = 1.0 - lat / latitudeBands;
        positions.push(x * peakRadius, y * peakRadius - capOffset, z * peakRadius);
        normals.push(x, y, z);
        uvs.push(u, v);
        u /= 3;
        v /= 3;
        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
        u += 2.0 / 3;
        uvs1.push(u, v);
      }
    }
    offset = (heightSegments + 1) * (capSegments + 1) + (longitudeBands + 1) * (latitudeBands + 1);
    for (lat = 0;lat < latitudeBands;++lat) {
      for (lon = 0;lon < longitudeBands;++lon) {
        first = lat * (longitudeBands + 1) + lon;
        second = first + longitudeBands + 1;
        indices.push(offset + first + 1, offset + second, offset + first);
        indices.push(offset + first + 1, offset + second + 1, offset + second);
      }
    }
  } else {
    offset = (heightSegments + 1) * (capSegments + 1);
    if (baseRadius > 0.0) {
      for (i = 0;i < capSegments;i++) {
        theta = i / capSegments * 2.0 * Math.PI;
        x = Math.sin(theta);
        y = -height / 2.0;
        z = Math.cos(theta);
        u = 1.0 - (x + 1.0) / 2.0;
        v = (z + 1.0) / 2.0;
        positions.push(x * baseRadius, y, z * baseRadius);
        normals.push(0.0, -1.0, 0.0);
        uvs.push(u, v);
        u /= 3;
        v /= 3;
        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
        u += 1.0 / 3;
        uvs1.push(u, v);
        if (i > 1) {
          indices.push(offset, offset + i, offset + i - 1);
        }
      }
    }
    offset += capSegments;
    if (peakRadius > 0.0) {
      for (i = 0;i < capSegments;i++) {
        theta = i / capSegments * 2.0 * Math.PI;
        x = Math.sin(theta);
        y = height / 2.0;
        z = Math.cos(theta);
        u = 1.0 - (x + 1.0) / 2.0;
        v = (z + 1.0) / 2.0;
        positions.push(x * peakRadius, y, z * peakRadius);
        normals.push(0.0, 1.0, 0.0);
        uvs.push(u, v);
        u /= 3;
        v /= 3;
        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
        u += 2.0 / 3;
        uvs1.push(u, v);
        if (i > 1) {
          indices.push(offset, offset + i - 1, offset + i);
        }
      }
    }
  }
  return {positions:positions, normals:normals, uvs:uvs, uvs1:uvs1, indices:indices};
};
pc.createCylinder = function(device, opts) {
  var radius = opts && (opts.radius || opts.baseRadius);
  radius = radius !== undefined ? radius : 0.5;
  var height = opts && opts.height !== undefined ? opts.height : 1.0;
  var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;
  var capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 20;
  var options = pc._createConeData(radius, radius, height, heightSegments, capSegments, false);
  if (pc.precalculatedTangents) {
    options.tangents = pc.calculateTangents(options.positions, options.normals, options.uvs, options.indices);
  }
  return pc.createMesh(device, options.positions, options);
};
pc.createCapsule = function(device, opts) {
  var radius = opts && opts.radius !== undefined ? opts.radius : 0.3;
  var height = opts && opts.height !== undefined ? opts.height : 1.0;
  var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;
  var sides = opts && opts.sides !== undefined ? opts.sides : 20;
  var options = pc._createConeData(radius, radius, height - 2 * radius, heightSegments, sides, true);
  if (pc.precalculatedTangents) {
    options.tangents = pc.calculateTangents(options.positions, options.normals, options.uvs, options.indices);
  }
  return pc.createMesh(device, options.positions, options);
};
pc.createCone = function(device, opts) {
  var baseRadius = opts && opts.baseRadius !== undefined ? opts.baseRadius : 0.5;
  var peakRadius = opts && opts.peakRadius !== undefined ? opts.peakRadius : 0.0;
  var height = opts && opts.height !== undefined ? opts.height : 1.0;
  var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;
  var capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 18;
  var options = pc._createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, false);
  if (pc.precalculatedTangents) {
    options.tangents = pc.calculateTangents(options.positions, options.normals, options.uvs, options.indices);
  }
  return pc.createMesh(device, options.positions, options);
};
pc.createSphere = function(device, opts) {
  var radius = opts && opts.radius !== undefined ? opts.radius : 0.5;
  var latitudeBands = opts && opts.latitudeBands !== undefined ? opts.latitudeBands : 16;
  var longitudeBands = opts && opts.longitudeBands !== undefined ? opts.longitudeBands : 16;
  var lon, lat;
  var theta, sinTheta, cosTheta, phi, sinPhi, cosPhi;
  var first, second;
  var x, y, z, u, v;
  var positions = [];
  var normals = [];
  var uvs = [];
  var indices = [];
  for (lat = 0;lat <= latitudeBands;lat++) {
    theta = lat * Math.PI / latitudeBands;
    sinTheta = Math.sin(theta);
    cosTheta = Math.cos(theta);
    for (lon = 0;lon <= longitudeBands;lon++) {
      phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2.0;
      sinPhi = Math.sin(phi);
      cosPhi = Math.cos(phi);
      x = cosPhi * sinTheta;
      y = cosTheta;
      z = sinPhi * sinTheta;
      u = 1.0 - lon / longitudeBands;
      v = 1.0 - lat / latitudeBands;
      positions.push(x * radius, y * radius, z * radius);
      normals.push(x, y, z);
      uvs.push(u, v);
    }
  }
  for (lat = 0;lat < latitudeBands;++lat) {
    for (lon = 0;lon < longitudeBands;++lon) {
      first = lat * (longitudeBands + 1) + lon;
      second = first + longitudeBands + 1;
      indices.push(first + 1, second, first);
      indices.push(first + 1, second + 1, second);
    }
  }
  var options = {normals:normals, uvs:uvs, uvs1:uvs, indices:indices};
  if (pc.precalculatedTangents) {
    options.tangents = pc.calculateTangents(positions, normals, uvs, indices);
  }
  return pc.createMesh(device, positions, options);
};
pc.createPlane = function(device, opts) {
  var he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new pc.Vec2(0.5, 0.5);
  var ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 5;
  var ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 5;
  var i, j;
  var x, y, z, u, v;
  var positions = [];
  var normals = [];
  var uvs = [];
  var indices = [];
  var vcounter = 0;
  for (i = 0;i <= ws;i++) {
    for (j = 0;j <= ls;j++) {
      x = -he.x + 2.0 * he.x * i / ws;
      y = 0.0;
      z = -(-he.y + 2.0 * he.y * j / ls);
      u = i / ws;
      v = j / ls;
      positions.push(x, y, z);
      normals.push(0.0, 1.0, 0.0);
      uvs.push(u, v);
      if (i < ws && j < ls) {
        indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
        indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
      }
      vcounter++;
    }
  }
  var options = {normals:normals, uvs:uvs, uvs1:uvs, indices:indices};
  if (pc.precalculatedTangents) {
    options.tangents = pc.calculateTangents(positions, normals, uvs, indices);
  }
  return pc.createMesh(device, positions, options);
};
pc.createBox = function(device, opts) {
  var he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new pc.Vec3(0.5, 0.5, 0.5);
  var ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 1;
  var ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 1;
  var hs = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;
  var corners = [new pc.Vec3(-he.x, -he.y, he.z), new pc.Vec3(he.x, -he.y, he.z), new pc.Vec3(he.x, he.y, he.z), new pc.Vec3(-he.x, he.y, he.z), new pc.Vec3(he.x, -he.y, -he.z), new pc.Vec3(-he.x, -he.y, -he.z), new pc.Vec3(-he.x, he.y, -he.z), new pc.Vec3(he.x, he.y, -he.z)];
  var faceAxes = [[0, 1, 3], [4, 5, 7], [3, 2, 6], [1, 0, 4], [1, 4, 2], [5, 0, 6]];
  var faceNormals = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]];
  var sides = {FRONT:0, BACK:1, TOP:2, BOTTOM:3, RIGHT:4, LEFT:5};
  var positions = [];
  var normals = [];
  var uvs = [];
  var uvs1 = [];
  var indices = [];
  var vcounter = 0;
  var generateFace = function(side, uSegments, vSegments) {
    var u, v;
    var i, j;
    for (i = 0;i <= uSegments;i++) {
      for (j = 0;j <= vSegments;j++) {
        var temp1 = new pc.Vec3;
        var temp2 = new pc.Vec3;
        var temp3 = new pc.Vec3;
        var r = new pc.Vec3;
        temp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);
        temp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);
        temp3.sub2(temp2, corners[faceAxes[side][0]]);
        r.add2(temp1, temp3);
        u = i / uSegments;
        v = j / vSegments;
        positions.push(r.x, r.y, r.z);
        normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
        uvs.push(u, v);
        u /= 3;
        v /= 3;
        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
        u += side % 3 / 3;
        v += Math.floor(side / 3) / 3;
        uvs1.push(u, v);
        if (i < uSegments && j < vSegments) {
          indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);
          indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);
        }
        vcounter++;
      }
    }
  };
  generateFace(sides.FRONT, ws, hs);
  generateFace(sides.BACK, ws, hs);
  generateFace(sides.TOP, ws, ls);
  generateFace(sides.BOTTOM, ws, ls);
  generateFace(sides.RIGHT, ls, hs);
  generateFace(sides.LEFT, ls, hs);
  var options = {normals:normals, uvs:uvs, uvs1:uvs1, indices:indices};
  if (pc.precalculatedTangents) {
    options.tangents = pc.calculateTangents(positions, normals, uvs, indices);
  }
  return pc.createMesh(device, positions, options);
};
pc.Scene.defaultMaterial = new pc.StandardMaterial;
pc.Scene.defaultMaterial.shadingModel = pc.SPECULAR_BLINN;
Object.assign(pc, function() {
  var keyA, keyB, sortPos, sortDir;
  function sortManual(drawCallA, drawCallB) {
    return drawCallA.drawOrder - drawCallB.drawOrder;
  }
  function sortMaterialMesh(drawCallA, drawCallB) {
    keyA = drawCallA._key[pc.SORTKEY_FORWARD];
    keyB = drawCallB._key[pc.SORTKEY_FORWARD];
    if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
      return drawCallB.mesh.id - drawCallA.mesh.id;
    }
    return keyB - keyA;
  }
  function sortBackToFront(drawCallA, drawCallB) {
    return drawCallB.zdist - drawCallA.zdist;
  }
  function sortFrontToBack(drawCallA, drawCallB) {
    return drawCallA.zdist - drawCallB.zdist;
  }
  var sortCallbacks = [null, sortManual, sortMaterialMesh, sortBackToFront, sortFrontToBack];
  function sortCameras(camA, camB) {
    return camA.priority - camB.priority;
  }
  function sortLights(lightA, lightB) {
    return lightB.key - lightA.key;
  }
  var layerCounter = 0;
  var VisibleInstanceList = function() {
    this.list = [];
    this.length = 0;
    this.done = false;
  };
  var InstanceList = function() {
    this.opaqueMeshInstances = [];
    this.transparentMeshInstances = [];
    this.shadowCasters = [];
    this.visibleOpaque = [];
    this.visibleTransparent = [];
  };
  var Layer = function(options) {
    if (options.id !== undefined) {
      this.id = options.id;
      layerCounter = Math.max(this.id + 1, layerCounter);
    } else {
      this.id = layerCounter++;
    }
    this.name = options.name;
    this._enabled = options.enabled === undefined ? true : options.enabled;
    this._refCounter = this._enabled ? 1 : 0;
    this.opaqueSortMode = options.opaqueSortMode === undefined ? pc.SORTMODE_MATERIALMESH : options.opaqueSortMode;
    this.transparentSortMode = options.transparentSortMode === undefined ? pc.SORTMODE_BACK2FRONT : options.transparentSortMode;
    this.renderTarget = options.renderTarget;
    this.shaderPass = options.shaderPass === undefined ? pc.SHADER_FORWARD : options.shaderPass;
    this.passThrough = options.passThrough === undefined ? false : options.passThrough;
    this.overrideClear = options.overrideClear === undefined ? false : options.overrideClear;
    this._clearColor = new pc.Color(0, 0, 0, 1);
    if (options.clearColor) {
      this._clearColor.copy(options.clearColor);
    }
    this._clearColorBuffer = options.clearColorBuffer === undefined ? false : options.clearColorBuffer;
    this._clearDepthBuffer = options.clearDepthBuffer === undefined ? false : options.clearDepthBuffer;
    this._clearStencilBuffer = options.clearStencilBuffer === undefined ? false : options.clearStencilBuffer;
    this._clearOptions = {color:this._clearColor.data, depth:1.0, stencil:0, flags:(this._clearColorBuffer ? pc.CLEARFLAG_COLOR : 0) | (this._clearDepthBuffer ? pc.CLEARFLAG_DEPTH : 0) | (this._clearStencilBuffer ? pc.CLEARFLAG_STENCIL : 0)};
    this.onPreCull = options.onPreCull;
    this.onPreRender = options.onPreRender;
    this.onPreRenderOpaque = options.onPreRenderOpaque;
    this.onPreRenderTransparent = options.onPreRenderTransparent;
    this.onPostCull = options.onPostCull;
    this.onPostRender = options.onPostRender;
    this.onPostRenderOpaque = options.onPostRenderOpaque;
    this.onPostRenderTransparent = options.onPostRenderTransparent;
    this.onDrawCall = options.onDrawCall;
    this.onEnable = options.onEnable;
    this.onDisable = options.onDisable;
    if (this._enabled && this.onEnable) {
      this.onEnable();
    }
    this.layerReference = options.layerReference;
    this.instances = options.layerReference ? options.layerReference.instances : new InstanceList;
    this.cullingMask = options.cullingMask ? options.cullingMask : 4294967295;
    this.opaqueMeshInstances = this.instances.opaqueMeshInstances;
    this.transparentMeshInstances = this.instances.transparentMeshInstances;
    this.shadowCasters = this.instances.shadowCasters;
    this._lightComponents = [];
    this._lights = [];
    this._sortedLights = [[], [], []];
    this.cameras = [];
    this._dirty = false;
    this._dirtyLights = false;
    this._dirtyCameras = false;
    this._cameraHash = 0;
    this._lightHash = 0;
    this._staticLightHash = 0;
    this._needsStaticPrepare = true;
    this._staticPrepareDone = false;
    this._shaderVersion = -1;
    this._version = 0;
    this._lightCube = null;
  };
  Object.defineProperty(Layer.prototype, "enabled", {get:function() {
    return this._enabled;
  }, set:function(val) {
    if (val !== this._enabled) {
      this._enabled = val;
      if (val) {
        this.incrementCounter();
        if (this.onEnable) {
          this.onEnable();
        }
      } else {
        this.decrementCounter();
        if (this.onDisable) {
          this.onDisable();
        }
      }
    }
  }});
  Object.defineProperty(Layer.prototype, "clearColor", {get:function() {
    return this._clearColor;
  }, set:function(val) {
    this._clearColor.copy(val);
  }});
  Layer.prototype._updateClearFlags = function() {
    var flags = 0;
    if (this._clearColorBuffer) {
      flags |= pc.CLEARFLAG_COLOR;
    }
    if (this._clearDepthBuffer) {
      flags |= pc.CLEARFLAG_DEPTH;
    }
    if (this._clearStencilBuffer) {
      flags |= pc.CLEARFLAG_STENCIL;
    }
    this._clearOptions.flags = flags;
  };
  Object.defineProperty(Layer.prototype, "clearColorBuffer", {get:function() {
    return this._clearColorBuffer;
  }, set:function(val) {
    this._clearColorBuffer = val;
    this._updateClearFlags();
  }});
  Object.defineProperty(Layer.prototype, "clearDepthBuffer", {get:function() {
    return this._clearDepthBuffer;
  }, set:function(val) {
    this._clearDepthBuffer = val;
    this._updateClearFlags();
  }});
  Object.defineProperty(Layer.prototype, "clearStencilBuffer", {get:function() {
    return this._clearStencilBuffer;
  }, set:function(val) {
    this._clearStencilBuffer = val;
    this._updateClearFlags();
  }});
  Layer.prototype.incrementCounter = function() {
    if (this._refCounter === 0) {
      this._enabled = true;
      if (this.onEnable) {
        this.onEnable();
      }
    }
    this._refCounter++;
  };
  Layer.prototype.decrementCounter = function() {
    if (this._refCounter === 1) {
      this._enabled = false;
      if (this.onDisable) {
        this.onDisable();
      }
    } else {
      if (this._refCounter === 0) {
        return;
      }
    }
    this._refCounter--;
  };
  Layer.prototype.addMeshInstances = function(meshInstances, skipShadowCasters) {
    var sceneShaderVer = this._shaderVersion;
    var m, arr, mat;
    var casters = this.shadowCasters;
    for (var i = 0;i < meshInstances.length;i++) {
      m = meshInstances[i];
      mat = m.material;
      if (mat.blendType === pc.BLEND_NONE) {
        arr = this.opaqueMeshInstances;
      } else {
        arr = this.transparentMeshInstances;
      }
      if (arr.indexOf(m) < 0) {
        arr.push(m);
      }
      if (!skipShadowCasters && m.castShadow && casters.indexOf(m) < 0) {
        casters.push(m);
      }
      if (!this.passThrough && sceneShaderVer >= 0 && mat._shaderVersion !== sceneShaderVer) {
        if (mat.updateShader !== pc.Material.prototype.updateShader) {
          mat.clearVariants();
          mat.shader = null;
        }
        mat._shaderVersion = sceneShaderVer;
      }
    }
    if (!this.passThrough) {
      this._dirty = true;
    }
  };
  Layer.prototype.removeMeshInstances = function(meshInstances, skipShadowCasters) {
    var i, j, m, spliceOffset, spliceCount, len, drawCall;
    var opaque = this.opaqueMeshInstances;
    var transparent = this.transparentMeshInstances;
    var casters = this.shadowCasters;
    for (i = 0;i < meshInstances.length;i++) {
      m = meshInstances[i];
      spliceOffset = -1;
      spliceCount = 0;
      len = opaque.length;
      for (j = 0;j < len;j++) {
        drawCall = opaque[j];
        if (drawCall === m) {
          spliceOffset = j;
          spliceCount = 1;
          break;
        }
        if (drawCall._staticSource === m) {
          if (spliceOffset < 0) {
            spliceOffset = j;
          }
          spliceCount++;
        } else {
          if (spliceOffset >= 0) {
            break;
          }
        }
      }
      if (spliceOffset >= 0) {
        opaque.splice(spliceOffset, spliceCount);
      }
      spliceOffset = -1;
      spliceCount = 0;
      len = transparent.length;
      for (j = 0;j < len;j++) {
        drawCall = transparent[j];
        if (drawCall === m) {
          spliceOffset = j;
          spliceCount = 1;
          break;
        }
        if (drawCall._staticSource === m) {
          if (spliceOffset < 0) {
            spliceOffset = j;
          }
          spliceCount++;
        } else {
          if (spliceOffset >= 0) {
            break;
          }
        }
      }
      if (spliceOffset >= 0) {
        transparent.splice(spliceOffset, spliceCount);
      }
      if (skipShadowCasters) {
        continue;
      }
      j = casters.indexOf(m);
      if (j >= 0) {
        casters.splice(j, 1);
      }
    }
    this._dirty = true;
  };
  Layer.prototype.clearMeshInstances = function(skipShadowCasters) {
    if (this.opaqueMeshInstances.length === 0 && this.transparentMeshInstances.length === 0) {
      if (skipShadowCasters || this.shadowCasters.length === 0) {
        return;
      }
    }
    this.opaqueMeshInstances.length = 0;
    this.transparentMeshInstances.length = 0;
    if (!skipShadowCasters) {
      this.shadowCasters.length = 0;
    }
    if (!this.passThrough) {
      this._dirty = true;
    }
  };
  Layer.prototype.addLight = function(light) {
    if (this._lightComponents.indexOf(light) >= 0) {
      return;
    }
    this._lightComponents.push(light);
    this._lights.push(light.light);
    this._dirtyLights = true;
    this._generateLightHash();
  };
  Layer.prototype.removeLight = function(light) {
    var id = this._lightComponents.indexOf(light);
    if (id < 0) {
      return;
    }
    this._lightComponents.splice(id, 1);
    id = this._lights.indexOf(light.light);
    this._lights.splice(id, 1);
    this._dirtyLights = true;
    this._generateLightHash();
  };
  Layer.prototype.clearLights = function() {
    this._lightComponents.length = 0;
    this._lights.length = 0;
    this._dirtyLights = true;
  };
  Layer.prototype.addShadowCasters = function(meshInstances) {
    var m;
    var arr = this.shadowCasters;
    for (var i = 0;i < meshInstances.length;i++) {
      m = meshInstances[i];
      if (!m.castShadow) {
        continue;
      }
      if (arr.indexOf(m) < 0) {
        arr.push(m);
      }
    }
    this._dirtyLights = true;
  };
  Layer.prototype.removeShadowCasters = function(meshInstances) {
    var id;
    var arr = this.shadowCasters;
    for (var i = 0;i < meshInstances.length;i++) {
      id = arr.indexOf(meshInstances[i]);
      if (id >= 0) {
        arr.splice(id, 1);
      }
    }
    this._dirtyLights = true;
  };
  Layer.prototype._generateLightHash = function() {
    if (this._lights.length > 0) {
      this._lights.sort(sortLights);
      var str = "";
      var strStatic = "";
      for (var i = 0;i < this._lights.length;i++) {
        if (this._lights[i].isStatic) {
          strStatic += this._lights[i].key;
        } else {
          str += this._lights[i].key;
        }
      }
      if (str.length === 0) {
        this._lightHash = 0;
      } else {
        this._lightHash = pc.hashCode(str);
      }
      if (strStatic.length === 0) {
        this._staticLightHash = 0;
      } else {
        this._staticLightHash = pc.hashCode(strStatic);
      }
    } else {
      this._lightHash = 0;
      this._staticLightHash = 0;
    }
  };
  Layer.prototype._generateCameraHash = function() {
    if (this.cameras.length > 1) {
      this.cameras.sort(sortCameras);
      var str = "";
      for (var i = 0;i < this.cameras.length;i++) {
        str += this.cameras[i].entity._guid;
      }
      this._cameraHash = pc.hashCode(str);
    } else {
      this._cameraHash = 0;
    }
    this._dirtyCameras = true;
  };
  Layer.prototype.addCamera = function(camera) {
    if (this.cameras.indexOf(camera) >= 0) {
      return;
    }
    this.cameras.push(camera);
    this._generateCameraHash();
  };
  Layer.prototype.removeCamera = function(camera) {
    var id = this.cameras.indexOf(camera);
    if (id < 0) {
      return;
    }
    this.cameras.splice(id, 1);
    this._generateCameraHash();
  };
  Layer.prototype.clearCameras = function() {
    this.cameras.length = 0;
    this._cameraHash = 0;
    this._dirtyCameras = true;
  };
  Layer.prototype._sortCameras = function() {
    this._generateCameraHash();
  };
  Layer.prototype._calculateSortDistances = function(drawCalls, drawCallsCount, camPos, camFwd) {
    var i, drawCall, meshPos;
    var tempx, tempy, tempz;
    for (i = 0;i < drawCallsCount;i++) {
      drawCall = drawCalls[i];
      if (drawCall.command) {
        continue;
      }
      if (drawCall.layer <= pc.scene.LAYER_FX) {
        continue;
      }
      meshPos = drawCall.aabb.center.data;
      tempx = meshPos[0] - camPos[0];
      tempy = meshPos[1] - camPos[1];
      tempz = meshPos[2] - camPos[2];
      drawCall.zdist = tempx * camFwd[0] + tempy * camFwd[1] + tempz * camFwd[2];
    }
  };
  Layer.prototype._sortVisible = function(transparent, cameraNode, cameraPass) {
    var objects = this.instances;
    var sortMode = transparent ? this.transparentSortMode : this.opaqueSortMode;
    if (sortMode === pc.SORTMODE_NONE) {
      return;
    }
    var visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];
    if (sortMode === pc.SORTMODE_BACK2FRONT || sortMode === pc.SORTMODE_FRONT2BACK) {
      sortPos = cameraNode.getPosition().data;
      sortDir = cameraNode.forward.data;
      this._calculateSortDistances(visible.list, visible.length, sortPos, sortDir);
    }
    if (visible.list.length !== visible.length) {
      visible.list.length = visible.length;
    }
    visible.list.sort(sortCallbacks[sortMode]);
  };
  return {Layer:Layer, InstanceList:InstanceList, VisibleInstanceList:VisibleInstanceList};
}());
Object.assign(pc, function() {
  var LayerComposition = function() {
    this.layerList = [];
    this.subLayerList = [];
    this.subLayerEnabled = [];
    this._dirty = false;
    this._dirtyBlend = false;
    this._dirtyLights = false;
    this._dirtyCameras = false;
    this._meshInstances = [];
    this._lights = [];
    this.cameras = [];
    this._sortedLights = [[], [], []];
    this._lightShadowCasters = [];
    this._globalLightCameras = [];
    this._globalLightCameraIds = [];
    this._renderedRt = [];
    this._renderedByCam = [];
    this._renderedLayer = [];
    this._renderList = [];
    this._renderListCamera = [];
    pc.events.attach(this);
  };
  LayerComposition.prototype._sortLights = function(target) {
    var light;
    var lights = target._lights;
    target._sortedLights[pc.LIGHTTYPE_DIRECTIONAL].length = 0;
    target._sortedLights[pc.LIGHTTYPE_POINT].length = 0;
    target._sortedLights[pc.LIGHTTYPE_SPOT].length = 0;
    for (var i = 0;i < lights.length;i++) {
      light = lights[i];
      if (light._enabled) {
        target._sortedLights[light._type].push(light);
      }
    }
  };
  LayerComposition.prototype._update = function() {
    var i, j, k, l;
    var layer;
    var len = this.layerList.length;
    var result = 0;
    if (!this._dirty || !this._dirtyLights || !this._dirtyCameras) {
      for (i = 0;i < len;i++) {
        layer = this.layerList[i];
        if (layer._dirty) {
          this._dirty = true;
        }
        if (layer._dirtyLights) {
          this._dirtyLights = true;
        }
        if (layer._dirtyCameras) {
          this._dirtyCameras = true;
        }
      }
    }
    var arr;
    if (this._dirty) {
      result |= pc.COMPUPDATED_INSTANCES;
      this._meshInstances.length = 0;
      var mi;
      for (i = 0;i < len;i++) {
        layer = this.layerList[i];
        if (layer.passThrough) {
          continue;
        }
        arr = layer.opaqueMeshInstances;
        for (j = 0;j < arr.length;j++) {
          mi = arr[j];
          if (this._meshInstances.indexOf(mi) < 0) {
            this._meshInstances.push(mi);
            if (mi.material && mi.material._dirtyBlend) {
              this._dirtyBlend = true;
              mi.material._dirtyBlend = false;
            }
          }
        }
        arr = layer.transparentMeshInstances;
        for (j = 0;j < arr.length;j++) {
          mi = arr[j];
          if (this._meshInstances.indexOf(mi) < 0) {
            this._meshInstances.push(mi);
            if (mi.material && mi.material._dirtyBlend) {
              this._dirtyBlend = true;
              mi.material._dirtyBlend = false;
            }
          }
        }
      }
      for (i = 0;i < len;i++) {
        this.layerList[i]._dirty = false;
        this.layerList[i]._version++;
      }
    }
    if (this._dirtyBlend) {
      result |= pc.COMPUPDATED_BLEND;
      var opaqueOld, transparentOld, opaqueNew, transparentNew;
      for (i = 0;i < len;i++) {
        layer = this.layerList[i];
        if (layer.passThrough) {
          continue;
        }
        opaqueOld = layer.opaqueMeshInstances;
        transparentOld = layer.transparentMeshInstances;
        opaqueNew = [];
        transparentNew = [];
        for (j = 0;j < opaqueOld.length;j++) {
          if (opaqueOld[j].material && opaqueOld[j].material.blendType !== pc.BLEND_NONE) {
            transparentNew.push(opaqueOld[j]);
          } else {
            opaqueNew.push(opaqueOld[j]);
          }
        }
        for (j = 0;j < transparentOld.length;j++) {
          if (transparentOld[j].material && transparentOld[j].material.blendType !== pc.BLEND_NONE) {
            transparentNew.push(transparentOld[j]);
          } else {
            opaqueNew.push(transparentOld[j]);
          }
        }
        layer.opaqueMeshInstances.length = opaqueNew.length;
        for (j = 0;j < opaqueNew.length;j++) {
          layer.opaqueMeshInstances[j] = opaqueNew[j];
        }
        layer.transparentMeshInstances.length = transparentNew.length;
        for (j = 0;j < transparentNew.length;j++) {
          layer.transparentMeshInstances[j] = transparentNew[j];
        }
      }
      this._dirtyBlend = false;
    }
    this._dirty = false;
    var casters, lid, light;
    if (this._dirtyLights || result & pc.COMPUPDATED_INSTANCES) {
      result |= pc.COMPUPDATED_LIGHTS;
      this._lights.length = 0;
      this._lightShadowCasters.length = 0;
      for (i = 0;i < len;i++) {
        layer = this.layerList[i];
        arr = layer._lights;
        for (j = 0;j < arr.length;j++) {
          light = arr[j];
          lid = this._lights.indexOf(light);
          if (lid < 0) {
            this._lights.push(light);
            lid = this._lights.length - 1;
          }
          casters = this._lightShadowCasters[lid];
          if (!casters) {
            this._lightShadowCasters[lid] = casters = [];
          }
        }
      }
    }
    if (this._dirtyLights) {
      this._sortLights(this);
      this._dirtyLights = false;
      for (i = 0;i < len;i++) {
        layer = this.layerList[i];
        this._sortLights(layer);
        layer._dirtyLights = false;
      }
    }
    if (result) {
      for (i = 0;i < len;i++) {
        layer = this.layerList[i];
        arr = layer._lights;
        for (j = 0;j < arr.length;j++) {
          light = arr[j];
          lid = this._lights.indexOf(light);
          casters = this._lightShadowCasters[lid];
          var meshInstances = layer.shadowCasters;
          for (k = 0;k < meshInstances.length;k++) {
            if (casters.indexOf(meshInstances[k]) < 0) {
              casters.push(meshInstances[k]);
            }
          }
        }
      }
    }
    if (result & pc.COMPUPDATED_LIGHTS || this._dirtyCameras) {
      this._globalLightCameras.length = 0;
      var globalLights = this._sortedLights[pc.LIGHTTYPE_DIRECTIONAL];
      for (l = 0;l < globalLights.length;l++) {
        light = globalLights[l];
        this._globalLightCameras[l] = [];
        for (i = 0;i < len;i++) {
          layer = this.layerList[i];
          if (layer._sortedLights[pc.LIGHTTYPE_DIRECTIONAL].indexOf(light) < 0) {
            continue;
          }
          for (k = 0;k < layer.cameras.length;k++) {
            if (this._globalLightCameras[l].indexOf(layer.cameras[k]) >= 0) {
              continue;
            }
            this._globalLightCameras[l].push(layer.cameras[k]);
          }
        }
      }
    }
    var camera, index;
    if (this._dirtyCameras) {
      result |= pc.COMPUPDATED_CAMERAS;
      this.cameras.length = 0;
      for (i = 0;i < len;i++) {
        layer = this.layerList[i];
        for (j = 0;j < layer.cameras.length;j++) {
          camera = layer.cameras[j];
          index = this.cameras.indexOf(camera);
          if (index < 0) {
            index = this.cameras.length;
            this.cameras.push(camera);
          }
        }
      }
      this._renderList.length = 0;
      this._renderListCamera.length = 0;
      var hash, hash2, groupLength, cam;
      var skipCount = 0;
      for (i = 0;i < len;i++) {
        if (skipCount) {
          skipCount--;
          continue;
        }
        layer = this.layerList[i];
        if (layer.cameras.length === 0 && !layer.isPostEffect) {
          continue;
        }
        hash = layer._cameraHash;
        if (hash === 0) {
          this._renderList.push(i);
          this._renderListCamera.push(0);
        } else {
          groupLength = 1;
          for (j = i + 1;j < len;j++) {
            hash2 = this.layerList[j]._cameraHash;
            if (hash !== hash2) {
              groupLength = j - i - 1;
              break;
            } else {
              if (j === len - 1) {
                groupLength = j - i;
              }
            }
          }
          if (groupLength === 1) {
            for (cam = 0;cam < layer.cameras.length;cam++) {
              this._renderList.push(i);
              this._renderListCamera.push(cam);
            }
          } else {
            cam = 0;
            for (cam = 0;cam < layer.cameras.length;cam++) {
              for (j = 0;j <= groupLength;j++) {
                this._renderList.push(i + j);
                this._renderListCamera.push(cam);
              }
            }
            skipCount = groupLength;
          }
        }
      }
      this._dirtyCameras = false;
      for (i = 0;i < len;i++) {
        this.layerList[i]._dirtyCameras = false;
      }
    }
    if (result & pc.COMPUPDATED_LIGHTS || result & pc.COMPUPDATED_CAMERAS) {
      this._globalLightCameraIds.length = 0;
      for (l = 0;l < this._globalLightCameras.length;l++) {
        arr = [];
        for (i = 0;i < this._globalLightCameras[l].length;i++) {
          index = this.cameras.indexOf(this._globalLightCameras[l][i]);
          if (index < 0) {
            continue;
          }
          arr.push(index);
        }
        this._globalLightCameraIds.push(arr);
      }
    }
    return result;
  };
  LayerComposition.prototype._isLayerAdded = function(layer) {
    if (this.layerList.indexOf(layer) >= 0) {
      return true;
    }
    return false;
  };
  LayerComposition.prototype._isSublayerAdded = function(layer, transparent) {
    for (var i = 0;i < this.layerList.length;i++) {
      if (this.layerList[i] === layer && this.subLayerList[i] === transparent) {
        return true;
      }
    }
    return false;
  };
  LayerComposition.prototype.push = function(layer) {
    if (this._isLayerAdded(layer)) {
      return;
    }
    this.layerList.push(layer);
    this.layerList.push(layer);
    this.subLayerList.push(false);
    this.subLayerList.push(true);
    this.subLayerEnabled.push(true);
    this.subLayerEnabled.push(true);
    this._dirty = true;
    this._dirtyLights = true;
    this._dirtyCameras = true;
    this.fire("add", layer);
  };
  LayerComposition.prototype.insert = function(layer, index) {
    if (this._isLayerAdded(layer)) {
      return;
    }
    this.layerList.splice(index, 0, layer, layer);
    this.subLayerList.splice(index, 0, false, true);
    this.subLayerEnabled.splice(index, 0, true, true);
    this._dirty = true;
    this._dirtyLights = true;
    this._dirtyCameras = true;
    this.fire("add", layer);
  };
  LayerComposition.prototype.remove = function(layer) {
    var id = this.layerList.indexOf(layer);
    while (id >= 0) {
      this.layerList.splice(id, 1);
      this.subLayerList.splice(id, 1);
      this.subLayerEnabled.splice(id, 1);
      id = this.layerList.indexOf(layer);
      this._dirty = true;
      this._dirtyLights = true;
      this._dirtyCameras = true;
      this.fire("remove", layer);
    }
  };
  LayerComposition.prototype.pushOpaque = function(layer) {
    if (this._isSublayerAdded(layer, false)) {
      return;
    }
    this.layerList.push(layer);
    this.subLayerList.push(false);
    this.subLayerEnabled.push(true);
    this._dirty = true;
    this._dirtyLights = true;
    this._dirtyCameras = true;
    this.fire("add", layer);
  };
  LayerComposition.prototype.insertOpaque = function(layer, index) {
    if (this._isSublayerAdded(layer, false)) {
      return;
    }
    this.layerList.splice(index, 0, layer);
    this.subLayerList.splice(index, 0, false);
    this.subLayerEnabled.splice(index, 0, true);
    this._dirty = true;
    this._dirtyLights = true;
    this._dirtyCameras = true;
    this.fire("add", layer);
  };
  LayerComposition.prototype.removeOpaque = function(layer) {
    for (var i = 0;i < this.layerList.length;i++) {
      if (this.layerList[i] === layer && !this.subLayerList[i]) {
        this.layerList.splice(i, 1);
        this.subLayerList.splice(i, 1);
        this.subLayerEnabled.splice(i, 1);
        this._dirty = true;
        this._dirtyLights = true;
        this._dirtyCameras = true;
        if (this.layerList.indexOf(layer) < 0) {
          this.fire("remove", layer);
        }
        return;
      }
    }
  };
  LayerComposition.prototype.pushTransparent = function(layer) {
    if (this._isSublayerAdded(layer, true)) {
      return;
    }
    this.layerList.push(layer);
    this.subLayerList.push(true);
    this.subLayerEnabled.push(true);
    this._dirty = true;
    this._dirtyLights = true;
    this._dirtyCameras = true;
    this.fire("add", layer);
  };
  LayerComposition.prototype.insertTransparent = function(layer, index) {
    if (this._isSublayerAdded(layer, true)) {
      return;
    }
    this.layerList.splice(index, 0, layer);
    this.subLayerList.splice(index, 0, true);
    this.subLayerEnabled.splice(index, 0, true);
    this._dirty = true;
    this._dirtyLights = true;
    this._dirtyCameras = true;
    this.fire("add", layer);
  };
  LayerComposition.prototype.removeTransparent = function(layer) {
    for (var i = 0;i < this.layerList.length;i++) {
      if (this.layerList[i] === layer && this.subLayerList[i]) {
        this.layerList.splice(i, 1);
        this.subLayerList.splice(i, 1);
        this.subLayerEnabled.splice(i, 1);
        this._dirty = true;
        this._dirtyLights = true;
        this._dirtyCameras = true;
        if (this.layerList.indexOf(layer) < 0) {
          this.fire("remove", layer);
        }
        return;
      }
    }
  };
  LayerComposition.prototype._getSublayerIndex = function(layer, transparent) {
    var id = this.layerList.indexOf(layer);
    if (id < 0) {
      return -1;
    }
    if (this.subLayerList[id] !== transparent) {
      id = this.layerList.indexOf(layer, id + 1);
      if (id < 0) {
        return -1;
      }
      if (this.subLayerList[id] !== transparent) {
        return -1;
      }
    }
    return id;
  };
  LayerComposition.prototype.getOpaqueIndex = function(layer) {
    return this._getSublayerIndex(layer, false);
  };
  LayerComposition.prototype.getTransparentIndex = function(layer) {
    return this._getSublayerIndex(layer, true);
  };
  LayerComposition.prototype.getLayerById = function(id) {
    for (var i = 0;i < this.layerList.length;i++) {
      if (this.layerList[i].id === id) {
        return this.layerList[i];
      }
    }
    return null;
  };
  LayerComposition.prototype.getLayerByName = function(name) {
    for (var i = 0;i < this.layerList.length;i++) {
      if (this.layerList[i].name === name) {
        return this.layerList[i];
      }
    }
    return null;
  };
  return {LayerComposition:LayerComposition};
}());
Object.assign(pc, function() {
  pc.SPRITE_RENDERMODE_SIMPLE = 0;
  pc.SPRITE_RENDERMODE_SLICED = 1;
  pc.SPRITE_RENDERMODE_TILED = 2;
  var spriteNormals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
  var spriteIndices = [0, 1, 3, 2, 3, 1];
  var Sprite = function(device, options) {
    this._device = device;
    this._pixelsPerUnit = options && options.pixelsPerUnit !== undefined ? options.pixelsPerUnit : 1;
    this._renderMode = options && options.renderMode !== undefined ? options.renderMode : pc.SPRITE_RENDERMODE_SIMPLE;
    this._atlas = options && options.atlas !== undefined ? options.atlas : null;
    this._frameKeys = options && options.frameKeys !== undefined ? options.frameKeys : null;
    this._meshes = [];
    this._updatingProperties = false;
    this._meshesDirty = false;
    pc.events.attach(this);
    if (this._atlas && this._frameKeys) {
      this._createMeshes();
    }
  };
  Sprite.prototype._createMeshes = function() {
    var i, len;
    for (i = 0, len = this._meshes.length;i < len;i++) {
      var mesh = this._meshes[i];
      if (!mesh) {
        continue;
      }
      mesh.vertexBuffer.destroy();
      for (var j = 0, len2 = mesh.indexBuffer.length;j < len2;j++) {
        mesh.indexBuffer[j].destroy();
      }
    }
    var count = this._frameKeys.length;
    this._meshes = new Array(count);
    var createMeshFunc = this.renderMode === pc.SPRITE_RENDERMODE_SLICED || this._renderMode === pc.SPRITE_RENDERMODE_TILED ? this._create9SliceMesh : this._createSimpleMesh;
    for (i = 0;i < count;i++) {
      var frame = this._atlas.frames[this._frameKeys[i]];
      this._meshes[i] = frame ? createMeshFunc.call(this, frame) : null;
    }
    this.fire("set:meshes");
  };
  Sprite.prototype._createSimpleMesh = function(frame) {
    var rect = frame.rect;
    var texWidth = this._atlas.texture.width;
    var texHeight = this._atlas.texture.height;
    var w = rect.data[2] / this._pixelsPerUnit;
    var h = rect.data[3] / this._pixelsPerUnit;
    var hp = frame.pivot.x;
    var vp = frame.pivot.y;
    var positions = [-hp * w, -vp * h, 0, (1 - hp) * w, -vp * h, 0, (1 - hp) * w, (1 - vp) * h, 0, -hp * w, (1 - vp) * h, 0];
    var lu = rect.data[0] / texWidth;
    var bv = rect.data[1] / texHeight;
    var ru = (rect.data[0] + rect.data[2]) / texWidth;
    var tv = (rect.data[1] + rect.data[3]) / texHeight;
    var uvs = [lu, bv, ru, bv, ru, tv, lu, tv];
    var mesh = pc.createMesh(this._device, positions, {uvs:uvs, normals:spriteNormals, indices:spriteIndices});
    return mesh;
  };
  Sprite.prototype._create9SliceMesh = function() {
    var he = pc.Vec2.ONE;
    var ws = 3;
    var ls = 3;
    var i, j;
    var x, y, z, u, v;
    var positions = [];
    var normals = [];
    var uvs = [];
    var indices = [];
    var vcounter = 0;
    for (i = 0;i <= ws;i++) {
      u = i === 0 || i === ws ? 0 : 1;
      for (j = 0;j <= ls;j++) {
        x = -he.x + 2.0 * he.x * (i <= 1 ? 0 : 3) / ws;
        y = 0.0;
        z = -(-he.y + 2.0 * he.y * (j <= 1 ? 0 : 3) / ls);
        v = j === 0 || j === ls ? 0 : 1;
        positions.push(-x, y, z);
        normals.push(0.0, 1.0, 0.0);
        uvs.push(u, v);
        if (i < ws && j < ls) {
          indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
          indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
        }
        vcounter++;
      }
    }
    var options = {normals:normals, uvs:uvs, indices:indices};
    return pc.createMesh(this._device, positions, options);
  };
  Sprite.prototype._onSetFrames = function(frames) {
    if (this._updatingProperties) {
      this._meshesDirty = true;
    } else {
      this._createMeshes();
    }
  };
  Sprite.prototype._onFrameChanged = function(frameKey, frame) {
    var idx = this._frameKeys.indexOf(frameKey);
    if (idx < 0) {
      return;
    }
    if (frame) {
      if (this.renderMode === pc.SPRITE_RENDERMODE_SIMPLE) {
        this._meshes[idx] = this._createSimpleMesh(frame);
      }
    } else {
      this._meshes[idx] = null;
    }
    this.fire("set:meshes");
  };
  Sprite.prototype._onFrameRemoved = function(frameKey) {
    var idx = this._frameKeys.indexOf(frameKey);
    if (idx < 0) {
      return;
    }
    this._meshes[idx] = null;
    this.fire("set:meshes");
  };
  Sprite.prototype.startUpdate = function() {
    this._updatingProperties = true;
    this._meshesDirty = false;
  };
  Sprite.prototype.endUpdate = function() {
    this._updatingProperties = false;
    if (this._meshesDirty && this._atlas && this._frameKeys) {
      this._createMeshes();
    }
    this._meshesDirty = false;
  };
  Sprite.prototype.destroy = function() {
    var i;
    var len;
    for (i = 0, len = this._meshes.length;i < len;i++) {
      var mesh = this._meshes[i];
      if (!mesh) {
        continue;
      }
      mesh.vertexBuffer.destroy();
      for (var j = 0, len2 = mesh.indexBuffer.length;j < len2;j++) {
        mesh.indexBuffer[j].destroy();
      }
    }
    this._meshes.length = 0;
  };
  Object.defineProperty(Sprite.prototype, "frameKeys", {get:function() {
    return this._frameKeys;
  }, set:function(value) {
    this._frameKeys = value;
    if (this._atlas && this._frameKeys) {
      if (this._updatingProperties) {
        this._meshesDirty = true;
      } else {
        this._createMeshes();
      }
    }
    this.fire("set:frameKeys", value);
  }});
  Object.defineProperty(Sprite.prototype, "atlas", {get:function() {
    return this._atlas;
  }, set:function(value) {
    if (value === this._atlas) {
      return;
    }
    if (this._atlas) {
      this._atlas.off("set:frames", this._onSetFrames, this);
      this._atlas.off("set:frame", this._onFrameChanged, this);
      this._atlas.off("remove:frame", this._onFrameRemoved, this);
    }
    this._atlas = value;
    if (this._atlas && this._frameKeys) {
      this._atlas.on("set:frames", this._onSetFrames, this);
      this._atlas.on("set:frame", this._onFrameChanged, this);
      this._atlas.on("remove:frame", this._onFrameRemoved, this);
      if (this._updatingProperties) {
        this._meshesDirty = true;
      } else {
        this._createMeshes();
      }
    }
    this.fire("set:atlas", value);
  }});
  Object.defineProperty(Sprite.prototype, "pixelsPerUnit", {get:function() {
    return this._pixelsPerUnit;
  }, set:function(value) {
    if (this._pixelsPerUnit === value) {
      return;
    }
    this._pixelsPerUnit = value;
    this.fire("set:pixelsPerUnit", value);
    if (this._atlas && this._frameKeys && this.renderMode === pc.SPRITE_RENDERMODE_SIMPLE) {
      if (this._updatingProperties) {
        this._meshesDirty = true;
      } else {
        this._createMeshes();
      }
    }
  }});
  Object.defineProperty(Sprite.prototype, "renderMode", {get:function() {
    return this._renderMode;
  }, set:function(value) {
    if (this._renderMode === value) {
      return;
    }
    var prev = this._renderMode;
    this._renderMode = value;
    this.fire("set:renderMode", value);
    if (prev === pc.SPRITE_RENDERMODE_SIMPLE || value === pc.SPRITE_RENDERMODE_SIMPLE) {
      if (this._atlas && this._frameKeys) {
        if (this._updatingProperties) {
          this._meshesDirty = true;
        } else {
          this._createMeshes();
        }
      }
    }
  }});
  Object.defineProperty(Sprite.prototype, "meshes", {get:function() {
    return this._meshes;
  }});
  return {Sprite:Sprite};
}());
Object.assign(pc, function() {
  var TextureAtlas = function() {
    this._texture = null;
    this._frames = null;
    pc.events.attach(this);
  };
  TextureAtlas.prototype.setFrame = function(key, data) {
    var frame = this._frames[key];
    if (!frame) {
      frame = {rect:data.rect.clone(), pivot:data.pivot.clone(), border:data.border.clone()};
      this._frames[key] = frame;
    } else {
      frame.rect.copy(data.rect);
      frame.pivot.copy(data.pivot);
      frame.border.copy(data.border);
    }
    this.fire("set:frame", key.toString(), frame);
  };
  TextureAtlas.prototype.removeFrame = function(key) {
    var frame = this._frames[key];
    if (frame) {
      delete this._frames[key];
      this.fire("remove:frame", key.toString(), frame);
    }
  };
  TextureAtlas.prototype.destroy = function() {
    if (this._texture) {
      this._texture.destroy();
    }
  };
  Object.defineProperty(TextureAtlas.prototype, "texture", {get:function() {
    return this._texture;
  }, set:function(value) {
    this._texture = value;
    this.fire("set:texture", value);
  }});
  Object.defineProperty(TextureAtlas.prototype, "frames", {get:function() {
    return this._frames;
  }, set:function(value) {
    this._frames = value;
    this.fire("set:frames", value);
  }});
  return {TextureAtlas:TextureAtlas};
}());
Object.assign(pc, function() {
  var StencilParameters = function(options) {
    this.func = options.func === undefined ? pc.FUNC_ALWAYS : options.func;
    this.ref = options.ref || 0;
    this.readMask = options.readMask === undefined ? 255 : options.readMask;
    this.writeMask = options.writeMask === undefined ? 255 : options.writeMask;
    this.fail = options.fail || pc.STENCILOP_KEEP;
    this.zfail = options.zfail || pc.STENCILOP_KEEP;
    this.zpass = options.zpass || pc.STENCILOP_KEEP;
  };
  StencilParameters.prototype.clone = function() {
    var clone = new pc.StencilParameters({func:this.func, ref:this.ref, readMask:this.readMask, writeMask:this.writeMask, fail:this.fail, zfail:this.zfail, zpass:this.zpass});
    return clone;
  };
  return {StencilParameters:StencilParameters};
}());
Object.assign(pc, function() {
  var Key = function Key(time, position, rotation, scale) {
    this.time = time;
    this.position = position;
    this.rotation = rotation;
    this.scale = scale;
  };
  var Node = function Node() {
    this._name = "";
    this._keys = [];
  };
  var Animation = function Animation() {
    this.name = "";
    this.duration = 0;
    this._nodes = [];
    this._nodeDict = {};
  };
  Animation.prototype.getDuration = function() {
    return this.duration;
  };
  Animation.prototype.getName = function() {
    return this.name;
  };
  Animation.prototype.getNode = function(name) {
    return this._nodeDict[name];
  };
  Object.defineProperty(Animation.prototype, "nodes", {get:function() {
    return this._nodes;
  }});
  Animation.prototype.getNodes = function() {
    return this._nodes;
  };
  Animation.prototype.setDuration = function(duration) {
    this.duration = duration;
  };
  Animation.prototype.setName = function(name) {
    this.name = name;
  };
  Animation.prototype.addNode = function(node) {
    this._nodes.push(node);
    this._nodeDict[node._name] = node;
  };
  return {Animation:Animation, Key:Key, Node:Node};
}());
Object.assign(pc, function() {
  function InterpolatedKey() {
    this._written = false;
    this._name = "";
    this._keyFrames = [];
    this._quat = new pc.Quat;
    this._pos = new pc.Vec3;
    this._scale = new pc.Vec3;
    this._targetNode = null;
  }
  Object.assign(InterpolatedKey.prototype, {getTarget:function() {
    return this._targetNode;
  }, setTarget:function(node) {
    this._targetNode = node;
  }});
  var Skeleton = function Skeleton(graph) {
    this._animation = null;
    this._time = 0;
    this.looping = true;
    this._interpolatedKeys = [];
    this._interpolatedKeyDict = {};
    this._currKeyIndices = {};
    this.graph = null;
    var self = this;
    function addInterpolatedKeys(node) {
      var interpKey = new InterpolatedKey;
      interpKey._name = node.name;
      self._interpolatedKeys.push(interpKey);
      self._interpolatedKeyDict[node.name] = interpKey;
      self._currKeyIndices[node.name] = 0;
      for (var i = 0;i < node._children.length;i++) {
        addInterpolatedKeys(node._children[i]);
      }
    }
    addInterpolatedKeys(graph);
  };
  Skeleton.prototype.addTime = function(delta) {
    if (this._animation !== null) {
      var i;
      var node, nodeName;
      var keys, interpKey;
      var k1, k2, alpha;
      var nodes = this._animation._nodes;
      var duration = this._animation.duration;
      if (this._time === duration && !this.looping) {
        return;
      }
      this._time += delta;
      if (this._time > duration) {
        this._time = this.looping ? 0.0 : duration;
        for (i = 0;i < nodes.length;i++) {
          node = nodes[i];
          nodeName = node._name;
          this._currKeyIndices[nodeName] = 0;
        }
      } else {
        if (this._time < 0) {
          this._time = this.looping ? duration : 0.0;
          for (i = 0;i < nodes.length;i++) {
            node = nodes[i];
            nodeName = node._name;
            this._currKeyIndices[nodeName] = node._keys.length - 2;
          }
        }
      }
      var offset = delta >= 0 ? 1 : -1;
      var foundKey;
      for (i = 0;i < nodes.length;i++) {
        node = nodes[i];
        nodeName = node._name;
        keys = node._keys;
        interpKey = this._interpolatedKeyDict[nodeName];
        foundKey = false;
        if (keys.length !== 1) {
          for (var currKeyIndex = this._currKeyIndices[nodeName];currKeyIndex < keys.length - 1 && currKeyIndex >= 0;currKeyIndex += offset) {
            k1 = keys[currKeyIndex];
            k2 = keys[currKeyIndex + 1];
            if (k1.time <= this._time && k2.time >= this._time) {
              alpha = (this._time - k1.time) / (k2.time - k1.time);
              interpKey._pos.lerp(k1.position, k2.position, alpha);
              interpKey._quat.slerp(k1.rotation, k2.rotation, alpha);
              interpKey._scale.lerp(k1.scale, k2.scale, alpha);
              interpKey._written = true;
              this._currKeyIndices[nodeName] = currKeyIndex;
              foundKey = true;
              break;
            }
          }
        }
        if (keys.length === 1 || !foundKey && this._time === 0.0 && this.looping) {
          interpKey._pos.copy(keys[0].position);
          interpKey._quat.copy(keys[0].rotation);
          interpKey._scale.copy(keys[0].scale);
          interpKey._written = true;
        }
      }
    }
  };
  Skeleton.prototype.blend = function(skel1, skel2, alpha) {
    var numNodes = this._interpolatedKeys.length;
    for (var i = 0;i < numNodes;i++) {
      var key1 = skel1._interpolatedKeys[i];
      var key2 = skel2._interpolatedKeys[i];
      var dstKey = this._interpolatedKeys[i];
      if (key1._written && key2._written) {
        dstKey._quat.slerp(key1._quat, skel2._interpolatedKeys[i]._quat, alpha);
        dstKey._pos.lerp(key1._pos, skel2._interpolatedKeys[i]._pos, alpha);
        dstKey._scale.lerp(key1._scale, key2._scale, alpha);
        dstKey._written = true;
      } else {
        if (key1._written) {
          dstKey._quat.copy(key1._quat);
          dstKey._pos.copy(key1._pos);
          dstKey._scale.copy(key1._scale);
          dstKey._written = true;
        } else {
          if (key2._written) {
            dstKey._quat.copy(key2._quat);
            dstKey._pos.copy(key2._pos);
            dstKey._scale.copy(key2._scale);
            dstKey._written = true;
          }
        }
      }
    }
  };
  Object.defineProperty(Skeleton.prototype, "animation", {get:function() {
    return this._animation;
  }, set:function(value) {
    this._animation = value;
    this.currentTime = 0;
  }});
  Skeleton.prototype.getAnimation = function() {
    return this._animation;
  };
  Object.defineProperty(Skeleton.prototype, "currentTime", {get:function() {
    return this._time;
  }, set:function(value) {
    this._time = value;
    var numNodes = this._interpolatedKeys.length;
    for (var i = 0;i < numNodes;i++) {
      var node = this._interpolatedKeys[i];
      var nodeName = node._name;
      this._currKeyIndices[nodeName] = 0;
    }
    this.addTime(0);
    this.updateGraph();
  }});
  Skeleton.prototype.getCurrentTime = function() {
    return this._time;
  };
  Skeleton.prototype.setCurrentTime = function(time) {
    this.currentTime = time;
  };
  Object.defineProperty(Skeleton.prototype, "numNodes", {get:function() {
    return this._interpolatedKeys.length;
  }});
  Skeleton.prototype.getNumNodes = function() {
    return this._interpolatedKeys.length;
  };
  Skeleton.prototype.setAnimation = function(animation) {
    this.animation = animation;
  };
  Skeleton.prototype.setGraph = function(graph) {
    var i;
    this.graph = graph;
    if (graph) {
      for (i = 0;i < this._interpolatedKeys.length;i++) {
        var interpKey = this._interpolatedKeys[i];
        var graphNode = graph.findByName(interpKey._name);
        this._interpolatedKeys[i].setTarget(graphNode);
      }
    } else {
      for (i = 0;i < this._interpolatedKeys.length;i++) {
        this._interpolatedKeys[i].setTarget(null);
      }
    }
  };
  Skeleton.prototype.updateGraph = function() {
    if (this.graph) {
      for (var i = 0;i < this._interpolatedKeys.length;i++) {
        var interpKey = this._interpolatedKeys[i];
        if (interpKey._written) {
          var transform = interpKey.getTarget();
          transform.localPosition.copy(interpKey._pos);
          transform.localRotation.copy(interpKey._quat);
          transform.localScale.copy(interpKey._scale);
          if (!transform._dirtyLocal) {
            transform._dirtify(true);
          }
          interpKey._written = false;
        }
      }
    }
  };
  Skeleton.prototype.setLooping = function(looping) {
    this.looping = looping;
  };
  Skeleton.prototype.getLooping = function() {
    return this.looping;
  };
  return {Skeleton:Skeleton};
}());
Object.assign(pc, function() {
  function hasAudio() {
    return typeof Audio !== "undefined";
  }
  function hasAudioContext() {
    return !!(typeof AudioContext !== "undefined" || typeof webkitAudioContext !== "undefined");
  }
  var SoundManager = function(options) {
    if (hasAudioContext() || options.forceWebAudioApi) {
      if (typeof AudioContext !== "undefined") {
        this.context = new AudioContext;
      } else {
        if (typeof webkitAudioContext !== "undefined") {
          this.context = new webkitAudioContext;
        }
      }
      if (this.context) {
        var context = this.context;
        if (pc.platform.ios) {
          var unlock = function() {
            var buffer = context.createBuffer(1, 1, 44100);
            var source = context.createBufferSource();
            source.buffer = buffer;
            source.connect(context.destination);
            source.start(0);
            source.disconnect();
            window.removeEventListener("touchend", unlock);
          };
          window.addEventListener("touchend", unlock);
        }
      }
    } else {
      console.warn("No support for 3D audio found");
    }
    if (!hasAudio()) {
      console.warn("No support for 2D audio found");
    }
    this.listener = new pc.Listener(this);
    this._volume = 1;
    this.suspended = false;
    pc.events.attach(this);
  };
  SoundManager.hasAudio = hasAudio;
  SoundManager.hasAudioContext = hasAudioContext;
  Object.assign(SoundManager.prototype, {suspend:function() {
    this.suspended = true;
    this.fire("suspend");
  }, resume:function() {
    this.suspended = false;
    this.fire("resume");
  }, destroy:function() {
    this.fire("destroy");
    if (this.context && this.context.close) {
      this.context.close();
      this.context = null;
    }
  }, getListener:function() {
    console.warn('DEPRECATED: getListener is deprecated. Get the "listener" field instead.');
    return this.listener;
  }, getVolume:function() {
    console.warn('DEPRECATED: getVolume is deprecated. Get the "volume" property instead.');
    return this.volume;
  }, setVolume:function(volume) {
    console.warn('DEPRECATED: setVolume is deprecated. Set the "volume" property instead.');
    this.volume = volume;
  }, playSound:function(sound, options) {
    options = options || {};
    var channel = null;
    if (pc.Channel) {
      channel = new pc.Channel(this, sound, options);
      channel.play();
    }
    return channel;
  }, playSound3d:function(sound, position, options) {
    options = options || {};
    var channel = null;
    if (pc.Channel3d) {
      channel = new pc.Channel3d(this, sound, options);
      channel.setPosition(position);
      if (options.volume) {
        channel.setVolume(options.volume);
      }
      if (options.loop) {
        channel.setLoop(options.loop);
      }
      if (options.maxDistance) {
        channel.setMaxDistance(options.maxDistance);
      }
      if (options.minDistance) {
        channel.setMinDistance(options.minDistance);
      }
      if (options.rollOffFactor) {
        channel.setRollOffFactor(options.rollOffFactor);
      }
      if (options.distanceModel) {
        channel.setDistanceModel(options.distanceModel);
      }
      channel.play();
    }
    return channel;
  }});
  Object.defineProperty(SoundManager.prototype, "volume", {get:function() {
    return this._volume;
  }, set:function(volume) {
    volume = pc.math.clamp(volume, 0, 1);
    this._volume = volume;
    this.fire("volumechange", volume);
  }});
  pc.AudioManager = SoundManager;
  return {SoundManager:SoundManager};
}());
Object.assign(pc, function() {
  var Sound = function(resource) {
    if (resource instanceof Audio) {
      this.audio = resource;
    } else {
      this.buffer = resource;
    }
  };
  Object.defineProperty(Sound.prototype, "duration", {get:function() {
    var duration = 0;
    if (this.buffer) {
      duration = this.buffer.duration;
    } else {
      if (this.audio) {
        duration = this.audio.duration;
      }
    }
    return duration || 0;
  }});
  return {Sound:Sound};
}());
Object.assign(pc, function() {
  var Listener = function(manager) {
    this.position = new pc.Vec3;
    this.velocity = new pc.Vec3;
    this.orientation = new pc.Mat4;
    if (pc.AudioManager.hasAudioContext()) {
      this.listener = manager.context.listener;
    }
  };
  Object.assign(Listener.prototype, {getPosition:function() {
    return this.position;
  }, setPosition:function(position) {
    this.position.copy(position);
    if (this.listener) {
      this.listener.setPosition(position.x, position.y, position.z);
    }
  }, getVelocity:function() {
    return this.velocity;
  }, setVelocity:function(velocity) {
    this.velocity.copy(velocity);
    if (this.listener) {
      this.listener.setPosition(velocity.x, velocity.y, velocity.z);
    }
  }, setOrientation:function(orientation) {
    this.orientation.copy(orientation);
    if (this.listener) {
      this.listener.setOrientation(-orientation.data[8], -orientation.data[9], -orientation.data[10], orientation.data[4], orientation.data[5], orientation.data[6]);
    }
  }, getOrientation:function() {
    return this.orientation;
  }});
  return {Listener:Listener};
}());
Object.assign(pc, function() {
  var SoundInstance;
  var STATE_PLAYING = 0;
  var STATE_PAUSED = 1;
  var STATE_STOPPED = 2;
  var capTime = function(time, duration) {
    return time % duration || 0;
  };
  if (pc.SoundManager.hasAudioContext()) {
    SoundInstance = function(manager, sound, options) {
      pc.events.attach(this);
      options = options || {};
      this._volume = options.volume !== undefined ? pc.math.clamp(Number(options.volume) || 0, 0, 1) : 1;
      this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
      this._loop = !!(options.loop !== undefined ? options.loop : false);
      this._sound = sound;
      this._state = STATE_STOPPED;
      this._suspended = false;
      this._suspendEndEvent = false;
      this._suspendInstanceEvents = false;
      this._startTime = Math.max(0, Number(options.startTime) || 0);
      this._duration = Math.max(0, Number(options.duration) || 0);
      this._startedAt = 0;
      this._startOffset = null;
      this._currentTime = 0;
      this._currentOffset = 0;
      this._playWhenLoaded = true;
      this._manager = manager;
      this._inputNode = null;
      this._connectorNode = null;
      this._firstNode = null;
      this._lastNode = null;
      this._initializeNodes();
      this._onPlayCallback = options.onPlay;
      this._onPauseCallback = options.onPause;
      this._onResumeCallback = options.onResume;
      this._onStopCallback = options.onStop;
      this._onEndCallback = options.onEnd;
      this._endedHandler = this._onEnded.bind(this);
      this.source = null;
    };
    Object.assign(SoundInstance.prototype, {_initializeNodes:function() {
      this.gain = this._manager.context.createGain();
      this._inputNode = this.gain;
      this._connectorNode = this.gain;
      this._connectorNode.connect(this._manager.context.destination);
    }, play:function() {
      if (this._state !== STATE_STOPPED) {
        this.stop();
      }
      if (!this.source) {
        this._createSource();
      }
      var offset = capTime(this._startOffset, this.duration);
      offset = capTime(this._startTime + offset, this._sound.duration);
      this._startOffset = null;
      if (this._duration) {
        this.source.start(0, offset, this._duration);
      } else {
        this.source.start(0, offset);
      }
      this._startedAt = this._manager.context.currentTime;
      this._currentTime = 0;
      this._currentOffset = offset;
      this._state = STATE_PLAYING;
      this._playWhenLoaded = false;
      this.volume = this._volume;
      this.loop = this._loop;
      this.pitch = this._pitch;
      this._manager.on("volumechange", this._onManagerVolumeChange, this);
      this._manager.on("suspend", this._onManagerSuspend, this);
      this._manager.on("resume", this._onManagerResume, this);
      this._manager.on("destroy", this._onManagerDestroy, this);
      if (this._manager.suspended) {
        this._onManagerSuspend();
      }
      if (!this._suspendInstanceEvents) {
        this._onPlay();
      }
      return true;
    }, pause:function() {
      if (this._state !== STATE_PLAYING || !this.source) {
        return false;
      }
      this._updateCurrentTime();
      this._state = STATE_PAUSED;
      this._suspendEndEvent = true;
      this.source.stop(0);
      this.source = null;
      this._playWhenLoaded = false;
      this._startOffset = null;
      if (!this._suspendInstanceEvents) {
        this._onPause();
      }
      return true;
    }, resume:function() {
      if (this._state !== STATE_PAUSED) {
        return false;
      }
      if (!this.source) {
        this._createSource();
      }
      var offset = this.currentTime;
      if (this._startOffset !== null) {
        offset = capTime(this._startOffset, this.duration);
        offset = capTime(this._startTime + offset, this._sound.duration);
        this._startOffset = null;
      }
      if (this._duration) {
        this.source.start(0, offset, this._duration);
      } else {
        this.source.start(0, offset);
      }
      this._state = STATE_PLAYING;
      this._startedAt = this._manager.context.currentTime;
      this._currentOffset = offset;
      this.volume = this._volume;
      this.loop = this._loop;
      this.pitch = this._pitch;
      this._playWhenLoaded = false;
      if (!this._suspendInstanceEvents) {
        this._onResume();
      }
      return true;
    }, stop:function() {
      if (this._state === STATE_STOPPED || !this.source) {
        return false;
      }
      this._manager.off("volumechange", this._onManagerVolumeChange, this);
      this._manager.off("suspend", this._onManagerSuspend, this);
      this._manager.off("resume", this._onManagerResume, this);
      this._manager.off("destroy", this._onManagerDestroy, this);
      this._startedAt = 0;
      this._currentTime = 0;
      this._currentOffset = 0;
      this._startOffset = null;
      this._playWhenLoaded = false;
      this._suspendEndEvent = true;
      if (this._state === STATE_PLAYING) {
        this.source.stop(0);
      }
      this.source = null;
      this._state = STATE_STOPPED;
      if (!this._suspendInstanceEvents) {
        this._onStop();
      }
      return true;
    }, setExternalNodes:function(firstNode, lastNode) {
      if (!firstNode) {
        console.error("The firstNode must be a valid Audio Node");
        return;
      }
      if (!lastNode) {
        lastNode = firstNode;
      }
      var speakers = this._manager.context.destination;
      if (this._firstNode !== firstNode) {
        if (this._firstNode) {
          this._connectorNode.disconnect(this._firstNode);
        } else {
          this._connectorNode.disconnect(speakers);
        }
        this._firstNode = firstNode;
        this._connectorNode.connect(firstNode);
      }
      if (this._lastNode !== lastNode) {
        if (this._lastNode) {
          this._lastNode.disconnect(speakers);
        }
        this._lastNode = lastNode;
        this._lastNode.connect(speakers);
      }
    }, clearExternalNodes:function() {
      var speakers = this._manager.context.destination;
      if (this._firstNode) {
        this._connectorNode.disconnect(this._firstNode);
        this._firstNode = null;
      }
      if (this._lastNode) {
        this._lastNode.disconnect(speakers);
        this._lastNode = null;
      }
      this._connectorNode.connect(speakers);
    }, getExternalNodes:function() {
      return [this._firstNode, this._lastNode];
    }, _createSource:function() {
      if (!this._sound) {
        return null;
      }
      var context = this._manager.context;
      if (this._sound.buffer) {
        this.source = context.createBufferSource();
        this.source.buffer = this._sound.buffer;
        this.source.connect(this._inputNode);
        this.source.onended = this._endedHandler;
        this.source.loopStart = capTime(this._startTime, this.source.buffer.duration);
        if (this._duration) {
          this.source.loopEnd = Math.max(this.source.loopStart, capTime(this._startTime + this._duration, this.source.buffer.duration));
        }
      }
      return this.source;
    }, _updateCurrentTime:function() {
      this._currentTime = capTime((this._manager.context.currentTime - this._startedAt) * this.pitch + this._currentOffset, this.duration);
    }, _onManagerDestroy:function() {
      if (this.source && this.isPlaying) {
        this.source.stop(0);
        this.source = null;
      }
    }});
    Object.defineProperty(SoundInstance.prototype, "volume", {get:function() {
      return this._volume;
    }, set:function(volume) {
      volume = pc.math.clamp(volume, 0, 1);
      this._volume = volume;
      if (this.gain) {
        this.gain.gain.value = volume * this._manager.volume;
      }
    }});
    Object.defineProperty(SoundInstance.prototype, "pitch", {get:function() {
      return this._pitch;
    }, set:function(pitch) {
      this._currentOffset = this.currentTime;
      this._startedAt = this._manager.context.currentTime;
      this._pitch = Math.max(Number(pitch) || 0, 0.01);
      if (this.source) {
        this.source.playbackRate.value = this._pitch;
      }
    }});
    Object.defineProperty(SoundInstance.prototype, "loop", {get:function() {
      return this._loop;
    }, set:function(loop) {
      this._loop = !!loop;
      if (this.source) {
        this.source.loop = this._loop;
      }
    }});
    Object.defineProperty(SoundInstance.prototype, "sound", {get:function() {
      return this._sound;
    }, set:function(value) {
      this._sound = value;
      if (!this.isStopped) {
        this.stop();
      } else {
        this._createSource();
      }
    }});
    Object.defineProperty(SoundInstance.prototype, "currentTime", {get:function() {
      if (this._startOffset !== null) {
        return this._startOffset;
      }
      if (this.isPaused) {
        return this._currentTime;
      }
      if (this.isStopped || !this.source) {
        return 0;
      }
      this._updateCurrentTime();
      return this._currentTime;
    }, set:function(value) {
      if (value < 0) {
        return;
      }
      if (this.isPlaying) {
        this.stop();
        var suspend = this._suspendInstanceEvents;
        this._suspendInstanceEvents = true;
        this._startOffset = value;
        this.play();
        this._suspendInstanceEvents = suspend;
      } else {
        this._startOffset = value;
        this._currentTime = value;
      }
    }});
  } else {
    if (pc.SoundManager.hasAudio()) {
      SoundInstance = function(manager, resource, options) {
        pc.events.attach(this);
        options = options || {};
        this._volume = options.volume !== undefined ? pc.math.clamp(Number(options.volume) || 0, 0, 1) : 1;
        this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
        this._loop = !!(options.loop !== undefined ? options.loop : false);
        this._sound = resource;
        this._state = STATE_STOPPED;
        this._suspended = false;
        this._suspendEndEvent = false;
        this._suspendInstanceEvents = false;
        this._playWhenLoaded = true;
        this._startTime = Math.max(0, Number(options.startTime) || 0);
        this._duration = Math.max(0, Number(options.duration) || 0);
        this._startOffset = null;
        this._isReady = false;
        this._manager = manager;
        this._loadedMetadataHandler = this._onLoadedMetadata.bind(this);
        this._timeUpdateHandler = this._onTimeUpdate.bind(this);
        this._endedHandler = this._onEnded.bind(this);
        this._onPlayCallback = options.onPlay;
        this._onPauseCallback = options.onPause;
        this._onResumeCallback = options.onResume;
        this._onStopCallback = options.onStop;
        this._onEndCallback = options.onEnd;
        this.source = null;
        this._createSource();
      };
      Object.assign(SoundInstance.prototype, {play:function() {
        if (this._state !== STATE_STOPPED) {
          this.stop();
        }
        if (!this.source) {
          if (!this._createSource()) {
            return false;
          }
        }
        this.volume = this._volume;
        this.pitch = this._pitch;
        this.loop = this._loop;
        this.source.play();
        this._state = STATE_PLAYING;
        this._playWhenLoaded = false;
        this._manager.on("volumechange", this._onManagerVolumeChange, this);
        this._manager.on("suspend", this._onManagerSuspend, this);
        this._manager.on("resume", this._onManagerResume, this);
        this._manager.on("destroy", this._onManagerDestroy, this);
        if (this._manager.suspended) {
          this._onManagerSuspend();
        }
        if (!this._suspendInstanceEvents) {
          this._onPlay();
        }
        return true;
      }, pause:function() {
        if (!this.source || this._state !== STATE_PLAYING) {
          return false;
        }
        this._suspendEndEvent = true;
        this.source.pause();
        this._playWhenLoaded = false;
        this._state = STATE_PAUSED;
        this._startOffset = null;
        if (!this._suspendInstanceEvents) {
          this._onPause();
        }
        return true;
      }, resume:function() {
        if (!this.source || this._state !== STATE_PAUSED) {
          return false;
        }
        this._state = STATE_PLAYING;
        this._playWhenLoaded = false;
        if (this.source.paused) {
          this.source.play();
          if (!this._suspendInstanceEvents) {
            this._onResume();
          }
        }
        return true;
      }, stop:function() {
        if (!this.source || this._state === STATE_STOPPED) {
          return false;
        }
        this._manager.off("volumechange", this._onManagerVolumeChange, this);
        this._manager.off("suspend", this._onManagerSuspend, this);
        this._manager.off("resume", this._onManagerResume, this);
        this._manager.off("destroy", this._onManagerDestroy, this);
        this._suspendEndEvent = true;
        this.source.pause();
        this._playWhenLoaded = false;
        this._state = STATE_STOPPED;
        this._startOffset = null;
        if (!this._suspendInstanceEvents) {
          this._onStop();
        }
        return true;
      }, setExternalNodes:function() {
      }, clearExternalNodes:function() {
      }, getExternalNodes:function() {
        return [null, null];
      }, _onLoadedMetadata:function() {
        this.source.removeEventListener("loadedmetadata", this._loadedMetadataHandler);
        this._isReady = true;
        var offset = capTime(this._startOffset, this.duration);
        offset = capTime(this._startTime + offset, this._sound.duration);
        this._startOffset = null;
        this.source.currentTime = offset;
      }, _createSource:function() {
        if (this._sound && this._sound.audio) {
          this._isReady = false;
          this.source = this._sound.audio.cloneNode(true);
          this.source.addEventListener("loadedmetadata", this._loadedMetadataHandler);
          this.source.addEventListener("timeupdate", this._timeUpdateHandler);
          this.source.onended = this._endedHandler;
        }
        return this.source;
      }, _onTimeUpdate:function() {
        if (!this._duration) {
          return;
        }
        if (this.source.currentTime > capTime(this._startTime + this._duration, this.source.duration)) {
          if (this.loop) {
            this.source.currentTime = capTime(this._startTime, this.source.duration);
          } else {
            this.source.removeEventListener("timeupdate", this._timeUpdateHandler);
            this.source.pause();
            this._onEnded();
          }
        }
      }, _onManagerDestroy:function() {
        if (this.source) {
          this.source.pause();
        }
      }});
      Object.defineProperty(SoundInstance.prototype, "volume", {get:function() {
        return this._volume;
      }, set:function(volume) {
        volume = pc.math.clamp(volume, 0, 1);
        this._volume = volume;
        if (this.source) {
          this.source.volume = volume * this._manager.volume;
        }
      }});
      Object.defineProperty(SoundInstance.prototype, "pitch", {get:function() {
        return this._pitch;
      }, set:function(pitch) {
        this._pitch = Math.max(Number(pitch) || 0, 0.01);
        if (this.source) {
          this.source.playbackRate = this._pitch;
        }
      }});
      Object.defineProperty(SoundInstance.prototype, "loop", {get:function() {
        return this._loop;
      }, set:function(loop) {
        this._loop = !!loop;
        if (this.source) {
          this.source.loop = this._loop;
        }
      }});
      Object.defineProperty(SoundInstance.prototype, "sound", {get:function() {
        return this._sound;
      }, set:function(value) {
        this.stop();
        this._sound = value;
      }});
      Object.defineProperty(SoundInstance.prototype, "currentTime", {get:function() {
        if (this._startOffset !== null) {
          return this._startOffset;
        }
        if (this.isStopped || !this.source) {
          return 0;
        }
        return this.source.currentTime - this._startTime;
      }, set:function(value) {
        if (value < 0) {
          return;
        }
        this._startOffset = value;
        if (this.source && this._isReady) {
          this.source.currentTime = capTime(this._startTime + capTime(value, this.duration), this._sound.duration);
          this._startOffset = null;
        }
      }});
    } else {
      SoundInstance = function() {
      };
    }
  }
  Object.assign(SoundInstance.prototype, {_onPlay:function() {
    this.fire("play");
    if (this._onPlayCallback) {
      this._onPlayCallback(this);
    }
  }, _onPause:function() {
    this.fire("pause");
    if (this._onPauseCallback) {
      this._onPauseCallback(this);
    }
  }, _onResume:function() {
    this.fire("resume");
    if (this._onResumeCallback) {
      this._onResumeCallback(this);
    }
  }, _onStop:function() {
    this.fire("stop");
    if (this._onStopCallback) {
      this._onStopCallback(this);
    }
  }, _onEnded:function() {
    if (this._suspendEndEvent) {
      this._suspendEndEvent = false;
      return;
    }
    this.fire("end");
    if (this._onEndCallback) {
      this._onEndCallback(this);
    }
    this.stop();
  }, _onManagerVolumeChange:function() {
    this.volume = this._volume;
  }, _onManagerSuspend:function() {
    if (this.isPlaying && !this._suspended) {
      this._suspended = true;
      this.pause();
    }
  }, _onManagerResume:function() {
    if (this._suspended) {
      this._suspended = false;
      this.resume();
    }
  }});
  Object.defineProperty(SoundInstance.prototype, "startTime", {get:function() {
    return this._startTime;
  }, set:function(value) {
    this._startTime = Math.max(0, Number(value) || 0);
    var isPlaying = this.isPlaying;
    this.stop();
    if (isPlaying) {
      this.play();
    }
  }});
  Object.defineProperty(SoundInstance.prototype, "duration", {get:function() {
    if (!this._sound) {
      return 0;
    }
    if (this._duration) {
      return capTime(this._duration, this._sound.duration);
    }
    return this._sound.duration;
  }, set:function(value) {
    this._duration = Math.max(0, Number(value) || 0);
    var isPlaying = this.isPlaying;
    this.stop();
    if (isPlaying) {
      this.play();
    }
  }});
  Object.defineProperty(SoundInstance.prototype, "isPlaying", {get:function() {
    return this._state === STATE_PLAYING;
  }});
  Object.defineProperty(SoundInstance.prototype, "isPaused", {get:function() {
    return this._state === STATE_PAUSED;
  }});
  Object.defineProperty(SoundInstance.prototype, "isStopped", {get:function() {
    return this._state === STATE_STOPPED;
  }});
  Object.defineProperty(SoundInstance.prototype, "isSuspended", {get:function() {
    return this._suspended;
  }});
  return {SoundInstance:SoundInstance};
}());
Object.assign(pc, function() {
  var MAX_DISTANCE = 10000;
  var SoundInstance3d;
  if (pc.SoundManager.hasAudioContext()) {
    SoundInstance3d = function(manager, sound, options) {
      pc.SoundInstance.call(this, manager, sound, options);
      options = options || {};
      this._position = new pc.Vec3;
      if (options.position) {
        this.position = options.position;
      }
      this._velocity = new pc.Vec3;
      if (options.velocity) {
        this.velocity = options.velocity;
      }
      this.maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE;
      this.refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;
      this.rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;
      this.distanceModel = options.distanceModel !== undefined ? options.distanceModel : pc.DISTANCE_LINEAR;
    };
    SoundInstance3d.prototype = Object.create(pc.SoundInstance.prototype);
    SoundInstance3d.prototype.constructor = SoundInstance3d;
    Object.assign(SoundInstance3d.prototype, {_initializeNodes:function() {
      this.gain = this._manager.context.createGain();
      this.panner = this._manager.context.createPanner();
      this.panner.connect(this.gain);
      this._inputNode = this.panner;
      this._connectorNode = this.gain;
      this._connectorNode.connect(this._manager.context.destination);
    }});
    Object.defineProperty(SoundInstance3d.prototype, "position", {get:function() {
      return this._position;
    }, set:function(position) {
      this._position.copy(position);
      this.panner.setPosition(position.x, position.y, position.z);
    }});
    Object.defineProperty(SoundInstance3d.prototype, "velocity", {get:function() {
      return this._velocity;
    }, set:function(velocity) {
      this._velocity.copy(velocity);
      this.panner.setVelocity(velocity.x, velocity.y, velocity.z);
    }});
    Object.defineProperty(SoundInstance3d.prototype, "maxDistance", {get:function() {
      return this.panner.maxDistance;
    }, set:function(value) {
      this.panner.maxDistance = value;
    }});
    Object.defineProperty(SoundInstance3d.prototype, "refDistance", {get:function() {
      return this.panner.refDistance;
    }, set:function(value) {
      this.panner.refDistance = value;
    }});
    Object.defineProperty(SoundInstance3d.prototype, "rollOffFactor", {get:function() {
      return this.panner.rolloffFactor;
    }, set:function(value) {
      this.panner.rolloffFactor = value;
    }});
    Object.defineProperty(SoundInstance3d.prototype, "distanceModel", {get:function() {
      return this.panner.distanceModel;
    }, set:function(value) {
      this.panner.distanceModel = value;
    }});
  } else {
    if (pc.SoundManager.hasAudio()) {
      var offset = new pc.Vec3;
      var fallOff = function(posOne, posTwo, refDistance, maxDistance, rollOffFactor, distanceModel) {
        offset = offset.sub2(posOne, posTwo);
        var distance = offset.length();
        if (distance < refDistance) {
          return 1;
        } else {
          if (distance > maxDistance) {
            return 0;
          }
        }
        var result = 0;
        if (distanceModel === pc.DISTANCE_LINEAR) {
          result = 1 - rollOffFactor * (distance - refDistance) / (maxDistance - refDistance);
        } else {
          if (distanceModel === pc.DISTANCE_INVERSE) {
            result = refDistance / (refDistance + rollOffFactor * (distance - refDistance));
          } else {
            if (distanceModel === pc.DISTANCE_EXPONENTIAL) {
              result = Math.pow(distance / refDistance, -rollOffFactor);
            }
          }
        }
        return pc.math.clamp(result, 0, 1);
      };
      SoundInstance3d = function(manager, sound, options) {
        pc.SoundInstance.call(this, manager, sound, options);
        options = options || {};
        this._position = new pc.Vec3;
        if (options.position) {
          this.position = options.position;
        }
        this._velocity = new pc.Vec3;
        if (options.velocity) {
          this.velocity = options.velocity;
        }
        this._maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE;
        this._refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;
        this._rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;
        this._distanceModel = options.distanceModel !== undefined ? options.distanceModel : pc.DISTANCE_LINEAR;
      };
      SoundInstance3d.prototype = Object.create(pc.SoundInstance.prototype);
      SoundInstance3d.prototype.constructor = SoundInstance3d;
      Object.defineProperty(SoundInstance3d.prototype, "position", {get:function() {
        return this._position;
      }, set:function(position) {
        this._position.copy(position);
        if (this.source) {
          var listener = this._manager.listener;
          var lpos = listener.getPosition();
          var factor = fallOff(lpos, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
          var v = this.volume;
          this.source.volume = v * factor * this._manager.volume;
        }
      }});
      Object.defineProperty(SoundInstance3d.prototype, "velocity", {get:function() {
        return this._velocity;
      }, set:function(velocity) {
        this._velocity.copy(velocity);
      }});
      Object.defineProperty(SoundInstance3d.prototype, "maxDistance", {get:function() {
        return this._maxDistance;
      }, set:function(value) {
        this._maxDistance = value;
      }});
      Object.defineProperty(SoundInstance3d.prototype, "refDistance", {get:function() {
        return this._refDistance;
      }, set:function(value) {
        this._refDistance = value;
      }});
      Object.defineProperty(SoundInstance3d.prototype, "rollOffFactor", {get:function() {
        return this._rollOffFactor;
      }, set:function(value) {
        this._rollOffFactor = value;
      }});
      Object.defineProperty(SoundInstance3d.prototype, "distanceModel", {get:function() {
        return this._distanceModel;
      }, set:function(value) {
        this._distanceModel = value;
      }});
    } else {
      SoundInstance3d = function() {
      };
    }
  }
  return {SoundInstance3d:SoundInstance3d};
}());
Object.assign(pc, function() {
  var Channel;
  if (pc.AudioManager.hasAudioContext()) {
    Channel = function(manager, sound, options) {
      options = options || {};
      this.volume = options.volume === undefined ? 1 : options.volume;
      this.loop = options.loop === undefined ? false : options.loop;
      this.pitch = options.pitch === undefined ? 1 : options.pitch;
      this.sound = sound;
      this.paused = false;
      this.suspended = false;
      this.startTime = 0;
      this.startOffset = 0;
      this.manager = manager;
      this.source = null;
      var context = manager.context;
      this.gain = context.createGain();
    };
    Object.assign(Channel.prototype, {play:function() {
      if (this.source) {
        throw new Error("Call stop() before calling play()");
      }
      this._createSource();
      if (!this.source) {
        return;
      }
      this.startTime = this.manager.context.currentTime;
      this.source.start(0, this.startOffset % this.source.buffer.duration);
      this.setVolume(this.volume);
      this.setLoop(this.loop);
      this.setPitch(this.pitch);
      this.manager.on("volumechange", this.onManagerVolumeChange, this);
      this.manager.on("suspend", this.onManagerSuspend, this);
      this.manager.on("resume", this.onManagerResume, this);
      if (this.manager.suspended) {
        this.onManagerSuspend();
      }
    }, pause:function() {
      if (this.source) {
        this.paused = true;
        this.startOffset += this.manager.context.currentTime - this.startTime;
        this.source.stop(0);
        this.source = null;
      }
    }, unpause:function() {
      if (this.source || !this.paused) {
        console.warn("Call pause() before unpausing.");
        return;
      }
      this._createSource();
      if (!this.source) {
        return;
      }
      this.startTime = this.manager.context.currentTime;
      this.source.start(0, this.startOffset % this.source.buffer.duration);
      this.setVolume(this.volume);
      this.setLoop(this.loop);
      this.setPitch(this.pitch);
      this.paused = false;
    }, stop:function() {
      if (this.source) {
        this.source.stop(0);
        this.source = null;
      }
      this.manager.off("volumechange", this.onManagerVolumeChange, this);
      this.manager.off("suspend", this.onManagerSuspend, this);
      this.manager.off("resume", this.onManagerResume, this);
    }, setLoop:function(loop) {
      this.loop = loop;
      if (this.source) {
        this.source.loop = loop;
      }
    }, setVolume:function(volume) {
      volume = pc.math.clamp(volume, 0, 1);
      this.volume = volume;
      if (this.gain) {
        this.gain.gain.value = volume * this.manager.volume;
      }
    }, setPitch:function(pitch) {
      this.pitch = pitch;
      if (this.source) {
        this.source.playbackRate.value = pitch;
      }
    }, isPlaying:function() {
      return !this.paused && this.source.playbackState === this.source.PLAYING_STATE;
    }, getDuration:function() {
      return this.source ? this.source.buffer.duration : 0;
    }, _createSource:function() {
      var context = this.manager.context;
      if (this.sound.buffer) {
        this.source = context.createBufferSource();
        this.source.buffer = this.sound.buffer;
        this.source.connect(this.gain);
        this.gain.connect(context.destination);
        if (!this.loop) {
          this.source.onended = this.pause.bind(this);
        }
      }
    }});
  } else {
    if (pc.AudioManager.hasAudio()) {
      Channel = function(manager, sound, options) {
        this.volume = options.volume || 1;
        this.loop = options.loop || false;
        this.sound = sound;
        this.pitch = options.pitch !== undefined ? options.pitch : 1;
        this.paused = false;
        this.suspended = false;
        this.manager = manager;
        if (sound.audio) {
          this.source = sound.audio.cloneNode(false);
          this.source.pause();
        }
      };
      Object.assign(Channel.prototype, {play:function() {
        if (this.source) {
          this.paused = false;
          this.setVolume(this.volume);
          this.setLoop(this.loop);
          this.setPitch(this.pitch);
          this.source.play();
        }
        this.manager.on("volumechange", this.onManagerVolumeChange, this);
        this.manager.on("suspend", this.onManagerSuspend, this);
        this.manager.on("resume", this.onManagerResume, this);
        if (this.manager.suspended) {
          this.onManagerSuspend();
        }
      }, pause:function() {
        if (this.source) {
          this.paused = true;
          this.source.pause();
        }
      }, unpause:function() {
        if (this.source) {
          this.paused = false;
          this.source.play();
        }
      }, stop:function() {
        if (this.source) {
          this.source.pause();
        }
        this.manager.off("volumechange", this.onManagerVolumeChange, this);
        this.manager.off("suspend", this.onManagerSuspend, this);
        this.manager.off("resume", this.onManagerResume, this);
      }, setVolume:function(volume) {
        volume = pc.math.clamp(volume, 0, 1);
        this.volume = volume;
        if (this.source) {
          this.source.volume = volume * this.manager.volume;
        }
      }, setLoop:function(loop) {
        this.loop = loop;
        if (this.source) {
          this.source.loop = loop;
        }
      }, setPitch:function(pitch) {
        this.pitch = pitch;
        if (this.source) {
          this.source.playbackRate = pitch;
        }
      }, getDuration:function() {
        return this.source && !isNaN(this.source.duration) ? this.source.duration : 0;
      }, isPlaying:function() {
        return !this.source.paused;
      }});
    } else {
      Channel = function() {
      };
    }
  }
  Object.assign(Channel.prototype, {getVolume:function() {
    return this.volume;
  }, getLoop:function() {
    return this.loop;
  }, getPitch:function() {
    return this.pitch;
  }, onManagerVolumeChange:function() {
    this.setVolume(this.getVolume());
  }, onManagerSuspend:function() {
    if (this.isPlaying() && !this.suspended) {
      this.suspended = true;
      this.pause();
    }
  }, onManagerResume:function() {
    if (this.suspended) {
      this.suspended = false;
      this.unpause();
    }
  }});
  return {Channel:Channel};
}());
Object.assign(pc, function() {
  var MAX_DISTANCE = 10000;
  var Channel3d;
  if (pc.AudioManager.hasAudioContext()) {
    Channel3d = function(manager, sound, options) {
      pc.Channel.call(this, manager, sound, options);
      this.position = new pc.Vec3;
      this.velocity = new pc.Vec3;
      var context = manager.context;
      this.panner = context.createPanner();
    };
    Channel3d.prototype = Object.create(pc.Channel.prototype);
    Channel3d.prototype.constructor = Channel3d;
    Object.assign(Channel3d.prototype, {getPosition:function() {
      return this.position;
    }, setPosition:function(position) {
      this.position.copy(position);
      this.panner.setPosition(position.x, position.y, position.z);
    }, getVelocity:function() {
      return this.velocity;
    }, setVelocity:function(velocity) {
      this.velocity.copy(velocity);
      this.panner.setVelocity(velocity.x, velocity.y, velocity.z);
    }, getMaxDistance:function() {
      return this.panner.maxDistance;
    }, setMaxDistance:function(max) {
      this.panner.maxDistance = max;
    }, getMinDistance:function() {
      return this.panner.refDistance;
    }, setMinDistance:function(min) {
      this.panner.refDistance = min;
    }, getRollOffFactor:function() {
      return this.panner.rolloffFactor;
    }, setRollOffFactor:function(factor) {
      this.panner.rolloffFactor = factor;
    }, getDistanceModel:function() {
      return this.pannel.distanceModel;
    }, setDistanceModel:function(distanceModel) {
      this.panner.distanceModel = distanceModel;
    }, _createSource:function() {
      var context = this.manager.context;
      this.source = context.createBufferSource();
      this.source.buffer = this.sound.buffer;
      this.source.connect(this.panner);
      this.panner.connect(this.gain);
      this.gain.connect(context.destination);
      if (!this.loop) {
        this.source.onended = this.pause.bind(this);
      }
    }});
  } else {
    if (pc.AudioManager.hasAudio()) {
      var offset = new pc.Vec3;
      var fallOff = function(posOne, posTwo, refDistance, maxDistance, rolloffFactor, distanceModel) {
        offset = offset.sub2(posOne, posTwo);
        var distance = offset.length();
        if (distance < refDistance) {
          return 1;
        } else {
          if (distance > maxDistance) {
            return 0;
          }
        }
        var result = 0;
        if (distanceModel === pc.DISTANCE_LINEAR) {
          result = 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance);
        } else {
          if (distanceModel === pc.DISTANCE_INVERSE) {
            result = refDistance / (refDistance + rolloffFactor * (distance - refDistance));
          } else {
            if (distanceModel === pc.DISTANCE_EXPONENTIAL) {
              result = Math.pow(distance / refDistance, -rolloffFactor);
            }
          }
        }
        return pc.math.clamp(result, 0, 1);
      };
      Channel3d = function(manager, sound) {
        pc.Channel.call(this, manager, sound);
        this.position = new pc.Vec3;
        this.velocity = new pc.Vec3;
        this.maxDistance = MAX_DISTANCE;
        this.minDistance = 1;
        this.rollOffFactor = 1;
        this.distanceModel = pc.DISTANCE_INVERSE;
      };
      Channel3d.prototype = Object.create(pc.Channel.prototype);
      Channel3d.prototype.constructor = Channel3d;
      Object.assign(Channel3d.prototype, {getPosition:function() {
        return this.position;
      }, setPosition:function(position) {
        this.position.copy(position);
        if (this.source) {
          var listener = this.manager.listener;
          var lpos = listener.getPosition();
          var factor = fallOff(lpos, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
          var v = this.getVolume();
          this.source.volume = v * factor;
        }
      }, getVelocity:function() {
        return this.velocity;
      }, setVelocity:function(velocity) {
        this.velocity.copy(velocity);
      }, getMaxDistance:function() {
        return this.maxDistance;
      }, setMaxDistance:function(max) {
        this.maxDistance = max;
      }, getMinDistance:function() {
        return this.minDistance;
      }, setMinDistance:function(min) {
        this.minDistance = min;
      }, getRollOffFactor:function() {
        return this.rollOffFactor;
      }, setRollOffFactor:function(factor) {
        this.rollOffFactor = factor;
      }, getDistanceModel:function() {
        return this.distanceModel;
      }, setDistanceModel:function(distanceModel) {
        this.distanceModel = distanceModel;
      }});
    } else {
      Channel3d = function() {
      };
    }
  }
  return {Channel3d:Channel3d};
}());
(function() {
  var enums = {ACTION_MOUSE:"mouse", ACTION_KEYBOARD:"keyboard", ACTION_GAMEPAD:"gamepad", AXIS_MOUSE_X:"mousex", AXIS_MOUSE_Y:"mousey", AXIS_PAD_L_X:"padlx", AXIS_PAD_L_Y:"padly", AXIS_PAD_R_X:"padrx", AXIS_PAD_R_Y:"padry", AXIS_KEY:"key", EVENT_KEYDOWN:"keydown", EVENT_KEYUP:"keyup", EVENT_MOUSEDOWN:"mousedown", EVENT_MOUSEMOVE:"mousemove", EVENT_MOUSEUP:"mouseup", EVENT_MOUSEWHEEL:"mousewheel", EVENT_TOUCHSTART:"touchstart", EVENT_TOUCHEND:"touchend", EVENT_TOUCHMOVE:"touchmove", EVENT_TOUCHCANCEL:"touchcancel", 
  KEY_BACKSPACE:8, KEY_TAB:9, KEY_RETURN:13, KEY_ENTER:13, KEY_SHIFT:16, KEY_CONTROL:17, KEY_ALT:18, KEY_PAUSE:19, KEY_CAPS_LOCK:20, KEY_ESCAPE:27, KEY_SPACE:32, KEY_PAGE_UP:33, KEY_PAGE_DOWN:34, KEY_END:35, KEY_HOME:36, KEY_LEFT:37, KEY_UP:38, KEY_RIGHT:39, KEY_DOWN:40, KEY_PRINT_SCREEN:44, KEY_INSERT:45, KEY_DELETE:46, KEY_0:48, KEY_1:49, KEY_2:50, KEY_3:51, KEY_4:52, KEY_5:53, KEY_6:54, KEY_7:55, KEY_8:56, KEY_9:57, KEY_SEMICOLON:59, KEY_EQUAL:61, KEY_A:65, KEY_B:66, KEY_C:67, KEY_D:68, KEY_E:69, 
  KEY_F:70, KEY_G:71, KEY_H:72, KEY_I:73, KEY_J:74, KEY_K:75, KEY_L:76, KEY_M:77, KEY_N:78, KEY_O:79, KEY_P:80, KEY_Q:81, KEY_R:82, KEY_S:83, KEY_T:84, KEY_U:85, KEY_V:86, KEY_W:87, KEY_X:88, KEY_Y:89, KEY_Z:90, KEY_WINDOWS:91, KEY_CONTEXT_MENU:93, KEY_NUMPAD_0:96, KEY_NUMPAD_1:97, KEY_NUMPAD_2:98, KEY_NUMPAD_3:99, KEY_NUMPAD_4:100, KEY_NUMPAD_5:101, KEY_NUMPAD_6:102, KEY_NUMPAD_7:103, KEY_NUMPAD_8:104, KEY_NUMPAD_9:105, KEY_MULTIPLY:106, KEY_ADD:107, KEY_SEPARATOR:108, KEY_SUBTRACT:109, KEY_DECIMAL:110, 
  KEY_DIVIDE:111, KEY_F1:112, KEY_F2:113, KEY_F3:114, KEY_F4:115, KEY_F5:116, KEY_F6:117, KEY_F7:118, KEY_F8:119, KEY_F9:120, KEY_F10:121, KEY_F11:122, KEY_F12:123, KEY_COMMA:188, KEY_PERIOD:190, KEY_SLASH:191, KEY_OPEN_BRACKET:219, KEY_BACK_SLASH:220, KEY_CLOSE_BRACKET:221, KEY_META:224, MOUSEBUTTON_NONE:-1, MOUSEBUTTON_LEFT:0, MOUSEBUTTON_MIDDLE:1, MOUSEBUTTON_RIGHT:2, PAD_1:0, PAD_2:1, PAD_3:2, PAD_4:3, PAD_FACE_1:0, PAD_FACE_2:1, PAD_FACE_3:2, PAD_FACE_4:3, PAD_L_SHOULDER_1:4, PAD_R_SHOULDER_1:5, 
  PAD_L_SHOULDER_2:6, PAD_R_SHOULDER_2:7, PAD_SELECT:8, PAD_START:9, PAD_L_STICK_BUTTON:10, PAD_R_STICK_BUTTON:11, PAD_UP:12, PAD_DOWN:13, PAD_LEFT:14, PAD_RIGHT:15, PAD_VENDOR:16, PAD_L_STICK_X:0, PAD_L_STICK_Y:1, PAD_R_STICK_X:2, PAD_R_STICK_Y:3};
  Object.assign(pc, enums);
  pc.input = {};
  Object.assign(pc.input, enums);
})();
Object.assign(pc, function() {
  var MouseEvent = function(mouse, event) {
    var coords = {x:0, y:0};
    if (event) {
      if (event instanceof MouseEvent) {
        throw Error("Expected MouseEvent");
      }
      coords = mouse._getTargetCoords(event);
    } else {
      event = {};
    }
    if (coords) {
      this.x = coords.x;
      this.y = coords.y;
    } else {
      if (pc.Mouse.isPointerLocked()) {
        this.x = 0;
        this.y = 0;
      } else {
        return;
      }
    }
    if (event.detail) {
      this.wheel = -1 * event.detail;
    } else {
      if (event.wheelDelta) {
        this.wheel = event.wheelDelta / 120;
      } else {
        this.wheel = 0;
      }
    }
    if (pc.Mouse.isPointerLocked()) {
      this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
      this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
    } else {
      this.dx = this.x - mouse._lastX;
      this.dy = this.y - mouse._lastY;
    }
    if (event.type === "mousedown" || event.type === "mouseup") {
      this.button = event.button;
    } else {
      this.button = pc.MOUSEBUTTON_NONE;
    }
    this.buttons = mouse._buttons.slice(0);
    this.element = event.target;
    this.ctrlKey = event.ctrlKey || false;
    this.altKey = event.altKey || false;
    this.shiftKey = event.shiftKey || false;
    this.metaKey = event.metaKey || false;
    this.event = event;
  };
  var Mouse = function(element) {
    this._lastX = 0;
    this._lastY = 0;
    this._buttons = [false, false, false];
    this._lastbuttons = [false, false, false];
    this._upHandler = this._handleUp.bind(this);
    this._downHandler = this._handleDown.bind(this);
    this._moveHandler = this._handleMove.bind(this);
    this._wheelHandler = this._handleWheel.bind(this);
    this._contextMenuHandler = function(event) {
      event.preventDefault();
    };
    this._target = null;
    this._attached = false;
    this.attach(element);
    pc.events.attach(this);
  };
  Mouse.isPointerLocked = function() {
    return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);
  };
  Object.assign(Mouse.prototype, {attach:function(element) {
    this._target = element;
    if (this._attached) {
      return;
    }
    this._attached = true;
    window.addEventListener("mouseup", this._upHandler, false);
    window.addEventListener("mousedown", this._downHandler, false);
    window.addEventListener("mousemove", this._moveHandler, false);
    window.addEventListener("mousewheel", this._wheelHandler, false);
    window.addEventListener("DOMMouseScroll", this._wheelHandler, false);
  }, detach:function() {
    if (!this._attached) {
      return;
    }
    this._attached = false;
    window.removeEventListener("mouseup", this._upHandler);
    window.removeEventListener("mousedown", this._downHandler);
    window.removeEventListener("mousemove", this._moveHandler);
    window.removeEventListener("mousewheel", this._wheelHandler);
    window.removeEventListener("DOMMouseScroll", this._wheelHandler);
  }, disableContextMenu:function() {
    if (!this._target) {
      return;
    }
    this._target.addEventListener("contextmenu", this._contextMenuHandler);
  }, enableContextMenu:function() {
    if (!this._target) {
      return;
    }
    this._target.removeEventListener("contextmenu", this._contextMenuHandler);
  }, enablePointerLock:function(success, error) {
    if (!document.body.requestPointerLock) {
      if (error) {
        error();
      }
      return;
    }
    var s = function() {
      success();
      document.removeEventListener("pointerlockchange", s);
    };
    var e = function() {
      error();
      document.removeEventListener("pointerlockerror", e);
    };
    if (success) {
      document.addEventListener("pointerlockchange", s, false);
    }
    if (error) {
      document.addEventListener("pointerlockerror", e, false);
    }
    document.body.requestPointerLock();
  }, disablePointerLock:function(success) {
    if (!document.exitPointerLock) {
      return;
    }
    var s = function() {
      success();
      document.removeEventListener("pointerlockchange", s);
    };
    if (success) {
      document.addEventListener("pointerlockchange", s, false);
    }
    document.exitPointerLock();
  }, update:function() {
    this._lastbuttons[0] = this._buttons[0];
    this._lastbuttons[1] = this._buttons[1];
    this._lastbuttons[2] = this._buttons[2];
  }, isPressed:function(button) {
    return this._buttons[button];
  }, wasPressed:function(button) {
    return this._buttons[button] && !this._lastbuttons[button];
  }, wasReleased:function(button) {
    return !this._buttons[button] && this._lastbuttons[button];
  }, _handleUp:function(event) {
    this._buttons[event.button] = false;
    var e = new MouseEvent(this, event);
    if (!e.event) {
      return;
    }
    this.fire(pc.EVENT_MOUSEUP, e);
  }, _handleDown:function(event) {
    this._buttons[event.button] = true;
    var e = new MouseEvent(this, event);
    if (!e.event) {
      return;
    }
    this.fire(pc.EVENT_MOUSEDOWN, e);
  }, _handleMove:function(event) {
    var e = new MouseEvent(this, event);
    if (!e.event) {
      return;
    }
    this.fire(pc.EVENT_MOUSEMOVE, e);
    this._lastX = e.x;
    this._lastY = e.y;
  }, _handleWheel:function(event) {
    var e = new MouseEvent(this, event);
    if (!e.event) {
      return;
    }
    this.fire(pc.EVENT_MOUSEWHEEL, e);
  }, _getTargetCoords:function(event) {
    var rect = this._target.getBoundingClientRect();
    var left = Math.floor(rect.left);
    var top = Math.floor(rect.top);
    if (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {
      return null;
    }
    return {x:event.clientX - left, y:event.clientY - top};
  }});
  return {Mouse:Mouse, MouseEvent:MouseEvent};
}());
Object.assign(pc, function() {
  var KeyboardEvent = function(keyboard, event) {
    if (event) {
      this.key = event.keyCode;
      this.element = event.target;
      this.event = event;
    } else {
      this.key = null;
      this.element = null;
      this.event = null;
    }
  };
  var _keyboardEvent = new KeyboardEvent;
  function makeKeyboardEvent(event) {
    _keyboardEvent.key = event.keyCode;
    _keyboardEvent.element = event.target;
    _keyboardEvent.event = event;
    return _keyboardEvent;
  }
  function toKeyCode(s) {
    if (typeof s === "string") {
      return s.toUpperCase().charCodeAt(0);
    }
    return s;
  }
  var _keyCodeToKeyIdentifier = {9:"Tab", 13:"Enter", 16:"Shift", 17:"Control", 18:"Alt", 27:"Escape", 37:"Left", 38:"Up", 39:"Right", 40:"Down", 46:"Delete", 91:"Win"};
  var Keyboard = function(element, options) {
    options = options || {};
    this._element = null;
    this._keyDownHandler = this._handleKeyDown.bind(this);
    this._keyUpHandler = this._handleKeyUp.bind(this);
    this._keyPressHandler = this._handleKeyPress.bind(this);
    pc.events.attach(this);
    this._keymap = {};
    this._lastmap = {};
    if (element) {
      this.attach(element);
    }
    this.preventDefault = options.preventDefault || false;
    this.stopPropagation = options.stopPropagation || false;
  };
  Keyboard.prototype.attach = function(element) {
    if (this._element) {
      this.detach();
    }
    this._element = element;
    this._element.addEventListener("keydown", this._keyDownHandler, false);
    this._element.addEventListener("keypress", this._keyPressHandler, false);
    this._element.addEventListener("keyup", this._keyUpHandler, false);
  };
  Keyboard.prototype.detach = function() {
    this._element.removeEventListener("keydown", this._keyDownHandler);
    this._element.removeEventListener("keypress", this._keyPressHandler);
    this._element.removeEventListener("keyup", this._keyUpHandler);
    this._element = null;
  };
  Keyboard.prototype.toKeyIdentifier = function(keyCode) {
    keyCode = toKeyCode(keyCode);
    var count;
    var hex;
    var length;
    var id = _keyCodeToKeyIdentifier[keyCode.toString()];
    if (id) {
      return id;
    }
    hex = keyCode.toString(16).toUpperCase();
    length = hex.length;
    for (count = 0;count < 4 - length;count++) {
      hex = "0" + hex;
    }
    return "U+" + hex;
  };
  Keyboard.prototype._handleKeyDown = function(event) {
    var code = event.keyCode || event.charCode;
    if (code === undefined) {
      return;
    }
    var id = this.toKeyIdentifier(code);
    this._keymap[id] = true;
    this.fire("keydown", makeKeyboardEvent(event));
    if (this.preventDefault) {
      event.preventDefault();
    }
    if (this.stopPropagation) {
      event.stopPropagation();
    }
  };
  Keyboard.prototype._handleKeyUp = function(event) {
    var code = event.keyCode || event.charCode;
    if (code === undefined) {
      return;
    }
    var id = this.toKeyIdentifier(code);
    delete this._keymap[id];
    this.fire("keyup", makeKeyboardEvent(event));
    if (this.preventDefault) {
      event.preventDefault();
    }
    if (this.stopPropagation) {
      event.stopPropagation();
    }
  };
  Keyboard.prototype._handleKeyPress = function(event) {
    this.fire("keypress", makeKeyboardEvent(event));
    if (this.preventDefault) {
      event.preventDefault();
    }
    if (this.stopPropagation) {
      event.stopPropagation();
    }
  };
  Keyboard.prototype.update = function() {
    var prop;
    for (prop in this._lastmap) {
      delete this._lastmap[prop];
    }
    for (prop in this._keymap) {
      if (this._keymap.hasOwnProperty(prop)) {
        this._lastmap[prop] = this._keymap[prop];
      }
    }
  };
  Keyboard.prototype.isPressed = function(key) {
    var keyCode = toKeyCode(key);
    var id = this.toKeyIdentifier(keyCode);
    return !!this._keymap[id];
  };
  Keyboard.prototype.wasPressed = function(key) {
    var keyCode = toKeyCode(key);
    var id = this.toKeyIdentifier(keyCode);
    return !!this._keymap[id] && !!!this._lastmap[id];
  };
  Keyboard.prototype.wasReleased = function(key) {
    var keyCode = toKeyCode(key);
    var id = this.toKeyIdentifier(keyCode);
    return !!!this._keymap[id] && !!this._lastmap[id];
  };
  return {Keyboard:Keyboard, KeyboardEvent:KeyboardEvent};
}());
Object.assign(pc, function() {
  var GamePads = function() {
    this.gamepadsSupported = !!navigator.getGamepads || !!navigator.webkitGetGamepads;
    this.current = [];
    this.previous = [];
    this.deadZone = 0.25;
  };
  var MAPS = {DEFAULT:{buttons:["PAD_FACE_1", "PAD_FACE_2", "PAD_FACE_3", "PAD_FACE_4", "PAD_L_SHOULDER_1", "PAD_R_SHOULDER_1", "PAD_L_SHOULDER_2", "PAD_R_SHOULDER_2", "PAD_SELECT", "PAD_START", "PAD_L_STICK_BUTTON", "PAD_R_STICK_BUTTON", "PAD_UP", "PAD_DOWN", "PAD_LEFT", "PAD_RIGHT", "PAD_VENDOR"], axes:["PAD_L_STICK_X", "PAD_L_STICK_Y", "PAD_R_STICK_X", "PAD_R_STICK_Y"]}, PS3:{buttons:["PAD_FACE_1", "PAD_FACE_2", "PAD_FACE_4", "PAD_FACE_3", "PAD_L_SHOULDER_1", "PAD_R_SHOULDER_1", "PAD_L_SHOULDER_2", 
  "PAD_R_SHOULDER_2", "PAD_SELECT", "PAD_START", "PAD_L_STICK_BUTTON", "PAD_R_STICK_BUTTON", "PAD_UP", "PAD_DOWN", "PAD_LEFT", "PAD_RIGHT", "PAD_VENDOR"], axes:["PAD_L_STICK_X", "PAD_L_STICK_Y", "PAD_R_STICK_X", "PAD_R_STICK_Y"]}};
  var PRODUCT_CODES = {"Product: 0268":"PS3"};
  Object.assign(GamePads.prototype, {update:function() {
    var i, j, l;
    var buttons, buttonsLen;
    for (i = 0, l = this.current.length;i < l;i++) {
      buttons = this.current[i].pad.buttons;
      buttonsLen = buttons.length;
      for (j = 0;j < buttonsLen;j++) {
        if (this.previous[i] === undefined) {
          this.previous[i] = [];
        }
        this.previous[i][j] = buttons[j].pressed;
      }
    }
    var pads = this.poll();
    for (i = 0, l = pads.length;i < l;i++) {
      this.current[i] = pads[i];
    }
  }, poll:function() {
    var pads = [];
    if (this.gamepadsSupported) {
      var padDevices = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads();
      var i, len = padDevices.length;
      for (i = 0;i < len;i++) {
        if (padDevices[i]) {
          pads.push({map:this.getMap(padDevices[i]), pad:padDevices[i]});
        }
      }
    }
    return pads;
  }, getMap:function(pad) {
    for (var code in PRODUCT_CODES) {
      if (pad.id.indexOf(code) >= 0) {
        return MAPS[PRODUCT_CODES[code]];
      }
    }
    return MAPS.DEFAULT;
  }, isPressed:function(index, button) {
    if (!this.current[index]) {
      return false;
    }
    var key = this.current[index].map.buttons[button];
    return this.current[index].pad.buttons[pc[key]].pressed;
  }, wasPressed:function(index, button) {
    if (!this.current[index]) {
      return false;
    }
    var key = this.current[index].map.buttons[button];
    var i = pc[key];
    return this.current[index].pad.buttons[i].pressed && !this.previous[index][i];
  }, getAxis:function(index, axes) {
    if (!this.current[index]) {
      return false;
    }
    var key = this.current[index].map.axes[axes];
    var value = this.current[index].pad.axes[pc[key]];
    if (Math.abs(value) < this.deadZone) {
      value = 0;
    }
    return value;
  }});
  return {GamePads:GamePads};
}());
Object.assign(pc, function() {
  var Touch = function(touch) {
    var coords = pc.getTouchTargetCoords(touch);
    this.id = touch.identifier;
    this.x = coords.x;
    this.y = coords.y;
    this.target = touch.target;
    this.touch = touch;
  };
  var TouchEvent = function(device, event) {
    this.element = event.target;
    this.event = event;
    this.touches = [];
    this.changedTouches = [];
    if (event) {
      var i, l = event.touches.length;
      for (i = 0;i < l;i++) {
        this.touches.push(new Touch(event.touches[i]));
      }
      l = event.changedTouches.length;
      for (i = 0;i < l;i++) {
        this.changedTouches.push(new Touch(event.changedTouches[i]));
      }
    }
  };
  Object.assign(TouchEvent.prototype, {getTouchById:function(id, list) {
    var i, l = list.length;
    for (i = 0;i < l;i++) {
      if (list[i].id === id) {
        return list[i];
      }
    }
    return null;
  }});
  var TouchDevice = function(element) {
    this._startHandler = this._handleTouchStart.bind(this);
    this._endHandler = this._handleTouchEnd.bind(this);
    this._moveHandler = this._handleTouchMove.bind(this);
    this._cancelHandler = this._handleTouchCancel.bind(this);
    this.attach(element);
    pc.events.attach(this);
  };
  Object.assign(TouchDevice.prototype, {attach:function(element) {
    if (this._element) {
      this.detach();
    }
    this._element = element;
    this._element.addEventListener("touchstart", this._startHandler, false);
    this._element.addEventListener("touchend", this._endHandler, false);
    this._element.addEventListener("touchmove", this._moveHandler, false);
    this._element.addEventListener("touchcancel", this._cancelHandler, false);
  }, detach:function() {
    if (this._element) {
      this._element.removeEventListener("touchstart", this._startHandler, false);
      this._element.removeEventListener("touchend", this._endHandler, false);
      this._element.removeEventListener("touchmove", this._moveHandler, false);
      this._element.removeEventListener("touchcancel", this._cancelHandler, false);
    }
    this._element = null;
  }, _handleTouchStart:function(e) {
    this.fire("touchstart", new TouchEvent(this, e));
  }, _handleTouchEnd:function(e) {
    this.fire("touchend", new TouchEvent(this, e));
  }, _handleTouchMove:function(e) {
    e.preventDefault();
    this.fire("touchmove", new TouchEvent(this, e));
  }, _handleTouchCancel:function(e) {
    this.fire("touchcancel", new TouchEvent(this, e));
  }});
  return {getTouchTargetCoords:function(touch) {
    var totalOffsetX = 0;
    var totalOffsetY = 0;
    var target = touch.target;
    while (!(target instanceof HTMLElement)) {
      target = target.parentNode;
    }
    var currentElement = target;
    do {
      totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
      totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
      currentElement = currentElement.offsetParent;
    } while (currentElement);
    return {x:touch.pageX - totalOffsetX, y:touch.pageY - totalOffsetY};
  }, TouchDevice:TouchDevice, TouchEvent:TouchEvent};
}());
Object.assign(pc, function() {
  var Controller = function(element, options) {
    options = options || {};
    this._keyboard = options.keyboard || null;
    this._mouse = options.mouse || null;
    this._gamepads = options.gamepads || null;
    this._element = null;
    this._actions = {};
    this._axes = {};
    this._axesValues = {};
    if (element) {
      this.attach(element);
    }
  };
  Controller.prototype.attach = function(element) {
    this._element = element;
    if (this._keyboard) {
      this._keyboard.attach(element);
    }
    if (this._mouse) {
      this._mouse.attach(element);
    }
  };
  Controller.prototype.detach = function() {
    if (this._keyboard) {
      this._keyboard.detach();
    }
    if (this._mouse) {
      this._mouse.detach();
    }
    this._element = null;
  };
  Controller.prototype.disableContextMenu = function() {
    if (!this._mouse) {
      this._enableMouse();
    }
    this._mouse.disableContextMenu();
  };
  Controller.prototype.enableContextMenu = function() {
    if (!this._mouse) {
      this._enableMouse();
    }
    this._mouse.enableContextMenu();
  };
  Controller.prototype.update = function(dt) {
    if (this._keyboard) {
      this._keyboard.update(dt);
    }
    if (this._mouse) {
      this._mouse.update(dt);
    }
    if (this._gamepads) {
      this._gamepads.update(dt);
    }
    this._axesValues = {};
    for (var key in this._axes) {
      this._axesValues[key] = [];
    }
  };
  Controller.prototype.registerKeys = function(action, keys) {
    if (!this._keyboard) {
      this._enableKeyboard();
    }
    if (this._actions[action]) {
      throw new Error(pc.string.format("Action: {0} already registered", action));
    }
    if (keys === undefined) {
      throw new Error("Invalid button");
    }
    if (!keys.length) {
      keys = [keys];
    }
    if (this._actions[action]) {
      this._actions[action].push({type:pc.ACTION_KEYBOARD, keys:keys});
    } else {
      this._actions[action] = [{type:pc.ACTION_KEYBOARD, keys:keys}];
    }
  };
  Controller.prototype.registerMouse = function(action, button) {
    if (!this._mouse) {
      this._enableMouse();
    }
    if (button === undefined) {
      throw new Error("Invalid button");
    }
    if (this._actions[action]) {
      this._actions[action].push({type:pc.ACTION_MOUSE, button:button});
    } else {
      this._actions[action] = [{type:pc.ACTION_MOUSE, button:-button}];
    }
  };
  Controller.prototype.registerPadButton = function(action, pad, button) {
    if (button === undefined) {
      throw new Error("Invalid button");
    }
    if (this._actions[action]) {
      this._actions[action].push({type:pc.ACTION_GAMEPAD, button:button, pad:pad});
    } else {
      this._actions[action] = [{type:pc.ACTION_GAMEPAD, button:button, pad:pad}];
    }
  };
  Controller.prototype.registerAxis = function(options) {
    var name = options.name;
    if (!this._axes[name]) {
      this._axes[name] = [];
    }
    var i = this._axes[name].push(name);
    options = options || {};
    options.pad = options.pad || pc.PAD_1;
    var bind = function(controller, source, value, key) {
      switch(source) {
        case "mousex":
          controller._mouse.on(pc.EVENT_MOUSEMOVE, function(e) {
            controller._axesValues[name][i] = e.dx / 10;
          });
          break;
        case "mousey":
          controller._mouse.on(pc.EVENT_MOUSEMOVE, function(e) {
            controller._axesValues[name][i] = e.dy / 10;
          });
          break;
        case "key":
          controller._axes[name].push(function() {
            return controller._keyboard.isPressed(key) ? value : 0;
          });
          break;
        case "padrx":
          controller._axes[name].push(function() {
            return controller._gamepads.getAxis(options.pad, pc.PAD_R_STICK_X);
          });
          break;
        case "padry":
          controller._axes[name].push(function() {
            return controller._gamepads.getAxis(options.pad, pc.PAD_R_STICK_Y);
          });
          break;
        case "padlx":
          controller._axes[name].push(function() {
            return controller._gamepads.getAxis(options.pad, pc.PAD_L_STICK_X);
          });
          break;
        case "padly":
          controller._axes[name].push(function() {
            return controller._gamepads.getAxis(options.pad, pc.PAD_L_STICK_Y);
          });
          break;
        default:
          throw new Error("Unknown axis");
      }
    };
    bind(this, options.positive, 1, options.positiveKey);
    if (options.negativeKey || options.negative !== options.positive) {
      bind(this, options.negative, -1, options.negativeKey);
    }
  };
  Controller.prototype.isPressed = function(actionName) {
    if (!this._actions[actionName]) {
      return false;
    }
    var action;
    var index = 0;
    var length = this._actions[actionName].length;
    for (index = 0;index < length;++index) {
      action = this._actions[actionName][index];
      switch(action.type) {
        case pc.ACTION_KEYBOARD:
          if (this._keyboard) {
            var i, len = action.keys.length;
            for (i = 0;i < len;i++) {
              if (this._keyboard.isPressed(action.keys[i])) {
                return true;
              }
            }
          }
          break;
        case pc.ACTION_MOUSE:
          if (this._mouse && this._mouse.isPressed(action.button)) {
            return true;
          }
          break;
        case pc.ACTION_GAMEPAD:
          if (this._gamepads && this._gamepads.isPressed(action.pad, action.button)) {
            return true;
          }
          break;
      }
    }
    return false;
  };
  Controller.prototype.wasPressed = function(actionName) {
    if (!this._actions[actionName]) {
      return false;
    }
    var index = 0;
    var length = this._actions[actionName].length;
    for (index = 0;index < length;++index) {
      var action = this._actions[actionName][index];
      switch(action.type) {
        case pc.ACTION_KEYBOARD:
          if (this._keyboard) {
            var i, len = action.keys.length;
            for (i = 0;i < len;i++) {
              if (this._keyboard.wasPressed(action.keys[i])) {
                return true;
              }
            }
          }
          break;
        case pc.ACTION_MOUSE:
          if (this._mouse && this._mouse.wasPressed(action.button)) {
            return true;
          }
          break;
        case pc.ACTION_GAMEPAD:
          if (this._gamepads && this._gamepads.wasPressed(action.pad, action.button)) {
            return true;
          }
          break;
      }
    }
    return false;
  };
  Controller.prototype.getAxis = function(name) {
    var value = 0;
    if (this._axes[name]) {
      var i, len = this._axes[name].length;
      for (i = 0;i < len;i++) {
        if (pc.type(this._axes[name][i]) === "function") {
          var v = this._axes[name][i]();
          if (Math.abs(v) > Math.abs(value)) {
            value = v;
          }
        } else {
          if (this._axesValues[name]) {
            if (Math.abs(this._axesValues[name][i]) > Math.abs(value)) {
              value = this._axesValues[name][i];
            }
          }
        }
      }
    }
    return value;
  };
  Controller.prototype._enableMouse = function() {
    this._mouse = new pc.Mouse;
    if (!this._element) {
      throw new Error("Controller must be attached to an Element");
    }
    this._mouse.attach(this._element);
  };
  Controller.prototype._enableKeyboard = function() {
    this._keyboard = new pc.Keyboard;
    if (!this._element) {
      throw new Error("Controller must be attached to an Element");
    }
    this._keyboard.attach(this._element);
  };
  return {Controller:Controller};
}());
Object.assign(pc, function() {
  var targetX, targetY;
  var vecA = new pc.Vec3;
  var vecB = new pc.Vec3;
  var _pq = new pc.Vec3;
  var _pa = new pc.Vec3;
  var _pb = new pc.Vec3;
  var _pc = new pc.Vec3;
  var _pd = new pc.Vec3;
  var _m = new pc.Vec3;
  var _sct = new pc.Vec3;
  var _accumulatedScale = new pc.Vec2;
  var _paddingTop = new pc.Vec3;
  var _paddingBottom = new pc.Vec3;
  var _paddingLeft = new pc.Vec3;
  var _paddingRight = new pc.Vec3;
  var _cornerBottomLeft = new pc.Vec3;
  var _cornerBottomRight = new pc.Vec3;
  var _cornerTopRight = new pc.Vec3;
  var _cornerTopLeft = new pc.Vec3;
  var ZERO_VEC4 = new pc.Vec4;
  var scalarTriple = function(p1, p2, p3) {
    return _sct.cross(p1, p2).dot(p3);
  };
  var intersectLineQuad = function(p, q, corners) {
    _pq.sub2(q, p);
    _pa.sub2(corners[0], p);
    _pb.sub2(corners[1], p);
    _pc.sub2(corners[2], p);
    _m.cross(_pc, _pq);
    var v = _pa.dot(_m);
    if (v >= 0) {
      if (-_pb.dot(_m) < 0) {
        return false;
      }
      if (scalarTriple(_pq, _pb, _pa) < 0) {
        return false;
      }
    } else {
      _pd.sub2(corners[3], p);
      if (_pd.dot(_m) < 0) {
        return false;
      }
      if (scalarTriple(_pq, _pa, _pd) < 0) {
        return false;
      }
    }
    if (_pq.sub2(corners[0], corners[2]).lengthSq() < 0.0001 * 0.0001) {
      return false;
    }
    if (_pq.sub2(corners[1], corners[3]).lengthSq() < 0.0001 * 0.0001) {
      return false;
    }
    return true;
  };
  var ElementInputEvent = function(event, element, camera) {
    this.event = event;
    this.element = element;
    this.camera = camera;
    this._stopPropagation = false;
  };
  Object.assign(ElementInputEvent.prototype, {stopPropagation:function() {
    this._stopPropagation = true;
    this.event.stopImmediatePropagation();
    this.event.stopPropagation();
  }});
  var ElementMouseEvent = function(event, element, camera, x, y, lastX, lastY) {
    ElementInputEvent.call(this, event, element, camera);
    this.x = x;
    this.y = y;
    this.ctrlKey = event.ctrlKey || false;
    this.altKey = event.altKey || false;
    this.shiftKey = event.shiftKey || false;
    this.metaKey = event.metaKey || false;
    this.button = event.button;
    if (pc.Mouse.isPointerLocked()) {
      this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
      this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
    } else {
      this.dx = x - lastX;
      this.dy = y - lastY;
    }
    if (event.detail) {
      this.wheel = -1 * event.detail;
    } else {
      if (event.wheelDelta) {
        this.wheel = event.wheelDelta / 120;
      } else {
        this.wheel = 0;
      }
    }
  };
  ElementMouseEvent.prototype = Object.create(ElementInputEvent.prototype);
  ElementMouseEvent.prototype.constructor = ElementMouseEvent;
  var ElementTouchEvent = function(event, element, camera, x, y, input) {
    ElementInputEvent.call(this, event, element, camera);
    this.touches = event.touches;
    this.changedTouches = event.changedTouches;
    this.x = x;
    this.y = y;
  };
  ElementTouchEvent.prototype = Object.create(ElementInputEvent.prototype);
  ElementTouchEvent.prototype.constructor = ElementTouchEvent;
  var ElementInput = function(domElement) {
    this._app = null;
    this._attached = false;
    this._target = null;
    this._enabled = true;
    this._lastX = 0;
    this._lastY = 0;
    this._upHandler = this._handleUp.bind(this);
    this._downHandler = this._handleDown.bind(this);
    this._moveHandler = this._handleMove.bind(this);
    this._wheelHandler = this._handleWheel.bind(this);
    this._touchstartHandler = this._handleTouchStart.bind(this);
    this._touchendHandler = this._handleTouchEnd.bind(this);
    this._touchcancelHandler = this._touchendHandler;
    this._touchmoveHandler = this._handleTouchMove.bind(this);
    this._elements = [];
    this._hoveredElement = null;
    this._pressedElement = null;
    this._touchedElements = {};
    this._touchesForWhichTouchLeaveHasFired = {};
    if ("ontouchstart" in window) {
      this._clickedEntities = {};
    }
    this.attach(domElement);
  };
  Object.assign(ElementInput.prototype, {attach:function(domElement) {
    if (this._attached) {
      this._attached = false;
      this.detach();
    }
    this._target = domElement;
    this._attached = true;
    window.addEventListener("mouseup", this._upHandler, {passive:true});
    window.addEventListener("mousedown", this._downHandler, {passive:true});
    window.addEventListener("mousemove", this._moveHandler, {passive:true});
    window.addEventListener("mousewheel", this._wheelHandler, {passive:true});
    window.addEventListener("DOMMouseScroll", this._wheelHandler, {passive:true});
    if ("ontouchstart" in window) {
      this._target.addEventListener("touchstart", this._touchstartHandler, {passive:true});
      this._target.addEventListener("touchend", this._touchendHandler, false);
      this._target.addEventListener("touchmove", this._touchmoveHandler, false);
      this._target.addEventListener("touchcancel", this._touchcancelHandler, {passive:true});
    }
  }, detach:function() {
    if (!this._attached) {
      return;
    }
    this._attached = false;
    window.removeEventListener("mouseup", this._upHandler, false);
    window.removeEventListener("mousedown", this._downHandler, false);
    window.removeEventListener("mousemove", this._moveHandler, false);
    window.removeEventListener("mousewheel", this._wheelHandler, false);
    window.removeEventListener("DOMMouseScroll", this._wheelHandler, false);
    this._target.removeEventListener("touchstart", this._touchstartHandler, false);
    this._target.removeEventListener("touchend", this._touchendHandler, false);
    this._target.removeEventListener("touchmove", this._touchmoveHandler, false);
    this._target.removeEventListener("touchcancel", this._touchcancelHandler, false);
    this._target = null;
  }, addElement:function(element) {
    if (this._elements.indexOf(element) === -1) {
      this._elements.push(element);
    }
  }, removeElement:function(element) {
    var idx = this._elements.indexOf(element);
    if (idx !== -1) {
      this._elements.splice(idx, 1);
    }
  }, _handleUp:function(event) {
    if (!this._enabled) {
      return;
    }
    if (pc.Mouse.isPointerLocked()) {
      return;
    }
    this._calcMouseCoords(event);
    if (targetX === null) {
      return;
    }
    this._onElementMouseEvent(event);
  }, _handleDown:function(event) {
    if (!this._enabled) {
      return;
    }
    if (pc.Mouse.isPointerLocked()) {
      return;
    }
    this._calcMouseCoords(event);
    if (targetX === null) {
      return;
    }
    this._onElementMouseEvent(event);
  }, _handleMove:function(event) {
    if (!this._enabled) {
      return;
    }
    this._calcMouseCoords(event);
    if (targetX === null) {
      return;
    }
    this._onElementMouseEvent(event);
    this._lastX = targetX;
    this._lastY = targetY;
  }, _handleWheel:function(event) {
    if (!this._enabled) {
      return;
    }
    this._calcMouseCoords(event);
    if (targetX === null) {
      return;
    }
    this._onElementMouseEvent(event);
  }, _determineTouchedElements:function(event) {
    var touchedElements = {};
    var cameras = this.app.systems.camera.cameras;
    var i, j, len;
    for (i = cameras.length - 1;i >= 0;i--) {
      var camera = cameras[i];
      var done = 0;
      for (j = 0, len = event.changedTouches.length;j < len;j++) {
        if (touchedElements[event.changedTouches[j].identifier]) {
          done++;
          continue;
        }
        var coords = this._calcTouchCoords(event.changedTouches[j]);
        var element = this._getTargetElement(camera, coords.x, coords.y);
        if (element) {
          done++;
          touchedElements[event.changedTouches[j].identifier] = {element:element, camera:camera, x:coords.x, y:coords.y};
        }
      }
      if (done === len) {
        break;
      }
    }
    return touchedElements;
  }, _handleTouchStart:function(event) {
    if (!this._enabled) {
      return;
    }
    var newTouchedElements = this._determineTouchedElements(event);
    for (var i = 0, len = event.changedTouches.length;i < len;i++) {
      var touch = event.changedTouches[i];
      var newTouchInfo = newTouchedElements[touch.identifier];
      var oldTouchInfo = this._touchedElements[touch.identifier];
      if (newTouchInfo && (!oldTouchInfo || newTouchInfo.element !== oldTouchInfo.element)) {
        this._fireEvent(event.type, new ElementTouchEvent(event, newTouchInfo.element, newTouchInfo.camera, newTouchInfo.x, newTouchInfo.y, this));
        this._touchesForWhichTouchLeaveHasFired[touch.identifier] = false;
      }
    }
    for (var touchId in newTouchedElements) {
      this._touchedElements[touchId] = newTouchedElements[touchId];
    }
  }, _handleTouchEnd:function(event) {
    if (!this._enabled) {
      return;
    }
    var cameras = this.app.systems.camera.cameras;
    for (var key in this._clickedEntities) {
      delete this._clickedEntities[key];
    }
    for (var i = 0, len = event.changedTouches.length;i < len;i++) {
      var touch = event.changedTouches[i];
      var touchInfo = this._touchedElements[touch.identifier];
      if (!touchInfo) {
        continue;
      }
      var element = touchInfo.element;
      var camera = touchInfo.camera;
      var x = touchInfo.x;
      var y = touchInfo.y;
      delete this._touchedElements[touch.identifier];
      delete this._touchesForWhichTouchLeaveHasFired[touch.identifier];
      this._fireEvent(event.type, new ElementTouchEvent(event, element, camera, x, y, this));
      if (event.touches.length === 0) {
        var coords = this._calcTouchCoords(touch);
        for (var c = cameras.length - 1;c >= 0;c--) {
          var hovered = this._getTargetElement(cameras[c], coords.x, coords.y);
          if (hovered === element) {
            if (!this._clickedEntities[element.entity.getGuid()]) {
              this._fireEvent("click", new ElementTouchEvent(event, element, camera, x, y, this));
              this._clickedEntities[element.entity.getGuid()] = true;
            }
          }
        }
      }
    }
  }, _handleTouchMove:function(event) {
    if (!this._enabled) {
      return;
    }
    event.preventDefault();
    var newTouchedElements = this._determineTouchedElements(event);
    for (var i = 0, len = event.changedTouches.length;i < len;i++) {
      var touch = event.changedTouches[i];
      var newTouchInfo = newTouchedElements[touch.identifier];
      var oldTouchInfo = this._touchedElements[touch.identifier];
      if (oldTouchInfo) {
        var coords = this._calcTouchCoords(touch);
        if ((!newTouchInfo || newTouchInfo.element !== oldTouchInfo.element) && !this._touchesForWhichTouchLeaveHasFired[touch.identifier]) {
          this._fireEvent("touchleave", new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, this));
          this._touchesForWhichTouchLeaveHasFired[touch.identifier] = true;
        }
        this._fireEvent("touchmove", new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, this));
      }
    }
  }, _onElementMouseEvent:function(event) {
    var element;
    var hovered = this._hoveredElement;
    this._hoveredElement = null;
    var cameras = this.app.systems.camera.cameras;
    var camera;
    for (var i = cameras.length - 1;i >= 0;i--) {
      camera = cameras[i];
      element = this._getTargetElement(camera, targetX, targetY);
      if (element) {
        break;
      }
    }
    if (element) {
      this._fireEvent(event.type, new ElementMouseEvent(event, element, camera, targetX, targetY, this._lastX, this._lastY));
      this._hoveredElement = element;
      if (event.type === pc.EVENT_MOUSEDOWN) {
        this._pressedElement = element;
      }
    }
    if (hovered !== this._hoveredElement) {
      if (hovered) {
        this._fireEvent("mouseleave", new ElementMouseEvent(event, hovered, camera, targetX, targetY, this._lastX, this._lastY));
      }
      if (this._hoveredElement) {
        this._fireEvent("mouseenter", new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
      }
    }
    if (event.type === pc.EVENT_MOUSEUP && this._pressedElement) {
      if (this._pressedElement === this._hoveredElement) {
        this._pressedElement = null;
        if (!this._clickedEntities || !this._clickedEntities[this._hoveredElement.entity.getGuid()]) {
          this._fireEvent("click", new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
        }
      } else {
        this._pressedElement = null;
      }
    }
  }, _fireEvent:function(name, evt) {
    var element = evt.element;
    while (true) {
      element.fire(name, evt);
      if (evt._stopPropagation) {
        break;
      }
      if (!element.entity.parent) {
        break;
      }
      element = element.entity.parent.element;
      if (!element) {
        break;
      }
    }
  }, _calcMouseCoords:function(event) {
    var rect = this._target.getBoundingClientRect();
    var left = Math.floor(rect.left);
    var top = Math.floor(rect.top);
    if (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {
      targetX = null;
      targetY = null;
    } else {
      targetX = event.clientX - left;
      targetY = event.clientY - top;
    }
  }, _calcTouchCoords:function(touch) {
    var totalOffsetX = 0;
    var totalOffsetY = 0;
    var target = touch.target;
    while (!(target instanceof HTMLElement)) {
      target = target.parentNode;
    }
    var currentElement = target;
    do {
      totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
      totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
      currentElement = currentElement.offsetParent;
    } while (currentElement);
    return {x:touch.pageX - totalOffsetX, y:touch.pageY - totalOffsetY};
  }, _sortElements:function(a, b) {
    if (a.screen && !b.screen) {
      return -1;
    }
    if (!a.screen && b.screen) {
      return 1;
    }
    if (!a.screen && !b.screen) {
      return 0;
    }
    if (a.screen.screen.screenSpace && !b.screen.screen.screenSpace) {
      return -1;
    }
    if (b.screen.screen.screenSpace && !a.screen.screen.screenSpace) {
      return 1;
    }
    return b.drawOrder - a.drawOrder;
  }, _getTargetElement:function(camera, x, y) {
    var result = null;
    this._elements.sort(this._sortElements);
    for (var i = 0, len = this._elements.length;i < len;i++) {
      var element = this._elements[i];
      if (element.screen && element.screen.screen.screenSpace) {
        if (this._checkElement2d(x, y, element, camera)) {
          result = element;
          break;
        }
      } else {
        if (this._checkElement3d(x, y, element, camera)) {
          result = element;
          break;
        }
      }
    }
    return result;
  }, _buildHitCorners:function(element, screenOrWorldCorners, scaleX, scaleY) {
    var hitCorners = screenOrWorldCorners;
    var button = element.entity && element.entity.button;
    if (button) {
      var hitPadding = element.entity.button.hitPadding || ZERO_VEC4;
      _paddingTop.copy(element.entity.up);
      _paddingBottom.copy(_paddingTop).scale(-1);
      _paddingRight.copy(element.entity.right);
      _paddingLeft.copy(_paddingRight).scale(-1);
      _paddingTop.scale(hitPadding.data[3] * scaleY);
      _paddingBottom.scale(hitPadding.data[1] * scaleY);
      _paddingRight.scale(hitPadding.data[2] * scaleX);
      _paddingLeft.scale(hitPadding.data[0] * scaleX);
      _cornerBottomLeft.copy(hitCorners[0]).add(_paddingBottom).add(_paddingLeft);
      _cornerBottomRight.copy(hitCorners[1]).add(_paddingBottom).add(_paddingRight);
      _cornerTopRight.copy(hitCorners[2]).add(_paddingTop).add(_paddingRight);
      _cornerTopLeft.copy(hitCorners[3]).add(_paddingTop).add(_paddingLeft);
      hitCorners = [_cornerBottomLeft, _cornerBottomRight, _cornerTopRight, _cornerTopLeft];
    }
    return hitCorners;
  }, _calculateScaleToScreen:function(element) {
    var current = element.entity;
    var screenScale = element.screen.screen.scale;
    _accumulatedScale.set(screenScale, screenScale);
    while (current && !current.screen) {
      _accumulatedScale.mul(current.getLocalScale());
      current = current.parent;
    }
    return _accumulatedScale;
  }, _checkElement2d:function(x, y, element, camera) {
    var sw = this.app.graphicsDevice.width;
    var sh = this.app.graphicsDevice.height;
    var cameraWidth = camera.rect.z * sw;
    var cameraHeight = camera.rect.w * sh;
    var cameraLeft = camera.rect.x * sw;
    var cameraRight = cameraLeft + cameraWidth;
    var cameraBottom = (1 - camera.rect.y) * sh;
    var cameraTop = cameraBottom - cameraHeight;
    var _x = x * sw / this._target.clientWidth;
    var _y = y * sh / this._target.clientHeight;
    if (_x >= cameraLeft && _x <= cameraRight && _y <= cameraBottom && _y >= cameraTop) {
      _x = sw * (_x - cameraLeft) / cameraWidth;
      _y = sh * (_y - cameraTop) / cameraHeight;
      _y = sh - _y;
      var scale = this._calculateScaleToScreen(element);
      var hitCorners = this._buildHitCorners(element, element.screenCorners, scale.x, scale.y);
      vecA.set(_x, _y, 1);
      vecB.set(_x, _y, -1);
      if (intersectLineQuad(vecA, vecB, hitCorners)) {
        return true;
      }
    }
    return false;
  }, _checkElement3d:function(x, y, element, camera) {
    var sw = this._target.clientWidth;
    var sh = this._target.clientHeight;
    var cameraWidth = camera.rect.z * sw;
    var cameraHeight = camera.rect.w * sh;
    var cameraLeft = camera.rect.x * sw;
    var cameraRight = cameraLeft + cameraWidth;
    var cameraBottom = (1 - camera.rect.y) * sh;
    var cameraTop = cameraBottom - cameraHeight;
    var _x = x;
    var _y = y;
    if (x >= cameraLeft && x <= cameraRight && y <= cameraBottom && _y >= cameraTop) {
      _x = sw * (_x - cameraLeft) / cameraWidth;
      _y = sh * (_y - cameraTop) / cameraHeight;
      var scale = element.entity.getWorldTransform().getScale();
      var worldCorners = this._buildHitCorners(element, element.worldCorners, scale.x, scale.y);
      var start = vecA;
      var end = vecB;
      camera.screenToWorld(_x, _y, camera.nearClip, start);
      camera.screenToWorld(_x, _y, camera.farClip, end);
      if (intersectLineQuad(start, end, worldCorners)) {
        return true;
      }
    }
    return false;
  }});
  Object.defineProperty(ElementInput.prototype, "enabled", {get:function() {
    return this._enabled;
  }, set:function(value) {
    this._enabled = value;
  }});
  Object.defineProperty(ElementInput.prototype, "app", {get:function() {
    return this._app || pc.app;
  }, set:function(value) {
    this._app = value;
  }});
  return {ElementInput:ElementInput, ElementInputEvent:ElementInputEvent, ElementMouseEvent:ElementMouseEvent, ElementTouchEvent:ElementTouchEvent};
}());
Object.assign(pc, function() {
  var VrManager = function(app) {
    pc.events.attach(this);
    var self = this;
    this.isSupported = VrManager.isSupported;
    this.usesPolyfill = VrManager.usesPolyfill;
    if (window.InitializeWebVRPolyfill) {
      window.InitializeWebVRPolyfill();
    }
    this._index = {};
    this.displays = [];
    this.display = null;
    this._app = app;
    this._onDisplayConnect = this._onDisplayConnect.bind(this);
    this._onDisplayDisconnect = this._onDisplayDisconnect.bind(this);
    self._attach();
    this._getDisplays(function(err, displays) {
      if (err) {
        self.fire("error", err);
      } else {
        for (var i = 0;i < displays.length;i++) {
          self._addDisplay(displays[i]);
        }
        self.fire("ready", self.displays);
      }
    });
  };
  VrManager.isSupported = !!navigator.getVRDisplays;
  VrManager.usesPolyfill = !!window.InitializeWebVRPolyfill;
  Object.assign(VrManager.prototype, {_attach:function() {
    window.addEventListener("vrdisplayconnect", this._onDisplayConnect);
    window.addEventListener("vrdisplaydisconnect", this._onDisplayDisconnect);
  }, _detach:function() {
    window.removeEventListener("vrdisplayconnect", this._onDisplayConnect);
    window.removeEventListener("vrdisplaydisconnect", this._onDisplayDisconnect);
  }, destroy:function() {
    this._detach();
  }, poll:function() {
    var l = this.displays.length;
    if (!l) {
      return;
    }
    for (var i = 0;i < l;i++) {
      if (this.displays[i]._camera) {
        this.displays[i].poll();
      }
    }
  }, _getDisplays:function(callback) {
    if (navigator.getVRDisplays) {
      navigator.getVRDisplays().then(function(displays) {
        if (callback) {
          callback(null, displays);
        }
      });
    } else {
      if (callback) {
        callback(new Error("WebVR not supported"));
      }
    }
  }, _addDisplay:function(vrDisplay) {
    if (this._index[vrDisplay.displayId]) {
      return;
    }
    var display = new pc.VrDisplay(this._app, vrDisplay);
    this._index[display.id] = display;
    this.displays.push(display);
    if (!this.display) {
      this.display = display;
    }
    this.fire("displayconnect", display);
  }, _onDisplayConnect:function(e) {
    if (e.detail && e.detail.display) {
      this._addDisplay(e.detail.display);
    } else {
      this._addDisplay(e.display);
    }
  }, _onDisplayDisconnect:function(e) {
    var id;
    if (e.detail && e.detail.display) {
      id = e.detail.display.displayId;
    } else {
      id = e.display.displayId;
    }
    var display = this._index[id];
    if (!display) {
      return;
    }
    display.destroy();
    delete this._index[display.id];
    var ind = this.displays.indexOf(display);
    this.displays.splice(ind, 1);
    if (this.display === display) {
      if (this.displays.length) {
        this.display = this.displays[0];
      } else {
        this.display = null;
      }
    }
    this.fire("displaydisconnect", display);
  }});
  return {VrManager:VrManager};
}());
Object.assign(pc, function() {
  var VrDisplay = function(app, display) {
    var self = this;
    this._app = app;
    this._device = app.graphicsDevice;
    this.id = display.displayId;
    this._frameData = null;
    if (window.VRFrameData) {
      this._frameData = new window.VRFrameData;
    }
    this.display = display;
    this._camera = null;
    this.sitToStandInv = new pc.Mat4;
    this.leftView = new pc.Mat4;
    this.leftProj = new pc.Mat4;
    this.leftViewInv = new pc.Mat4;
    this.leftPos = new pc.Vec3;
    this.rightView = new pc.Mat4;
    this.rightProj = new pc.Mat4;
    this.rightViewInv = new pc.Mat4;
    this.rightPos = new pc.Vec3;
    this.combinedPos = new pc.Vec3;
    this.combinedView = new pc.Mat4;
    this.combinedProj = new pc.Mat4;
    this.combinedViewInv = new pc.Mat4;
    this.combinedFov = 0;
    this.combinedAspect = 0;
    this.presenting = false;
    self._presentChange = function(event) {
      var display;
      if (event.display) {
        display = event.display;
      } else {
        if (event.detail && event.detail.display) {
          display = event.detail.display;
        } else {
          if (event.detail && event.detail.vrdisplay) {
            display = event.detail.vrdisplay;
          } else {
            display = self.display;
          }
        }
      }
      if (display === self.display) {
        self.presenting = self.display && self.display.isPresenting;
        if (self.presenting) {
          var leftEye = self.display.getEyeParameters("left");
          var rightEye = self.display.getEyeParameters("right");
          var w = Math.max(leftEye.renderWidth, rightEye.renderWidth) * 2;
          var h = Math.max(leftEye.renderHeight, rightEye.renderHeight);
          self._app.graphicsDevice.setResolution(w, h);
          self._app._allowResize = false;
        } else {
          self._app.setCanvasResolution(pc.RESOLUTION_AUTO);
          self._app._allowResize = true;
        }
        self.fire("beforepresentchange", self);
        self.fire("presentchange", self);
      }
    };
    window.addEventListener("vrdisplaypresentchange", self._presentChange, false);
    pc.events.attach(this);
  };
  Object.assign(VrDisplay.prototype, {destroy:function() {
    window.removeEventListener("vrdisplaypresentchange", self._presentChange);
    if (this._camera) {
      this._camera.vrDisplay = null;
    }
    this._camera = null;
  }, poll:function() {
    if (this.display) {
      this.display.getFrameData(this._frameData);
      this.leftProj.data = this._frameData.leftProjectionMatrix;
      this.rightProj.data = this._frameData.rightProjectionMatrix;
      var stage = this.display.stageParameters;
      if (stage) {
        this.sitToStandInv.set(stage.sittingToStandingTransform).invert();
        this.combinedView.set(this._frameData.leftViewMatrix);
        this.leftView.mul2(this.combinedView, this.sitToStandInv);
        this.combinedView.set(this._frameData.rightViewMatrix);
        this.rightView.mul2(this.combinedView, this.sitToStandInv);
      } else {
        this.leftView.set(this._frameData.leftViewMatrix);
        this.rightView.set(this._frameData.rightViewMatrix);
      }
      var nx = this.leftProj.data[3] + this.leftProj.data[0];
      var nz = this.leftProj.data[11] + this.leftProj.data[8];
      var l = 1.0 / Math.sqrt(nx * nx + nz * nz);
      nx *= l;
      nz *= l;
      var maxFov = -Math.atan2(nz, nx);
      nx = this.rightProj.data[3] + this.rightProj.data[0];
      nz = this.rightProj.data[11] + this.rightProj.data[8];
      l = 1.0 / Math.sqrt(nx * nx + nz * nz);
      nx *= l;
      nz *= l;
      maxFov = Math.max(maxFov, -Math.atan2(nz, nx));
      maxFov *= 2.0;
      this.combinedFov = maxFov;
      var aspect = this.rightProj.data[5] / this.rightProj.data[0];
      this.combinedAspect = aspect;
      var view = this.combinedView;
      view.copy(this.leftView);
      view.invert();
      this.leftViewInv.copy(view);
      var pos = this.combinedPos.data;
      pos[0] = this.leftPos.data[0] = view.data[12];
      pos[1] = this.leftPos.data[1] = view.data[13];
      pos[2] = this.leftPos.data[2] = view.data[14];
      view.copy(this.rightView);
      view.invert();
      this.rightViewInv.copy(view);
      var deltaX = pos[0] - view.data[12];
      var deltaY = pos[1] - view.data[13];
      var deltaZ = pos[2] - view.data[14];
      var dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);
      this.rightPos.data[0] = view.data[12];
      this.rightPos.data[1] = view.data[13];
      this.rightPos.data[2] = view.data[14];
      pos[0] += view.data[12];
      pos[1] += view.data[13];
      pos[2] += view.data[14];
      pos[0] *= 0.5;
      pos[1] *= 0.5;
      pos[2] *= 0.5;
      var b = Math.PI * 0.5;
      var c = maxFov * 0.5;
      var a = Math.PI - (b + c);
      var offset = dist * 0.5 * Math.sin(a);
      var fwdX = view.data[8];
      var fwdY = view.data[9];
      var fwdZ = view.data[10];
      view.data[12] = pos[0] + fwdX * offset;
      view.data[13] = pos[1] + fwdY * offset;
      view.data[14] = pos[2] + fwdZ * offset;
      this.combinedViewInv.copy(view);
      view.invert();
      this.combinedProj.setPerspective(maxFov * pc.math.RAD_TO_DEG, aspect, this.display.depthNear + offset, this.display.depthFar + offset, true);
    }
  }, requestPresent:function(callback) {
    if (!this.display) {
      if (callback) {
        callback(new Error("No VrDisplay to requestPresent"));
      }
      return;
    }
    if (this.presenting) {
      if (callback) {
        callback(new Error("VrDisplay already presenting"));
      }
      return;
    }
    this.display.requestPresent([{source:this._device.canvas}]).then(function() {
      if (callback) {
        callback();
      }
    }, function(err) {
      if (callback) {
        callback(err);
      }
    });
  }, exitPresent:function(callback) {
    if (!this.display) {
      if (callback) {
        callback(new Error("No VrDisplay to exitPresent"));
      }
    }
    if (!this.presenting) {
      if (callback) {
        callback(new Error("VrDisplay not presenting"));
      }
      return;
    }
    this.display.exitPresent().then(function() {
      if (callback) {
        callback();
      }
    }, function() {
      if (callback) {
        callback(new Error("exitPresent failed"));
      }
    });
  }, requestAnimationFrame:function(fn) {
    if (this.display) {
      this.display.requestAnimationFrame(fn);
    }
  }, submitFrame:function() {
    if (this.display) {
      this.display.submitFrame();
    }
  }, reset:function() {
    if (this.display) {
      this.display.resetPose();
    }
  }, setClipPlanes:function(n, f) {
    if (this.display) {
      this.display.depthNear = n;
      this.display.depthFar = f;
    }
  }, getFrameData:function() {
    if (this.display) {
      return this._frameData;
    }
  }});
  Object.defineProperty(VrDisplay.prototype, "capabilities", {get:function() {
    if (this.display) {
      return this.display.capabilities;
    }
    return {};
  }});
  return {VrDisplay:VrDisplay};
}());
Object.assign(pc, function() {
  var Http = function Http() {
  };
  Http.ContentType = {FORM_URLENCODED:"application/x-www-form-urlencoded", GIF:"image/gif", JPEG:"image/jpeg", DDS:"image/dds", JSON:"application/json", PNG:"image/png", TEXT:"text/plain", XML:"application/xml", WAV:"audio/x-wav", OGG:"audio/ogg", MP3:"audio/mpeg", MP4:"audio/mp4", AAC:"audio/aac", BIN:"application/octet-stream"};
  Http.ResponseType = {TEXT:"text", ARRAY_BUFFER:"arraybuffer", BLOB:"blob", DOCUMENT:"document"};
  Http.binaryExtensions = [".model", ".wav", ".ogg", ".mp3", ".mp4", ".m4a", ".aac", ".dds"];
  Object.assign(Http.prototype, {ContentType:Http.ContentType, ResponseType:Http.ResponseType, binaryExtensions:Http.binaryExtensions, get:function(url, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    return this.request("GET", url, options, callback);
  }, post:function(url, data, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options.postdata = data;
    return this.request("POST", url, options, callback);
  }, put:function(url, data, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options.postdata = data;
    return this.request("PUT", url, options, callback);
  }, del:function(url, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    return this.request("DELETE", url, options, callback);
  }, request:function(method, url, options, callback) {
    var uri, query, timestamp, postdata, xhr;
    var errored = false;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options.callback = callback;
    if (options.async == null) {
      options.async = true;
    }
    if (options.headers == null) {
      options.headers = {};
    }
    if (options.postdata != null) {
      if (options.postdata instanceof Document) {
        postdata = options.postdata;
      } else {
        if (options.postdata instanceof FormData) {
          postdata = options.postdata;
        } else {
          if (options.postdata instanceof Object) {
            var contentType = options.headers["Content-Type"];
            if (contentType === undefined) {
              options.headers["Content-Type"] = Http.ContentType.FORM_URLENCODED;
              contentType = options.headers["Content-Type"];
            }
            switch(contentType) {
              case Http.ContentType.FORM_URLENCODED:
                postdata = "";
                var bFirstItem = true;
                for (var key in options.postdata) {
                  if (options.postdata.hasOwnProperty(key)) {
                    if (bFirstItem) {
                      bFirstItem = false;
                    } else {
                      postdata += "&";
                    }
                    postdata += escape(key) + "=" + escape(options.postdata[key]);
                  }
                }
                break;
              default:
              case Http.ContentType.JSON:
                if (contentType == null) {
                  options.headers["Content-Type"] = Http.ContentType.JSON;
                }
                postdata = JSON.stringify(options.postdata);
                break;
            }
          } else {
            postdata = options.postdata;
          }
        }
      }
    }
    if (!xhr) {
      xhr = new XMLHttpRequest;
    }
    if (options.cache === false) {
      timestamp = pc.time.now();
      uri = new pc.URI(url);
      if (!uri.query) {
        uri.query = "ts=" + timestamp;
      } else {
        uri.query = uri.query + "&ts=" + timestamp;
      }
      url = uri.toString();
    }
    if (options.query) {
      uri = new pc.URI(url);
      query = pc.extend(uri.getQuery(), options.query);
      uri.setQuery(query);
      url = uri.toString();
    }
    xhr.open(method, url, options.async);
    xhr.withCredentials = options.withCredentials !== undefined ? options.withCredentials : false;
    xhr.responseType = options.responseType || this._guessResponseType(url);
    for (var header in options.headers) {
      if (options.headers.hasOwnProperty(header)) {
        xhr.setRequestHeader(header, options.headers[header]);
      }
    }
    xhr.onreadystatechange = function() {
      this._onReadyStateChange(method, url, options, xhr);
    }.bind(this);
    xhr.onerror = function() {
      this._onError(method, url, options, xhr);
      errored = true;
    }.bind(this);
    try {
      xhr.send(postdata);
    } catch (e) {
      if (!errored) {
        options.error(xhr.status, xhr, e);
      }
    }
    return xhr;
  }, _guessResponseType:function(url) {
    var uri = new pc.URI(url);
    var ext = pc.path.getExtension(uri.path);
    if (Http.binaryExtensions.indexOf(ext) >= 0) {
      return Http.ResponseType.ARRAY_BUFFER;
    }
    if (ext === ".xml") {
      return Http.ResponseType.DOCUMENT;
    }
    return Http.ResponseType.TEXT;
  }, _isBinaryContentType:function(contentType) {
    var binTypes = [Http.ContentType.MP4, Http.ContentType.WAV, Http.ContentType.OGG, Http.ContentType.MP3, Http.ContentType.BIN, Http.ContentType.DDS];
    if (binTypes.indexOf(contentType) >= 0) {
      return true;
    }
    return false;
  }, _onReadyStateChange:function(method, url, options, xhr) {
    if (xhr.readyState === 4) {
      switch(xhr.status) {
        case 0:
          {
            if (url[0] != "/") {
              this._onSuccess(method, url, options, xhr);
            }
            break;
          }
        case 200:
        case 201:
        case 206:
        case 304:
          {
            this._onSuccess(method, url, options, xhr);
            break;
          }
        default:
          {
            this._onError(method, url, options, xhr);
            break;
          }
      }
    }
  }, _onSuccess:function(method, url, options, xhr) {
    var response;
    var header;
    var contentType;
    var parts;
    header = xhr.getResponseHeader("Content-Type");
    if (header) {
      parts = header.split(";");
      contentType = parts[0].trim();
    }
    if (contentType === this.ContentType.JSON || url.split("?")[0].endsWith(".json")) {
      response = JSON.parse(xhr.responseText);
    } else {
      if (this._isBinaryContentType(contentType)) {
        response = xhr.response;
      } else {
        if (xhr.responseType === Http.ResponseType.ARRAY_BUFFER) {
          logWARNING(pc.string.format("responseType: {0} being served with Content-Type: {1}", Http.ResponseType.ARRAY_BUFFER, contentType));
          response = xhr.response;
        } else {
          if (xhr.responseType === Http.ResponseType.DOCUMENT || contentType === this.ContentType.XML) {
            response = xhr.responseXML;
          } else {
            response = xhr.responseText;
          }
        }
      }
    }
    options.callback(null, response);
  }, _onError:function(method, url, options, xhr) {
    options.callback(xhr.status, null);
  }});
  return {Http:Http, http:new Http};
}());
Object.assign(pc, function() {
  var ScriptRegistry = function(app) {
    pc.events.attach(this);
    this.app = app;
    this._scripts = {};
    this._list = [];
  };
  ScriptRegistry.prototype.add = function(script) {
    var self = this;
    if (this._scripts.hasOwnProperty(script.__name)) {
      setTimeout(function() {
        if (script.prototype.swap) {
          var old = self._scripts[script.__name];
          var ind = self._list.indexOf(old);
          self._list[ind] = script;
          self._scripts[script.__name] = script;
          self.fire("swap", script.__name, script);
          self.fire("swap:" + script.__name, script);
        } else {
          console.warn("script registry already has '" + script.__name + "' script, define 'swap' method for new script type to enable code hot swapping");
        }
      });
      return false;
    }
    this._scripts[script.__name] = script;
    this._list.push(script);
    this.fire("add", script.__name, script);
    this.fire("add:" + script.__name, script);
    setTimeout(function() {
      if (!self._scripts.hasOwnProperty(script.__name)) {
        return;
      }
      var components = self.app.systems.script._components;
      var i, scriptInstance, attributes;
      var scriptInstances = [];
      var scriptInstancesInitialized = [];
      for (i = 0;i < components.length;i++) {
        if (components[i]._scriptsIndex[script.__name] && components[i]._scriptsIndex[script.__name].awaiting) {
          if (components[i]._scriptsData && components[i]._scriptsData[script.__name]) {
            attributes = components[i]._scriptsData[script.__name].attributes;
          }
          scriptInstance = components[i].create(script.__name, {preloading:true, ind:components[i]._scriptsIndex[script.__name].ind, attributes:attributes});
          if (scriptInstance) {
            scriptInstances.push(scriptInstance);
          }
        }
      }
      for (i = 0;i < scriptInstances.length;i++) {
        scriptInstances[i].__initializeAttributes();
      }
      for (i = 0;i < scriptInstances.length;i++) {
        if (scriptInstances[i].enabled) {
          scriptInstances[i]._initialized = true;
          scriptInstancesInitialized.push(scriptInstances[i]);
          if (scriptInstances[i].initialize) {
            scriptInstances[i].initialize();
          }
        }
      }
      for (i = 0;i < scriptInstancesInitialized.length;i++) {
        if (!scriptInstancesInitialized[i].enabled || scriptInstancesInitialized[i]._postInitialized) {
          continue;
        }
        scriptInstancesInitialized[i]._postInitialized = true;
        if (scriptInstancesInitialized[i].postInitialize) {
          scriptInstancesInitialized[i].postInitialize();
        }
      }
    });
    return true;
  };
  ScriptRegistry.prototype.remove = function(name) {
    if (typeof name === "function") {
      name = name.__name;
    }
    if (!this._scripts.hasOwnProperty(name)) {
      return false;
    }
    var item = this._scripts[name];
    delete this._scripts[name];
    var ind = this._list.indexOf(item);
    this._list.splice(ind, 1);
    this.fire("remove", name, item);
    this.fire("remove:" + name, item);
    return true;
  };
  ScriptRegistry.prototype.get = function(name) {
    return this._scripts[name] || null;
  };
  ScriptRegistry.prototype.has = function(name) {
    return this._scripts.hasOwnProperty(name);
  };
  ScriptRegistry.prototype.list = function() {
    return this._list;
  };
  return {ScriptRegistry:ScriptRegistry};
}());
Object.assign(pc, function() {
  var rawToValue = function(app, args, value, old) {
    var i;
    switch(args.type) {
      case "boolean":
        return !!value;
      case "number":
        if (typeof value === "number") {
          return value;
        } else {
          if (typeof value === "string") {
            var v = parseInt(value, 10);
            if (isNaN(v)) {
              return null;
            }
            return v;
          } else {
            if (typeof value === "boolean") {
              return 0 + value;
            }
          }
        }
        return null;
      case "json":
        if (typeof value === "object") {
          return value;
        }
        try {
          return JSON.parse(value);
        } catch (ex) {
          return null;
        }
      case "asset":
        if (value instanceof pc.Asset) {
          return value;
        } else {
          if (typeof value === "number") {
            return app.assets.get(value) || null;
          } else {
            if (typeof value === "string") {
              return app.assets.get(parseInt(value, 10)) || null;
            }
          }
        }
        return null;
      case "entity":
        if (value instanceof pc.GraphNode) {
          return value;
        } else {
          if (typeof value === "string") {
            return app.root.findByGuid(value);
          }
        }
        return null;
      case "rgb":
      case "rgba":
        if (value instanceof pc.Color) {
          if (old instanceof pc.Color) {
            old.copy(value);
            return old;
          }
          return value.clone();
        } else {
          if (value instanceof Array && value.length >= 3 && value.length <= 4) {
            for (i = 0;i < value.length;i++) {
              if (typeof value[i] !== "number") {
                return null;
              }
            }
            if (!old) {
              old = new pc.Color;
            }
            for (i = 0;i < 4;i++) {
              old.data[i] = i === 4 && value.length === 3 ? 1 : value[i];
            }
            return old;
          } else {
            if (typeof value === "string" && /#([0-9abcdef]{2}){3,4}/i.test(value)) {
              if (!old) {
                old = new pc.Color;
              }
              old.fromString(value);
              return old;
            }
          }
        }
        return null;
      case "vec2":
      case "vec3":
      case "vec4":
        var len = parseInt(args.type.slice(3), 10);
        if (value instanceof pc["Vec" + len]) {
          if (old instanceof pc["Vec" + len]) {
            old.copy(value);
            return old;
          }
          return value.clone();
        } else {
          if (value instanceof Array && value.length === len) {
            for (i = 0;i < value.length;i++) {
              if (typeof value[i] !== "number") {
                return null;
              }
            }
            if (!old) {
              old = new pc["Vec" + len];
            }
            for (i = 0;i < len;i++) {
              old.data[i] = value[i];
            }
            return old;
          }
        }
        return null;
      case "curve":
        if (value) {
          var curve;
          if (value instanceof pc.Curve || value instanceof pc.CurveSet) {
            curve = value.clone();
          } else {
            var CurveType = value.keys[0] instanceof Array ? pc.CurveSet : pc.Curve;
            curve = new CurveType(value.keys);
            curve.type = value.type;
          }
          return curve;
        }
        break;
    }
    return value;
  };
  var ScriptAttributes = function(scriptType) {
    this.scriptType = scriptType;
    this.index = {};
  };
  ScriptAttributes.prototype.add = function(name, args) {
    if (this.index[name]) {
      return;
    } else {
      if (pc.createScript.reservedAttributes[name]) {
        return;
      }
    }
    this.index[name] = args;
    Object.defineProperty(this.scriptType.prototype, name, {get:function() {
      return this.__attributes[name];
    }, set:function(raw) {
      var old = this.__attributes[name];
      if (args.array) {
        this.__attributes[name] = [];
        if (raw) {
          var i;
          var len;
          for (i = 0, len = raw.length;i < len;i++) {
            this.__attributes[name].push(rawToValue(this.app, args, raw[i], old ? old[i] : null));
          }
        }
      } else {
        this.__attributes[name] = rawToValue(this.app, args, raw, old);
      }
      this.fire("attr", name, this.__attributes[name], old);
      this.fire("attr:" + name, this.__attributes[name], old);
    }});
  };
  ScriptAttributes.prototype.remove = function(name) {
    if (!this.index[name]) {
      return false;
    }
    delete this.index[name];
    delete this.scriptType.prototype[name];
    return true;
  };
  ScriptAttributes.prototype.has = function(name) {
    return !!this.index[name];
  };
  ScriptAttributes.prototype.get = function(name) {
    return this.index[name] || null;
  };
  var createScript = function(name, app) {
    if (pc.script.legacy) {
      return null;
    }
    if (createScript.reservedScripts[name]) {
      throw new Error("script name: '" + name + "' is reserved, please change script name");
    }
    var script = function(args) {
      pc.events.attach(this);
      this.app = args.app;
      this.entity = args.entity;
      this._enabled = typeof args.enabled === "boolean" ? args.enabled : true;
      this._enabledOld = this.enabled;
      this.__destroyed = false;
      this.__attributes = {};
      this.__attributesRaw = args.attributes || null;
      this.__scriptType = script;
    };
    script.__name = name;
    script.attributes = new ScriptAttributes(script);
    script.prototype.__initializeAttributes = function(force) {
      if (!force && !this.__attributesRaw) {
        return;
      }
      for (var key in script.attributes.index) {
        if (this.__attributesRaw && this.__attributesRaw.hasOwnProperty(key)) {
          this[key] = this.__attributesRaw[key];
        } else {
          if (!this.__attributes.hasOwnProperty(key)) {
            if (script.attributes.index[key].hasOwnProperty("default")) {
              this[key] = script.attributes.index[key]["default"];
            } else {
              this[key] = null;
            }
          }
        }
      }
      this.__attributesRaw = null;
    };
    script.extend = function(methods) {
      for (var key in methods) {
        if (!methods.hasOwnProperty(key)) {
          continue;
        }
        script.prototype[key] = methods[key];
      }
    };
    Object.defineProperty(script.prototype, "enabled", {get:function() {
      return this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled;
    }, set:function(value) {
      this._enabled = !!value;
      if (this.enabled === this._enabledOld) {
        return;
      }
      this._enabledOld = this.enabled;
      this.fire(this.enabled ? "enable" : "disable");
      this.fire("state", this.enabled);
      if (!this._initialized && this.enabled) {
        this._initialized = true;
        this.__initializeAttributes(true);
        if (this.initialize) {
          this.entity.script._scriptMethod(this, pc.ScriptComponent.scriptMethods.initialize);
        }
      }
      if (this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled) {
        this._postInitialized = true;
        if (this.postInitialize) {
          this.entity.script._scriptMethod(this, pc.ScriptComponent.scriptMethods.postInitialize);
        }
      }
    }});
    var registry = app ? app.scripts : pc.Application.getApplication().scripts;
    registry.add(script);
    pc.ScriptHandler._push(script);
    return script;
  };
  createScript.reservedScripts = ["system", "entity", "create", "destroy", "swap", "move", "scripts", "_scripts", "_scriptsIndex", "_scriptsData", "enabled", "_oldState", "onEnable", "onDisable", "onPostStateChange", "_onSetEnabled", "_checkState", "_onBeforeRemove", "_onInitializeAttributes", "_onInitialize", "_onPostInitialize", "_onUpdate", "_onPostUpdate", "_callbacks", "has", "on", "off", "fire", "once", "hasEvent"];
  var reservedScripts = {};
  var i;
  for (i = 0;i < createScript.reservedScripts.length;i++) {
    reservedScripts[createScript.reservedScripts[i]] = 1;
  }
  createScript.reservedScripts = reservedScripts;
  createScript.reservedAttributes = ["app", "entity", "enabled", "_enabled", "_enabledOld", "_destroyed", "__attributes", "__attributesRaw", "__scriptType", "_callbacks", "has", "on", "off", "fire", "once", "hasEvent"];
  var reservedAttributes = {};
  for (i = 0;i < createScript.reservedAttributes.length;i++) {
    reservedAttributes[createScript.reservedAttributes[i]] = 1;
  }
  createScript.reservedAttributes = reservedAttributes;
  return {createScript:createScript};
}());
pc.script = function() {
  var _legacy = false;
  var _createdLoadingScreen = false;
  var script = {app:null, create:function(name, callback) {
    if (!_legacy) {
      return;
    }
    var ScriptType = callback(pc.script.app);
    ScriptType._pcScriptName = name;
    pc.ScriptHandler._push(ScriptType);
    this.fire("created", name, callback);
  }, attribute:function(name, type, defaultValue, options) {
  }, createLoadingScreen:function(callback) {
    if (_createdLoadingScreen) {
      return;
    }
    _createdLoadingScreen = true;
    var app = pc.Application.getApplication();
    callback(app);
  }};
  Object.defineProperty(script, "legacy", {get:function() {
    return _legacy;
  }, set:function(value) {
    _legacy = value;
  }});
  pc.events.attach(script);
  return script;
}();
Object.assign(pc, function() {
  var Application = function(canvas, options) {
    options = options || {};
    pc.log.open();
    pc.events.attach(this);
    Application._applications[canvas.id] = this;
    Application._currentApplication = this;
    this._time = 0;
    this.timeScale = 1;
    this.maxDeltaTime = 0.1;
    this.autoRender = true;
    this.renderNextFrame = false;
    this._librariesLoaded = false;
    this._fillMode = pc.FILLMODE_KEEP_ASPECT;
    this._resolutionMode = pc.RESOLUTION_FIXED;
    this._allowResize = true;
    this.context = this;
    this.graphicsDevice = new pc.GraphicsDevice(canvas, options.graphicsDeviceOptions);
    this.stats = new pc.ApplicationStats(this.graphicsDevice);
    this.systems = new pc.ComponentSystemRegistry;
    this._audioManager = new pc.SoundManager(options);
    this.loader = new pc.ResourceLoader;
    this.scene = new pc.Scene;
    this.root = new pc.Entity(this);
    this.root._enabledInHierarchy = true;
    this._enableList = [];
    this._enableList.size = 0;
    this.assets = new pc.AssetRegistry(this.loader);
    if (options.assetPrefix) {
      this.assets.prefix = options.assetPrefix;
    }
    this.scriptsOrder = options.scriptsOrder || [];
    this.scripts = new pc.ScriptRegistry(this);
    this._sceneRegistry = new pc.SceneRegistry(this);
    var self = this;
    this.defaultLayerWorld = new pc.Layer({name:"World", id:pc.LAYERID_WORLD});
    if (this.graphicsDevice.webgl2) {
      this.defaultLayerDepth = new pc.Layer({enabled:false, name:"Depth", id:pc.LAYERID_DEPTH, onEnable:function() {
        if (this.renderTarget) {
          return;
        }
        var depthBuffer = new pc.Texture(self.graphicsDevice, {format:pc.PIXELFORMAT_DEPTHSTENCIL, width:self.graphicsDevice.width, height:self.graphicsDevice.height});
        depthBuffer.minFilter = pc.FILTER_NEAREST;
        depthBuffer.magFilter = pc.FILTER_NEAREST;
        depthBuffer.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
        depthBuffer.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
        this.renderTarget = new pc.RenderTarget({colorBuffer:null, depthBuffer:depthBuffer, autoResolve:false});
        self.graphicsDevice.scope.resolve("uDepthMap").setValue(depthBuffer);
      }, onDisable:function() {
        if (!this.renderTarget) {
          return;
        }
        this.renderTarget._depthBuffer.destroy();
        this.renderTarget.destroy();
        this.renderTarget = null;
      }, onPreRenderOpaque:function(cameraPass) {
        var gl = self.graphicsDevice.gl;
        this.srcFbo = gl.getParameter(gl.FRAMEBUFFER_BINDING);
        if (!this.renderTarget || (this.renderTarget.width !== self.graphicsDevice.width || this.renderTarget.height !== self.graphicsDevice.height)) {
          this.onDisable();
          this.onEnable();
        }
        this.oldClear = this.cameras[cameraPass].camera._clearOptions;
        this.cameras[cameraPass].camera._clearOptions = this.depthClearOptions;
      }, onPostRenderOpaque:function(cameraPass) {
        if (!this.renderTarget) {
          return;
        }
        this.cameras[cameraPass].camera._clearOptions = this.oldClear;
        var gl = self.graphicsDevice.gl;
        self.graphicsDevice.setRenderTarget(this.renderTarget);
        self.graphicsDevice.updateBegin();
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.srcFbo);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.renderTarget._glFrameBuffer);
        gl.blitFramebuffer(0, 0, this.renderTarget.width, this.renderTarget.height, 0, 0, this.renderTarget.width, this.renderTarget.height, gl.DEPTH_BUFFER_BIT, gl.NEAREST);
      }});
      this.defaultLayerDepth.depthClearOptions = {flags:0};
    } else {
      this.defaultLayerDepth = new pc.Layer({enabled:false, name:"Depth", id:pc.LAYERID_DEPTH, shaderPass:pc.SHADER_DEPTH, onEnable:function() {
        if (this.renderTarget) {
          return;
        }
        var colorBuffer = new pc.Texture(self.graphicsDevice, {format:pc.PIXELFORMAT_R8_G8_B8_A8, width:self.graphicsDevice.width, height:self.graphicsDevice.height});
        colorBuffer.minFilter = pc.FILTER_NEAREST;
        colorBuffer.magFilter = pc.FILTER_NEAREST;
        colorBuffer.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
        colorBuffer.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
        this.renderTarget = new pc.RenderTarget(self.graphicsDevice, colorBuffer, {depth:true, stencil:self.graphicsDevice.supportsStencil});
        self.graphicsDevice.scope.resolve("uDepthMap").setValue(colorBuffer);
      }, onDisable:function() {
        if (!this.renderTarget) {
          return;
        }
        this.renderTarget._colorBuffer.destroy();
        this.renderTarget.destroy();
        this.renderTarget = null;
      }, onPostCull:function(cameraPass) {
        var visibleObjects = this.instances.visibleOpaque[cameraPass];
        var visibleList = visibleObjects.list;
        var visibleLength = 0;
        var layers = self.scene.layers.layerList;
        var subLayerEnabled = self.scene.layers.subLayerEnabled;
        var isTransparent = self.scene.layers.subLayerList;
        var rt = self.defaultLayerWorld.renderTarget;
        var cam = this.cameras[cameraPass];
        var layer;
        var j;
        var layerVisibleList, layerCamId, layerVisibleListLength, drawCall, transparent;
        for (var i = 0;i < layers.length;i++) {
          layer = layers[i];
          if (layer === this) {
            break;
          }
          if (layer.renderTarget !== rt || !layer.enabled || !subLayerEnabled[i]) {
            continue;
          }
          layerCamId = layer.cameras.indexOf(cam);
          if (layerCamId < 0) {
            continue;
          }
          transparent = isTransparent[i];
          layerVisibleList = transparent ? layer.instances.visibleTransparent[layerCamId] : layer.instances.visibleOpaque[layerCamId];
          layerVisibleListLength = layerVisibleList.length;
          layerVisibleList = layerVisibleList.list;
          for (j = 0;j < layerVisibleListLength;j++) {
            drawCall = layerVisibleList[j];
            if (drawCall.material && drawCall.material.depthWrite && !drawCall._noDepthDrawGl1) {
              visibleList[visibleLength] = drawCall;
              visibleLength++;
            }
          }
        }
        visibleObjects.length = visibleLength;
      }, onPreRenderOpaque:function(cameraPass) {
        if (!this.renderTarget || (this.renderTarget.width !== self.graphicsDevice.width || this.renderTarget.height !== self.graphicsDevice.height)) {
          this.onDisable();
          this.onEnable();
        }
        this.oldClear = this.cameras[cameraPass].camera._clearOptions;
        this.cameras[cameraPass].camera._clearOptions = this.rgbaDepthClearOptions;
      }, onDrawCall:function() {
        self.graphicsDevice.setColorWrite(true, true, true, true);
      }, onPostRenderOpaque:function(cameraPass) {
        if (!this.renderTarget) {
          return;
        }
        this.cameras[cameraPass].camera._clearOptions = this.oldClear;
      }});
      this.defaultLayerDepth.rgbaDepthClearOptions = {color:[254.0 / 255, 254.0 / 255, 254.0 / 255, 254.0 / 255], depth:1.0, flags:pc.CLEARFLAG_COLOR | pc.CLEARFLAG_DEPTH};
    }
    this.defaultLayerSkybox = new pc.Layer({enabled:false, name:"Skybox", id:pc.LAYERID_SKYBOX, opaqueSortMode:pc.SORTMODE_NONE});
    this.defaultLayerUi = new pc.Layer({enabled:true, name:"UI", id:pc.LAYERID_UI, transparentSortMode:pc.SORTMODE_MANUAL, passThrough:true});
    this.defaultLayerImmediate = new pc.Layer({enabled:true, name:"Immediate", id:pc.LAYERID_IMMEDIATE, opaqueSortMode:pc.SORTMODE_NONE, passThrough:true});
    this.defaultLayerComposition = new pc.LayerComposition;
    this.defaultLayerComposition.pushOpaque(this.defaultLayerWorld);
    this.defaultLayerComposition.pushOpaque(this.defaultLayerDepth);
    this.defaultLayerComposition.pushOpaque(this.defaultLayerSkybox);
    this.defaultLayerComposition.pushTransparent(this.defaultLayerWorld);
    this.defaultLayerComposition.pushOpaque(this.defaultLayerImmediate);
    this.defaultLayerComposition.pushTransparent(this.defaultLayerImmediate);
    this.defaultLayerComposition.pushTransparent(this.defaultLayerUi);
    this.scene.layers = this.defaultLayerComposition;
    this._immediateLayer = this.defaultLayerImmediate;
    this.scene.on("set:layers", function(oldComp, newComp) {
      var list = newComp.layerList;
      var layer;
      for (var i = 0;i < list.length;i++) {
        layer = list[i];
        switch(layer.id) {
          case pc.LAYERID_DEPTH:
            layer.onEnable = self.defaultLayerDepth.onEnable;
            layer.onDisable = self.defaultLayerDepth.onDisable;
            layer.onPreRenderOpaque = self.defaultLayerDepth.onPreRenderOpaque;
            layer.onPostRenderOpaque = self.defaultLayerDepth.onPostRenderOpaque;
            layer.depthClearOptions = self.defaultLayerDepth.depthClearOptions;
            layer.rgbaDepthClearOptions = self.defaultLayerDepth.rgbaDepthClearOptions;
            layer.shaderPass = self.defaultLayerDepth.shaderPass;
            layer.onPostCull = self.defaultLayerDepth.onPostCull;
            layer.onDrawCall = self.defaultLayerDepth.onDrawCall;
            break;
          case pc.LAYERID_UI:
            layer.passThrough = self.defaultLayerUi.passThrough;
            break;
          case pc.LAYERID_IMMEDIATE:
            layer.passThrough = self.defaultLayerImmediate.passThrough;
            break;
        }
      }
    });
    this.renderer = new pc.ForwardRenderer(this.graphicsDevice);
    this.renderer.scene = this.scene;
    this.lightmapper = new pc.Lightmapper(this.graphicsDevice, this.root, this.scene, this.renderer, this.assets);
    this.once("prerender", this._firstBake, this);
    this.batcher = new pc.BatchManager(this.graphicsDevice, this.root, this.scene);
    this.once("prerender", this._firstBatch, this);
    this.keyboard = options.keyboard || null;
    this.mouse = options.mouse || null;
    this.touch = options.touch || null;
    this.gamepads = options.gamepads || null;
    this.elementInput = options.elementInput || null;
    if (this.elementInput) {
      this.elementInput.app = this;
    }
    this.vr = null;
    if (options.vr) {
      this._onVrChange(options.vr);
    }
    this._inTools = false;
    this._skyboxLast = 0;
    this._scriptPrefix = options.scriptPrefix || "";
    this.loader.addHandler("animation", new pc.AnimationHandler);
    this.loader.addHandler("model", new pc.ModelHandler(this.graphicsDevice));
    this.loader.addHandler("material", new pc.MaterialHandler(this));
    this.loader.addHandler("texture", new pc.TextureHandler(this.graphicsDevice, this.assets, this.loader));
    this.loader.addHandler("text", new pc.TextHandler);
    this.loader.addHandler("json", new pc.JsonHandler);
    this.loader.addHandler("audio", new pc.AudioHandler(this._audioManager));
    this.loader.addHandler("script", new pc.ScriptHandler(this));
    this.loader.addHandler("scene", new pc.SceneHandler(this));
    this.loader.addHandler("cubemap", new pc.CubemapHandler(this.graphicsDevice, this.assets, this.loader));
    this.loader.addHandler("html", new pc.HtmlHandler);
    this.loader.addHandler("css", new pc.CssHandler);
    this.loader.addHandler("shader", new pc.ShaderHandler);
    this.loader.addHandler("hierarchy", new pc.HierarchyHandler(this));
    this.loader.addHandler("scenesettings", new pc.SceneSettingsHandler(this));
    this.loader.addHandler("folder", new pc.FolderHandler);
    this.loader.addHandler("font", new pc.FontHandler(this.loader));
    this.loader.addHandler("binary", new pc.BinaryHandler);
    this.loader.addHandler("textureatlas", new pc.TextureAtlasHandler(this.loader));
    this.loader.addHandler("sprite", new pc.SpriteHandler(this.assets, this.graphicsDevice));
    new pc.RigidBodyComponentSystem(this);
    new pc.CollisionComponentSystem(this);
    new pc.AnimationComponentSystem(this);
    new pc.ModelComponentSystem(this);
    new pc.CameraComponentSystem(this);
    new pc.LightComponentSystem(this);
    if (pc.script.legacy) {
      new pc.ScriptLegacyComponentSystem(this);
    } else {
      new pc.ScriptComponentSystem(this);
    }
    new pc.AudioSourceComponentSystem(this, this._audioManager);
    new pc.SoundComponentSystem(this, this._audioManager);
    new pc.AudioListenerComponentSystem(this, this._audioManager);
    new pc.ParticleSystemComponentSystem(this);
    new pc.ScreenComponentSystem(this);
    new pc.ElementComponentSystem(this);
    new pc.ButtonComponentSystem(this);
    new pc.ScrollViewComponentSystem(this);
    new pc.ScrollbarComponentSystem(this);
    new pc.SpriteComponentSystem(this);
    new pc.LayoutGroupComponentSystem(this);
    new pc.LayoutChildComponentSystem(this);
    new pc.ZoneComponentSystem(this);
    this._visibilityChangeHandler = this.onVisibilityChange.bind(this);
    if (document.hidden !== undefined) {
      this._hiddenAttr = "hidden";
      document.addEventListener("visibilitychange", this._visibilityChangeHandler, false);
    } else {
      if (document.mozHidden !== undefined) {
        this._hiddenAttr = "mozHidden";
        document.addEventListener("mozvisibilitychange", this._visibilityChangeHandler, false);
      } else {
        if (document.msHidden !== undefined) {
          this._hiddenAttr = "msHidden";
          document.addEventListener("msvisibilitychange", this._visibilityChangeHandler, false);
        } else {
          if (document.webkitHidden !== undefined) {
            this._hiddenAttr = "webkitHidden";
            document.addEventListener("webkitvisibilitychange", this._visibilityChangeHandler, false);
          }
        }
      }
    }
    this.tick = makeTick(this);
  };
  Application._currentApplication = null;
  Application._applications = {};
  Application.getApplication = function(id) {
    return id ? Application._applications[id] : Application._currentApplication;
  };
  var Progress = function(length) {
    this.length = length;
    this.count = 0;
    this.inc = function() {
      this.count++;
    };
    this.done = function() {
      return this.count === this.length;
    };
  };
  Object.assign(Application.prototype, {configure:function(url, callback) {
    var self = this;
    pc.http.get(url, function(err, response) {
      if (err) {
        callback(err);
        return;
      }
      var props = response.application_properties;
      var scenes = response.scenes;
      var assets = response.assets;
      self._parseApplicationProperties(props, function(err) {
        self._onVrChange(props.vr);
        self._parseScenes(scenes);
        self._parseAssets(assets);
        if (!err) {
          callback(null);
        } else {
          callback(err);
        }
      });
    });
  }, preload:function(callback) {
    var self = this;
    self.fire("preload:start");
    var assets = this.assets.list({preload:true});
    var _assets = new Progress(assets.length);
    var _done = false;
    var done = function() {
      if (!self.graphicsDevice) {
        return;
      }
      if (!_done && _assets.done()) {
        _done = true;
        self.fire("preload:end");
        callback();
      }
    };
    var total = assets.length;
    var count = function() {
      return _assets.count;
    };
    var i;
    if (_assets.length) {
      var onAssetLoad = function(asset) {
        _assets.inc();
        self.fire("preload:progress", count() / total);
        if (_assets.done()) {
          done();
        }
      };
      var onAssetError = function(err, asset) {
        _assets.inc();
        self.fire("preload:progress", count() / total);
        if (_assets.done()) {
          done();
        }
      };
      for (i = 0;i < assets.length;i++) {
        if (!assets[i].loaded) {
          assets[i].once("load", onAssetLoad);
          assets[i].once("error", onAssetError);
          this.assets.load(assets[i]);
        } else {
          _assets.inc();
          self.fire("preload:progress", count() / total);
          if (_assets.done()) {
            done();
          }
        }
      }
    } else {
      done();
    }
  }, getSceneUrl:function(name) {
    var entry = this._sceneRegistry.find(name);
    if (entry) {
      return entry.url;
    }
    return null;
  }, loadSceneHierarchy:function(url, callback) {
    this._sceneRegistry.loadSceneHierarchy(url, callback);
  }, loadSceneSettings:function(url, callback) {
    this._sceneRegistry.loadSceneSettings(url, callback);
  }, loadScene:function(url, callback) {
    this._sceneRegistry.loadScene(url, callback);
  }, _preloadScripts:function(sceneData, callback) {
    if (!pc.script.legacy) {
      callback();
      return;
    }
    var self = this;
    self.systems.script.preloading = true;
    var scripts = this._getScriptReferences(sceneData);
    var i = 0, l = scripts.length;
    var progress = new Progress(l);
    var scriptUrl;
    var regex = /^http(s)?:\/\//;
    if (l) {
      var onLoad = function(err, ScriptType) {
        if (err) {
          console.error(err);
        }
        progress.inc();
        if (progress.done()) {
          self.systems.script.preloading = false;
          callback();
        }
      };
      for (i = 0;i < l;i++) {
        scriptUrl = scripts[i];
        if (!regex.test(scriptUrl.toLowerCase()) && self._scriptPrefix) {
          scriptUrl = pc.path.join(self._scriptPrefix, scripts[i]);
        }
        this.loader.load(scriptUrl, "script", onLoad);
      }
    } else {
      self.systems.script.preloading = false;
      callback();
    }
  }, _parseApplicationProperties:function(props, callback) {
    var i;
    var len;
    if (!props.useDevicePixelRatio) {
      props.useDevicePixelRatio = props.use_device_pixel_ratio;
    }
    if (!props.resolutionMode) {
      props.resolutionMode = props.resolution_mode;
    }
    if (!props.fillMode) {
      props.fillMode = props.fill_mode;
    }
    if (!props.vrPolyfillUrl) {
      props.vrPolyfillUrl = props.vr_polyfill_url;
    }
    this._width = props.width;
    this._height = props.height;
    if (props.useDevicePixelRatio) {
      this.graphicsDevice.maxPixelRatio = window.devicePixelRatio;
    }
    this.setCanvasResolution(props.resolutionMode, this._width, this._height);
    this.setCanvasFillMode(props.fillMode, this._width, this._height);
    if (props.vr && props.vrPolyfillUrl) {
      if (!pc.VrManager.isSupported || pc.platform.android) {
        props.libraries.push(props.vrPolyfillUrl);
      }
    }
    if (props.layers && props.layerOrder) {
      var composition = new pc.LayerComposition;
      var layers = {};
      for (var key in props.layers) {
        var data = props.layers[key];
        data.id = parseInt(key, 10);
        data.enabled = data.id !== pc.LAYERID_DEPTH;
        layers[key] = new pc.Layer(data);
      }
      for (i = 0, len = props.layerOrder.length;i < len;i++) {
        var sublayer = props.layerOrder[i];
        var layer = layers[sublayer.layer];
        if (!layer) {
          continue;
        }
        if (sublayer.transparent) {
          composition.pushTransparent(layer);
        } else {
          composition.pushOpaque(layer);
        }
        composition.subLayerEnabled[i] = sublayer.enabled;
      }
      this.scene.layers = composition;
    }
    if (props.batchGroups) {
      for (i = 0, len = props.batchGroups.length;i < len;i++) {
        var grp = props.batchGroups[i];
        this.batcher.addGroup(grp.name, grp.dynamic, grp.maxAabbSize, grp.id, grp.layers);
      }
    }
    this._loadLibraries(props.libraries, callback);
  }, _loadLibraries:function(urls, callback) {
    var len = urls.length;
    var count = len;
    var self = this;
    var regex = /^http(s)?:\/\//;
    if (len) {
      var onLoad = function(err, script) {
        count--;
        if (err) {
          callback(err);
        } else {
          if (count === 0) {
            self.onLibrariesLoaded();
            callback(null);
          }
        }
      };
      for (var i = 0;i < len;++i) {
        var url = urls[i];
        if (!regex.test(url.toLowerCase()) && self._scriptPrefix) {
          url = pc.path.join(self._scriptPrefix, url);
        }
        this.loader.load(url, "script", onLoad);
      }
    } else {
      callback(null);
    }
  }, _parseScenes:function(scenes) {
    if (!scenes) {
      return;
    }
    for (var i = 0;i < scenes.length;i++) {
      this._sceneRegistry.add(scenes[i].name, scenes[i].url);
    }
  }, _parseAssets:function(assets) {
    var i, id;
    var list = [];
    var scriptsIndex = {};
    if (!pc.script.legacy) {
      for (i = 0;i < this.scriptsOrder.length;i++) {
        id = this.scriptsOrder[i];
        if (!assets[id]) {
          continue;
        }
        scriptsIndex[id] = true;
        list.push(assets[id]);
      }
      for (id in assets) {
        if (scriptsIndex[id]) {
          continue;
        }
        list.push(assets[id]);
      }
    } else {
      for (id in assets) {
        list.push(assets[id]);
      }
    }
    for (i = 0;i < list.length;i++) {
      var data = list[i];
      var asset = new pc.Asset(data.name, data.type, data.file, data.data);
      asset.id = parseInt(data.id, 10);
      asset.preload = data.preload ? data.preload : false;
      asset.tags.add(data.tags);
      this.assets.add(asset);
    }
  }, _getScriptReferences:function(scene) {
    var i, key;
    var priorityScripts = [];
    if (scene.settings.priority_scripts) {
      priorityScripts = scene.settings.priority_scripts;
    }
    var _scripts = [];
    var _index = {};
    for (i = 0;i < priorityScripts.length;i++) {
      _scripts.push(priorityScripts[i]);
      _index[priorityScripts[i]] = true;
    }
    var entities = scene.entities;
    for (key in entities) {
      if (!entities[key].components.script) {
        continue;
      }
      var scripts = entities[key].components.script.scripts;
      for (i = 0;i < scripts.length;i++) {
        if (_index[scripts[i].url]) {
          continue;
        }
        _scripts.push(scripts[i].url);
        _index[scripts[i].url] = true;
      }
    }
    return _scripts;
  }, start:function() {
    this.fire("start", {timestamp:pc.now(), target:this});
    if (!this._librariesLoaded) {
      this.onLibrariesLoaded();
    }
    pc.ComponentSystem.initialize(this.root);
    this.fire("initialize");
    pc.ComponentSystem.postInitialize(this.root);
    this.fire("postinitialize");
    this.tick();
  }, update:function(dt) {
    this.graphicsDevice.updateClientRect();
    if (this.vr) {
      this.vr.poll();
    }
    if (pc.script.legacy) {
      pc.ComponentSystem.fixedUpdate(1.0 / 60.0, this._inTools);
    }
    pc.ComponentSystem.update(dt, this._inTools);
    pc.ComponentSystem.postUpdate(dt, this._inTools);
    this.fire("update", dt);
    if (this.controller) {
      this.controller.update(dt);
    }
    if (this.mouse) {
      this.mouse.update(dt);
    }
    if (this.keyboard) {
      this.keyboard.update(dt);
    }
    if (this.gamepads) {
      this.gamepads.update(dt);
    }
  }, render:function() {
    this.fire("prerender");
    this.root.syncHierarchy();
    this.batcher.updateAll();
    pc._skipRenderCounter = 0;
    this.renderer.renderComposition(this.scene.layers);
    this.fire("postrender");
  }, _fillFrameStats:function(now, dt, ms) {
    var stats = this.stats.frame;
    stats.dt = dt;
    stats.ms = ms;
    if (now > stats._timeToCountFrames) {
      stats.fps = stats._fpsAccum;
      stats._fpsAccum = 0;
      stats._timeToCountFrames = now + 1000;
    } else {
      stats._fpsAccum++;
    }
    stats.cameras = this.renderer._camerasRendered;
    stats.materials = this.renderer._materialSwitches;
    stats.shaders = this.graphicsDevice._shaderSwitchesPerFrame;
    stats.shadowMapUpdates = this.renderer._shadowMapUpdates;
    stats.shadowMapTime = this.renderer._shadowMapTime;
    stats.depthMapTime = this.renderer._depthMapTime;
    stats.forwardTime = this.renderer._forwardTime;
    var prims = this.graphicsDevice._primsPerFrame;
    stats.triangles = prims[pc.PRIMITIVE_TRIANGLES] / 3 + Math.max(prims[pc.PRIMITIVE_TRISTRIP] - 2, 0) + Math.max(prims[pc.PRIMITIVE_TRIFAN] - 2, 0);
    stats.cullTime = this.renderer._cullTime;
    stats.sortTime = this.renderer._sortTime;
    stats.skinTime = this.renderer._skinTime;
    stats.morphTime = this.renderer._morphTime;
    stats.instancingTime = this.renderer._instancingTime;
    stats.otherPrimitives = 0;
    for (var i = 0;i < prims.length;i++) {
      if (i < pc.PRIMITIVE_TRIANGLES) {
        stats.otherPrimitives += prims[i];
      }
      prims[i] = 0;
    }
    this.renderer._camerasRendered = 0;
    this.renderer._materialSwitches = 0;
    this.renderer._shadowMapUpdates = 0;
    this.graphicsDevice._shaderSwitchesPerFrame = 0;
    this.renderer._cullTime = 0;
    this.renderer._sortTime = 0;
    this.renderer._skinTime = 0;
    this.renderer._morphTime = 0;
    this.renderer._instancingTime = 0;
    this.renderer._shadowMapTime = 0;
    this.renderer._depthMapTime = 0;
    this.renderer._forwardTime = 0;
    stats = this.stats.drawCalls;
    stats.forward = this.renderer._forwardDrawCalls;
    stats.depth = 0;
    stats.shadow = this.renderer._shadowDrawCalls;
    stats.skinned = this.renderer._skinDrawCalls;
    stats.immediate = 0;
    stats.instanced = 0;
    stats.removedByInstancing = 0;
    stats.total = this.graphicsDevice._drawCallsPerFrame;
    stats.misc = stats.total - (stats.forward + stats.shadow);
    this.renderer._depthDrawCalls = 0;
    this.renderer._shadowDrawCalls = 0;
    this.renderer._forwardDrawCalls = 0;
    this.renderer._skinDrawCalls = 0;
    this.renderer._immediateRendered = 0;
    this.renderer._instancedDrawCalls = 0;
    this.renderer._removedByInstancing = 0;
    this.graphicsDevice._drawCallsPerFrame = 0;
    this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;
    stats = this.stats.particles;
    stats.updatesPerFrame = stats._updatesPerFrame;
    stats.frameTime = stats._frameTime;
    stats._updatesPerFrame = 0;
    stats._frameTime = 0;
  }, setCanvasFillMode:function(mode, width, height) {
    this._fillMode = mode;
    this.resizeCanvas(width, height);
  }, setCanvasResolution:function(mode, width, height) {
    this._resolutionMode = mode;
    if (mode === pc.RESOLUTION_AUTO && width === undefined) {
      width = this.graphicsDevice.canvas.clientWidth;
      height = this.graphicsDevice.canvas.clientHeight;
    }
    this.graphicsDevice.resizeCanvas(width, height);
  }, isFullscreen:function() {
    return !!document.fullscreenElement;
  }, enableFullscreen:function(element, success, error) {
    element = element || this.graphicsDevice.canvas;
    var s = function() {
      success();
      document.removeEventListener("fullscreenchange", s);
    };
    var e = function() {
      error();
      document.removeEventListener("fullscreenerror", e);
    };
    if (success) {
      document.addEventListener("fullscreenchange", s, false);
    }
    if (error) {
      document.addEventListener("fullscreenerror", e, false);
    }
    if (element.requestFullscreen) {
      element.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    } else {
      error();
    }
  }, disableFullscreen:function(success) {
    var s = function() {
      success();
      document.removeEventListener("fullscreenchange", s);
    };
    if (success) {
      document.addEventListener("fullscreenchange", s, false);
    }
    document.exitFullscreen();
  }, isHidden:function() {
    return document[this._hiddenAttr];
  }, onVisibilityChange:function() {
    if (this.isHidden()) {
      this._audioManager.suspend();
    } else {
      this._audioManager.resume();
    }
  }, resizeCanvas:function(width, height) {
    if (!this._allowResize) {
      return;
    }
    var windowWidth = window.innerWidth;
    var windowHeight = window.innerHeight;
    if (navigator.isCocoonJS) {
      width = windowWidth;
      height = windowHeight;
      this.graphicsDevice.resizeCanvas(width, height);
    } else {
      if (this._fillMode === pc.FILLMODE_KEEP_ASPECT) {
        var r = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;
        var winR = windowWidth / windowHeight;
        if (r > winR) {
          width = windowWidth;
          height = width / r;
        } else {
          height = windowHeight;
          width = height * r;
        }
      } else {
        if (this._fillMode === pc.FILLMODE_FILL_WINDOW) {
          width = windowWidth;
          height = windowHeight;
        } else {
        }
      }
      this.graphicsDevice.canvas.style.width = width + "px";
      this.graphicsDevice.canvas.style.height = height + "px";
      if (this._resolutionMode === pc.RESOLUTION_AUTO) {
        this.setCanvasResolution(pc.RESOLUTION_AUTO);
      }
    }
    return {width:width, height:height};
  }, onLibrariesLoaded:function() {
    this._librariesLoaded = true;
    this.systems.rigidbody.onLibraryLoaded();
    this.systems.collision.onLibraryLoaded();
  }, applySceneSettings:function(settings) {
    var asset;
    if (this.systems.rigidbody && typeof Ammo !== "undefined") {
      var gravity = settings.physics.gravity;
      this.systems.rigidbody.setGravity(gravity[0], gravity[1], gravity[2]);
    }
    this.scene.applySettings(settings);
    if (settings.render.hasOwnProperty("skybox")) {
      if (settings.render.skybox) {
        asset = this.assets.get(settings.render.skybox);
        if (asset) {
          this.setSkybox(asset);
        } else {
          this.assets.once("add:" + settings.render.skybox, this.setSkybox, this);
        }
      } else {
        this.setSkybox(null);
      }
    }
  }, setSkybox:function(asset) {
    if (asset) {
      if (this._skyboxLast === asset.id) {
        if (this.scene.skyboxMip === 0 && !asset.loadFaces) {
          this._skyboxLoad(asset);
        } else {
          this._onSkyboxChange(asset);
        }
        return;
      }
      if (this._skyboxLast) {
        this.assets.off("add:" + this._skyboxLast, this.setSkybox, this);
        this.assets.off("load:" + this._skyboxLast, this._onSkyboxChange, this);
        this.assets.off("remove:" + this._skyboxLast, this._skyboxRemove, this);
      }
      this._skyboxLast = asset.id;
      this.assets.on("load:" + asset.id, this._onSkyboxChange, this);
      this.assets.once("remove:" + asset.id, this._skyboxRemove, this);
      if (asset.resource) {
        this.scene.setSkybox(asset.resources);
      }
      this._skyboxLoad(asset);
    } else {
      if (!this._skyboxLast) {
        return;
      }
      this._skyboxRemove({id:this._skyboxLast});
    }
  }, _onVrChange:function(enabled) {
    if (enabled) {
      if (!this.vr) {
        this.vr = new pc.VrManager(this);
      }
    } else {
      if (this.vr) {
        this.vr.destroy();
        this.vr = null;
      }
    }
  }, _onSkyboxChange:function(asset) {
    this.scene.setSkybox(asset.resources);
  }, _skyboxLoad:function(asset) {
    if (this.scene.skyboxMip === 0) {
      asset.loadFaces = true;
    }
    this.assets.load(asset);
    this._onSkyboxChange(asset);
  }, _skyboxRemove:function(asset) {
    if (!this._skyboxLast) {
      return;
    }
    this.assets.off("add:" + asset.id, this.setSkybox, this);
    this.assets.off("load:" + asset.id, this._onSkyboxChange, this);
    this.assets.off("remove:" + asset.id, this._skyboxRemove, this);
    this.scene.setSkybox(null);
    this._skyboxLast = null;
  }, _firstBake:function() {
    this.lightmapper.bake(null, this.scene.lightmapMode);
  }, _firstBatch:function() {
    if (this.scene._needsStaticPrepare) {
      this.renderer.prepareStaticMeshes(this.graphicsDevice, this.scene);
      this.scene._needsStaticPrepare = false;
    }
    this.batcher.generate();
  }, destroy:function() {
    Application._applications[this.graphicsDevice.canvas.id] = null;
    if (Application._currentApplication === this) {
      Application._currentApplication = null;
    }
    this.off("librariesloaded");
    document.removeEventListener("visibilitychange", this._visibilityChangeHandler);
    document.removeEventListener("mozvisibilitychange", this._visibilityChangeHandler);
    document.removeEventListener("msvisibilitychange", this._visibilityChangeHandler);
    document.removeEventListener("webkitvisibilitychange", this._visibilityChangeHandler);
    this.root.destroy();
    this.root = null;
    if (this.mouse) {
      this.mouse.off("mouseup");
      this.mouse.off("mousedown");
      this.mouse.off("mousewheel");
      this.mouse.off("mousemove");
      this.mouse.detach();
      this.mouse = null;
    }
    if (this.keyboard) {
      this.keyboard.off("keydown");
      this.keyboard.off("keyup");
      this.keyboard.off("keypress");
      this.keyboard.detach();
      this.keyboard = null;
    }
    if (this.touch) {
      this.touch.off("touchstart");
      this.touch.off("touchend");
      this.touch.off("touchmove");
      this.touch.off("touchcancel");
      this.touch.detach();
      this.touch = null;
    }
    if (this.elementInput) {
      this.elementInput.detach();
      this.elementInput = null;
    }
    if (this.controller) {
      this.controller = null;
    }
    pc.ComponentSystem.destroy();
    var assets = this.assets.list();
    for (var i = 0;i < assets.length;i++) {
      assets[i].unload();
    }
    this.loader.destroy();
    this.loader = null;
    this.scene = null;
    this.systems = [];
    this.context = null;
    this.graphicsDevice.clearShaderCache();
    this.graphicsDevice.destroy();
    this.graphicsDevice.destroyed = true;
    this.graphicsDevice = null;
    this.renderer = null;
    this.tick = null;
    if (this._audioManager) {
      this._audioManager.destroy();
      this._audioManager = null;
    }
    pc.http = new pc.Http;
    pc.ParticleEmitter.DEFAULT_PARAM_TEXTURE = null;
    pc.destroyPostEffectQuad();
  }});
  var _frameEndData = {};
  var makeTick = function(_app) {
    var app = _app;
    return function(timestamp) {
      if (!app.graphicsDevice) {
        return;
      }
      Application._currentApplication = app;
      pc.app = app;
      var now = timestamp || pc.now();
      var ms = now - (app._time || now);
      var dt = ms / 1000.0;
      dt = pc.math.clamp(dt, 0, app.maxDeltaTime);
      dt *= app.timeScale;
      app._time = now;
      if (app.vr && app.vr.display) {
        app.vr.display.requestAnimationFrame(app.tick);
      } else {
        window.requestAnimationFrame(app.tick);
      }
      if (app.graphicsDevice.contextLost) {
        return;
      }
      app.update(dt);
      if (app.autoRender || app.renderNextFrame) {
        app.render();
        app.renderNextFrame = false;
      }
      _frameEndData.timestamp = pc.now();
      _frameEndData.target = app;
      app.fire("frameend", _frameEndData);
      app.fire("frameEnd", _frameEndData);
      if (app.vr && app.vr.display && app.vr.display.presenting) {
        app.vr.display.submitFrame();
      }
    };
  };
  return {FILLMODE_NONE:"NONE", FILLMODE_FILL_WINDOW:"FILL_WINDOW", FILLMODE_KEEP_ASPECT:"KEEP_ASPECT", RESOLUTION_AUTO:"AUTO", RESOLUTION_FIXED:"FIXED", Application:Application};
}());
pc.ApplicationStats = function(device) {
  this.frame = {fps:0, ms:0, dt:0, updateStart:0, updateTime:0, renderStart:0, renderTime:0, physicsStart:0, physicsTime:0, cullTime:0, sortTime:0, skinTime:0, morphTime:0, instancingTime:0, triangles:0, otherPrimitives:0, shaders:0, materials:0, cameras:0, shadowMapUpdates:0, shadowMapTime:0, depthMapTime:0, forwardTime:0, _timeToCountFrames:0, _fpsAccum:0};
  this.drawCalls = {forward:0, depth:0, shadow:0, immediate:0, misc:0, total:0, skinned:0, instanced:0, removedByInstancing:0};
  this.misc = {renderTargetCreationTime:0};
  this.particles = {updatesPerFrame:0, _updatesPerFrame:0, frameTime:0, _frameTime:0};
  this.vram = device._vram;
  this.shaders = device._shaderStats;
  Object.defineProperty(this.vram, "totalUsed", {get:function() {
    return this.tex + this.vb + this.ib;
  }});
  Object.defineProperty(this, "scene", {get:function() {
    return pc.Application._currentApplication.scene._stats;
  }});
  Object.defineProperty(this, "lightmapper", {get:function() {
    return pc.Application._currentApplication.lightmapper._stats;
  }});
  Object.defineProperty(this, "batcher", {get:function() {
    return pc.Application._currentApplication.batcher._stats;
  }});
  pc.events.attach(this);
};
Object.assign(pc, function() {
  var SceneRegistryItem = function(name, url) {
    this.name = name;
    this.url = url;
  };
  var SceneRegistry = function(app) {
    this._app = app;
    this._list = [];
    this._index = {};
    this._urlIndex = {};
  };
  SceneRegistry.prototype.list = function() {
    return this._list;
  };
  SceneRegistry.prototype.add = function(name, url) {
    if (this._index.hasOwnProperty(name)) {
      return false;
    }
    var item = new pc.SceneRegistryItem(name, url);
    var i = this._list.push(item);
    this._index[item.name] = i - 1;
    this._urlIndex[item.url] = i - 1;
    return true;
  };
  SceneRegistry.prototype.find = function(name) {
    if (this._index.hasOwnProperty(name)) {
      return this._list[this._index[name]];
    }
    return null;
  };
  SceneRegistry.prototype.findByUrl = function(url) {
    if (this._urlIndex.hasOwnProperty(url)) {
      return this._list[this._urlIndex[url]];
    }
    return null;
  };
  SceneRegistry.prototype.remove = function(name) {
    if (this._index.hasOwnProperty(name)) {
      var i = this._index[name];
      var item = this._list[i];
      delete this._urlIndex[item.url];
      delete this._index[name];
      this._list.splice(i, 1);
      for (i = 0;i < this._list.length;i++) {
        item = this._list[i];
        this._index[item.name] = i;
        this._urlIndex[item.url] = i;
      }
    }
  };
  SceneRegistry.prototype.loadSceneHierarchy = function(url, callback) {
    var self = this;
    var handler = this._app.loader.getHandler("hierarchy");
    if (this._app.assets && this._app.assets.prefix && !pc.ABSOLUTE_URL.test(url)) {
      url = pc.path.join(this._app.assets.prefix, url);
    }
    handler.load(url, function(err, data) {
      if (err) {
        if (callback) {
          callback(err);
        }
        return;
      }
      var _loaded = function() {
        self._app.systems.script.preloading = true;
        var entity = handler.open(url, data);
        self._app.systems.script.preloading = false;
        self._app.loader.clearCache(url, "hierarchy");
        self._app.root.addChild(entity);
        pc.ComponentSystem.initialize(entity);
        pc.ComponentSystem.postInitialize(entity);
        if (callback) {
          callback(err, entity);
        }
      };
      self._app._preloadScripts(data, _loaded);
    });
  };
  SceneRegistry.prototype.loadSceneSettings = function(url, callback) {
    var self = this;
    if (this._app.assets && this._app.assets.prefix && !pc.ABSOLUTE_URL.test(url)) {
      url = pc.path.join(this._app.assets.prefix, url);
    }
    this._app.loader.load(url, "scenesettings", function(err, settings) {
      if (!err) {
        self._app.applySceneSettings(settings);
        if (callback) {
          callback(null);
        }
      } else {
        if (callback) {
          callback(err);
        }
      }
    });
  };
  SceneRegistry.prototype.loadScene = function(url, callback) {
    var self = this;
    var handler = this._app.loader.getHandler("scene");
    if (this._app.assets && this._app.assets.prefix && !pc.ABSOLUTE_URL.test(url)) {
      url = pc.path.join(this._app.assets.prefix, url);
    }
    handler.load(url, function(err, data) {
      if (!err) {
        var _loaded = function() {
          self._app.systems.script.preloading = true;
          var scene = handler.open(url, data);
          self._app.systems.script.preloading = false;
          self._app.loader.clearCache(url, "scene");
          self._app.loader.patch({resource:scene, type:"scene"}, self._app.assets);
          self._app.root.addChild(scene.root);
          if (self._app.systems.rigidbody && typeof Ammo !== "undefined") {
            self._app.systems.rigidbody.setGravity(scene._gravity.x, scene._gravity.y, scene._gravity.z);
          }
          if (callback) {
            callback(null, scene);
          }
        };
        self._app._preloadScripts(data, _loaded);
      } else {
        if (callback) {
          callback(err);
        }
      }
    });
  };
  return {SceneRegistry:SceneRegistry, SceneRegistryItem:SceneRegistryItem};
}());
Object.assign(pc, function() {
  var ComponentSystemRegistry = function() {
  };
  Object.assign(ComponentSystemRegistry.prototype, {add:function(name, system) {
    if (!this[name]) {
      this[name] = system;
      system.name = name;
    } else {
      throw new Error(pc.string.format("ComponentSystem name '{0}' already registered or not allowed", name));
    }
  }, remove:function(name) {
    if (!this[name]) {
      throw new Error(pc.string.format("No ComponentSystem named '{0}' registered", name));
    }
    delete this[name];
  }, list:function() {
    var list = Object.keys(this);
    var defaultPriority = 1;
    var priorities = {"collisionrect":0.5, "collisioncircle":0.5};
    list.sort(function(a, b) {
      var pa = priorities[a] || defaultPriority;
      var pb = priorities[b] || defaultPriority;
      if (pa < pb) {
        return -1;
      } else {
        if (pa > pb) {
          return 1;
        }
      }
      return 0;
    });
    return list.map(function(key) {
      return this[key];
    }, this);
  }, getComponentSystemOrder:function() {
    var index;
    var names = Object.keys(this);
    index = names.indexOf("collisionrect");
    names.splice(index, 1);
    names.unshift("collisionrect");
    index = names.indexOf("collisioncircle");
    names.splice(index, 1);
    names.unshift("collisioncircle");
    return names;
  }});
  return {ComponentSystemRegistry:ComponentSystemRegistry};
}());
Object.assign(pc, function() {
  var ComponentSystem = function(app) {
    this.app = app;
    this.dataStore = {};
    this.schema = [];
    pc.events.attach(this);
  };
  Object.assign(ComponentSystem, {initialize:function(root) {
    ComponentSystem.fire("initialize", root);
  }, postInitialize:function(root) {
    ComponentSystem.fire("postInitialize", root);
  }, update:function(dt, inTools) {
    if (inTools) {
      ComponentSystem.fire("toolsUpdate", dt);
    } else {
      ComponentSystem.fire("update", dt);
    }
  }, fixedUpdate:function(dt, inTools) {
    ComponentSystem.fire("fixedUpdate", dt);
  }, postUpdate:function(dt, inTools) {
    ComponentSystem.fire("postUpdate", dt);
  }});
  ComponentSystem.prototype = {get store() {
    return this.dataStore;
  }, addComponent:function(entity, data) {
    var component = new this.ComponentType(this, entity);
    var componentData = new this.DataType;
    data = data || {};
    this.dataStore[entity._guid] = {entity:entity, data:componentData};
    entity[this.id] = component;
    entity.c[this.id] = component;
    this.initializeComponentData(component, data, []);
    this.fire("add", entity, component);
    return component;
  }, removeComponent:function(entity) {
    var record = this.dataStore[entity._guid];
    var component = entity.c[this.id];
    this.fire("beforeremove", entity, component);
    delete this.dataStore[entity._guid];
    delete entity[this.id];
    delete entity.c[this.id];
    this.fire("remove", entity, record.data);
  }, cloneComponent:function(entity, clone) {
    var src = this.dataStore[entity._guid];
    return this.addComponent(clone, src.data);
  }, initializeComponentData:function(component, data, properties) {
    data = data || {};
    properties.forEach(function(descriptor) {
      var name;
      var type;
      if (typeof descriptor === "object") {
        name = descriptor.name;
        type = descriptor.type;
      } else {
        name = descriptor;
      }
      var value = data[name];
      if (value !== undefined) {
        if (type !== undefined) {
          value = convertValue(value, type);
        }
        component[name] = value;
      } else {
        component[name] = component.data[name];
      }
    }, this);
    if (component.enabled && component.entity.enabled) {
      component.onEnable();
    }
  }, getPropertiesOfType:function(type) {
    var matchingProperties = [];
    var schema = this.schema || [];
    schema.forEach(function(descriptor) {
      if (descriptor && typeof descriptor === "object" && descriptor.type === type) {
        matchingProperties.push(descriptor);
      }
    });
    return matchingProperties;
  }};
  function convertValue(value, type) {
    if (!value) {
      return value;
    }
    value = value && value.data ? value.data : value;
    switch(type) {
      case "rgb":
        return new pc.Color(value[0], value[1], value[2]);
      case "rgba":
        return new pc.Color(value[0], value[1], value[2], value[3]);
      case "vec2":
        return new pc.Vec2(value[0], value[1]);
      case "vec3":
        return new pc.Vec3(value[0], value[1], value[2]);
      case "vec4":
        return new pc.Vec4(value[0], value[1], value[2], value[3]);
      case "boolean":
      case "number":
      case "string":
        return value;
      case "entity":
        return value;
      default:
        throw new Error("Could not convert unhandled type: " + type);
    }
  }
  pc.events.attach(ComponentSystem);
  ComponentSystem.destroy = function() {
    ComponentSystem.off("initialize");
    ComponentSystem.off("postInitialize");
    ComponentSystem.off("toolsUpdate");
    ComponentSystem.off("update");
    ComponentSystem.off("fixedUpdate");
    ComponentSystem.off("postUpdate");
  };
  return {ComponentSystem:ComponentSystem};
}());
Object.assign(pc, function() {
  var Component = function(system, entity) {
    this.system = system;
    this.entity = entity;
    pc.events.attach(this);
    if (this.system.schema && !this._accessorsBuilt) {
      this.buildAccessors(this.system.schema);
    }
    this.on("set", function(name, oldValue, newValue) {
      this.fire("set_" + name, name, oldValue, newValue);
    });
    this.on("set_enabled", this.onSetEnabled, this);
  };
  Component._buildAccessors = function(obj, schema) {
    schema.forEach(function(descriptor) {
      var name = typeof descriptor === "object" ? descriptor.name : descriptor;
      Object.defineProperty(obj, name, {get:function() {
        return this.data[name];
      }, set:function(value) {
        var data = this.data;
        var oldValue = data[name];
        data[name] = value;
        this.fire("set", name, oldValue, value);
      }, configurable:true});
    });
    obj._accessorsBuilt = true;
  };
  Component.prototype = {get data() {
    var record = this.system.store[this.entity._guid];
    return record ? record.data : null;
  }, buildAccessors:function(schema) {
    Component._buildAccessors(this, schema);
  }, onSetEnabled:function(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      if (this.entity.enabled) {
        if (newValue) {
          this.onEnable();
        } else {
          this.onDisable();
        }
      }
    }
  }, onEnable:function() {
  }, onDisable:function() {
  }, onPostStateChange:function() {
  }};
  return {Component:Component};
}());
Object.assign(pc, function() {
  var ComponentData = function() {
  };
  return {ComponentData:ComponentData};
}());
Object.assign(pc, function() {
  var AnimationComponent = function(system, entity) {
    pc.Component.call(this, system, entity);
    this.animationsIndex = {};
    this.on("set_animations", this.onSetAnimations, this);
    this.on("set_assets", this.onSetAssets, this);
    this.on("set_loop", this.onSetLoop, this);
  };
  AnimationComponent.prototype = Object.create(pc.Component.prototype);
  AnimationComponent.prototype.constructor = AnimationComponent;
  Object.assign(AnimationComponent.prototype, {play:function(name, blendTime) {
    if (!this.data.animations[name]) {
      console.error(pc.string.format("Trying to play animation '{0}' which doesn't exist", name));
      return;
    }
    if (!this.enabled || !this.entity.enabled) {
      return;
    }
    blendTime = blendTime || 0;
    var data = this.data;
    data.prevAnim = data.currAnim;
    data.currAnim = name;
    if (data.model) {
      data.blending = blendTime > 0 && data.prevAnim;
      if (data.blending) {
        data.blendTime = blendTime;
        data.blendTimeRemaining = blendTime;
        data.fromSkel.animation = data.animations[data.prevAnim];
        data.fromSkel.addTime(data.skeleton._time);
        data.toSkel.animation = data.animations[data.currAnim];
      } else {
        data.skeleton.animation = data.animations[data.currAnim];
      }
    }
    data.playing = true;
  }, getAnimation:function(name) {
    return this.data.animations[name];
  }, setModel:function(model) {
    var data = this.data;
    if (model) {
      var graph = model.getGraph();
      data.fromSkel = new pc.Skeleton(graph);
      data.toSkel = new pc.Skeleton(graph);
      data.skeleton = new pc.Skeleton(graph);
      data.skeleton.looping = data.loop;
      data.skeleton.setGraph(graph);
    }
    data.model = model;
    if (data.animations && data.currAnim && data.animations[data.currAnim]) {
      this.play(data.currAnim);
    }
  }, loadAnimationAssets:function(ids) {
    if (!ids || !ids.length) {
      return;
    }
    var self = this;
    var assets = this.system.app.assets;
    var i, l = ids.length;
    var onAssetReady = function(asset) {
      self.animations[asset.name] = asset.resource;
      self.animationsIndex[asset.id] = asset.name;
      self.animations = self.animations;
    };
    var onAssetAdd = function(asset) {
      asset.off("change", self.onAssetChanged, self);
      asset.on("change", self.onAssetChanged, self);
      asset.off("remove", self.onAssetRemoved, self);
      asset.on("remove", self.onAssetRemoved, self);
      if (asset.resource) {
        onAssetReady(asset);
      } else {
        asset.once("load", onAssetReady, self);
        if (self.enabled && self.entity.enabled) {
          assets.load(asset);
        }
      }
    };
    for (i = 0;i < l;i++) {
      var asset = assets.get(ids[i]);
      if (asset) {
        onAssetAdd(asset);
      } else {
        assets.on("add:" + ids[i], onAssetAdd);
      }
    }
  }, onAssetChanged:function(asset, attribute, newValue, oldValue) {
    if (attribute === "resource") {
      if (newValue) {
        this.animations[asset.name] = newValue;
        this.animationsIndex[asset.id] = asset.name;
        if (this.data.currAnim === asset.name) {
          if (this.data.playing && this.data.enabled && this.entity.enabled) {
            this.play(asset.name, 0);
          }
        }
      } else {
        delete this.animations[asset.name];
        delete this.animationsIndex[asset.id];
      }
    }
  }, onAssetRemoved:function(asset) {
    asset.off("remove", this.onAssetRemoved, this);
    if (this.animations && this.animations[asset.name]) {
      delete this.animations[asset.name];
      delete this.animationsIndex[asset.id];
      if (this.data.currAnim === asset.name) {
        this._stopCurrentAnimation();
      }
    }
  }, _stopCurrentAnimation:function() {
    this.data.currAnim = null;
    this.data.playing = false;
    if (this.data.skeleton) {
      this.data.skeleton.currentTime = 0;
      this.data.skeleton.animation = null;
    }
  }, onSetAnimations:function(name, oldValue, newValue) {
    var data = this.data;
    var modelComponent = this.entity.model;
    if (modelComponent) {
      var m = modelComponent.model;
      if (m && m !== data.model) {
        this.entity.animation.setModel(m);
      }
    }
    if (!data.currAnim && data.activate && data.enabled && this.entity.enabled) {
      for (var animName in data.animations) {
        this.play(animName, 0);
        break;
      }
    }
  }, onSetAssets:function(name, oldValue, newValue) {
    if (oldValue && oldValue.length) {
      for (var i = 0;i < oldValue.length;i++) {
        if (oldValue[i]) {
          var asset = this.system.app.assets.get(oldValue[i]);
          if (asset) {
            asset.off("change", this.onAssetChanged, this);
            asset.off("remove", this.onAssetRemoved, this);
            var animName = this.animationsIndex[asset.id];
            if (this.data.currAnim === animName) {
              this._stopCurrentAnimation();
            }
            delete this.animations[animName];
            delete this.animationsIndex[asset.id];
          }
        }
      }
    }
    var ids = newValue.map(function(value) {
      return value instanceof pc.Asset ? value.id : value;
    });
    this.loadAnimationAssets(ids);
  }, onSetLoop:function(name, oldValue, newValue) {
    if (this.data.skeleton) {
      this.data.skeleton.looping = this.data.loop;
    }
  }, onSetCurrentTime:function(name, oldValue, newValue) {
    this.data.skeleton.currentTime = newValue;
    this.data.skeleton.addTime(0);
    this.data.skeleton.updateGraph();
  }, onEnable:function() {
    pc.Component.prototype.onEnable.call(this);
    var assets = this.data.assets;
    var registry = this.system.app.assets;
    if (assets) {
      for (var i = 0, len = assets.length;i < len;i++) {
        var asset = assets[i];
        if (!(asset instanceof pc.Asset)) {
          asset = registry.get(asset);
        }
        if (asset && !asset.resource) {
          registry.load(asset);
        }
      }
    }
    if (this.data.activate && !this.data.currAnim) {
      for (var animName in this.data.animations) {
        this.play(animName, 0);
        break;
      }
    }
  }, onBeforeRemove:function() {
    for (var i = 0;i < this.assets.length;i++) {
      var asset = this.system.app.assets.get(this.assets[i]);
      if (!asset) {
        continue;
      }
      asset.off("change", this.onAssetChanged, this);
      asset.off("remove", this.onAssetRemoved, this);
    }
    delete this.data.animation;
    delete this.data.skeleton;
    delete this.data.fromSkel;
    delete this.data.toSkel;
  }});
  Object.defineProperties(AnimationComponent.prototype, {currentTime:{get:function() {
    return this.data.skeleton._time;
  }, set:function(currentTime) {
    this.data.skeleton.currentTime = currentTime;
    this.data.skeleton.addTime(0);
    this.data.skeleton.updateGraph();
  }}, duration:{get:function() {
    return this.data.animations[this.data.currAnim].duration;
  }}});
  return {AnimationComponent:AnimationComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled", "assets", "speed", "loop", "activate", "animations", "skeleton", "model", "prevAnim", "currAnim", "fromSkel", "toSkel", "blending", "blendTimeRemaining", "playing"];
  var AnimationComponentSystem = function AnimationComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "animation";
    this.description = "Specifies the animation assets that can run on the model specified by the Entity's model Component.";
    app.systems.add(this.id, this);
    this.ComponentType = pc.AnimationComponent;
    this.DataType = pc.AnimationComponentData;
    this.schema = _schema;
    this.on("beforeremove", this.onBeforeRemove, this);
    this.on("update", this.onUpdate, this);
    pc.ComponentSystem.on("update", this.onUpdate, this);
  };
  AnimationComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  AnimationComponentSystem.prototype.constructor = AnimationComponentSystem;
  pc.Component._buildAccessors(pc.AnimationComponent.prototype, _schema);
  Object.assign(AnimationComponentSystem.prototype, {initializeComponentData:function(component, data, properties) {
    properties = ["activate", "enabled", "loop", "speed", "assets"];
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
  }, cloneComponent:function(entity, clone) {
    var key;
    this.addComponent(clone, {});
    clone.animation.data.assets = pc.extend([], entity.animation.assets);
    clone.animation.data.speed = entity.animation.speed;
    clone.animation.data.loop = entity.animation.loop;
    clone.animation.data.activate = entity.animation.activate;
    clone.animation.data.enabled = entity.animation.enabled;
    var clonedAnimations = {};
    var animations = entity.animation.animations;
    for (key in animations) {
      if (animations.hasOwnProperty(key)) {
        clonedAnimations[key] = animations[key];
      }
    }
    clone.animation.animations = clonedAnimations;
    var clonedAnimationsIndex = {};
    var animationsIndex = entity.animation.animationsIndex;
    for (key in animationsIndex) {
      if (animationsIndex.hasOwnProperty(key)) {
        clonedAnimationsIndex[key] = animationsIndex[key];
      }
    }
    clone.animation.animationsIndex = clonedAnimationsIndex;
  }, onBeforeRemove:function(entity, component) {
    component.onBeforeRemove();
  }, onUpdate:function(dt) {
    var components = this.store;
    for (var id in components) {
      if (components.hasOwnProperty(id)) {
        var component = components[id];
        var componentData = component.data;
        if (componentData.enabled && componentData.playing && component.entity.enabled) {
          var skeleton = componentData.skeleton;
          if (skeleton !== null && componentData.model !== null) {
            if (componentData.blending) {
              componentData.blendTimeRemaining -= dt;
              if (componentData.blendTimeRemaining < 0.0) {
                componentData.blendTimeRemaining = 0.0;
              }
              var alpha = 1.0 - componentData.blendTimeRemaining / componentData.blendTime;
              skeleton.blend(componentData.fromSkel, componentData.toSkel, alpha);
            } else {
              var delta = dt * componentData.speed;
              skeleton.addTime(delta);
              if (skeleton._time === skeleton._animation.duration && !componentData.loop) {
                componentData.playing = false;
              }
            }
            if (componentData.blending && componentData.blendTimeRemaining === 0.0) {
              componentData.blending = false;
              skeleton.animation = componentData.toSkel._animation;
            }
            skeleton.updateGraph();
          }
        }
      }
    }
  }});
  return {AnimationComponentSystem:AnimationComponentSystem};
}());
Object.assign(pc, function() {
  var AnimationComponentData = function() {
    this.assets = [];
    this.speed = 1.0;
    this.loop = true;
    this.activate = true;
    this.enabled = true;
    this.animations = {};
    this.skeleton = null;
    this.model = null;
    this.prevAnim = null;
    this.currAnim = null;
    this.fromSkel = null;
    this.toSkel = null;
    this.blending = false;
    this.blendTime = 0;
    this.blendTimeRemaining = 0;
    this.playing = false;
  };
  return {AnimationComponentData:AnimationComponentData};
}());
Object.assign(pc, function() {
  var ModelComponent = function ModelComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this.on("set_type", this.onSetType, this);
    this.on("set_asset", this.onSetAsset, this);
    this.on("set_castShadows", this.onSetCastShadows, this);
    this.on("set_receiveShadows", this.onSetReceiveShadows, this);
    this.on("set_castShadowsLightmap", this.onSetCastShadowsLightmap, this);
    this.on("set_lightmapped", this.onSetLightmapped, this);
    this.on("set_lightmapSizeMultiplier", this.onSetLightmapSizeMultiplier, this);
    this.on("set_isStatic", this.onSetIsStatic, this);
    this.on("set_model", this.onSetModel, this);
    this.on("set_material", this.onSetMaterial, this);
    this.on("set_mapping", this.onSetMapping, this);
    this.on("set_layers", this.onSetLayers, this);
    this.on("set_batchGroupId", this.onSetBatchGroupId, this);
    Object.defineProperty(this, "materialAsset", {set:this.setMaterialAsset.bind(this), get:this.getMaterialAsset.bind(this)});
    this._assetOld = 0;
    this._materialEvents = null;
    this._dirtyModelAsset = false;
    this._dirtyMaterialAsset = false;
    this._clonedModel = false;
  };
  ModelComponent.prototype = Object.create(pc.Component.prototype);
  ModelComponent.prototype.constructor = ModelComponent;
  Object.assign(ModelComponent.prototype, {setVisible:function(visible) {
    console.warn("WARNING: setVisible: Function is deprecated. Set enabled property instead.");
    this.enabled = visible;
  }, _onAssetLoad:function(asset) {
    if (asset.resource) {
      this._onModelLoaded(asset.resource.clone());
      this._clonedModel = true;
    }
  }, addModelToLayers:function() {
    var layer;
    for (var i = 0;i < this.layers.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer.addMeshInstances(this.meshInstances);
    }
  }, removeModelFromLayers:function(model) {
    var layer;
    for (var i = 0;i < this.layers.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer.removeMeshInstances(model.meshInstances);
    }
  }, _onAssetUnload:function(asset) {
    if (!this.model) {
      return;
    }
    this.removeModelFromLayers(this.model);
    this.model = null;
  }, _onAssetChange:function(asset, attribute, newValue, oldValue) {
    if (attribute === "data") {
      this.mapping = this.data.mapping;
    }
  }, _onAssetRemove:function(asset) {
    if (this.asset === asset.id) {
      this.asset = null;
    }
  }, _setModelAsset:function(id) {
    if (this._assetOld === id) {
      return;
    }
    var assets = this.system.app.assets;
    var asset = id !== null ? assets.get(id) : null;
    this._dirtyModelAsset = true;
    this._onModelAsset(asset || null);
    if (!asset && id !== null) {
      assets.once("add:" + id, this._onModelAsset, this);
    }
  }, _onModelAsset:function(asset) {
    var assets = this.system.app.assets;
    if (this._assetOld) {
      assets.off("add:" + this._assetOld, this._onModelAsset, this);
      var assetOld = assets.get(this._assetOld);
      if (assetOld) {
        assetOld.off("load", this._onAssetLoad, this);
        assetOld.off("unload", this._onAssetUnload, this);
        assetOld.off("change", this._onAssetChange, this);
        assetOld.off("remove", this._onAssetRemove, this);
      }
    }
    this._assetOld = asset ? asset.id : 0;
    if (asset) {
      asset.on("load", this._onAssetLoad, this);
      asset.on("unload", this._onAssetUnload, this);
      asset.on("change", this._onAssetChange, this);
      asset.on("remove", this._onAssetRemove, this);
      if (asset.resource) {
        this._dirtyModelAsset = false;
        this._onModelLoaded(asset.resource.clone());
        this._clonedModel = true;
      } else {
        if (this.enabled && this.entity.enabled) {
          this._dirtyModelAsset = false;
          assets.load(asset);
        }
      }
    } else {
      this._dirtyModelAsset = false;
    }
  }, remove:function() {
    this._onModelAsset(null);
  }, _onModelLoaded:function(model) {
    if (this.data.type === "asset") {
      this.model = model;
    }
  }, onSetType:function(name, oldValue, newValue) {
    var data = this.data;
    if (newValue) {
      var mesh = null;
      this._area = null;
      if (newValue === "asset") {
        if (this.data.asset !== null) {
          this._setModelAsset(this.data.asset);
        } else {
          this.model = null;
        }
      } else {
        switch(newValue) {
          case "box":
            mesh = this.system.box;
            this._area = {x:2, y:2, z:2, uv:2.0 / 3};
            break;
          case "capsule":
            mesh = this.system.capsule;
            this._area = {x:Math.PI * 2, y:Math.PI, z:Math.PI * 2, uv:1.0 / 3 + 1.0 / 3 / 3 * 2};
            break;
          case "sphere":
            mesh = this.system.sphere;
            this._area = {x:Math.PI, y:Math.PI, z:Math.PI, uv:1};
            break;
          case "cone":
            mesh = this.system.cone;
            this._area = {x:2.54, y:2.54, z:2.54, uv:1.0 / 3 + 1.0 / 3 / 3};
            break;
          case "cylinder":
            mesh = this.system.cylinder;
            this._area = {x:Math.PI, y:0.79 * 2, z:Math.PI, uv:1.0 / 3 + 1.0 / 3 / 3 * 2};
            break;
          case "plane":
            mesh = this.system.plane;
            this._area = {x:0, y:1, z:0, uv:1};
            break;
          default:
            throw new Error("Invalid model type: " + newValue);
        }
        var node = new pc.GraphNode;
        var model = new pc.Model;
        model.graph = node;
        model.meshInstances = [new pc.MeshInstance(node, mesh, data.material)];
        if (this.system._inTools) {
          model.generateWireframe();
        }
        this.model = model;
        this.asset = null;
      }
    }
  }, onSetAsset:function(name, oldValue, newValue) {
    var id = null;
    if (this.data.type === "asset") {
      if (newValue !== null) {
        id = newValue;
        if (newValue instanceof pc.Asset) {
          this.data.asset = newValue.id;
          id = newValue.id;
        }
      } else {
        this.model = null;
      }
    }
    if (id === null) {
      this.data.asset = null;
    }
    this._setModelAsset(id);
  }, onSetCastShadows:function(name, oldValue, newValue) {
    var layer;
    var i;
    var model = this.data.model;
    if (model) {
      var layers = this.layers;
      var scene = this.system.app.scene;
      if (oldValue && !newValue) {
        for (i = 0;i < layers.length;i++) {
          layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
          if (!layer) {
            continue;
          }
          layer.removeShadowCasters(model.meshInstances);
        }
      }
      var meshInstances = model.meshInstances;
      for (i = 0;i < meshInstances.length;i++) {
        meshInstances[i].castShadow = newValue;
      }
      if (!oldValue && newValue) {
        for (i = 0;i < layers.length;i++) {
          layer = scene.layers.getLayerById(layers[i]);
          if (!layer) {
            continue;
          }
          layer.addShadowCasters(model.meshInstances);
        }
      }
    }
  }, onSetCastShadowsLightmap:function(name, oldValue, newValue) {
  }, onSetLightmapped:function(name, oldValue, newValue) {
    var i, m, mask;
    if (this.data.model) {
      var rcv = this.data.model.meshInstances;
      if (newValue) {
        for (i = 0;i < rcv.length;i++) {
          m = rcv[i];
          mask = m.mask;
          m.mask = (mask | pc.MASK_BAKED) & ~(pc.MASK_DYNAMIC | pc.MASK_LIGHTMAP);
        }
      } else {
        for (i = 0;i < rcv.length;i++) {
          m = rcv[i];
          m.deleteParameter("texture_lightMap");
          m.deleteParameter("texture_dirLightMap");
          m._shaderDefs &= ~pc.SHADERDEF_LM;
          mask = m.mask;
          m.mask = (mask | pc.MASK_DYNAMIC) & ~(pc.MASK_BAKED | pc.MASK_LIGHTMAP);
        }
      }
    }
  }, onSetLightmapSizeMultiplier:function(name, oldValue, newValue) {
    this.data.lightmapSizeMultiplier = newValue;
  }, onSetIsStatic:function(name, oldValue, newValue) {
    var i, m;
    if (this.data.model) {
      var rcv = this.data.model.meshInstances;
      for (i = 0;i < rcv.length;i++) {
        m = rcv[i];
        m.isStatic = newValue;
      }
    }
  }, onSetLayers:function(name, oldValue, newValue) {
    if (!this.meshInstances) {
      return;
    }
    var i, layer;
    for (i = 0;i < oldValue.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
      if (!layer) {
        continue;
      }
      layer.removeMeshInstances(this.meshInstances);
    }
    if (!this.enabled || !this.entity.enabled) {
      return;
    }
    for (i = 0;i < newValue.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(newValue[i]);
      if (!layer) {
        continue;
      }
      layer.addMeshInstances(this.meshInstances);
    }
  }, onLayersChanged:function(oldComp, newComp) {
    this.addModelToLayers();
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
  }, onLayerAdded:function(layer) {
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    layer.addMeshInstances(this.meshInstances);
  }, onLayerRemoved:function(layer) {
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    layer.removeMeshInstances(this.meshInstances);
  }, onSetBatchGroupId:function(name, oldValue, newValue) {
    if (oldValue >= 0) {
      this.system.app.batcher.markGroupDirty(oldValue);
    }
    if (newValue >= 0) {
      this.system.app.batcher.markGroupDirty(newValue);
    }
    if (newValue < 0 && oldValue >= 0 && this.enabled && this.entity.enabled) {
      this.addModelToLayers();
    }
  }, onSetModel:function(name, oldValue, newValue) {
    if (oldValue) {
      this.removeModelFromLayers(oldValue);
      this.entity.removeChild(oldValue.getGraph());
      delete oldValue._entity;
      if (this._clonedModel) {
        oldValue.destroy();
        this._clonedModel = false;
      }
    }
    if (newValue) {
      var componentData = this.data;
      var meshInstances = newValue.meshInstances;
      for (var i = 0;i < meshInstances.length;i++) {
        meshInstances[i].castShadow = componentData.castShadows;
        meshInstances[i].receiveShadow = componentData.receiveShadows;
      }
      this.lightmapped = componentData.lightmapped;
      this.isStatic = componentData.isStatic;
      this.entity.addChild(newValue.graph);
      if (this.enabled && this.entity.enabled) {
        this.addModelToLayers();
      }
      newValue._entity = this.entity;
      if (this.entity.animation) {
        this.entity.animation.setModel(newValue);
      }
      if (this.data.type === "asset") {
        this.mapping = this.data.mapping;
      } else {
        this._unsetMaterialEvents();
      }
    } else {
      this._unsetMaterialEvents();
    }
  }, _onMaterialAssetRemove:function(asset) {
    var assets = this.system.app.assets;
    var id = isNaN(asset) ? asset.id : asset;
    if (asset && isNaN(asset) && asset.resource === this.material) {
      this.material = pc.ModelHandler.DEFAULT_MATERIAL;
    }
    assets.off("add:" + id, this._onMaterialAssetAdd, this);
    assets.off("load:" + id, this._onMaterialAssetLoad, this);
    assets.off("unload:" + id, this._onMaterialAssetUnload, this);
    assets.off("remove:" + id, this._onMaterialAssetRemove, this);
  }, _onMaterialAssetAdd:function(asset) {
    var assets = this.system.app.assets;
    if (asset.resource) {
      this.material = asset.resource;
      this._dirtyMaterialAsset = false;
    } else {
      if (this.enabled && this.entity.enabled) {
        this._dirtyMaterialAsset = false;
        assets.load(asset);
      }
    }
  }, _onMaterialAssetLoad:function(asset) {
    var assets = this.system.app.assets;
    if (asset.resource) {
      this.material = asset.resource;
      this._dirtyMaterialAsset = false;
    } else {
      if (this.enabled && this.entity.enabled) {
        this._dirtyMaterialAsset = false;
        assets.load(asset);
      }
    }
  }, _onMaterialAssetUnload:function(asset) {
    if (asset && isNaN(asset) && asset.resource === this.material) {
      this.material = pc.ModelHandler.DEFAULT_MATERIAL;
    }
  }, setMaterialAsset:function(value) {
    this._dirtyMaterialAsset = true;
    var id = typeof value === "number" || !value ? value : value.id;
    var assets = this.system.app.assets;
    var self = this;
    if (this.data.materialAsset !== id) {
      if (this.data.materialAsset) {
        this._onMaterialAssetRemove(this.data.materialAsset);
      }
      if (id) {
        assets.on("load:" + id, this._onMaterialAssetLoad, this);
        assets.on("unload:" + id, this._onMaterialAssetUnload, this);
        assets.on("remove:" + id, this._onMaterialAssetRemove, this);
      }
    }
    if (id !== undefined && id !== null) {
      var asset = assets.get(id);
      if (asset) {
        this._onMaterialAssetLoad(asset);
      }
      assets.once("add:" + id, this._onMaterialAssetAdd, this);
    } else {
      if (id === null) {
        self.material = pc.ModelHandler.DEFAULT_MATERIAL;
        self._dirtyMaterialAsset = false;
      }
    }
    var valueOld = this.data.materialAsset;
    this.data.materialAsset = id;
    this.fire("set", "materialAsset", valueOld, id);
  }, getMaterialAsset:function() {
    return this.system.app.assets.get(this.data.materialAsset);
  }, onSetMaterial:function(name, oldValue, newValue) {
    if (newValue !== oldValue) {
      this.data.material = newValue;
      if (this.data.model && this.data.type !== "asset") {
        var meshInstances = this.data.model.meshInstances;
        for (var i = 0;i < meshInstances.length;i++) {
          meshInstances[i].material = newValue;
        }
      }
    }
  }, onSetMapping:function(name, oldValue, newValue) {
    if (this.data.type !== "asset" || !this.data.model) {
      return;
    }
    this._unsetMaterialEvents();
    if (!newValue) {
      newValue = {};
    }
    var meshInstances = this.data.model.meshInstances;
    var modelAsset = this.asset ? this.system.app.assets.get(this.asset) : null;
    var assetMapping = modelAsset ? modelAsset.data.mapping : null;
    for (var i = 0, len = meshInstances.length;i < len;i++) {
      if (newValue[i] !== undefined) {
        if (newValue[i]) {
          this._loadAndSetMeshInstanceMaterial(newValue[i], meshInstances[i], i);
        } else {
          meshInstances[i].material = pc.ModelHandler.DEFAULT_MATERIAL;
        }
      } else {
        if (assetMapping) {
          if (assetMapping[i] && (assetMapping[i].material || assetMapping[i].path)) {
            var idOrPath = assetMapping[i].material || assetMapping[i].path;
            this._loadAndSetMeshInstanceMaterial(idOrPath, meshInstances[i], i);
          } else {
            meshInstances[i].material = pc.ModelHandler.DEFAULT_MATERIAL;
          }
        }
      }
    }
  }, _setMaterialEvent:function(index, event, id, handler) {
    var evt = event + ":" + id;
    this.system.app.assets.on(evt, handler, this);
    if (!this._materialEvents) {
      this._materialEvents = [];
    }
    if (!this._materialEvents[index]) {
      this._materialEvents[index] = {};
    }
    this._materialEvents[index][evt] = {id:id, handler:handler};
  }, _unsetMaterialEvents:function() {
    var assets = this.system.app.assets;
    var events = this._materialEvents;
    if (!events) {
      return;
    }
    for (var i = 0, len = events.length;i < len;i++) {
      if (!events[i]) {
        continue;
      }
      var evt = events[i];
      for (var key in evt) {
        assets.off(key, evt[key].handler, this);
      }
    }
    this._materialEvents = null;
  }, _getAssetByIdOrPath:function(idOrPath) {
    var asset = null;
    var isPath = isNaN(parseInt(idOrPath, 10));
    if (!isPath) {
      asset = this.system.app.assets.get(idOrPath);
    } else {
      if (this.asset) {
        var url = this._getMaterialAssetUrl(idOrPath);
        if (url) {
          asset = this.system.app.assets.getByUrl(url);
        }
      }
    }
    return asset;
  }, _getMaterialAssetUrl:function(path) {
    if (!this.asset) {
      return null;
    }
    var modelAsset = this.system.app.assets.get(this.asset);
    if (!modelAsset) {
      return null;
    }
    var fileUrl = modelAsset.getFileUrl();
    var dirUrl = pc.path.getDirectory(fileUrl);
    return pc.path.join(dirUrl, path);
  }, _loadAndSetMeshInstanceMaterial:function(idOrPath, meshInstance, index) {
    var self = this;
    var assets = this.system.app.assets;
    var asset = this._getAssetByIdOrPath(idOrPath);
    if (!asset) {
      return;
    }
    var handleMaterial = function(asset) {
      if (asset.resource) {
        meshInstance.material = asset.resource;
        self._setMaterialEvent(index, "remove", asset.id, function() {
          meshInstance.material = pc.ModelHandler.DEFAULT_MATERIAL;
        });
      } else {
        self._setMaterialEvent(index, "load", asset.id, function(asset) {
          meshInstance.material = asset.resource;
          self._setMaterialEvent(index, "remove", asset.id, function() {
            meshInstance.material = pc.ModelHandler.DEFAULT_MATERIAL;
          });
        });
        if (self.enabled && self.entity.enabled) {
          assets.load(asset);
        }
      }
    };
    if (asset) {
      handleMaterial(asset);
    } else {
      meshInstance.material = pc.ModelHandler.DEFAULT_MATERIAL;
      var isPath = isNaN(parseInt(idOrPath, 10));
      self._setMaterialEvent(index, isPath ? "add:url" : "add", idOrPath, handleMaterial);
    }
  }, onSetReceiveShadows:function(name, oldValue, newValue) {
    if (newValue !== undefined) {
      var componentData = this.data;
      if (componentData.model) {
        var meshInstances = componentData.model.meshInstances;
        for (var i = 0;i < meshInstances.length;i++) {
          meshInstances[i].receiveShadow = newValue;
        }
      }
    }
  }, onEnable:function() {
    pc.Component.prototype.onEnable.call(this);
    this.system.app.scene.on("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.on("add", this.onLayerAdded, this);
      this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
    }
    var asset;
    var model = this.data.model;
    var isAsset = this.data.type === "asset";
    if (model) {
      this.addModelToLayers();
    } else {
      if (isAsset && this._dirtyModelAsset) {
        asset = this.data.asset;
        if (!asset) {
          return;
        }
        asset = this.system.app.assets.get(asset);
        if (asset) {
          this._onModelAsset(asset);
        }
      }
    }
    if (this._dirtyMaterialAsset) {
      var materialAsset = this.data.materialAsset;
      if (materialAsset) {
        materialAsset = this.system.app.assets.get(materialAsset);
        if (materialAsset && !materialAsset.resource) {
          this._onMaterialAssetLoad(materialAsset);
        }
      }
    }
    if (isAsset) {
      var mapping = this.data.mapping;
      if (mapping) {
        for (var index in mapping) {
          if (mapping[index]) {
            asset = this._getAssetByIdOrPath(mapping[index]);
            if (asset && !asset.resource) {
              this.system.app.assets.load(asset);
            }
          }
        }
      }
    }
  }, onDisable:function() {
    pc.Component.prototype.onDisable.call(this);
    this.system.app.scene.off("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.off("add", this.onLayerAdded, this);
      this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
    }
    if (this.batchGroupId >= 0) {
      this.system.app.batcher.markGroupDirty(this.batchGroupId);
    }
    var model = this.data.model;
    if (model) {
      this.removeModelFromLayers(this.model);
    }
  }, hide:function() {
    var model = this.data.model;
    if (model) {
      var i, l;
      var instances = model.meshInstances;
      for (i = 0, l = instances.length;i < l;i++) {
        instances[i].visible = false;
      }
    }
  }, show:function() {
    var model = this.data.model;
    if (model) {
      var i, l;
      var instances = model.meshInstances;
      for (i = 0, l = instances.length;i < l;i++) {
        instances[i].visible = true;
      }
    }
  }});
  Object.defineProperty(ModelComponent.prototype, "meshInstances", {get:function() {
    if (!this.model) {
      return null;
    }
    return this.model.meshInstances;
  }, set:function(value) {
    if (!this.model) {
      return;
    }
    this.model.meshInstances = value;
  }});
  return {ModelComponent:ModelComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled", "type", "asset", "materialAsset", "castShadows", "receiveShadows", "castShadowsLightmap", "lightmapped", "lightmapSizeMultiplier", "isStatic", "material", "model", "layers", "batchGroupId", "mapping"];
  var ModelComponentSystem = function ModelComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "model";
    this.description = "Renders a 3D model at the location of the Entity.";
    app.systems.add(this.id, this);
    this.ComponentType = pc.ModelComponent;
    this.DataType = pc.ModelComponentData;
    this.schema = _schema;
    var gd = app.graphicsDevice;
    this.box = pc.createBox(gd, {halfExtents:new pc.Vec3(0.5, 0.5, 0.5)});
    this.capsule = pc.createCapsule(gd, {radius:0.5, height:2});
    this.sphere = pc.createSphere(gd, {radius:0.5});
    this.cone = pc.createCone(gd, {baseRadius:0.5, peakRadius:0, height:1});
    this.cylinder = pc.createCylinder(gd, {radius:0.5, height:1});
    this.plane = pc.createPlane(gd, {halfExtents:new pc.Vec2(0.5, 0.5), widthSegments:1, lengthSegments:1});
    this.defaultMaterial = new pc.StandardMaterial;
    this.on("beforeremove", this.onRemove, this);
  };
  ModelComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  ModelComponentSystem.prototype.constructor = ModelComponentSystem;
  pc.Component._buildAccessors(pc.ModelComponent.prototype, _schema);
  Object.assign(ModelComponentSystem.prototype, {initializeComponentData:function(component, _data, properties) {
    properties = ["enabled", "material", "materialAsset", "asset", "castShadows", "receiveShadows", "castShadowsLightmap", "lightmapped", "lightmapSizeMultiplier", "type", "mapping", "layers", "isStatic", "batchGroupId"];
    var data = {};
    var name;
    for (var i = 0;i < properties.length;i++) {
      name = properties[i];
      data[name] = _data[name];
    }
    data.material = this.defaultMaterial;
    if (data.batchGroupId === null || data.batchGroupId === undefined) {
      data.batchGroupId = -1;
    }
    if (data.layers && pc.type(data.layers) === "array") {
      data.layers = data.layers.slice(0);
    }
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
  }, removeComponent:function(entity) {
    var data = entity.model.data;
    entity.model.asset = null;
    if (data.type !== "asset" && data.model) {
      entity.model.removeModelFromLayers(entity.model.model);
      entity.removeChild(data.model.getGraph());
      data.model = null;
    }
    pc.ComponentSystem.prototype.removeComponent.call(this, entity);
  }, cloneComponent:function(entity, clone) {
    var data = {type:entity.model.type, asset:entity.model.asset, castShadows:entity.model.castShadows, receiveShadows:entity.model.receiveShadows, castShadowsLightmap:entity.model.castShadowsLightmap, lightmapped:entity.model.lightmapped, lightmapSizeMultiplier:entity.model.lightmapSizeMultiplier, isStatic:entity.model.isStatic, enabled:entity.model.enabled, layers:entity.model.layers, batchGroupId:entity.model.batchGroupId, mapping:pc.extend({}, entity.model.mapping)};
    var materialAsset = entity.model.materialAsset;
    if (!(materialAsset instanceof pc.Asset) && materialAsset != null) {
      materialAsset = this.app.assets.get(materialAsset);
    }
    var material = entity.model.material;
    if (!material || material === pc.ModelHandler.DEFAULT_MATERIAL || !materialAsset || material === materialAsset.resource) {
      data.materialAsset = materialAsset;
    }
    var component = this.addComponent(clone, data);
    if (entity.model.model && entity.model.type === "asset" && !entity.model.asset) {
      component.model = entity.model.model.clone();
      component._clonedModel = true;
    }
    if (!data.materialAsset) {
      component.material = material;
    }
    if (entity.model.model) {
      var meshInstances = entity.model.model.meshInstances;
      var meshInstancesClone = component.model.meshInstances;
      for (var i = 0;i < meshInstances.length;i++) {
        meshInstancesClone[i].mask = meshInstances[i].mask;
        meshInstancesClone[i].material = meshInstances[i].material;
        meshInstancesClone[i].layer = meshInstances[i].layer;
        meshInstancesClone[i].receiveShadow = meshInstances[i].receiveShadow;
      }
    }
  }, onRemove:function(entity, component) {
    entity.model.materialAsset = null;
    component.remove();
  }});
  return {ModelComponentSystem:ModelComponentSystem};
}());
Object.assign(pc, function() {
  var ModelComponentData = function() {
    this.enabled = true;
    this.type = "asset";
    this.asset = null;
    this.castShadows = true;
    this.receiveShadows = true;
    this.materialAsset = null;
    this.mapping = null;
    this.castShadowsLightmap = true;
    this.lightmapped = false;
    this.lightmapSizeMultiplier = 1;
    this.isStatic = false;
    this.layers = [pc.LAYERID_WORLD];
    this.batchGroupId = -1;
    this.material = null;
    this.model = null;
  };
  return {ModelComponentData:ModelComponentData};
}());
Object.assign(pc, function() {
  var CameraComponent = function CameraComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this.on("set_aspectRatioMode", this.onSetAspectRatioMode, this);
    this.on("set_aspectRatio", this.onSetAspectRatio, this);
    this.on("set_camera", this.onSetCamera, this);
    this.on("set_clearColor", this.onSetClearColor, this);
    this.on("set_fov", this.onSetFov, this);
    this.on("set_orthoHeight", this.onSetOrthoHeight, this);
    this.on("set_nearClip", this.onSetNearClip, this);
    this.on("set_farClip", this.onSetFarClip, this);
    this.on("set_projection", this.onSetProjection, this);
    this.on("set_priority", this.onSetPriority, this);
    this.on("set_clearColorBuffer", this.updateClearFlags, this);
    this.on("set_clearDepthBuffer", this.updateClearFlags, this);
    this.on("set_clearStencilBuffer", this.updateClearFlags, this);
    this.on("set_renderTarget", this.onSetRenderTarget, this);
    this.on("set_rect", this.onSetRect, this);
    this.on("set_scissorRect", this.onSetScissorRect, this);
    this.on("set_horizontalFov", this.onSetHorizontalFov, this);
    this.on("set_frustumCulling", this.onSetFrustumCulling, this);
    this.on("set_calculateTransform", this.onSetCalculateTransform, this);
    this.on("set_calculateProjection", this.onSetCalculateProjection, this);
    this.on("set_cullFaces", this.onSetCullFaces, this);
    this.on("set_flipFaces", this.onSetFlipFaces, this);
    this.on("set_layers", this.onSetLayers, this);
  };
  CameraComponent.prototype = Object.create(pc.Component.prototype);
  CameraComponent.prototype.constructor = CameraComponent;
  Object.defineProperty(CameraComponent.prototype, "projectionMatrix", {get:function() {
    return this.data.camera.getProjectionMatrix();
  }});
  Object.defineProperty(CameraComponent.prototype, "viewMatrix", {get:function() {
    var wtm = this.data.camera._node.getWorldTransform();
    return wtm.clone().invert();
  }});
  Object.defineProperty(CameraComponent.prototype, "frustum", {get:function() {
    return this.data.camera.frustum;
  }});
  Object.defineProperty(CameraComponent.prototype, "vrDisplay", {get:function() {
    return this.data.camera.vrDisplay;
  }, set:function(value) {
    this.data.camera.vrDisplay = value;
    if (value) {
      value._camera = this.data.camera;
    }
  }});
  Object.defineProperty(CameraComponent.prototype, "node", {get:function() {
    return this.data.camera._node;
  }});
  Object.assign(CameraComponent.prototype, {screenToWorld:function(screenx, screeny, cameraz, worldCoord) {
    var device = this.system.app.graphicsDevice;
    return this.data.camera.screenToWorld(screenx, screeny, cameraz, device.clientRect.width, device.clientRect.height, worldCoord);
  }, worldToScreen:function(worldCoord, screenCoord) {
    var device = this.system.app.graphicsDevice;
    return this.data.camera.worldToScreen(worldCoord, device.clientRect.width, device.clientRect.height, screenCoord);
  }, onSetAspectRatioMode:function(name, oldValue, newValue) {
    this.data.camera.aspectRatioMode = newValue;
  }, onSetAspectRatio:function(name, oldValue, newValue) {
    this.data.camera.aspectRatio = newValue;
  }, onSetCamera:function(name, oldValue, newValue) {
    if (oldValue) {
      oldValue._node = null;
    }
    newValue._node = this.entity;
  }, onSetClearColor:function(name, oldValue, newValue) {
    this.data.camera.clearColor[0] = newValue.data[0];
    this.data.camera.clearColor[1] = newValue.data[1];
    this.data.camera.clearColor[2] = newValue.data[2];
    this.data.camera.clearColor[3] = newValue.data[3];
  }, onSetFov:function(name, oldValue, newValue) {
    this.data.camera.fov = newValue;
  }, onSetOrthoHeight:function(name, oldValue, newValue) {
    this.data.camera.orthoHeight = newValue;
  }, onSetNearClip:function(name, oldValue, newValue) {
    this.data.camera.nearClip = newValue;
  }, onSetFarClip:function(name, oldValue, newValue) {
    this.data.camera.farClip = newValue;
  }, onSetHorizontalFov:function(name, oldValue, newValue) {
    this.data.camera.horizontalFov = newValue;
  }, onSetFrustumCulling:function(name, oldValue, newValue) {
    this.data.camera.frustumCulling = newValue;
  }, onSetCalculateTransform:function(name, oldValue, newValue) {
    this._calculateTransform = newValue;
    this.camera.overrideCalculateTransform = !!newValue;
  }, onSetCalculateProjection:function(name, oldValue, newValue) {
    this._calculateProjection = newValue;
    this.camera._projMatDirty = true;
    this.camera.overrideCalculateProjection = !!newValue;
  }, onSetCullFaces:function(name, oldValue, newValue) {
    this.camera._cullFaces = newValue;
  }, onSetFlipFaces:function(name, oldValue, newValue) {
    this.camera._flipFaces = newValue;
  }, onSetProjection:function(name, oldValue, newValue) {
    this.data.camera.projection = newValue;
  }, onSetPriority:function(name, oldValue, newValue) {
    var layer;
    for (var i = 0;i < this.layers.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer._sortCameras();
    }
  }, onSetLayers:function(name, oldValue, newValue) {
    var i, layer;
    for (i = 0;i < oldValue.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
      if (!layer) {
        continue;
      }
      layer.removeCamera(this);
    }
    if (!this.enabled || !this.entity.enabled) {
      return;
    }
    for (i = 0;i < newValue.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(newValue[i]);
      if (!layer) {
        continue;
      }
      layer.addCamera(this);
    }
  }, addCameraToLayers:function() {
    var layer;
    for (var i = 0;i < this.layers.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer.addCamera(this);
    }
  }, removeCameraFromLayers:function() {
    var layer;
    for (var i = 0;i < this.layers.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer.removeCamera(this);
    }
  }, onLayersChanged:function(oldComp, newComp) {
    this.addCameraToLayers();
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
  }, onLayerAdded:function(layer) {
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    layer.addCamera(this);
  }, onLayerRemoved:function(layer) {
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    layer.removeCamera(this);
  }, updateClearFlags:function() {
    var flags = 0;
    if (this.clearColorBuffer) {
      flags |= pc.CLEARFLAG_COLOR;
    }
    if (this.clearDepthBuffer) {
      flags |= pc.CLEARFLAG_DEPTH;
    }
    if (this.clearStencilBuffer) {
      flags |= pc.CLEARFLAG_STENCIL;
    }
    this.data.camera.clearFlags = flags;
  }, onSetRenderTarget:function(name, oldValue, newValue) {
    this.data.camera.renderTarget = newValue;
  }, onSetRect:function(name, oldValue, newValue) {
    this.data.camera.setRect(newValue.data[0], newValue.data[1], newValue.data[2], newValue.data[3]);
  }, onSetScissorRect:function(name, oldValue, newValue) {
    this.data.camera.setScissorRect(newValue.data[0], newValue.data[1], newValue.data[2], newValue.data[3]);
  }, onEnable:function() {
    pc.Component.prototype.onEnable.call(this);
    this.system.addCamera(this);
    this.system.app.scene.on("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.on("add", this.onLayerAdded, this);
      this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
    }
    if (this.enabled && this.entity.enabled) {
      this.addCameraToLayers();
    }
    this.postEffects.enable();
  }, onDisable:function() {
    pc.Component.prototype.onDisable.call(this);
    this.postEffects.disable();
    this.removeCameraFromLayers();
    this.system.app.scene.off("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.off("add", this.onLayerAdded, this);
      this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
    }
    this.system.removeCamera(this);
  }, calculateAspectRatio:function(rt) {
    var src = rt ? rt : this.system.app.graphicsDevice;
    var rect = this.rect;
    return src.width * rect.z / (src.height * rect.w);
  }, frameBegin:function(rt) {
    if (this.aspectRatioMode === pc.ASPECT_AUTO) {
      this.aspectRatio = this.calculateAspectRatio(rt);
    }
    this.data.isRendering = true;
  }, frameEnd:function() {
    this.data.isRendering = false;
  }, enterVr:function(display, callback) {
    if (display instanceof Function && !callback) {
      callback = display;
      display = null;
    }
    if (!this.system.app.vr) {
      callback("VrManager not created. Enable VR in project settings.");
      return;
    }
    if (!display) {
      display = this.system.app.vr.display;
    }
    if (display) {
      var self = this;
      if (display.capabilities.canPresent) {
        display.requestPresent(function(err) {
          if (!err) {
            self.vrDisplay = display;
            self.vrDisplay.once("beforepresentchange", function(display) {
              if (!display.presenting) {
                self.vrDisplay = null;
              }
            });
          }
          callback(err);
        });
      } else {
        self.vrDisplay = display;
        callback();
      }
    } else {
      callback("No pc.VrDisplay to present");
    }
  }, exitVr:function(callback) {
    if (this.vrDisplay) {
      if (this.vrDisplay.capabilities.canPresent) {
        var display = this.vrDisplay;
        this.vrDisplay = null;
        display.exitPresent(callback);
      } else {
        this.vrDisplay = null;
        callback();
      }
    } else {
      callback("Not presenting VR");
    }
  }});
  return {CameraComponent:CameraComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled", "clearColorBuffer", "clearColor", "clearDepthBuffer", "clearStencilBuffer", "frustumCulling", "projection", "fov", "orthoHeight", "nearClip", "farClip", "priority", "rect", "scissorRect", "camera", "aspectRatio", "aspectRatioMode", "horizontalFov", "model", "renderTarget", "calculateTransform", "calculateProjection", "cullFaces", "flipFaces", "layers"];
  var CameraComponentSystem = function(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "camera";
    this.description = "Renders the scene from the location of the Entity.";
    app.systems.add(this.id, this);
    this.ComponentType = pc.CameraComponent;
    this.DataType = pc.CameraComponentData;
    this.schema = _schema;
    this.cameras = [];
    this.on("beforeremove", this.onBeforeRemove, this);
    this.on("remove", this.onRemove, this);
    pc.ComponentSystem.on("update", this.onUpdate, this);
  };
  CameraComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  CameraComponentSystem.prototype.constructor = CameraComponentSystem;
  pc.Component._buildAccessors(pc.CameraComponent.prototype, _schema);
  Object.assign(CameraComponentSystem.prototype, {initializeComponentData:function(component, _data, properties) {
    properties = ["postEffects", "enabled", "model", "camera", "aspectRatio", "aspectRatioMode", "horizontalFov", "renderTarget", "clearColor", "fov", "orthoHeight", "nearClip", "farClip", "projection", "priority", "clearColorBuffer", "clearDepthBuffer", "clearStencilBuffer", "frustumCulling", "rect", "scissorRect", "calculateTransform", "calculateProjection", "cullFaces", "flipFaces", "layers"];
    var data = {};
    properties.forEach(function(prop) {
      data[prop] = _data[prop];
    });
    if (data.layers && pc.type(data.layers) === "array") {
      data.layers = data.layers.slice(0);
    }
    if (data.clearColor && pc.type(data.clearColor) === "array") {
      var c = data.clearColor;
      data.clearColor = new pc.Color(c[0], c[1], c[2], c[3]);
    }
    if (data.rect && pc.type(data.rect) === "array") {
      var rect = data.rect;
      data.rect = new pc.Vec4(rect[0], rect[1], rect[2], rect[3]);
    }
    if (data.scissorRect && pc.type(data.scissorRect) === "array") {
      var scissorRect = data.scissorRect;
      data.scissorRect = new pc.Vec4(scissorRect[0], scissorRect[1], scissorRect[2], scissorRect[3]);
    }
    if (data.activate) {
      console.warn("WARNING: activate: Property is deprecated. Set enabled property instead.");
      data.enabled = data.activate;
    }
    data.camera = new pc.Camera;
    data._node = component.entity;
    data.camera._component = component;
    var self = component;
    data.camera.calculateTransform = function(mat, mode) {
      if (!self._calculateTransform) {
        return null;
      }
      return self._calculateTransform(mat, mode);
    };
    data.camera.calculateProjection = function(mat, mode) {
      if (!self._calculateProjection) {
        return null;
      }
      return self._calculateProjection(mat, mode);
    };
    data.postEffects = new pc.PostEffectQueue(this.app, component);
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
  }, onBeforeRemove:function(entity, component) {
    this.removeCamera(component);
  }, onRemove:function(entity, data) {
    data.camera = null;
  }, onUpdate:function(dt) {
    var components = this.store;
    var component, componentData, cam, vrDisplay;
    if (this.app.vr) {
      for (var id in components) {
        component = components[id];
        componentData = component.data;
        cam = componentData.camera;
        vrDisplay = cam.vrDisplay;
        if (componentData.enabled && component.entity.enabled && vrDisplay) {
          vrDisplay.setClipPlanes(cam._nearClip, cam._farClip);
          if (cam._node) {
            cam._node.localTransform.copy(vrDisplay.combinedViewInv);
            cam._node._dirtyLocal = false;
            cam._node._dirtify();
          }
        }
      }
    }
  }, addCamera:function(camera) {
    this.cameras.push(camera);
    this.sortCamerasByPriority();
  }, removeCamera:function(camera) {
    var index = this.cameras.indexOf(camera);
    if (index >= 0) {
      this.cameras.splice(index, 1);
      this.sortCamerasByPriority();
    }
  }, sortCamerasByPriority:function() {
    this.cameras.sort(function(a, b) {
      return a.priority - b.priority;
    });
  }});
  return {CameraComponentSystem:CameraComponentSystem};
}());
Object.assign(pc, function() {
  var CameraComponentData = function() {
    this.clearColor = new pc.Color(0.722, 0.722, 0.722, 1);
    this.clearColorBuffer = true;
    this.clearDepthBuffer = true;
    this.clearStencilBuffer = true;
    this.nearClip = 0.1;
    this.farClip = 1000;
    this.fov = 45;
    this.orthoHeight = 100;
    this.projection = pc.PROJECTION_PERSPECTIVE;
    this.priority = 0;
    this.rect = new pc.Vec4(0, 0, 1, 1);
    this.scissorRect = new pc.Vec4(0, 0, 1, 1);
    this.enabled = true;
    this.frustumCulling = false;
    this.cullFaces = true;
    this.flipFaces = false;
    this.layers = [pc.LAYERID_WORLD, pc.LAYERID_DEPTH, pc.LAYERID_SKYBOX, pc.LAYERID_UI, pc.LAYERID_IMMEDIATE];
    this.camera = null;
    this.aspectRatio = 16 / 9;
    this.aspectRatioMode = pc.ASPECT_AUTO;
    this.renderTarget = null;
    this.postEffects = null;
    this.isRendering = false;
    this.calculateTransform = null;
    this.calculateProjection = null;
  };
  return {CameraComponentData:CameraComponentData};
}());
Object.assign(pc, function() {
  function PostEffectQueue(app, camera) {
    var self = this;
    this.app = app;
    this.camera = camera;
    this.effects = [];
    this.enabled = false;
    this.depthTarget = null;
    this.renderTargetScale = 1;
    this.resizeTimeout = null;
    this.resizeLast = 0;
    this._resizeTimeoutCallback = function() {
      self.resizeRenderTargets();
    };
    camera.on("set_rect", this.onCameraRectChanged, this);
  }
  Object.assign(PostEffectQueue.prototype, {_createOffscreenTarget:function(useDepth, hdr) {
    var rect = this.camera.rect;
    var width = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
    var height = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);
    var device = this.app.graphicsDevice;
    var format = hdr ? device.getHdrFormat() : pc.PIXELFORMAT_R8_G8_B8_A8;
    var colorBuffer = new pc.Texture(device, {format:format, width:width, height:height});
    colorBuffer.minFilter = pc.FILTER_NEAREST;
    colorBuffer.magFilter = pc.FILTER_NEAREST;
    colorBuffer.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
    colorBuffer.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
    return new pc.RenderTarget(this.app.graphicsDevice, colorBuffer, {depth:useDepth});
  }, _resizeOffscreenTarget:function(rt) {
    var rect = this.camera.rect;
    var width = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
    var height = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);
    var device = this.app.graphicsDevice;
    var format = rt.colorBuffer.format;
    rt._colorBuffer.destroy();
    var colorBuffer = new pc.Texture(device, {format:format, width:width, height:height});
    colorBuffer.minFilter = pc.FILTER_NEAREST;
    colorBuffer.magFilter = pc.FILTER_NEAREST;
    colorBuffer.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
    colorBuffer.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
    rt._colorBuffer = colorBuffer;
    rt.destroy();
  }, setRenderTargetScale:function(scale) {
    this.renderTargetScale = scale;
    this.resizeRenderTargets();
  }, addEffect:function(effect) {
    var isFirstEffect = this.effects.length === 0;
    var effects = this.effects;
    var newEntry = {effect:effect, inputTarget:this._createOffscreenTarget(isFirstEffect, effect.hdr), outputTarget:null};
    if (!this.layer) {
      this.layer = new pc.Layer({opaqueSortMode:pc.SORTMODE_NONE, transparentSortMode:pc.SORTMODE_NONE, passThrough:true, name:"PostEffectQueue", renderTarget:this.camera.renderTarget, clear:false, onPostRender:function() {
        for (var i = 0;i < this._commandList.length;i++) {
          this._commandList[i]();
        }
      }});
      var layerList = this.app.scene.layers.layerList;
      var order = 0;
      var i;
      var start = layerList.length - 1;
      for (i = start;i >= 0;i--) {
        if (layerList[i].id === pc.LAYERID_UI) {
          start = i - 1;
          layerList[i].overrideClear = true;
          layerList[i].clearColorBuffer = false;
          layerList[i].clearDepthBuffer = this.camera.clearDepthBuffer;
          layerList[i].clearStencilBuffer = this.camera.clearStencilBuffer;
          break;
        }
      }
      for (i = start;i >= 0;i--) {
        if (layerList[i].cameras.indexOf(this.camera) >= 0) {
          if (order === 0) {
            order = i + 1;
          }
          layerList[i].renderTarget = newEntry.inputTarget;
        }
      }
      this.app.scene.layers.insertOpaque(this.layer, order);
      this.layer._commandList = [];
      this.layer.isPostEffect = true;
    }
    effects.push(newEntry);
    var len = effects.length;
    if (len > 1) {
      effects[len - 2].outputTarget = newEntry.inputTarget;
    }
    this.enable();
  }, removeEffect:function(effect) {
    var index = -1;
    for (var i = 0, len = this.effects.length;i < len;i++) {
      if (this.effects[i].effect === effect) {
        index = i;
        break;
      }
    }
    if (index >= 0) {
      if (index > 0) {
        this.effects[index - 1].outputTarget = index + 1 < this.effects.length ? this.effects[index + 1].inputTarget : null;
      } else {
        if (this.effects.length > 1) {
          if (!this.effects[1].inputTarget._depth) {
            this.effects[1].inputTarget.destroy();
            this.effects[1].inputTarget = this._createOffscreenTarget(true, this.effects[1].hdr);
          }
          this.camera.renderTarget = this.effects[1].inputTarget;
        }
      }
      this.effects[index].inputTarget.destroy();
      this.effects.splice(index, 1);
    }
    if (this.enabled) {
      if (effect.needsDepthBuffer) {
        this.camera.releaseDepthMap();
      }
    }
    if (this.effects.length === 0) {
      this.disable();
    }
  }, requestDepthMap:function() {
    for (var i = 0, len = this.effects.length;i < len;i++) {
      var effect = this.effects[i].effect;
      if (effect.needsDepthBuffer) {
        this.camera.camera.requestDepthMap();
      }
    }
  }, releaseDepthMap:function() {
    for (var i = 0, len = this.effects.length;i < len;i++) {
      var effect = this.effects[i].effect;
      if (effect.needsDepthBuffer) {
        this.camera.releaseDepthMap();
      }
    }
  }, destroy:function() {
    for (var i = 0, len = this.effects.length;i < len;i++) {
      this.effects[i].inputTarget.destroy();
    }
    this.effects.length = 0;
    this.disable();
  }, enable:function() {
    if (!this.enabled && this.effects.length) {
      this.enabled = true;
      var self = this;
      this.requestDepthMap();
      this.app.graphicsDevice.on("resizecanvas", this._onCanvasResized, this);
      this.command = function() {
        if (self.enabled) {
          var rect = null;
          var len = self.effects.length;
          if (len) {
            self.layer.renderTarget = self.effects[0].inputTarget;
            for (var i = 0;i < len;i++) {
              var fx = self.effects[i];
              if (i === len - 1) {
                rect = self.camera.rect;
              }
              fx.effect.render(fx.inputTarget, fx.outputTarget, rect);
            }
          }
        }
      };
      this.layer._commandList.push(this.command);
    }
  }, disable:function() {
    if (this.enabled) {
      this.enabled = false;
      this.app.graphicsDevice.off("resizecanvas", this._onCanvasResized, this);
      this.camera.renderTarget = null;
      this.releaseDepthMap();
      var i = this.layer._commandList.indexOf(this.command);
      if (i >= 0) {
        this.layer._commandList.splice(i, 1);
      }
    }
  }, _onCanvasResized:function(width, height) {
    var rect = this.camera.rect;
    var device = this.app.graphicsDevice;
    this.camera.camera.aspectRatio = device.width * rect.z / (device.height * rect.w);
    if (this.resizeTimeout) {
      return;
    }
    if (pc.now() - this.resizeLast > 100) {
      this.resizeRenderTargets();
    } else {
      this.resizeTimeout = setTimeout(this._resizeTimeoutCallback, 100);
    }
  }, resizeRenderTargets:function() {
    if (this.resizeTimeout) {
      clearTimeout(this.resizeTimeout);
      this.resizeTimeout = null;
    }
    this.resizeLast = pc.now();
    var rect = this.camera.rect;
    var desiredWidth = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
    var desiredHeight = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);
    var effects = this.effects;
    for (var i = 0, len = effects.length;i < len;i++) {
      var fx = effects[i];
      if (fx.inputTarget.width !== desiredWidth || fx.inputTarget.height !== desiredHeight) {
        this._resizeOffscreenTarget(fx.inputTarget);
      }
    }
  }, onCameraRectChanged:function(name, oldValue, newValue) {
    if (this.enabled) {
      this.resizeRenderTargets();
    }
  }});
  return {PostEffectQueue:PostEffectQueue};
}());
Object.assign(pc, function() {
  var _backbufferRt = [null, null];
  var _constInput = null;
  var _constScreenSize;
  var _constScreenSizeValue = new pc.Vec4;
  var _postEffectChain = [];
  var _backbufferRtUsed = false;
  var _backbufferRt2Used = false;
  var _backbufferRtWrittenByPost = false;
  var _regexUniforms = /uniform[ \t\n\r]+\S+[ \t\n\r]+\S+[ \t\n\r]*\;/g;
  var _regexUniformStart = /\S+[ \t\n\r]*\;/;
  var _regexUniformEnd = /[ \t\n\r]*\;/;
  var _regexVariables = /(float|int|bool|vec2|vec3|vec4|struct)([ \t\n\r]+[^\;]+[ \t\n\r]*\,*)+\;/g;
  var _regexVariableSurroundings = /(float|int|bool|vec2|vec3|vec4|struct|\,|\;|\{|\})/g;
  var _regexIrrelevantVariables = /(uniform|varying|in|out)[ \t\n\r]+(float|int|bool|vec2|vec3|vec4|struct)([ \t\n\r]+[^\;]+[ \t\n\r]*\,*)+\;/g;
  var _regexIrrelevantVariableSurroundings = /(float|int|bool|vec2|vec3|vec4|struct|uniform|varying|in|out|\,|\;|\{|\})/g;
  var _regexVersion = /#version/g;
  var _regexFragColor = /out highp vec4 pc_fragColor;/g;
  var _regexFragColor2 = /#define gl_FragColor/g;
  var _regexFragColor3 = /gl_FragColor/g;
  var _regexColorBuffer = /uniform[ \t\n\r]+sampler2D[ \t\n\r]+uColorBuffer;/g;
  var _regexUv = /(varying|in)[ \t\n\r]+vec2[ \t\n\r]+vUv0;/g;
  var _regexColorBufferSample = /(texture2D|texture)[ \t\n\r]*\([ \t\n\r]*uColorBuffer/g;
  var _regexMain = /void[ \t\n\r]+main/g;
  var _createBackbufferRt = function(id, device, format) {
    var tex = new pc.Texture(device, {format:format, width:device.width, height:device.height});
    tex.minFilter = pc.FILTER_NEAREST;
    tex.magFilter = pc.FILTER_NEAREST;
    tex.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
    tex.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
    _backbufferRt[id]._colorBuffer = tex;
  };
  var _destroyBackbufferRt = function(id) {
    _backbufferRt[id].colorBuffer.destroy();
    _backbufferRt[id].destroy();
  };
  var _collectUniforms = function(code) {
    var strs = code.match(_regexUniforms) || [];
    var start, end, uname;
    var uniforms = [];
    for (var i = 0;i < strs.length;i++) {
      start = strs[i].search(_regexUniformStart);
      end = strs[i].search(_regexUniformEnd);
      uname = strs[i].substr(start, end - start);
      if (uname !== "uColorBuffer") {
        uniforms.push(uname);
      }
    }
    return uniforms;
  };
  var _uniformsCollide = function(layers, chain, count, shader) {
    var uniforms = _collectUniforms(shader.definition.fshader);
    if (uniforms.length === 0) {
      return false;
    }
    var i, j, k, uniforms2;
    var uname;
    for (i = 0;i < count;i++) {
      for (j = 0;j < uniforms.length;j++) {
        uname = uniforms[j];
        uniforms2 = _collectUniforms(layers[chain[i]].shader.definition.fshader);
        for (k = 0;k < uniforms2.length;k++) {
          if (uniforms2[k] === uname) {
            return true;
          }
        }
      }
    }
    return false;
  };
  var _collectGlobalTempVars = function(code, list) {
    var len = code.length;
    var chr;
    var scopeStart = 0;
    var scopeEnd = 0;
    var scopeDepth = 0;
    var codeStart = 0;
    var codeWithoutScopes = "";
    var i, j;
    for (i = 0;i < len;i++) {
      chr = code.charAt(i);
      if (chr === "{") {
        if (scopeDepth === 0) {
          scopeStart = i;
        }
        scopeDepth++;
      } else {
        if (chr === "}") {
          if (scopeDepth === 1) {
            scopeEnd = i;
            codeWithoutScopes += code.substr(codeStart, scopeStart - codeStart + 1);
            codeStart = scopeEnd;
          }
          scopeDepth--;
        }
      }
    }
    codeWithoutScopes += code.substr(codeStart, code.length - codeStart + 1);
    var collisions = null;
    var decls = codeWithoutScopes.match(_regexVariables) || [];
    var vars, varName;
    for (i = 0;i < decls.length;i++) {
      vars = decls[i].split(",");
      for (j = 0;j < vars.length;j++) {
        varName = vars[j].replace(_regexVariableSurroundings, "").trim();
        if (list.indexOf(varName) >= 0) {
          if (!collisions) {
            collisions = [];
          }
          collisions.push(varName);
        } else {
          list.push(varName);
        }
      }
    }
    var irrelevantDecls = codeWithoutScopes.match(_regexIrrelevantVariables) || [];
    var index;
    for (i = 0;i < irrelevantDecls.length;i++) {
      vars = irrelevantDecls[i].split(",");
      for (j = 0;j < vars.length;j++) {
        varName = vars[j].replace(_regexIrrelevantVariableSurroundings, "").trim();
        index = list.indexOf(varName);
        if (index >= 0) {
          list.splice(index, 1);
        }
      }
    }
    return collisions;
  };
  function PostEffectPass(app, options) {
    this.app = app;
    this.srcRenderTarget = options.srcRenderTarget;
    this.hdr = options.hdr;
    this.blending = options.blending;
    this.shader = options.shader;
    this.setup = options.setup;
    var self = this;
    var device = app.graphicsDevice;
    this.layer = new pc.Layer({opaqueSortMode:pc.SORTMODE_NONE, transparentSortMode:pc.SORTMODE_NONE, passThrough:true, name:options.name, onPostRender:function() {
      if (self.srcRenderTarget) {
        _constScreenSizeValue.x = self.srcRenderTarget.width;
        _constScreenSizeValue.y = self.srcRenderTarget.height;
        _constScreenSizeValue.z = 1.0 / self.srcRenderTarget.width;
        _constScreenSizeValue.w = 1.0 / self.srcRenderTarget.height;
      } else {
        _constScreenSizeValue.x = device.width;
        _constScreenSizeValue.y = device.height;
        _constScreenSizeValue.z = 1.0 / device.width;
        _constScreenSizeValue.w = 1.0 / device.height;
      }
      _constScreenSize.setValue(_constScreenSizeValue.data);
      if (this._postEffectCombined && this._postEffectCombined < 0) {
        if (self.setup) {
          self.setup(device, self, _constScreenSizeValue, null, this.renderTarget);
        }
        return;
      }
      var src;
      if (this._postEffectCombinedSrc) {
        src = this._postEffectCombinedSrc;
      } else {
        src = self.srcRenderTarget ? self.srcRenderTarget : _backbufferRt[this._backbufferRtId];
      }
      if (src._samples > 1) {
        src.resolve(true, false);
      }
      var tex = src._colorBuffer;
      tex.magFilter = (this._postEffectCombinedShader ? this._postEffectCombinedBilinear : this.postEffectBilinear) ? pc.FILTER_LINEAR : pc.FILTER_NEAREST;
      _constInput.setValue(tex);
      if (self.setup) {
        self.setup(device, self, _constScreenSizeValue, src, this.renderTarget);
      }
      var shader = this._postEffectCombinedShader ? this._postEffectCombinedShader : this.shader;
      if (shader) {
        pc.drawQuadWithShader(device, this.renderTarget, shader, null, null, self.blending);
      }
      if (self.srcRenderTarget) {
        return;
      }
      var layers = app.scene.layers.layerList;
      for (var i = 0;i < layers.length;i++) {
        if (layers[i] === self.layer) {
          break;
        }
        if (layers[i].renderTarget === _backbufferRt[0] || layers[i].renderTarget === _backbufferRt[1]) {
          layers[i].renderTarget = null;
        }
      }
    }});
    this.layer._generateCameraHash();
    this.layer.isPostEffect = true;
    this.layer.unmodifiedUvs = options.unmodifiedUvs;
    this.layer.postEffectBilinear = options.bilinear;
    this.layer.postEffect = this;
    this.layer.shader = options.shader;
    this.layer.renderTarget = options.destRenderTarget;
    if (!_constInput) {
      _constInput = device.scope.resolve("uColorBuffer");
      _constScreenSize = device.scope.resolve("uScreenSize");
      var _backbufferMsaa = device.supportsMsaa ? 4 : 1;
      for (var i = 0;i < 2;i++) {
        _backbufferRt[i] = new pc.RenderTarget({depth:true, stencil:device.supportsStencil, samples:_backbufferMsaa, autoResolve:false});
        _backbufferRt[i].name = "backbuffer" + i;
      }
      app.on("prerender", function() {
        var layers = app.scene.layers.layerList;
        var i, j;
        var offset = 0;
        var rtId = 0;
        _backbufferRtUsed = false;
        _backbufferRt2Used = false;
        _backbufferRtWrittenByPost = false;
        var backbufferRtFormat = pc.PIXELFORMAT_R8_G8_B8_A8;
        if (app.scene.layers._dirty) {
          var iterator = 0;
          var breakChain = false;
          var collisions, k;
          for (i = 0;i < layers.length;i++) {
            breakChain = false;
            if (layers[i].isPostEffect && (iterator === 0 || layers[i].unmodifiedUvs && layers[i].shader && !_uniformsCollide(layers, _postEffectChain, iterator, layers[i].shader))) {
              _postEffectChain[iterator] = i;
              iterator++;
              if (i === layers.length - 1) {
                breakChain = true;
              }
            } else {
              if (iterator > 0) {
                breakChain = true;
              }
            }
            if (breakChain) {
              if (iterator > 1) {
                var cachedName = "post_";
                var layer;
                for (j = 0;j < iterator;j++) {
                  layer = layers[_postEffectChain[j]];
                  cachedName += layer.name ? layer.name : layer.id;
                  if (j < iterator - 1) {
                    cachedName += "_";
                  }
                }
                var shader = device.programLib._cache[cachedName];
                if (!shader) {
                  var subCode;
                  var code = "vec4 shaderOutput;\n";
                  var mainCode = "void main() {\n";
                  var globalTempVars = [];
                  for (j = 0;j < iterator;j++) {
                    subCode = layers[_postEffectChain[j]].shader.definition.fshader + "\n";
                    subCode = subCode.replace(_regexVersion, "//").replace(_regexFragColor, "//").replace(_regexFragColor2, "//").replace(_regexFragColor3, "shaderOutput");
                    if (j > 0) {
                      subCode = subCode.replace(_regexColorBuffer, "//").replace(_regexUv, "//").replace(_regexColorBufferSample, "shaderOutput;//");
                    }
                    subCode = subCode.replace(_regexMain, "void main" + j);
                    collisions = _collectGlobalTempVars(subCode, globalTempVars);
                    if (collisions) {
                      for (k = 0;k < collisions.length;k++) {
                        subCode = subCode.replace(new RegExp("\\b" + collisions[k] + "\\b", "g"), collisions[k] + "NNNN" + j);
                      }
                    }
                    code += subCode;
                    mainCode += "main" + j + "();\n";
                  }
                  mainCode += "gl_FragColor = shaderOutput;\n}\n";
                  shader = pc.shaderChunks.createShaderFromCode(device, pc.shaderChunks.fullscreenQuadVS, code + mainCode, cachedName);
                }
                for (j = 0;j < iterator;j++) {
                  layers[_postEffectChain[j]]._postEffectCombined = j === iterator - 1 ? 1 : -1;
                }
                layers[_postEffectChain[iterator - 1]]._postEffectCombinedShader = shader;
                layers[_postEffectChain[iterator - 1]]._postEffectCombinedBilinear = layers[_postEffectChain[0]].postEffectBilinear;
                layers[_postEffectChain[iterator - 1]]._postEffectCombinedSrc = layers[_postEffectChain[0]].postEffect.srcRenderTarget;
              }
              _postEffectChain[0] = i;
              iterator = 1;
            }
          }
        }
        for (i = 0;i < layers.length;i++) {
          if (layers[i].isPostEffect && (!layers[i].postEffect.srcRenderTarget && !layers[i]._postEffectCombined || !layers[i].postEffect._postEffectCombinedSrc && layers[i]._postEffectCombined >= 0)) {
            for (j = i - 1;j >= offset;j--) {
              if (!layers[j].renderTarget) {
                layers[j].renderTarget = _backbufferRt[rtId];
              }
            }
            layers[i]._backbufferRtId = rtId;
            offset = i;
            _backbufferRtUsed = true;
            if (rtId === 1) {
              _backbufferRt2Used = true;
            }
            if (layers[i].postEffect.hdr) {
              if (device.webgl2 && device.extTextureFloatRenderable) {
                backbufferRtFormat = pc.PIXELFORMAT_111110F;
              } else {
                if (device.extTextureHalfFloatLinear && device.extTextureHalfFloatRenderable) {
                  backbufferRtFormat = pc.PIXELFORMAT_RGBA16F;
                } else {
                  backbufferRtFormat = pc.PIXELFORMAT_R8_G8_B8_A8;
                }
              }
            }
            if (layers[i].postEffect.shader && !layers[i].renderTarget) {
              rtId = 1 - rtId;
            }
          } else {
            if (!layers[i].isPostEffect && !layers[i].renderTarget && _backbufferRtUsed) {
              layers[i].renderTarget = _backbufferRt[rtId];
            }
          }
          if (layers[i].isPostEffect && !layers[i].renderTarget) {
            _backbufferRtWrittenByPost = true;
          }
        }
        if (_backbufferRtUsed) {
          if (!_backbufferRt[0].colorBuffer) {
            _createBackbufferRt(0, device, backbufferRtFormat);
          } else {
            if (_backbufferRt[0].width !== device.width || _backbufferRt[0].height !== device.height || _backbufferRt[0]._colorBuffer._format !== backbufferRtFormat) {
              _destroyBackbufferRt(0);
              _createBackbufferRt(0, device, backbufferRtFormat);
            }
          }
        }
        if (_backbufferRt2Used) {
          if (!_backbufferRt[1].colorBuffer) {
            _createBackbufferRt(1, device, backbufferRtFormat);
          } else {
            if (_backbufferRt[1].width !== device.width || _backbufferRt[1].height !== device.height || _backbufferRt[1]._colorBuffer._format !== backbufferRtFormat) {
              _destroyBackbufferRt(1);
              _createBackbufferRt(1, device, backbufferRtFormat);
            }
          }
        }
      }, this);
      app.on("postrender", function() {
        var device = app.graphicsDevice;
        if (_backbufferRtUsed && !_backbufferRtWrittenByPost) {
          var layers = app.scene.layers.layerList;
          var rt;
          for (var i = layers.length - 1;i >= 0;i--) {
            rt = layers[i].renderTarget;
            if (rt === _backbufferRt[0] || rt === _backbufferRt[1]) {
              break;
            }
          }
          if (rt) {
            if (rt._samples > 1) {
              rt.resolve(true, false);
            }
            device.copyRenderTarget(rt, null, true, false);
          }
        }
      }, this);
    }
  }
  PostEffectPass.prototype.addToComposition = function(order) {
    this.app.scene.layers.insertTransparent(this.layer, order);
  };
  return {PostEffectPass:PostEffectPass};
}());
Object.assign(pc, function() {
  var LightComponent = function LightComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this._cookieAsset = null;
    this._cookieAssetId = null;
    this._cookieAssetAdd = false;
    this._cookieMatrix = null;
  };
  LightComponent.prototype = Object.create(pc.Component.prototype);
  LightComponent.prototype.constructor = LightComponent;
  var _props = [];
  var _propsDefault = [];
  var _defineProperty = function(name, defaultValue, setFunc, skipEqualsCheck) {
    var c = LightComponent.prototype;
    _props.push(name);
    _propsDefault.push(defaultValue);
    Object.defineProperty(c, name, {get:function() {
      return this.data[name];
    }, set:function(value) {
      var data = this.data;
      var oldValue = data[name];
      if (!skipEqualsCheck && oldValue === value) {
        return;
      }
      data[name] = value;
      if (setFunc) {
        setFunc.call(this, value, oldValue);
      }
    }, configurable:true});
  };
  var _defineProps = function() {
    _defineProperty("enabled", true, function(newValue, oldValue) {
      this.onSetEnabled(null, oldValue, newValue);
    });
    _defineProperty("light", null);
    _defineProperty("type", "directional", function(newValue, oldValue) {
      this.system.changeType(this, oldValue, newValue);
      this.refreshProperties();
    });
    _defineProperty("color", new pc.Color(1, 1, 1), function(newValue, oldValue) {
      this.light.setColor(newValue);
    }, true);
    _defineProperty("intensity", 1, function(newValue, oldValue) {
      this.light.intensity = newValue;
    });
    _defineProperty("castShadows", false, function(newValue, oldValue) {
      this.light.castShadows = newValue;
    });
    _defineProperty("shadowDistance", 40, function(newValue, oldValue) {
      this.light.shadowDistance = newValue;
    });
    _defineProperty("shadowResolution", 1024, function(newValue, oldValue) {
      this.light.shadowResolution = newValue;
    });
    _defineProperty("shadowBias", 0.05, function(newValue, oldValue) {
      this.light.shadowBias = -0.01 * newValue;
    });
    _defineProperty("normalOffsetBias", 0, function(newValue, oldValue) {
      this.light.normalOffsetBias = newValue;
    });
    _defineProperty("range", 10, function(newValue, oldValue) {
      this.light.attenuationEnd = newValue;
    });
    _defineProperty("innerConeAngle", 40, function(newValue, oldValue) {
      this.light.innerConeAngle = newValue;
    });
    _defineProperty("outerConeAngle", 45, function(newValue, oldValue) {
      this.light.outerConeAngle = newValue;
    });
    _defineProperty("falloffMode", pc.LIGHTFALLOFF_LINEAR, function(newValue, oldValue) {
      this.light.falloffMode = newValue;
    });
    _defineProperty("shadowType", pc.SHADOW_PCF3, function(newValue, oldValue) {
      this.light.shadowType = newValue;
    });
    _defineProperty("vsmBlurSize", 11, function(newValue, oldValue) {
      this.light.vsmBlurSize = newValue;
    });
    _defineProperty("vsmBlurMode", pc.BLUR_GAUSSIAN, function(newValue, oldValue) {
      this.light.vsmBlurMode = newValue;
    });
    _defineProperty("vsmBias", 0.01 * 0.25, function(newValue, oldValue) {
      this.light.vsmBias = newValue;
    });
    _defineProperty("cookieAsset", null, function(newValue, oldValue) {
      if (this._cookieAssetId && (newValue instanceof pc.Asset && newValue.id === this._cookieAssetId || newValue === this._cookieAssetId)) {
        return;
      }
      this.onCookieAssetRemove();
      this._cookieAssetId = null;
      if (newValue instanceof pc.Asset) {
        this.data.cookieAsset = newValue.id;
        this._cookieAssetId = newValue.id;
        this.onCookieAssetAdd(newValue);
      } else {
        if (typeof newValue === "number") {
          this._cookieAssetId = newValue;
          var asset = this.system.app.assets.get(newValue);
          if (asset) {
            this.onCookieAssetAdd(asset);
          } else {
            this._cookieAssetAdd = true;
            this.system.app.assets.on("add:" + this._cookieAssetId, this.onCookieAssetAdd, this);
          }
        }
      }
    });
    _defineProperty("cookie", null, function(newValue, oldValue) {
      this.light.cookie = newValue;
    });
    _defineProperty("cookieIntensity", 1, function(newValue, oldValue) {
      this.light.cookieIntensity = newValue;
    });
    _defineProperty("cookieFalloff", true, function(newValue, oldValue) {
      this.light.cookieFalloff = newValue;
    });
    _defineProperty("cookieChannel", "rgb", function(newValue, oldValue) {
      this.light.cookieChannel = newValue;
    });
    _defineProperty("cookieAngle", 0, function(newValue, oldValue) {
      if (newValue !== 0 || this.cookieScale !== null) {
        if (!this._cookieMatrix) {
          this._cookieMatrix = new pc.Vec4;
        }
        var scx = 1;
        var scy = 1;
        if (this.cookieScale) {
          scx = this.cookieScale.x;
          scy = this.cookieScale.y;
        }
        var c = Math.cos(newValue * pc.math.DEG_TO_RAD);
        var s = Math.sin(newValue * pc.math.DEG_TO_RAD);
        this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);
        this.light.cookieTransform = this._cookieMatrix;
      } else {
        this.light.cookieTransform = null;
      }
    });
    _defineProperty("cookieScale", null, function(newValue, oldValue) {
      if (newValue !== null || this.cookieAngle !== 0) {
        if (!this._cookieMatrix) {
          this._cookieMatrix = new pc.Vec4;
        }
        var scx = newValue.x;
        var scy = newValue.y;
        var c = Math.cos(this.cookieAngle * pc.math.DEG_TO_RAD);
        var s = Math.sin(this.cookieAngle * pc.math.DEG_TO_RAD);
        this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);
        this.light.cookieTransform = this._cookieMatrix;
      } else {
        this.light.cookieTransform = null;
      }
    }, true);
    _defineProperty("cookieOffset", null, function(newValue, oldValue) {
      this.light.cookieOffset = newValue;
    }, true);
    _defineProperty("shadowUpdateMode", pc.SHADOWUPDATE_REALTIME, function(newValue, oldValue) {
      this.light.shadowUpdateMode = newValue;
    });
    _defineProperty("mask", 1, function(newValue, oldValue) {
      this.light.mask = newValue;
    });
    _defineProperty("affectDynamic", true, function(newValue, oldValue) {
      if (newValue) {
        this.light.mask |= pc.MASK_DYNAMIC;
      } else {
        this.light.mask &= ~pc.MASK_DYNAMIC;
      }
      this.light.mask = this.light._mask;
    });
    _defineProperty("affectLightmapped", false, function(newValue, oldValue) {
      if (newValue) {
        this.light.mask |= pc.MASK_BAKED;
        if (this.bake) {
          this.light.mask &= ~pc.MASK_LIGHTMAP;
        }
      } else {
        this.light.mask &= ~pc.MASK_BAKED;
        if (this.bake) {
          this.light.mask |= pc.MASK_LIGHTMAP;
        }
      }
      this.light.mask = this.light._mask;
    });
    _defineProperty("bake", false, function(newValue, oldValue) {
      if (newValue) {
        this.light.mask |= pc.MASK_LIGHTMAP;
        if (this.affectLightmapped) {
          this.light.mask &= ~pc.MASK_BAKED;
        }
      } else {
        this.light.mask &= ~pc.MASK_LIGHTMAP;
        if (this.affectLightmapped) {
          this.light.mask |= pc.MASK_BAKED;
        }
      }
      this.light.mask = this.light._mask;
    });
    _defineProperty("bakeDir", true, function(newValue, oldValue) {
      this.light.bakeDir = newValue;
    });
    _defineProperty("isStatic", false, function(newValue, oldValue) {
      this.light.isStatic = newValue;
    });
    _defineProperty("layers", [pc.LAYERID_WORLD], function(newValue, oldValue) {
      var i, layer;
      for (i = 0;i < oldValue.length;i++) {
        layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
        if (!layer) {
          continue;
        }
        layer.removeLight(this);
      }
      for (i = 0;i < newValue.length;i++) {
        layer = this.system.app.scene.layers.getLayerById(newValue[i]);
        if (!layer) {
          continue;
        }
        if (this.enabled && this.entity.enabled) {
          layer.addLight(this);
        }
      }
    });
  };
  _defineProps();
  Object.defineProperty(LightComponent.prototype, "enable", {get:function() {
    console.warn("WARNING: enable: Property is deprecated. Query enabled property instead.");
    return this.enabled;
  }, set:function(value) {
    console.warn("WARNING: enable: Property is deprecated. Set enabled property instead.");
    this.enabled = value;
  }});
  Object.assign(LightComponent.prototype, {addLightToLayers:function() {
    var layer;
    for (var i = 0;i < this.layers.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer.addLight(this);
    }
  }, removeLightFromLayers:function() {
    var layer;
    for (var i = 0;i < this.layers.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer.removeLight(this);
    }
  }, onLayersChanged:function(oldComp, newComp) {
    if (this.enabled && this.entity.enabled) {
      this.addLightToLayers();
    }
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
  }, onLayerAdded:function(layer) {
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    if (this.enabled && this.entity.enabled) {
      layer.addLight(this);
    }
  }, onLayerRemoved:function(layer) {
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    layer.removeLight(this);
  }, refreshProperties:function() {
    var name;
    for (var i = 0;i < _props.length;i++) {
      name = _props[i];
      this[name] = this[name];
    }
    if (this.enabled && this.entity.enabled) {
      this.onEnable();
    }
  }, updateShadow:function() {
    this.light.updateShadow();
  }, onCookieAssetSet:function() {
    var forceLoad = false;
    if (this._cookieAsset.type === "cubemap" && !this._cookieAsset.loadFaces) {
      this._cookieAsset.loadFaces = true;
      forceLoad = true;
    }
    if (!this._cookieAsset.resource || forceLoad) {
      this.system.app.assets.load(this._cookieAsset);
    }
    if (this._cookieAsset.resource) {
      this.onCookieAssetLoad();
    }
  }, onCookieAssetAdd:function(asset) {
    if (this._cookieAssetId !== asset.id) {
      return;
    }
    this._cookieAsset = asset;
    if (this.light._enabled) {
      this.onCookieAssetSet();
    }
    this._cookieAsset.on("load", this.onCookieAssetLoad, this);
    this._cookieAsset.on("remove", this.onCookieAssetRemove, this);
  }, onCookieAssetLoad:function() {
    if (!this._cookieAsset || !this._cookieAsset.resource) {
      return;
    }
    this.cookie = this._cookieAsset.resource;
  }, onCookieAssetRemove:function() {
    if (!this._cookieAssetId) {
      return;
    }
    if (this._cookieAssetAdd) {
      this.system.app.assets.off("add:" + this._cookieAssetId, this.onCookieAssetAdd, this);
      this._cookieAssetAdd = false;
    }
    if (this._cookieAsset) {
      this._cookieAsset.off("load", this.onCookieAssetLoad, this);
      this._cookieAsset.off("remove", this.onCookieAssetRemove, this);
      this._cookieAsset = null;
    }
    this.cookie = null;
  }, onEnable:function() {
    pc.Component.prototype.onEnable.call(this);
    this.light.enabled = true;
    this.system.app.scene.on("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.on("add", this.onLayerAdded, this);
      this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
    }
    if (this.enabled && this.entity.enabled) {
      this.addLightToLayers();
    }
    if (this._cookieAsset && !this.cookie) {
      this.onCookieAssetSet();
    }
  }, onDisable:function() {
    pc.Component.prototype.onDisable.call(this);
    this.light.enabled = false;
    this.system.app.scene.off("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.off("add", this.onLayerAdded, this);
      this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
    }
    this.removeLightFromLayers();
  }});
  return {LightComponent:LightComponent, _lightProps:_props, _lightPropsDefault:_propsDefault};
}());
Object.assign(pc, function() {
  var lightTypes = {"directional":pc.LIGHTTYPE_DIRECTIONAL, "point":pc.LIGHTTYPE_POINT, "spot":pc.LIGHTTYPE_SPOT};
  var LightComponentSystem = function(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "light";
    this.description = "Enables the Entity to emit light.";
    app.systems.add(this.id, this);
    this.ComponentType = pc.LightComponent;
    this.DataType = pc.LightComponentData;
  };
  LightComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  LightComponentSystem.prototype.constructor = LightComponentSystem;
  Object.assign(LightComponentSystem.prototype, {initializeComponentData:function(component, _data) {
    var data = {};
    var _props = pc._lightProps;
    var name;
    for (var i = 0;i < _props.length;i++) {
      name = _props[i];
      data[name] = _data[name];
    }
    if (!data.type) {
      data.type = component.data.type;
    }
    component.data.type = data.type;
    if (data.layers && pc.type(data.layers) === "array") {
      data.layers = data.layers.slice(0);
    }
    if (data.color && pc.type(data.color) === "array") {
      data.color = new pc.Color(data.color[0], data.color[1], data.color[2]);
    }
    if (data.cookieOffset && data.cookieOffset instanceof Array) {
      data.cookieOffset = new pc.Vec2(data.cookieOffset[0], data.cookieOffset[1]);
    }
    if (data.cookieScale && data.cookieScale instanceof Array) {
      data.cookieScale = new pc.Vec2(data.cookieScale[0], data.cookieScale[1]);
    }
    if (data.enable) {
      console.warn("WARNING: enable: Property is deprecated. Set enabled property instead.");
      data.enabled = data.enable;
    }
    var light = new pc.Light;
    light.type = lightTypes[data.type];
    light._node = component.entity;
    light._scene = this.app.scene;
    component.data.light = light;
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, _props);
  }, removeComponent:function(entity) {
    var data = entity.light.data;
    data.light.destroy();
    pc.ComponentSystem.prototype.removeComponent.call(this, entity);
  }, cloneComponent:function(entity, clone) {
    var light = entity.light;
    var data = [];
    var name;
    var _props = pc._lightProps;
    for (var i = 0;i < _props.length;i++) {
      name = _props[i];
      if (name === "light") {
        continue;
      }
      if (light[name] && light[name].clone) {
        data[name] = light[name].clone();
      } else {
        data[name] = light[name];
      }
    }
    this.addComponent(clone, data);
  }, changeType:function(component, oldValue, newValue) {
    if (oldValue !== newValue) {
      component.light.type = lightTypes[newValue];
    }
  }});
  return {LightComponentSystem:LightComponentSystem};
}());
Object.assign(pc, function() {
  var LightComponentData = function() {
    var _props = pc._lightProps;
    var _propsDefault = pc._lightPropsDefault;
    var value;
    for (var i = 0;i < _props.length;i++) {
      value = _propsDefault[i];
      if (value && value.clone) {
        this[_props[i]] = value.clone();
      } else {
        this[_props[i]] = value;
      }
    }
  };
  return {LightComponentData:LightComponentData};
}());
Object.assign(pc, function() {
  var ScriptComponent = function ScriptComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this._scripts = [];
    this._scriptsIndex = {};
    this._destroyedScripts = [];
    this._destroyed = false;
    this._scriptsData = null;
    this._oldState = true;
    this._beingEnabled = false;
    this._isLoopingThroughScripts = false;
    this.on("set_enabled", this._onSetEnabled, this);
  };
  ScriptComponent.prototype = Object.create(pc.Component.prototype);
  ScriptComponent.prototype.constructor = ScriptComponent;
  ScriptComponent.scriptMethods = {initialize:"initialize", postInitialize:"postInitialize", update:"update", postUpdate:"postUpdate", swap:"swap"};
  Object.assign(ScriptComponent.prototype, {onEnable:function() {
    pc.Component.prototype.onEnable.call(this);
    this._beingEnabled = true;
    this._checkState();
    if (!this.entity._beingEnabled) {
      this.onPostStateChange();
    }
    this._beingEnabled = false;
  }, onDisable:function() {
    pc.Component.prototype.onDisable.call(this);
    this._checkState();
  }, onPostStateChange:function() {
    var script;
    var wasLooping = this._beginLooping();
    for (var i = 0, len = this.scripts.length;i < len;i++) {
      script = this.scripts[i];
      if (script._initialized && !script._postInitialized && script.enabled) {
        script._postInitialized = true;
        if (script.postInitialize) {
          this._scriptMethod(script, ScriptComponent.scriptMethods.postInitialize);
        }
      }
    }
    this._endLooping(wasLooping);
  }, _beginLooping:function() {
    var looping = this._isLoopingThroughScripts;
    this._isLoopingThroughScripts = true;
    return looping;
  }, _endLooping:function(wasLoopingBefore) {
    this._isLoopingThroughScripts = wasLoopingBefore;
    if (!this._isLoopingThroughScripts) {
      this._removeDestroyedScripts();
    }
  }, _onSetEnabled:function(prop, old, value) {
    this._beingEnabled = true;
    this._checkState();
    this._beingEnabled = false;
  }, _checkState:function() {
    var state = this.enabled && this.entity.enabled;
    if (state === this._oldState) {
      return;
    }
    this._oldState = state;
    this.fire(state ? "enable" : "disable");
    this.fire("state", state);
    var wasLooping = this._beginLooping();
    var script;
    for (var i = 0, len = this.scripts.length;i < len;i++) {
      script = this.scripts[i];
      script.enabled = script._enabled;
    }
    this._endLooping(wasLooping);
  }, _onBeforeRemove:function() {
    this.fire("remove");
    var wasLooping = this._beginLooping();
    for (var i = 0;i < this.scripts.length;i++) {
      var script = this.scripts[i];
      if (!script) {
        continue;
      }
      this.destroy(script.__scriptType.__name);
    }
    this._endLooping(wasLooping);
  }, _removeDestroyedScripts:function() {
    var len = this._destroyedScripts.length;
    if (!len) {
      return;
    }
    for (var i = 0;i < len;i++) {
      var idx = this._scripts.indexOf(this._destroyedScripts[i]);
      if (idx >= 0) {
        this._scripts.splice(idx, 1);
      }
    }
    this._destroyedScripts.length = 0;
  }, _onInitializeAttributes:function() {
    for (var i = 0, len = this.scripts.length;i < len;i++) {
      this.scripts[i].__initializeAttributes();
    }
  }, _scriptMethod:function(script, method, arg) {
    try {
      script[method](arg);
    } catch (ex) {
      script.enabled = false;
      if (!script._callbacks || !script._callbacks.error) {
        console.warn('unhandled exception while calling "' + method + '" for "' + script.__scriptType.__name + '" script: ', ex);
        console.error(ex);
      }
      script.fire("error", ex, method);
      this.fire("error", script, ex, method);
    }
  }, _onInitialize:function() {
    var script, scripts = this._scripts;
    var wasLooping = this._beginLooping();
    for (var i = 0, len = scripts.length;i < len;i++) {
      script = scripts[i];
      if (!script._initialized && script.enabled) {
        script._initialized = true;
        if (script.initialize) {
          this._scriptMethod(script, ScriptComponent.scriptMethods.initialize);
        }
      }
    }
    this._endLooping(wasLooping);
  }, _onPostInitialize:function() {
    this.onPostStateChange();
  }, _onUpdate:function(dt) {
    var script, scripts = this._scripts;
    var wasLooping = this._beginLooping();
    for (var i = 0, len = scripts.length;i < len;i++) {
      script = scripts[i];
      if (script.update && script.enabled) {
        this._scriptMethod(script, ScriptComponent.scriptMethods.update, dt);
      }
    }
    this._endLooping(wasLooping);
  }, _onPostUpdate:function(dt) {
    var i;
    var len;
    var wasLooping = this._beginLooping();
    var script, scripts = this._scripts;
    for (i = 0, len = scripts.length;i < len;i++) {
      script = scripts[i];
      if (script.postUpdate && script.enabled) {
        this._scriptMethod(script, ScriptComponent.scriptMethods.postUpdate, dt);
      }
    }
    this._endLooping(wasLooping);
  }, has:function(name) {
    var scriptType = name;
    if (typeof scriptType === "string") {
      scriptType = this.system.app.scripts.get(scriptType);
    }
    return !!this._scriptsIndex[scriptType.__name];
  }, create:function(name, args) {
    var self = this;
    args = args || {};
    var scriptType = name;
    var scriptName = name;
    if (typeof scriptType === "string") {
      scriptType = this.system.app.scripts.get(scriptType);
    } else {
      if (scriptType) {
        scriptName = scriptType.__name;
      }
    }
    if (scriptType) {
      if (!this._scriptsIndex[scriptType.__name] || !this._scriptsIndex[scriptType.__name].instance) {
        var scriptInstance = new scriptType({app:this.system.app, entity:this.entity, enabled:args.hasOwnProperty("enabled") ? args.enabled : true, attributes:args.attributes || null});
        var ind = -1;
        if (typeof args.ind === "number" && args.ind !== -1 && this._scripts.length > args.ind) {
          ind = args.ind;
        }
        if (ind === -1) {
          this._scripts.push(scriptInstance);
        } else {
          this._scripts.splice(ind, 0, scriptInstance);
        }
        this._scriptsIndex[scriptType.__name] = {instance:scriptInstance, onSwap:function() {
          self.swap(scriptType.__name);
        }};
        this[scriptType.__name] = scriptInstance;
        if (!args.preloading) {
          scriptInstance.__initializeAttributes();
        }
        this.fire("create", scriptType.__name, scriptInstance);
        this.fire("create:" + scriptType.__name, scriptInstance);
        this.system.app.scripts.on("swap:" + scriptType.__name, this._scriptsIndex[scriptType.__name].onSwap);
        if (!args.preloading) {
          if (scriptInstance.enabled && !scriptInstance._initialized) {
            scriptInstance._initialized = true;
            if (scriptInstance.initialize) {
              this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.initialize);
            }
          }
          if (scriptInstance.enabled && !scriptInstance._postInitialized) {
            scriptInstance._postInitialized = true;
            if (scriptInstance.postInitialize) {
              this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.postInitialize);
            }
          }
        }
        return scriptInstance;
      }
      console.warn("script '" + scriptName + "' is already added to entity '" + this.entity.name + "'");
    } else {
      this._scriptsIndex[scriptName] = {awaiting:true, ind:this._scripts.length};
      console.warn("script '" + scriptName + "' is not found, awaiting it to be added to registry");
    }
    return null;
  }, destroy:function(name) {
    var scriptName = name;
    var scriptType = name;
    if (typeof scriptType === "string") {
      scriptType = this.system.app.scripts.get(scriptType);
      if (scriptType) {
        scriptName = scriptType.__name;
      }
    }
    var scriptData = this._scriptsIndex[scriptName];
    delete this._scriptsIndex[scriptName];
    if (!scriptData) {
      return false;
    }
    if (scriptData.instance && !scriptData.instance._destroyed) {
      scriptData.instance.enabled = false;
      scriptData.instance._destroyed = true;
      if (!this._isLoopingThroughScripts) {
        var ind = this._scripts.indexOf(scriptData.instance);
        this._scripts.splice(ind, 1);
      } else {
        this._destroyedScripts.push(scriptData.instance);
      }
    }
    this.system.app.scripts.off("swap:" + scriptName, scriptData.onSwap);
    delete this[scriptName];
    this.fire("destroy", scriptName, scriptData.instance || null);
    this.fire("destroy:" + scriptName, scriptData.instance || null);
    if (scriptData.instance) {
      scriptData.instance.fire("destroy");
    }
    return true;
  }, swap:function(script) {
    var scriptType = script;
    if (typeof scriptType === "string") {
      scriptType = this.system.app.scripts.get(scriptType);
    }
    var old = this._scriptsIndex[scriptType.__name];
    if (!old || !old.instance) {
      return false;
    }
    var scriptInstanceOld = old.instance;
    var ind = this._scripts.indexOf(scriptInstanceOld);
    var scriptInstance = new scriptType({app:this.system.app, entity:this.entity, enabled:scriptInstanceOld.enabled, attributes:scriptInstanceOld.__attributes});
    if (!scriptInstance.swap) {
      return false;
    }
    scriptInstance.__initializeAttributes();
    this._scripts[ind] = scriptInstance;
    this._scriptsIndex[scriptType.__name].instance = scriptInstance;
    this[scriptType.__name] = scriptInstance;
    this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.swap, scriptInstanceOld);
    this.fire("swap", scriptType.__name, scriptInstance);
    this.fire("swap:" + scriptType.__name, scriptInstance);
    return true;
  }, move:function(name, ind) {
    if (ind >= this._scripts.length) {
      return false;
    }
    var scriptName = name;
    if (typeof scriptName !== "string") {
      scriptName = name.__name;
    }
    var scriptData = this._scriptsIndex[scriptName];
    if (!scriptData || !scriptData.instance) {
      return false;
    }
    var indOld = this._scripts.indexOf(scriptData.instance);
    if (indOld === -1 || indOld === ind) {
      return false;
    }
    this._scripts.splice(ind, 0, this._scripts.splice(indOld, 1)[0]);
    this.fire("move", scriptName, scriptData.instance, ind, indOld);
    this.fire("move:" + scriptName, scriptData.instance, ind, indOld);
    return true;
  }});
  Object.defineProperty(ScriptComponent.prototype, "scripts", {get:function() {
    return this._scripts;
  }, set:function(value) {
    this._scriptsData = value;
    for (var key in value) {
      if (!value.hasOwnProperty(key)) {
        continue;
      }
      var script = this._scriptsIndex[key];
      if (script) {
        if (typeof value[key].enabled === "boolean") {
          script.enabled = !!value[key].enabled;
        }
        if (typeof value[key].attributes === "object") {
          for (var attr in value[key].attributes) {
            if (pc.createScript.reservedAttributes[attr]) {
              continue;
            }
            if (!script.__attributes.hasOwnProperty(attr)) {
              var scriptType = this.system.app.scripts.get(key);
              if (scriptType) {
                scriptType.attributes.add(attr, {});
              }
            }
            script[attr] = value[key].attributes[attr];
          }
        }
      } else {
        console.log(this.order);
      }
    }
  }});
  return {ScriptComponent:ScriptComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled"];
  var ScriptComponentSystem = function ScriptComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "script";
    this.app = app;
    app.systems.add(this.id, this);
    this.ComponentType = pc.ScriptComponent;
    this.DataType = pc.ScriptComponentData;
    this.schema = _schema;
    this._components = [];
    this._destroyedComponents = [];
    this._isLoopingThroughComponents = false;
    this.preloading = true;
    this.on("beforeremove", this._onBeforeRemove, this);
    pc.ComponentSystem.on("initialize", this._onInitialize, this);
    pc.ComponentSystem.on("postInitialize", this._onPostInitialize, this);
    pc.ComponentSystem.on("update", this._onUpdate, this);
    pc.ComponentSystem.on("postUpdate", this._onPostUpdate, this);
  };
  ScriptComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  ScriptComponentSystem.prototype.constructor = ScriptComponentSystem;
  pc.Component._buildAccessors(pc.ScriptComponent.prototype, _schema);
  Object.assign(ScriptComponentSystem.prototype, {initializeComponentData:function(component, data, properties) {
    this._components.push(component);
    component.enabled = data.hasOwnProperty("enabled") ? !!data.enabled : true;
    if (data.hasOwnProperty("order") && data.hasOwnProperty("scripts")) {
      component._scriptsData = data.scripts;
      for (var i = 0;i < data.order.length;i++) {
        component.create(data.order[i], {enabled:data.scripts[data.order[i]].enabled, attributes:data.scripts[data.order[i]].attributes, preloading:this.preloading});
      }
    }
  }, cloneComponent:function(entity, clone) {
    var i, key;
    var order = [];
    var scripts = {};
    for (i = 0;i < entity.script._scripts.length;i++) {
      var scriptInstance = entity.script._scripts[i];
      var scriptName = scriptInstance.__scriptType.__name;
      order.push(scriptName);
      var attributes = {};
      for (key in scriptInstance.__attributes) {
        attributes[key] = scriptInstance.__attributes[key];
      }
      scripts[scriptName] = {enabled:scriptInstance._enabled, attributes:attributes};
    }
    for (key in entity.script._scriptsIndex) {
      if (key.awayting) {
        order.splice(key.ind, 0, key);
      }
    }
    var data = {enabled:entity.script.enabled, order:order, scripts:scripts};
    return this.addComponent(clone, data);
  }, _callComponentMethod:function(name, dt) {
    var wasLooping = this._beginLooping();
    for (var i = 0;i < this._components.length;i++) {
      if (this._components[i]._destroyed || !this._components[i].entity.enabled || !this._components[i].enabled) {
        continue;
      }
      this._components[i][name](dt);
    }
    this._endLooping(wasLooping);
  }, _beginLooping:function() {
    var looping = this._isLoopingThroughComponents;
    this._isLoopingThroughComponents = true;
    return looping;
  }, _endLooping:function(wasLooping) {
    this._isLoopingThroughComponents = wasLooping;
    if (!this._isLoopingThroughComponents) {
      var len = this._destroyedComponents.length;
      if (len) {
        for (var i = 0;i < len;i++) {
          var idx = this._components.indexOf(this._destroyedComponents[i]);
          if (idx >= 0) {
            this._components.splice(idx, 1);
          }
        }
        this._destroyedComponents.length = 0;
      }
    }
  }, _onInitialize:function() {
    this.preloading = false;
    for (var i = 0;i < this._components.length;i++) {
      this._components[i]._onInitializeAttributes();
    }
    this._callComponentMethod("_onInitialize");
  }, _onPostInitialize:function() {
    this._callComponentMethod("_onPostInitialize");
  }, _onUpdate:function(dt) {
    this._callComponentMethod("_onUpdate", dt);
  }, _onPostUpdate:function(dt) {
    this._callComponentMethod("_onPostUpdate", dt);
  }, _onBeforeRemove:function(entity, component) {
    var ind = this._components.indexOf(component);
    if (ind === -1) {
      return;
    }
    component._onBeforeRemove();
    if (!this._isLoopingThroughComponents) {
      this._components.splice(ind, 1);
    } else {
      component._destroyed = true;
      this._destroyedComponents.push(component);
    }
  }});
  return {ScriptComponentSystem:ScriptComponentSystem};
}());
Object.assign(pc, function() {
  var ScriptComponentData = function() {
    this.enabled = true;
  };
  return {ScriptComponentData:ScriptComponentData};
}());
Object.assign(pc, function() {
  var ScriptLegacyComponent = function ScriptLegacyComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this.on("set_scripts", this.onSetScripts, this);
  };
  ScriptLegacyComponent.prototype = Object.create(pc.Component.prototype);
  ScriptLegacyComponent.prototype.constructor = ScriptLegacyComponent;
  Object.assign(ScriptLegacyComponent.prototype, {send:function(name, functionName) {
    console.warn("DEPRECATED: ScriptLegacyComponent.send() is deprecated and will be removed soon. Please use: http://developer.playcanvas.com/user-manual/scripting/communication/");
    var args = pc.makeArray(arguments).slice(2);
    var instances = this.entity.script.instances;
    var fn;
    if (instances && instances[name]) {
      fn = instances[name].instance[functionName];
      if (fn) {
        return fn.apply(instances[name].instance, args);
      }
    }
  }, onEnable:function() {
    pc.Component.prototype.onEnable.call(this);
    if (this.data.areScriptsLoaded && !this.system.preloading) {
      if (!this.data.initialized) {
        this.system._initializeScriptComponent(this);
      } else {
        this.system._enableScriptComponent(this);
      }
      if (!this.data.postInitialized) {
        this.system._postInitializeScriptComponent(this);
      }
    }
  }, onDisable:function() {
    pc.Component.prototype.onDisable.call(this);
    this.system._disableScriptComponent(this);
  }, onSetScripts:function(name, oldValue, newValue) {
    if (!this.system._inTools || this.runInTools) {
      if (this._updateScriptAttributes(oldValue, newValue)) {
        return;
      }
      if (this.enabled) {
        this.system._disableScriptComponent(this);
      }
      this.system._destroyScriptComponent(this);
      this.data.areScriptsLoaded = false;
      var scripts = newValue;
      var urls = scripts.map(function(s) {
        return s.url;
      });
      if (this._loadFromCache(urls)) {
        return;
      }
      this._loadScripts(urls);
    }
  }, _updateScriptAttributes:function(oldValue, newValue) {
    var onlyUpdateAttributes = true;
    if (oldValue.length !== newValue.length) {
      onlyUpdateAttributes = false;
    } else {
      var i, len = newValue.length;
      for (i = 0;i < len;i++) {
        if (oldValue[i].url !== newValue[i].url) {
          onlyUpdateAttributes = false;
          break;
        }
      }
    }
    if (onlyUpdateAttributes) {
      for (var key in this.instances) {
        if (this.instances.hasOwnProperty(key)) {
          this.system._updateAccessors(this.entity, this.instances[key]);
        }
      }
    }
    return onlyUpdateAttributes;
  }, _loadFromCache:function(urls) {
    var i, len;
    var cached = [];
    var prefix = this.system.app._scriptPrefix || "";
    var regex = /^http(s)?:\/\//i;
    for (i = 0, len = urls.length;i < len;i++) {
      var url = urls[i];
      if (!regex.test(url)) {
        url = pc.path.join(prefix, url);
      }
      var type = this.system.app.loader.getFromCache(url, "script");
      if (!type) {
        return false;
      }
      cached.push(type);
    }
    for (i = 0, len = cached.length;i < len;i++) {
      var ScriptType = cached[i];
      if (ScriptType === true) {
        continue;
      }
      if (ScriptType && this.entity.script) {
        if (!this.entity.script.instances[ScriptType._pcScriptName]) {
          var instance = new ScriptType(this.entity);
          this.system._preRegisterInstance(this.entity, urls[i], ScriptType._pcScriptName, instance);
        }
      }
    }
    if (this.data) {
      this.data.areScriptsLoaded = true;
    }
    if (!this.system.preloading) {
      this.system.onInitialize(this.entity);
      this.system.onPostInitialize(this.entity);
    }
    return true;
  }, _loadScripts:function(urls) {
    var count = urls.length;
    var prefix = this.system.app._scriptPrefix || "";
    urls.forEach(function(url) {
      var _url = null;
      var _unprefixed = null;
      if (url.toLowerCase().startsWith("http://") || url.toLowerCase().startsWith("https://")) {
        _unprefixed = url;
        _url = url;
      } else {
        _unprefixed = url;
        _url = pc.path.join(prefix, url);
      }
      this.system.app.loader.load(_url, "script", function(err, ScriptType) {
        count--;
        if (!err) {
          if (ScriptType && this.entity.script) {
            if (!this.entity.script.instances[ScriptType._pcScriptName]) {
              var instance = new ScriptType(this.entity);
              this.system._preRegisterInstance(this.entity, _unprefixed, ScriptType._pcScriptName, instance);
            }
          }
        } else {
          console.error(err);
        }
        if (count === 0) {
          this.data.areScriptsLoaded = true;
          if (!this.system.preloading) {
            this.system.onInitialize(this.entity);
            this.system.onPostInitialize(this.entity);
          }
        }
      }.bind(this));
    }.bind(this));
  }});
  return {ScriptLegacyComponent:ScriptLegacyComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled", "scripts", "instances", "runInTools"];
  var INITIALIZE = "initialize";
  var POST_INITIALIZE = "postInitialize";
  var UPDATE = "update";
  var POST_UPDATE = "postUpdate";
  var FIXED_UPDATE = "fixedUpdate";
  var TOOLS_UPDATE = "toolsUpdate";
  var ON_ENABLE = "onEnable";
  var ON_DISABLE = "onDisable";
  var ScriptLegacyComponentSystem = function ScriptLegacyComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "script";
    this.description = "Allows the Entity to run JavaScript fragments to implement custom behavior.";
    app.systems.add(this.id, this);
    this.ComponentType = pc.ScriptLegacyComponent;
    this.DataType = pc.ScriptLegacyComponentData;
    this.schema = _schema;
    this.preloading = false;
    this.instancesWithUpdate = [];
    this.instancesWithFixedUpdate = [];
    this.instancesWithPostUpdate = [];
    this.instancesWithToolsUpdate = [];
    this.on("beforeremove", this.onBeforeRemove, this);
    pc.ComponentSystem.on(INITIALIZE, this.onInitialize, this);
    pc.ComponentSystem.on(POST_INITIALIZE, this.onPostInitialize, this);
    pc.ComponentSystem.on(UPDATE, this.onUpdate, this);
    pc.ComponentSystem.on(FIXED_UPDATE, this.onFixedUpdate, this);
    pc.ComponentSystem.on(POST_UPDATE, this.onPostUpdate, this);
    pc.ComponentSystem.on(TOOLS_UPDATE, this.onToolsUpdate, this);
  };
  ScriptLegacyComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  ScriptLegacyComponentSystem.prototype.constructor = ScriptLegacyComponentSystem;
  pc.Component._buildAccessors(pc.ScriptLegacyComponent.prototype, _schema);
  Object.assign(ScriptLegacyComponentSystem.prototype, {initializeComponentData:function(component, data, properties) {
    properties = ["runInTools", "enabled", "scripts"];
    if (data.scripts && data.scripts.length) {
      data.scripts.forEach(function(script) {
        if (script.attributes && pc.type(script.attributes) === "array") {
          var dict = {};
          for (var i = 0;i < script.attributes.length;i++) {
            dict[script.attributes[i].name] = script.attributes[i];
          }
          script.attributes = dict;
        }
      });
    }
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
  }, cloneComponent:function(entity, clone) {
    var src = this.dataStore[entity._guid];
    var data = {runInTools:src.data.runInTools, scripts:[], enabled:src.data.enabled};
    var scripts = src.data.scripts;
    for (var i = 0, len = scripts.length;i < len;i++) {
      var attributes = scripts[i].attributes;
      if (attributes) {
        delete scripts[i].attributes;
      }
      data.scripts.push(pc.extend({}, scripts[i]));
      if (attributes) {
        data.scripts[i].attributes = this._cloneAttributes(attributes);
        scripts[i].attributes = attributes;
      }
    }
    return this.addComponent(clone, data);
  }, onBeforeRemove:function(entity, component) {
    if (component.enabled) {
      this._disableScriptComponent(component);
    }
    this._destroyScriptComponent(component);
  }, onInitialize:function(root) {
    this._registerInstances(root);
    if (root.enabled) {
      if (root.script && root.script.enabled) {
        this._initializeScriptComponent(root.script);
      }
      var children = root._children;
      var i, len = children.length;
      for (i = 0;i < len;i++) {
        if (children[i] instanceof pc.Entity) {
          this.onInitialize(children[i]);
        }
      }
    }
  }, onPostInitialize:function(root) {
    if (root.enabled) {
      if (root.script && root.script.enabled) {
        this._postInitializeScriptComponent(root.script);
      }
      var children = root._children;
      var i, len = children.length;
      for (i = 0;i < len;i++) {
        if (children[i] instanceof pc.Entity) {
          this.onPostInitialize(children[i]);
        }
      }
    }
  }, _callInstancesMethod:function(script, method) {
    var instances = script.data.instances;
    for (var name in instances) {
      if (instances.hasOwnProperty(name)) {
        var instance = instances[name].instance;
        if (instance[method]) {
          instance[method]();
        }
      }
    }
  }, _initializeScriptComponent:function(script) {
    this._callInstancesMethod(script, INITIALIZE);
    script.data.initialized = true;
    if (script.enabled && script.entity.enabled) {
      this._enableScriptComponent(script);
    }
  }, _enableScriptComponent:function(script) {
    this._callInstancesMethod(script, ON_ENABLE);
  }, _disableScriptComponent:function(script) {
    this._callInstancesMethod(script, ON_DISABLE);
  }, _destroyScriptComponent:function(script) {
    var index;
    var instances = script.data.instances;
    for (var name in instances) {
      if (instances.hasOwnProperty(name)) {
        var instance = instances[name].instance;
        if (instance.destroy) {
          instance.destroy();
        }
        if (instance.update) {
          index = this.instancesWithUpdate.indexOf(instance);
          if (index >= 0) {
            this.instancesWithUpdate.splice(index, 1);
          }
        }
        if (instance.fixedUpdate) {
          index = this.instancesWithFixedUpdate.indexOf(instance);
          if (index >= 0) {
            this.instancesWithFixedUpdate.splice(index, 1);
          }
        }
        if (instance.postUpdate) {
          index = this.instancesWithPostUpdate.indexOf(instance);
          if (index >= 0) {
            this.instancesWithPostUpdate.splice(index, 1);
          }
        }
        if (instance.toolsUpdate) {
          index = this.instancesWithToolsUpdate.indexOf(instance);
          if (index >= 0) {
            this.instancesWithToolsUpdate.splice(index, 1);
          }
        }
        if (script.instances[name].instance === script[name]) {
          delete script[name];
        }
        delete script.instances[name];
      }
    }
  }, _postInitializeScriptComponent:function(script) {
    this._callInstancesMethod(script, POST_INITIALIZE);
    script.data.postInitialized = true;
  }, _updateInstances:function(method, updateList, dt) {
    var item;
    for (var i = 0, len = updateList.length;i < len;i++) {
      item = updateList[i];
      if (item && item.entity && item.entity.enabled && item.entity.script.enabled) {
        item[method](dt);
      }
    }
  }, onUpdate:function(dt) {
    this._updateInstances(UPDATE, this.instancesWithUpdate, dt);
  }, onFixedUpdate:function(dt) {
    this._updateInstances(FIXED_UPDATE, this.instancesWithFixedUpdate, dt);
  }, onPostUpdate:function(dt) {
    this._updateInstances(POST_UPDATE, this.instancesWithPostUpdate, dt);
  }, onToolsUpdate:function(dt) {
    this._updateInstances(TOOLS_UPDATE, this.instancesWithToolsUpdate, dt);
  }, broadcast:function(name, functionName) {
    console.warn("DEPRECATED: ScriptLegacyComponentSystem.broadcast() is deprecated and will be removed soon. Please use: http://developer.playcanvas.com/user-manual/scripting/communication/");
    var args = pc.makeArray(arguments).slice(2);
    var id, data, fn;
    var dataStore = this.store;
    for (id in dataStore) {
      if (dataStore.hasOwnProperty(id)) {
        data = dataStore[id].data;
        if (data.instances[name]) {
          fn = data.instances[name].instance[functionName];
          if (fn) {
            fn.apply(data.instances[name].instance, args);
          }
        }
      }
    }
  }, _preRegisterInstance:function(entity, url, name, instance) {
    if (entity.script) {
      entity.script.data._instances = entity.script.data._instances || {};
      if (entity.script.data._instances[name]) {
        throw Error(pc.string.format("Script name collision '{0}'. Scripts from '{1}' and '{2}' {{3}}", name, url, entity.script.data._instances[name].url, entity._guid));
      }
      entity.script.data._instances[name] = {url:url, name:name, instance:instance};
    }
  }, _registerInstances:function(entity) {
    var preRegistered, instance, instanceName;
    if (entity.script) {
      if (entity.script.data._instances) {
        entity.script.instances = entity.script.data._instances;
        for (instanceName in entity.script.instances) {
          preRegistered = entity.script.instances[instanceName];
          instance = preRegistered.instance;
          pc.events.attach(instance);
          if (instance.update) {
            this.instancesWithUpdate.push(instance);
          }
          if (instance.fixedUpdate) {
            this.instancesWithFixedUpdate.push(instance);
          }
          if (instance.postUpdate) {
            this.instancesWithPostUpdate.push(instance);
          }
          if (instance.toolsUpdate) {
            this.instancesWithToolsUpdate.push(instance);
          }
          if (entity.script.scripts) {
            this._createAccessors(entity, preRegistered);
          }
          if (entity.script[instanceName]) {
            throw Error(pc.string.format("Script with name '{0}' is already attached to Script Component", instanceName));
          } else {
            entity.script[instanceName] = instance;
          }
        }
        delete entity.script.data._instances;
      }
    }
    var children = entity._children;
    var i, len = children.length;
    for (i = 0;i < len;i++) {
      if (children[i] instanceof pc.Entity) {
        this._registerInstances(children[i]);
      }
    }
  }, _cloneAttributes:function(attributes) {
    var result = {};
    for (var key in attributes) {
      if (!attributes.hasOwnProperty(key)) {
        continue;
      }
      if (attributes[key].type !== "entity") {
        result[key] = pc.extend({}, attributes[key]);
      } else {
        var val = attributes[key].value;
        delete attributes[key].value;
        result[key] = pc.extend({}, attributes[key]);
        result[key].value = val;
        attributes[key].value = val;
      }
    }
    return result;
  }, _createAccessors:function(entity, instance) {
    var self = this;
    var i;
    var len = entity.script.scripts.length;
    var url = instance.url;
    for (i = 0;i < len;i++) {
      var script = entity.script.scripts[i];
      if (script.url === url) {
        var attributes = script.attributes;
        if (script.name && attributes) {
          for (var key in attributes) {
            if (attributes.hasOwnProperty(key)) {
              self._createAccessor(attributes[key], instance);
            }
          }
          entity.script.data.attributes[script.name] = self._cloneAttributes(attributes);
        }
        break;
      }
    }
  }, _createAccessor:function(attribute, instance) {
    var self = this;
    attribute = {name:attribute.name, value:attribute.value, type:attribute.type};
    self._convertAttributeValue(attribute);
    Object.defineProperty(instance.instance, attribute.name, {get:function() {
      return attribute.value;
    }, set:function(value) {
      var oldValue = attribute.value;
      attribute.value = value;
      self._convertAttributeValue(attribute);
      instance.instance.fire("set", attribute.name, oldValue, attribute.value);
    }, configurable:true});
  }, _updateAccessors:function(entity, instance) {
    var self = this;
    var i;
    var len = entity.script.scripts.length;
    var key;
    var url = instance.url;
    var scriptComponent, script, name, attributes;
    var previousAttributes;
    var oldAttribute;
    for (i = 0;i < len;i++) {
      scriptComponent = entity.script;
      script = scriptComponent.scripts[i];
      if (script.url === url) {
        name = script.name;
        attributes = script.attributes;
        if (name) {
          if (attributes) {
            for (key in attributes) {
              if (attributes.hasOwnProperty(key)) {
                self._createAccessor(attributes[key], instance);
              }
            }
          }
          previousAttributes = scriptComponent.data.attributes[name];
          if (previousAttributes) {
            for (key in previousAttributes) {
              oldAttribute = previousAttributes[key];
              if (!(key in attributes)) {
                delete instance.instance[oldAttribute.name];
              } else {
                if (attributes[key].value !== oldAttribute.value) {
                  if (instance.instance.onAttributeChanged) {
                    instance.instance.onAttributeChanged(oldAttribute.name, oldAttribute.value, attributes[key].value);
                  }
                }
              }
            }
          }
          if (attributes) {
            scriptComponent.data.attributes[name] = self._cloneAttributes(attributes);
          } else {
            delete scriptComponent.data.attributes[name];
          }
        }
        break;
      }
    }
  }, _convertAttributeValue:function(attribute) {
    if (attribute.type === "rgb" || attribute.type === "rgba") {
      if (pc.type(attribute.value) === "array") {
        attribute.value = attribute.value.length === 3 ? new pc.Color(attribute.value[0], attribute.value[1], attribute.value[2]) : new pc.Color(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);
      }
    } else {
      if (attribute.type === "vec2") {
        if (pc.type(attribute.value) === "array") {
          attribute.value = new pc.Vec2(attribute.value[0], attribute.value[1]);
        }
      } else {
        if (attribute.type === "vec3" || attribute.type === "vector") {
          if (pc.type(attribute.value) === "array") {
            attribute.value = new pc.Vec3(attribute.value[0], attribute.value[1], attribute.value[2]);
          }
        } else {
          if (attribute.type === "vec4") {
            if (pc.type(attribute.value) === "array") {
              attribute.value = new pc.Vec4(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);
            }
          } else {
            if (attribute.type === "entity") {
              if (attribute.value !== null && typeof attribute.value === "string") {
                attribute.value = this.app.root.findByGuid(attribute.value);
              }
            } else {
              if (attribute.type === "curve" || attribute.type === "colorcurve") {
                var curveType = attribute.value.keys[0] instanceof Array ? pc.CurveSet : pc.Curve;
                attribute.value = new curveType(attribute.value.keys);
                attribute.value.type = attribute.value.type;
              }
            }
          }
        }
      }
    }
  }});
  return {ScriptLegacyComponentSystem:ScriptLegacyComponentSystem};
}());
Object.assign(pc, function() {
  var ScriptLegacyComponentData = function() {
    this.scripts = [];
    this.enabled = true;
    this.instances = {};
    this._instances = {};
    this.runInTools = false;
    this.attributes = {};
    this.initialized = false;
    this.postInitialized = false;
    this.areScriptsLoaded = false;
  };
  return {ScriptLegacyComponentData:ScriptLegacyComponentData};
}());
Object.assign(pc, {DISTANCE_LINEAR:"linear", DISTANCE_INVERSE:"inverse", DISTANCE_EXPONENTIAL:"exponential"});
Object.assign(pc, function() {
  var instanceOptions = {volume:0, pitch:0, loop:false, startTime:0, duration:0, position:new pc.Vec3, maxDistance:0, refDistance:0, rollOffFactor:0, distanceModel:0, onPlay:null, onPause:null, onResume:null, onStop:null, onEnd:null};
  var SoundSlot = function(component, name, options) {
    options = options || {};
    this._component = component;
    this._assets = component.system.app.assets;
    this._manager = component.system.manager;
    this._name = name || "Untitled";
    this._volume = options.volume !== undefined ? pc.math.clamp(Number(options.volume) || 0, 0, 1) : 1;
    this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
    this._loop = !!(options.loop !== undefined ? options.loop : false);
    this._duration = options.duration > 0 ? options.duration : null;
    this._startTime = Math.max(0, Number(options.startTime) || 0);
    this._overlap = !!options.overlap;
    this._autoPlay = !!options.autoPlay;
    this._firstNode = null;
    this._lastNode = null;
    this._asset = options.asset;
    if (this._asset instanceof pc.Asset) {
      this._asset = this._asset.id;
    }
    this._onInstancePlayHandler = this._onInstancePlay.bind(this);
    this._onInstancePauseHandler = this._onInstancePause.bind(this);
    this._onInstanceResumeHandler = this._onInstanceResume.bind(this);
    this._onInstanceStopHandler = this._onInstanceStop.bind(this);
    this._onInstanceEndHandler = this._onInstanceEnd.bind(this);
    this.instances = [];
    pc.events.attach(this);
  };
  Object.assign(SoundSlot.prototype, {play:function() {
    if (!this.overlap && (this.isPlaying || this.isPaused)) {
      this.stop();
    }
    var instance = this._createInstance();
    this.instances.push(instance);
    if (!this.isLoaded) {
      var onLoad = function(sound) {
        var playWhenLoaded = instance._playWhenLoaded;
        instance.sound = sound;
        if (playWhenLoaded) {
          instance.play();
        }
      };
      this.off("load", onLoad);
      this.once("load", onLoad);
      this.load();
    } else {
      instance.play();
    }
    return instance;
  }, pause:function() {
    var paused = false;
    var instances = this.instances;
    for (var i = 0, len = instances.length;i < len;i++) {
      if (instances[i].pause()) {
        paused = true;
      }
    }
    return paused;
  }, resume:function() {
    var resumed = false;
    var instances = this.instances;
    for (var i = 0, len = instances.length;i < len;i++) {
      if (instances[i].resume()) {
        resumed = true;
      }
    }
    return resumed;
  }, stop:function() {
    var stopped = false;
    var instances = this.instances;
    for (var i = 0, len = instances.length;i < len;i++) {
      if (instances[i].stop()) {
        stopped = true;
      }
    }
    instances.length = 0;
    return stopped;
  }, load:function() {
    if (!this._hasAsset()) {
      return;
    }
    var asset = this._assets.get(this._asset);
    if (!asset) {
      this._assets.off("add:" + this._asset, this._onAssetAdd, this);
      this._assets.once("add:" + this._asset, this._onAssetAdd, this);
      return;
    }
    asset.off("remove", this._onAssetRemoved, this);
    asset.on("remove", this._onAssetRemoved, this);
    if (!asset.resource) {
      asset.off("load", this._onAssetLoad, this);
      asset.once("load", this._onAssetLoad, this);
      this._assets.load(asset);
      return;
    }
    this.fire("load", asset.resource);
  }, setExternalNodes:function(firstNode, lastNode) {
    if (!firstNode) {
      console.error("The firstNode must have a valid AudioNode");
      return;
    }
    if (!lastNode) {
      lastNode = firstNode;
    }
    this._firstNode = firstNode;
    this._lastNode = lastNode;
    if (!this._overlap) {
      var instances = this.instances;
      for (var i = 0, len = instances.length;i < len;i++) {
        instances[i].setExternalNodes(firstNode, lastNode);
      }
    }
  }, clearExternalNodes:function() {
    this._firstNode = null;
    this._lastNode = null;
    if (!this._overlap) {
      var instances = this.instances;
      for (var i = 0, len = instances.length;i < len;i++) {
        instances[i].clearExternalNodes();
      }
    }
  }, getExternalNodes:function() {
    return [this._firstNode, this._lastNode];
  }, _hasAsset:function() {
    return this._asset != null;
  }, _createInstance:function() {
    var instance = null;
    var component = this._component;
    var sound = null;
    if (this._hasAsset()) {
      var asset = this._assets.get(this._asset);
      if (asset) {
        sound = asset.resource;
      }
    }
    var data = instanceOptions;
    data.volume = this._volume * component.volume;
    data.pitch = this._pitch * component.pitch;
    data.loop = this._loop;
    data.startTime = this._startTime;
    data.duration = this._duration;
    data.onPlay = this._onInstancePlayHandler;
    data.onPause = this._onInstancePauseHandler;
    data.onResume = this._onInstanceResumeHandler;
    data.onStop = this._onInstanceStopHandler;
    data.onEnd = this._onInstanceEndHandler;
    if (component.positional) {
      data.position.copy(component.entity.getPosition());
      data.maxDistance = component.maxDistance;
      data.refDistance = component.refDistance;
      data.rollOffFactor = component.rollOffFactor;
      data.distanceModel = component.distanceModel;
      instance = new pc.SoundInstance3d(this._manager, sound, data);
    } else {
      instance = new pc.SoundInstance(this._manager, sound, data);
    }
    if (this._firstNode) {
      instance.setExternalNodes(this._firstNode, this._lastNode);
    }
    return instance;
  }, _onInstancePlay:function(instance) {
    this.fire("play", instance);
    this._component.fire("play", this, instance);
  }, _onInstancePause:function(instance) {
    this.fire("pause", instance);
    this._component.fire("pause", this, instance);
  }, _onInstanceResume:function(instance) {
    this.fire("resume", instance);
    this._component.fire("resume", this, instance);
  }, _onInstanceStop:function(instance) {
    this.fire("stop", instance);
    this._component.fire("stop", this, instance);
  }, _onInstanceEnd:function(instance) {
    var idx = this.instances.indexOf(instance);
    if (idx !== -1) {
      this.instances.splice(idx, 1);
    }
    this.fire("end", instance);
    this._component.fire("end", this, instance);
  }, _onAssetAdd:function(asset) {
    this.load();
  }, _onAssetLoad:function(asset) {
    this.load();
  }, _onAssetRemoved:function(asset) {
    asset.off("remove", this._onAssetRemoved, this);
    this._assets.off("add:" + asset.id, this._onAssetAdd, this);
    this.stop();
  }, updatePosition:function(position) {
    var instances = this.instances;
    for (var i = 0, len = instances.length;i < len;i++) {
      instances[i].position = position;
    }
  }});
  Object.defineProperty(SoundSlot.prototype, "name", {get:function() {
    return this._name;
  }, set:function(value) {
    this._name = value;
  }});
  Object.defineProperty(SoundSlot.prototype, "volume", {get:function() {
    return this._volume;
  }, set:function(value) {
    this._volume = pc.math.clamp(Number(value) || 0, 0, 1);
    if (!this._overlap) {
      var instances = this.instances;
      for (var i = 0, len = instances.length;i < len;i++) {
        instances[i].volume = this._volume * this._component.volume;
      }
    }
  }});
  Object.defineProperty(SoundSlot.prototype, "pitch", {get:function() {
    return this._pitch;
  }, set:function(value) {
    this._pitch = Math.max(Number(value) || 0, 0.01);
    if (!this._overlap) {
      var instances = this.instances;
      for (var i = 0, len = instances.length;i < len;i++) {
        instances[i].pitch = this.pitch * this._component.pitch;
      }
    }
  }});
  Object.defineProperty(SoundSlot.prototype, "loop", {get:function() {
    return this._loop;
  }, set:function(value) {
    this._loop = !!value;
    var instances = this.instances;
    for (var i = 0, len = instances.length;i < len;i++) {
      instances[i].loop = this._loop;
    }
  }});
  Object.defineProperty(SoundSlot.prototype, "autoPlay", {get:function() {
    return this._autoPlay;
  }, set:function(value) {
    this._autoPlay = !!value;
  }});
  Object.defineProperty(SoundSlot.prototype, "overlap", {get:function() {
    return this._overlap;
  }, set:function(value) {
    this._overlap = !!value;
  }});
  Object.defineProperty(SoundSlot.prototype, "startTime", {get:function() {
    return this._startTime;
  }, set:function(value) {
    this._startTime = Math.max(0, Number(value) || 0);
    if (!this._overlap) {
      var instances = this.instances;
      for (var i = 0, len = instances.length;i < len;i++) {
        instances[i].startTime = this._startTime;
      }
    }
  }});
  Object.defineProperty(SoundSlot.prototype, "duration", {get:function() {
    var assetDuration = 0;
    if (this._hasAsset()) {
      var asset = this._assets.get(this._asset);
      assetDuration = asset.resource ? asset.resource.duration : 0;
    }
    if (this._duration != null) {
      return this._duration % (assetDuration || 1);
    }
    return assetDuration;
  }, set:function(value) {
    this._duration = Math.max(0, Number(value) || 0) || null;
    if (!this._overlap) {
      var instances = this.instances;
      for (var i = 0, len = instances.length;i < len;i++) {
        instances[i].duration = this._duration;
      }
    }
  }});
  Object.defineProperty(SoundSlot.prototype, "asset", {get:function() {
    return this._asset;
  }, set:function(value) {
    var old = this._asset;
    if (old) {
      this._assets.off("add:" + old, this._onAssetAdd, this);
      var oldAsset = this._assets.get(old);
      if (oldAsset) {
        oldAsset.off("remove", this._onAssetRemoved, this);
      }
    }
    this._asset = value;
    if (this._asset instanceof pc.Asset) {
      this._asset = this._asset.id;
    }
    if (this._hasAsset() && this._component.enabled && this._component.entity.enabled) {
      this.load();
    }
  }});
  Object.defineProperty(SoundSlot.prototype, "isLoaded", {get:function() {
    if (this._hasAsset()) {
      var asset = this._assets.get(this._asset);
      if (asset) {
        return !!asset.resource;
      }
    }
    return false;
  }});
  Object.defineProperty(SoundSlot.prototype, "isPlaying", {get:function() {
    var instances = this.instances;
    for (var i = 0, len = instances.length;i < len;i++) {
      if (instances[i].isPlaying) {
        return true;
      }
    }
    return false;
  }});
  Object.defineProperty(SoundSlot.prototype, "isPaused", {get:function() {
    var instances = this.instances;
    var len = instances.length;
    if (len === 0) {
      return false;
    }
    for (var i = 0;i < len;i++) {
      if (!instances[i].isPaused) {
        return false;
      }
    }
    return true;
  }});
  Object.defineProperty(SoundSlot.prototype, "isStopped", {get:function() {
    var instances = this.instances;
    for (var i = 0, len = instances.length;i < len;i++) {
      if (!instances[i].isStopped) {
        return false;
      }
    }
    return true;
  }});
  return {SoundSlot:SoundSlot};
}());
Object.assign(pc, function() {
  var SoundComponent = function(system, entity) {
    pc.Component.call(this, system, entity);
    this.on("set_slots", this.onSetSlots, this);
    this.on("set_volume", this.onSetVolume, this);
    this.on("set_pitch", this.onSetPitch, this);
    this.on("set_refDistance", this.onSetRefDistance, this);
    this.on("set_maxDistance", this.onSetMaxDistance, this);
    this.on("set_rollOffFactor", this.onSetRollOffFactor, this);
    this.on("set_distanceModel", this.onSetDistanceModel, this);
    this.on("set_positional", this.onSetPositional, this);
  };
  SoundComponent.prototype = Object.create(pc.Component.prototype);
  SoundComponent.prototype.constructor = SoundComponent;
  Object.assign(SoundComponent.prototype, {onSetSlots:function(name, oldValue, newValue) {
    var key;
    if (oldValue) {
      for (key in oldValue) {
        oldValue[key].stop();
      }
    }
    var slots = {};
    for (key in newValue) {
      if (!(newValue[key] instanceof pc.SoundSlot)) {
        if (newValue[key].name) {
          slots[newValue[key].name] = new pc.SoundSlot(this, newValue[key].name, newValue[key]);
        }
      } else {
        slots[newValue[key].name] = newValue[key];
      }
    }
    this.data.slots = slots;
    if (this.enabled && this.entity.enabled) {
      this.onEnable();
    }
  }, onSetVolume:function(name, oldValue, newValue) {
    var slots = this.data.slots;
    for (var key in slots) {
      var slot = slots[key];
      if (!slot.overlap) {
        var instances = slot.instances;
        for (var i = 0, len = instances.length;i < len;i++) {
          instances[i].volume = slot.volume * newValue;
        }
      }
    }
  }, onSetPitch:function(name, oldValue, newValue) {
    var slots = this.data.slots;
    for (var key in slots) {
      var slot = slots[key];
      if (!slot.overlap) {
        var instances = slot.instances;
        for (var i = 0, len = instances.length;i < len;i++) {
          instances[i].pitch = slot.pitch * newValue;
        }
      }
    }
  }, onSetRefDistance:function(name, oldValue, newValue) {
    var slots = this.data.slots;
    for (var key in slots) {
      var slot = slots[key];
      if (!slot.overlap) {
        var instances = slot.instances;
        for (var i = 0, len = instances.length;i < len;i++) {
          instances[i].refDistance = newValue;
        }
      }
    }
  }, onSetMaxDistance:function(name, oldValue, newValue) {
    var slots = this.data.slots;
    for (var key in slots) {
      var slot = slots[key];
      if (!slot.overlap) {
        var instances = slot.instances;
        for (var i = 0, len = instances.length;i < len;i++) {
          instances[i].maxDistance = newValue;
        }
      }
    }
  }, onSetRollOffFactor:function(name, oldValue, newValue) {
    var slots = this.data.slots;
    for (var key in slots) {
      var slot = slots[key];
      if (!slot.overlap) {
        var instances = slot.instances;
        for (var i = 0, len = instances.length;i < len;i++) {
          instances[i].rollOffFactor = newValue;
        }
      }
    }
  }, onSetDistanceModel:function(name, oldValue, newValue) {
    var slots = this.data.slots;
    for (var key in slots) {
      var slot = slots[key];
      if (!slot.overlap) {
        var instances = slot.instances;
        for (var i = 0, len = instances.length;i < len;i++) {
          instances[i].distanceModel = newValue;
        }
      }
    }
  }, onSetPositional:function(name, oldValue, newValue) {
    var slots = this.data.slots;
    for (var key in slots) {
      var slot = slots[key];
      if (!slot.overlap) {
        var instances = slot.instances;
        for (var i = 0, len = instances.length;i < len;i++) {
          var isPlaying = instances[i].isPlaying || instances[i].isSuspended;
          var currentTime = instances[i].currentTime;
          if (isPlaying) {
            instances[i].stop();
          }
          instances[i] = slot._createInstance();
          if (isPlaying) {
            instances[i].play();
            instances[i].currentTime = currentTime;
          }
        }
      }
    }
  }, onEnable:function() {
    pc.Component.prototype.onEnable.call(this);
    if (this.system._inTools) {
      return;
    }
    var slots = this.data.slots;
    var playingBeforeDisable = this.data.playingBeforeDisable;
    for (var key in slots) {
      var slot = slots[key];
      if (slot.autoPlay && slot.isStopped) {
        slot.play();
      } else {
        if (playingBeforeDisable[key]) {
          slot.resume();
        } else {
          if (!slot.isLoaded) {
            slot.load();
          }
        }
      }
    }
  }, onDisable:function() {
    pc.Component.prototype.onDisable.call(this);
    var slots = this.data.slots;
    var playingBeforeDisable = {};
    for (var key in slots) {
      if (!slots[key].overlap) {
        if (slots[key].isPlaying) {
          slots[key].pause();
          playingBeforeDisable[key] = true;
        }
      }
    }
    this.data.playingBeforeDisable = playingBeforeDisable;
  }, addSlot:function(name, options) {
    var slots = this.data.slots;
    if (slots[name]) {
      logWARNING("A sound slot with name " + name + " already exists on Entity " + this.entity.getPath());
      return null;
    }
    var slot = new pc.SoundSlot(this, name, options);
    slots[name] = slot;
    if (slot.autoPlay && this.enabled && this.entity.enabled) {
      slot.play();
    }
    return slot;
  }, removeSlot:function(name) {
    var slots = this.data.slots;
    if (slots[name]) {
      slots[name].stop();
      delete slots[name];
    }
  }, slot:function(name) {
    return this.data.slots[name];
  }, play:function(name) {
    if (!this.enabled || !this.entity.enabled) {
      return null;
    }
    var slot = this.slots[name];
    if (!slot) {
      logWARNING("Trying to play sound slot with name " + name + " which does not exist");
      return null;
    }
    return slot.play();
  }, pause:function(name) {
    var slot;
    var slots = this.data.slots;
    if (name) {
      slot = slots[name];
      if (!slot) {
        logWARNING("Trying to pause sound slot with name " + name + " which does not exist");
        return;
      }
      slot.pause();
    } else {
      for (var key in slots) {
        slots[key].pause();
      }
    }
  }, resume:function(name) {
    var slot;
    var slots = this.data.slots;
    if (name) {
      slot = slots[name];
      if (!slot) {
        logWARNING("Trying to resume sound slot with name " + name + " which does not exist");
        return;
      }
      if (slot.isPaused) {
        slot.resume();
      }
    } else {
      for (var key in slots) {
        slots[key].resume();
      }
    }
  }, stop:function(name) {
    var slot;
    var slots = this.data.slots;
    if (name) {
      slot = slots[name];
      if (!slot) {
        logWARNING("Trying to stop sound slot with name " + name + " which does not exist");
        return;
      }
      slot.stop();
    } else {
      for (var key in slots) {
        slots[key].stop();
      }
    }
  }});
  return {SoundComponent:SoundComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled", "volume", "pitch", "positional", "refDistance", "maxDistance", "rollOffFactor", "distanceModel", "slots"];
  var SoundComponentSystem = function(app, manager) {
    pc.ComponentSystem.call(this, app);
    this.id = "sound";
    this.description = "Allows an Entity to play sounds";
    app.systems.add(this.id, this);
    this.ComponentType = pc.SoundComponent;
    this.DataType = pc.SoundComponentData;
    this.schema = _schema;
    this.manager = manager;
    pc.ComponentSystem.on("update", this.onUpdate, this);
    this.on("beforeremove", this.onBeforeRemove, this);
  };
  SoundComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  SoundComponentSystem.prototype.constructor = SoundComponentSystem;
  pc.Component._buildAccessors(pc.SoundComponent.prototype, _schema);
  Object.assign(SoundComponentSystem.prototype, {initializeComponentData:function(component, data, properties) {
    properties = ["volume", "pitch", "positional", "refDistance", "maxDistance", "rollOffFactor", "distanceModel", "slots", "enabled"];
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
  }, cloneComponent:function(entity, clone) {
    var key;
    var oldData = entity.sound.data;
    var newData = {};
    for (key in oldData) {
      if (oldData.hasOwnProperty(key)) {
        newData[key] = oldData[key];
      }
    }
    newData.slots = {};
    for (key in oldData.slots) {
      var oldSlot = oldData.slots[key];
      if (oldSlot instanceof pc.SoundSlot) {
        newData.slots[key] = {name:oldSlot.name, volume:oldSlot.volume, pitch:oldSlot.pitch, loop:oldSlot.loop, duration:oldSlot.duration, startTime:oldSlot.startTime, overlap:oldSlot.overlap, autoPlay:oldSlot.autoPlay, asset:oldSlot.asset};
      } else {
        newData.slots[key] = oldSlot;
      }
    }
    newData.playingBeforeDisable = {};
    return this.addComponent(clone, newData);
  }, onUpdate:function(dt) {
    var store = this.store;
    for (var id in store) {
      if (store.hasOwnProperty(id)) {
        var item = store[id];
        var entity = item.entity;
        var componentData = item.data;
        if (componentData.enabled && entity.enabled && componentData.positional) {
          var position = entity.getPosition();
          var slots = componentData.slots;
          for (var key in slots) {
            slots[key].updatePosition(position);
          }
        }
      }
    }
  }, onBeforeRemove:function(entity, component) {
    var slots = component.slots;
    for (var key in slots) {
      if (!slots[key].overlap) {
        slots[key].stop();
      }
    }
  }});
  Object.defineProperty(SoundComponentSystem.prototype, "volume", {get:function() {
    return this.manager.volume;
  }, set:function(volume) {
    this.manager.volume = volume;
  }});
  Object.defineProperty(SoundComponentSystem.prototype, "context", {get:function() {
    if (!pc.SoundManager.hasAudioContext()) {
      console.warn("WARNING: Audio context is not supported on this browser");
      return null;
    }
    return this.manager.context;
  }});
  return {SoundComponentSystem:SoundComponentSystem};
}());
pc.SoundComponentData = function SoundComponentData() {
  this.enabled = true;
  this.volume = 1;
  this.pitch = 1;
  this.positional = true;
  this.refDistance = 1;
  this.maxDistance = 10000;
  this.rollOffFactor = 1;
  this.distanceModel = pc.DISTANCE_LINEAR;
  this.slots = {};
  this.playingBeforeDisable = {};
};
Object.assign(pc, function() {
  var AudioSourceComponent = function(system, entity) {
    pc.Component.call(this, system, entity);
    this.on("set_assets", this.onSetAssets, this);
    this.on("set_loop", this.onSetLoop, this);
    this.on("set_volume", this.onSetVolume, this);
    this.on("set_pitch", this.onSetPitch, this);
    this.on("set_minDistance", this.onSetMinDistance, this);
    this.on("set_maxDistance", this.onSetMaxDistance, this);
    this.on("set_rollOffFactor", this.onSetRollOffFactor, this);
    this.on("set_distanceModel", this.onSetDistanceModel, this);
    this.on("set_3d", this.onSet3d, this);
  };
  AudioSourceComponent.prototype = Object.create(pc.Component.prototype);
  AudioSourceComponent.prototype.constructor = AudioSourceComponent;
  Object.assign(AudioSourceComponent.prototype, {play:function(name) {
    if (!this.enabled || !this.entity.enabled) {
      return;
    }
    if (this.channel) {
      this.stop();
    }
    var channel;
    var componentData = this.data;
    if (componentData.sources[name]) {
      if (!componentData["3d"]) {
        channel = this.system.manager.playSound(componentData.sources[name], componentData);
        componentData.currentSource = name;
        componentData.channel = channel;
      } else {
        var pos = this.entity.getPosition();
        channel = this.system.manager.playSound3d(componentData.sources[name], pos, componentData);
        componentData.currentSource = name;
        componentData.channel = channel;
      }
    }
  }, pause:function() {
    if (this.channel) {
      this.channel.pause();
    }
  }, unpause:function() {
    if (this.channel && this.channel.paused) {
      this.channel.unpause();
    }
  }, stop:function() {
    if (this.channel) {
      this.channel.stop();
      this.channel = null;
    }
  }, onSetAssets:function(name, oldValue, newValue) {
    var newAssets = [];
    var i, len = newValue.length;
    if (oldValue && oldValue.length) {
      for (i = 0;i < oldValue.length;i++) {
        if (oldValue[i]) {
          var asset = this.system.app.assets.get(oldValue[i]);
          if (asset) {
            asset.off("change", this.onAssetChanged, this);
            asset.off("remove", this.onAssetRemoved, this);
            if (this.currentSource === asset.name) {
              this.stop();
            }
          }
        }
      }
    }
    if (len) {
      for (i = 0;i < len;i++) {
        if (oldValue.indexOf(newValue[i]) < 0) {
          if (newValue[i] instanceof pc.Asset) {
            newAssets.push(newValue[i].id);
          } else {
            newAssets.push(newValue[i]);
          }
        }
      }
    }
    if (!this.system._inTools && newAssets.length) {
      this.loadAudioSourceAssets(newAssets);
    }
  }, onAssetChanged:function(asset, attribute, newValue, oldValue) {
    if (attribute === "resource") {
      var sources = this.data.sources;
      if (sources) {
        this.data.sources[asset.name] = newValue;
        if (this.data.currentSource === asset.name) {
          if (this.channel) {
            if (this.channel.paused) {
              this.play(asset.name);
              this.pause();
            } else {
              this.play(asset.name);
            }
          }
        }
      }
    }
  }, onAssetRemoved:function(asset) {
    asset.off("remove", this.onAssetRemoved, this);
    if (this.data.sources[asset.name]) {
      delete this.data.sources[asset.name];
      if (this.data.currentSource === asset.name) {
        this.stop();
        this.data.currentSource = null;
      }
    }
  }, onSetLoop:function(name, oldValue, newValue) {
    if (oldValue != newValue) {
      if (this.channel) {
        this.channel.setLoop(newValue);
      }
    }
  }, onSetVolume:function(name, oldValue, newValue) {
    if (oldValue != newValue) {
      if (this.channel) {
        this.channel.setVolume(newValue);
      }
    }
  }, onSetPitch:function(name, oldValue, newValue) {
    if (oldValue != newValue) {
      if (this.channel) {
        this.channel.setPitch(newValue);
      }
    }
  }, onSetMaxDistance:function(name, oldValue, newValue) {
    if (oldValue != newValue) {
      if (this.channel instanceof pc.Channel3d) {
        this.channel.setMaxDistance(newValue);
      }
    }
  }, onSetMinDistance:function(name, oldValue, newValue) {
    if (oldValue != newValue) {
      if (this.channel instanceof pc.Channel3d) {
        this.channel.setMinDistance(newValue);
      }
    }
  }, onSetRollOffFactor:function(name, oldValue, newValue) {
    if (oldValue != newValue) {
      if (this.channel instanceof pc.Channel3d) {
        this.channel.setRollOffFactor(newValue);
      }
    }
  }, onSetDistanceModel:function(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      if (this.channel instanceof pc.Channel3d) {
        this.channel.setDistanceModel(newValue);
      }
    }
  }, onSet3d:function(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      if (this.system.initialized && this.currentSource) {
        var paused = false;
        var suspended = false;
        if (this.channel) {
          paused = this.channel.paused;
          suspended = this.channel.suspended;
        }
        this.play(this.currentSource);
        if (this.channel) {
          this.channel.paused = paused;
          this.channel.suspended = suspended;
        }
      }
    }
  }, onEnable:function() {
    pc.Component.prototype.onEnable.call(this);
    var assets = this.data.assets;
    if (assets) {
      var registry = this.system.app.assets;
      for (var i = 0, len = assets.length;i < len;i++) {
        var asset = assets[i];
        if (!(asset instanceof pc.Asset)) {
          asset = registry.get(asset);
        }
        if (asset && !asset.resource) {
          registry.load(asset);
        }
      }
    }
    if (this.system.initialized) {
      if (this.data.activate && !this.channel) {
        this.play(this.currentSource);
      } else {
        this.unpause();
      }
    }
  }, onDisable:function() {
    pc.Component.prototype.onDisable.call(this);
    this.pause();
  }, loadAudioSourceAssets:function(ids) {
    var self = this;
    var assets = ids.map(function(id) {
      return this.system.app.assets.get(id);
    }, this);
    var sources = {};
    var currentSource = null;
    var count = assets.length;
    var _error = function(e) {
      count--;
    };
    var _done = function() {
      this.data.sources = sources;
      this.data.currentSource = currentSource;
      if (this.enabled && this.activate && currentSource) {
        this.onEnable();
      }
    }.bind(this);
    assets.forEach(function(asset, index) {
      if (asset) {
        currentSource = currentSource || asset.name;
        asset.off("change", this.onAssetChanged, this);
        asset.on("change", this.onAssetChanged, this);
        asset.off("remove", this.onAssetRemoved, this);
        asset.on("remove", this.onAssetRemoved, this);
        asset.off("error", _error, this);
        asset.on("error", _error, this);
        asset.ready(function(asset) {
          sources[asset.name] = asset.resource;
          count--;
          if (count === 0) {
            _done();
          }
        });
        if (!asset.resource && self.enabled && self.entity.enabled) {
          this.system.app.assets.load(asset);
        }
      } else {
        count--;
        if (count === 0) {
          _done();
        }
        this.system.app.assets.on("add:" + ids[index], function(asset) {
          asset.ready(function(asset) {
            self.data.sources[asset.name] = asset.resource;
          });
          if (!asset.resource) {
            self.system.app.assets.load(asset);
          }
        });
      }
    }, this);
  }});
  return {AudioSourceComponent:AudioSourceComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled", "assets", "volume", "pitch", "loop", "activate", "3d", "minDistance", "maxDistance", "rollOffFactor", "distanceModel", "sources", "currentSource", "channel"];
  var AudioSourceComponentSystem = function(app, manager) {
    pc.ComponentSystem.call(this, app);
    this.id = "audiosource";
    this.description = "Specifies audio assets that can be played at the position of the Entity.";
    app.systems.add(this.id, this);
    this.ComponentType = pc.AudioSourceComponent;
    this.DataType = pc.AudioSourceComponentData;
    this.schema = _schema;
    this.manager = manager;
    this.initialized = false;
    pc.ComponentSystem.on("initialize", this.onInitialize, this);
    pc.ComponentSystem.on("update", this.onUpdate, this);
    this.on("remove", this.onRemove, this);
  };
  AudioSourceComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  AudioSourceComponentSystem.prototype.constructor = AudioSourceComponentSystem;
  pc.Component._buildAccessors(pc.AudioSourceComponent.prototype, _schema);
  Object.assign(AudioSourceComponentSystem.prototype, {initializeComponentData:function(component, data, properties) {
    properties = ["activate", "volume", "pitch", "loop", "3d", "minDistance", "maxDistance", "rollOffFactor", "distanceModel", "enabled", "assets"];
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
    component.paused = !(component.enabled && component.activate);
  }, onInitialize:function(root) {
    if (root.audiosource && root.enabled && root.audiosource.enabled && root.audiosource.activate) {
      root.audiosource.play(root.audiosource.currentSource);
    }
    var children = root._children;
    var i, len = children.length;
    for (i = 0;i < len;i++) {
      if (children[i] instanceof pc.Entity) {
        this.onInitialize(children[i]);
      }
    }
    this.initialized = true;
  }, onUpdate:function(dt) {
    var components = this.store;
    for (var id in components) {
      if (components.hasOwnProperty(id)) {
        var component = components[id];
        var entity = component.entity;
        var componentData = component.data;
        if (componentData.enabled && entity.enabled && componentData.channel instanceof pc.Channel3d) {
          var pos = entity.getPosition();
          componentData.channel.setPosition(pos);
        }
      }
    }
  }, onRemove:function(entity, data) {
    if (data.channel) {
      data.channel.stop();
      data.channel = null;
    }
  }, setVolume:function(volume) {
    this.manager.setVolume(volume);
  }});
  return {AudioSourceComponentSystem:AudioSourceComponentSystem};
}());
pc.AudioSourceComponentData = function AudioSourceComponentData() {
  this.enabled = true;
  this.assets = [];
  this.activate = true;
  this.volume = 1;
  this.pitch = 1;
  this.loop = false;
  this["3d"] = true;
  this.minDistance = 1;
  this.maxDistance = 10000;
  this.rollOffFactor = 1;
  this.distanceModel = pc.DISTANCE_INVERSE;
  this.paused = true;
  this.sources = {};
  this.currentSource = null;
  this.channel = null;
};
Object.assign(pc, function() {
  var AudioListenerComponent = function(system, entity) {
    pc.Component.call(this, system, entity);
  };
  AudioListenerComponent.prototype = Object.create(pc.Component.prototype);
  AudioListenerComponent.prototype.constructor = AudioListenerComponent;
  Object.assign(AudioListenerComponent.prototype, {setCurrentListener:function() {
    if (this.enabled && this.entity.audiolistener && this.entity.enabled) {
      this.system.current = this.entity;
      var position = this.system.current.getPosition();
      this.system.manager.listener.setPosition(position);
    }
  }, onEnable:function() {
    pc.Component.prototype.onEnable.call(this);
    this.setCurrentListener();
  }, onDisable:function() {
    pc.Component.prototype.onDisable.call(this);
    if (this.system.current === this.entity) {
      this.system.current = null;
    }
  }});
  return {AudioListenerComponent:AudioListenerComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled"];
  var AudioListenerComponentSystem = function(app, manager) {
    pc.ComponentSystem.call(this, app);
    this.id = "audiolistener";
    this.description = "Specifies the location of the listener for 3D audio playback.";
    app.systems.add(this.id, this);
    this.ComponentType = pc.AudioListenerComponent;
    this.DataType = pc.AudioListenerComponentData;
    this.schema = _schema;
    this.manager = manager;
    this.current = null;
    pc.ComponentSystem.on("update", this.onUpdate, this);
  };
  AudioListenerComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  AudioListenerComponentSystem.prototype.constructor = AudioListenerComponentSystem;
  pc.Component._buildAccessors(pc.AudioListenerComponent.prototype, _schema);
  Object.assign(AudioListenerComponentSystem.prototype, {initializeComponentData:function(component, data, properties) {
    properties = ["enabled"];
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
  }, onUpdate:function(dt) {
    if (this.current) {
      var position = this.current.getPosition();
      this.manager.listener.setPosition(position);
      var wtm = this.current.getWorldTransform();
      this.manager.listener.setOrientation(wtm);
    }
  }});
  return {AudioListenerComponentSystem:AudioListenerComponentSystem};
}());
Object.assign(pc, function() {
  var AudioListenerComponentData = function() {
    this.enabled = true;
  };
  return {AudioListenerComponentData:AudioListenerComponentData};
}());
Object.assign(pc, {BODYTYPE_STATIC:"static", BODYTYPE_DYNAMIC:"dynamic", BODYTYPE_KINEMATIC:"kinematic", BODYFLAG_STATIC_OBJECT:1, BODYFLAG_KINEMATIC_OBJECT:2, BODYFLAG_NORESPONSE_OBJECT:4, BODYSTATE_ACTIVE_TAG:1, BODYSTATE_ISLAND_SLEEPING:2, BODYSTATE_WANTS_DEACTIVATION:3, BODYSTATE_DISABLE_DEACTIVATION:4, BODYSTATE_DISABLE_SIMULATION:5, BODYGROUP_NONE:0, BODYGROUP_DEFAULT:1, BODYGROUP_DYNAMIC:1, BODYGROUP_STATIC:2, BODYGROUP_KINEMATIC:4, BODYGROUP_ENGINE_1:8, BODYGROUP_TRIGGER:16, BODYGROUP_ENGINE_2:32, 
BODYGROUP_ENGINE_3:64, BODYGROUP_USER_1:128, BODYGROUP_USER_2:256, BODYGROUP_USER_3:512, BODYGROUP_USER_4:1024, BODYGROUP_USER_5:2048, BODYGROUP_USER_6:4096, BODYGROUP_USER_7:8192, BODYGROUP_USER_8:16384, BODYMASK_NONE:0, BODYMASK_ALL:65535, BODYMASK_STATIC:2, BODYMASK_NOT_STATIC:65535 ^ 2, BODYMASK_NOT_STATIC_KINEMATIC:65535 ^ (2 | 4)});
Object.assign(pc, function() {
  var ammoTransform;
  var ammoVec1, ammoVec2, ammoQuat, ammoOrigin;
  var RigidBodyComponent = function RigidBodyComponent(system, entity) {
    pc.Component.call(this, system, entity);
    if (typeof Ammo !== "undefined" && !ammoTransform) {
      ammoTransform = new Ammo.btTransform;
      ammoVec1 = new Ammo.btVector3;
      ammoVec2 = new Ammo.btVector3;
      ammoQuat = new Ammo.btQuaternion;
      ammoOrigin = new Ammo.btVector3(0, 0, 0);
    }
    this.on("set_mass", this.onSetMass, this);
    this.on("set_linearDamping", this.onSetLinearDamping, this);
    this.on("set_angularDamping", this.onSetAngularDamping, this);
    this.on("set_linearFactor", this.onSetLinearFactor, this);
    this.on("set_angularFactor", this.onSetAngularFactor, this);
    this.on("set_friction", this.onSetFriction, this);
    this.on("set_restitution", this.onSetRestitution, this);
    this.on("set_type", this.onSetType, this);
    this.on("set_group", this.onSetGroupOrMask, this);
    this.on("set_mask", this.onSetGroupOrMask, this);
    this.on("set_body", this.onSetBody, this);
    this._displacement = new pc.Vec3(0, 0, 0);
    this._linearVelocity = new pc.Vec3(0, 0, 0);
    this._angularVelocity = new pc.Vec3(0, 0, 0);
  };
  RigidBodyComponent.prototype = Object.create(pc.Component.prototype);
  RigidBodyComponent.prototype.constructor = RigidBodyComponent;
  Object.defineProperty(RigidBodyComponent.prototype, "bodyType", {get:function() {
    console.warn("WARNING: bodyType: Function is deprecated. Query type property instead.");
    return this.type;
  }, set:function(type) {
    console.warn("WARNING: bodyType: Function is deprecated. Set type property instead.");
    this.type = type;
  }});
  Object.defineProperty(RigidBodyComponent.prototype, "linearVelocity", {get:function() {
    if (!this.isKinematic()) {
      if (this.body) {
        var vel = this.body.getLinearVelocity();
        this._linearVelocity.set(vel.x(), vel.y(), vel.z());
      }
    }
    return this._linearVelocity;
  }, set:function(lv) {
    this.activate();
    if (!this.isKinematic()) {
      if (this.body) {
        ammoVec1.setValue(lv.x, lv.y, lv.z);
        this.body.setLinearVelocity(ammoVec1);
      }
    }
    this._linearVelocity.copy(lv);
  }});
  Object.defineProperty(RigidBodyComponent.prototype, "angularVelocity", {get:function() {
    if (!this.isKinematic()) {
      if (this.body) {
        var vel = this.body.getAngularVelocity();
        this._angularVelocity.set(vel.x(), vel.y(), vel.z());
      }
    }
    return this._angularVelocity;
  }, set:function(av) {
    this.activate();
    if (!this.isKinematic()) {
      if (this.body) {
        ammoVec1.setValue(av.x, av.y, av.z);
        this.body.setAngularVelocity(ammoVec1);
      }
    }
    this._angularVelocity.copy(av);
  }});
  Object.assign(RigidBodyComponent.prototype, {createBody:function() {
    var entity = this.entity;
    var shape;
    if (entity.collision) {
      shape = entity.collision.shape;
      if (entity.trigger) {
        entity.trigger.destroy();
        delete entity.trigger;
      }
    }
    if (shape) {
      if (this.body) {
        this.system.removeBody(this.body);
        Ammo.destroy(this.body);
      }
      var isStaticOrKinematic = this.isStaticOrKinematic();
      var mass = isStaticOrKinematic ? 0 : this.mass;
      var localInertia = new Ammo.btVector3(0, 0, 0);
      if (!isStaticOrKinematic) {
        shape.calculateLocalInertia(mass, localInertia);
      }
      var pos = entity.getPosition();
      var rot = entity.getRotation();
      ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
      var startTransform = new Ammo.btTransform;
      startTransform.setIdentity();
      startTransform.getOrigin().setValue(pos.x, pos.y, pos.z);
      startTransform.setRotation(ammoQuat);
      var motionState = new Ammo.btDefaultMotionState(startTransform);
      var bodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
      var body = new Ammo.btRigidBody(bodyInfo);
      body.setRestitution(this.restitution);
      body.setFriction(this.friction);
      body.setDamping(this.linearDamping, this.angularDamping);
      var v;
      v = this.linearFactor;
      ammoVec1.setValue(v.x, v.y, v.z);
      body.setLinearFactor(ammoVec1);
      v = this.angularFactor;
      ammoVec1.setValue(v.x, v.y, v.z);
      body.setAngularFactor(ammoVec1);
      body.entity = entity;
      if (this.isKinematic()) {
        body.setCollisionFlags(body.getCollisionFlags() | pc.BODYFLAG_KINEMATIC_OBJECT);
        body.setActivationState(pc.BODYSTATE_DISABLE_DEACTIVATION);
      }
      entity.rigidbody.body = body;
      if (this.enabled && this.entity.enabled) {
        this.enableSimulation();
      }
    }
  }, isActive:function() {
    if (this.body) {
      return this.body.isActive();
    }
    return false;
  }, activate:function() {
    if (this.body) {
      this.body.activate();
    }
  }, enableSimulation:function() {
    if (this.entity.collision && this.entity.collision.enabled && !this.data.simulationEnabled) {
      var body = this.body;
      if (body) {
        this.system.addBody(body, this.group, this.mask);
        if (this.isKinematic()) {
          body.forceActivationState(pc.BODYSTATE_DISABLE_DEACTIVATION);
          body.activate();
        } else {
          body.forceActivationState(pc.BODYFLAG_ACTIVE_TAG);
          this.syncEntityToBody();
        }
        this.data.simulationEnabled = true;
      }
    }
  }, disableSimulation:function() {
    var body = this.body;
    if (body && this.data.simulationEnabled) {
      this.system.removeBody(body);
      body.forceActivationState(pc.BODYSTATE_DISABLE_SIMULATION);
      this.data.simulationEnabled = false;
    }
  }, applyForce:function() {
    var x, y, z;
    var px, py, pz;
    switch(arguments.length) {
      case 1:
        x = arguments[0].x;
        y = arguments[0].y;
        z = arguments[0].z;
        break;
      case 2:
        x = arguments[0].x;
        y = arguments[0].y;
        z = arguments[0].z;
        px = arguments[1].x;
        py = arguments[1].y;
        pz = arguments[1].z;
        break;
      case 3:
        x = arguments[0];
        y = arguments[1];
        z = arguments[2];
        break;
      case 6:
        x = arguments[0];
        y = arguments[1];
        z = arguments[2];
        px = arguments[3];
        py = arguments[4];
        pz = arguments[5];
        break;
    }
    var body = this.body;
    if (body) {
      body.activate();
      ammoVec1.setValue(x, y, z);
      if (px !== undefined) {
        ammoVec2.setValue(px, py, pz);
        body.applyForce(ammoVec1, ammoVec2);
      } else {
        body.applyForce(ammoVec1, ammoOrigin);
      }
    }
  }, applyTorque:function() {
    var x, y, z;
    switch(arguments.length) {
      case 1:
        x = arguments[0].x;
        y = arguments[0].y;
        z = arguments[0].z;
        break;
      case 3:
        x = arguments[0];
        y = arguments[1];
        z = arguments[2];
        break;
      default:
        return;
    }
    var body = this.body;
    if (body) {
      body.activate();
      ammoVec1.setValue(x, y, z);
      body.applyTorque(ammoVec1);
    }
  }, applyImpulse:function() {
    var x, y, z;
    var px, py, pz;
    switch(arguments.length) {
      case 1:
        x = arguments[0].x;
        y = arguments[0].y;
        z = arguments[0].z;
        break;
      case 2:
        x = arguments[0].x;
        y = arguments[0].y;
        z = arguments[0].z;
        px = arguments[1].x;
        py = arguments[1].y;
        pz = arguments[1].z;
        break;
      case 3:
        x = arguments[0];
        y = arguments[1];
        z = arguments[2];
        break;
      case 6:
        x = arguments[0];
        y = arguments[1];
        z = arguments[2];
        px = arguments[3];
        py = arguments[4];
        pz = arguments[5];
        break;
      default:
        return;
    }
    var body = this.body;
    if (body) {
      body.activate();
      ammoVec1.setValue(x, y, z);
      if (px !== undefined) {
        ammoVec2.setValue(px, py, pz);
        body.applyImpulse(ammoVec1, ammoVec2);
      } else {
        body.applyImpulse(ammoVec1, ammoOrigin);
      }
    }
  }, applyTorqueImpulse:function() {
    var x, y, z;
    switch(arguments.length) {
      case 1:
        x = arguments[0].x;
        y = arguments[0].y;
        z = arguments[0].z;
        break;
      case 3:
        x = arguments[0];
        y = arguments[1];
        z = arguments[2];
        break;
      default:
        return;
    }
    var body = this.body;
    if (body) {
      body.activate();
      ammoVec1.setValue(x, y, z);
      body.applyTorqueImpulse(ammoVec1);
    }
  }, isStatic:function() {
    return this.type === pc.BODYTYPE_STATIC;
  }, isStaticOrKinematic:function() {
    return this.type === pc.BODYTYPE_STATIC || this.type === pc.BODYTYPE_KINEMATIC;
  }, isKinematic:function() {
    return this.type === pc.BODYTYPE_KINEMATIC;
  }, syncEntityToBody:function() {
    var body = this.body;
    if (body) {
      var pos = this.entity.getPosition();
      var rot = this.entity.getRotation();
      var transform = body.getWorldTransform();
      transform.getOrigin().setValue(pos.x, pos.y, pos.z);
      ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
      transform.setRotation(ammoQuat);
      if (this.isKinematic()) {
        var motionState = this.body.getMotionState();
        if (motionState) {
          motionState.setWorldTransform(transform);
        }
      }
      body.activate();
    }
  }, syncBodyToEntity:function() {
    var body = this.body;
    if (body.isActive()) {
      var motionState = body.getMotionState();
      if (motionState) {
        motionState.getWorldTransform(ammoTransform);
        var p = ammoTransform.getOrigin();
        var q = ammoTransform.getRotation();
        this.entity.setPosition(p.x(), p.y(), p.z());
        this.entity.setRotation(q.x(), q.y(), q.z(), q.w());
      }
    }
  }, teleport:function() {
    if (arguments.length < 3) {
      if (arguments[0]) {
        this.entity.setPosition(arguments[0]);
      }
      if (arguments[1]) {
        if (arguments[1] instanceof pc.Quat) {
          this.entity.setRotation(arguments[1]);
        } else {
          this.entity.setEulerAngles(arguments[1]);
        }
      }
    } else {
      if (arguments.length === 6) {
        this.entity.setEulerAngles(arguments[3], arguments[4], arguments[5]);
      }
      this.entity.setPosition(arguments[0], arguments[1], arguments[2]);
    }
    this.syncEntityToBody();
  }, _updateKinematic:function(dt) {
    this._displacement.copy(this._linearVelocity).scale(dt);
    this.entity.translate(this._displacement);
    this._displacement.copy(this._angularVelocity).scale(dt);
    this.entity.rotate(this._displacement.x, this._displacement.y, this._displacement.z);
    if (this.body.getMotionState()) {
      var pos = this.entity.getPosition();
      var rot = this.entity.getRotation();
      ammoTransform.getOrigin().setValue(pos.x, pos.y, pos.z);
      ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
      ammoTransform.setRotation(ammoQuat);
      this.body.getMotionState().setWorldTransform(ammoTransform);
    }
  }, onEnable:function() {
    pc.Component.prototype.onEnable.call(this);
    if (!this.body) {
      this.createBody();
    }
    this.enableSimulation();
  }, onDisable:function() {
    pc.Component.prototype.onDisable.call(this);
    this.disableSimulation();
  }, onSetMass:function(name, oldValue, newValue) {
    var body = this.data.body;
    if (body) {
      var isEnabled = this.enabled && this.entity.enabled;
      if (isEnabled) {
        this.disableSimulation();
      }
      var mass = newValue;
      var localInertia = new Ammo.btVector3(0, 0, 0);
      body.getCollisionShape().calculateLocalInertia(mass, localInertia);
      body.setMassProps(mass, localInertia);
      body.updateInertiaTensor();
      if (isEnabled) {
        this.enableSimulation();
      }
    }
  }, onSetLinearDamping:function(name, oldValue, newValue) {
    var body = this.data.body;
    if (body) {
      body.setDamping(newValue, this.data.angularDamping);
    }
  }, onSetAngularDamping:function(name, oldValue, newValue) {
    var body = this.data.body;
    if (body) {
      body.setDamping(this.data.linearDamping, newValue);
    }
  }, onSetLinearFactor:function(name, oldValue, newValue) {
    var body = this.data.body;
    if (body) {
      ammoVec1.setValue(newValue.x, newValue.y, newValue.z);
      body.setLinearFactor(ammoVec1);
    }
  }, onSetAngularFactor:function(name, oldValue, newValue) {
    var body = this.data.body;
    if (body) {
      ammoVec1.setValue(newValue.x, newValue.y, newValue.z);
      body.setAngularFactor(ammoVec1);
    }
  }, onSetFriction:function(name, oldValue, newValue) {
    var body = this.data.body;
    if (body) {
      body.setFriction(newValue);
    }
  }, onSetRestitution:function(name, oldValue, newValue) {
    var body = this.data.body;
    if (body) {
      body.setRestitution(newValue);
    }
  }, onSetType:function(name, oldValue, newValue) {
    if (newValue !== oldValue) {
      this.disableSimulation();
      if (newValue === pc.BODYTYPE_DYNAMIC) {
        this.data.group = pc.BODYGROUP_DYNAMIC;
        this.data.mask = pc.BODYMASK_ALL;
      } else {
        if (newValue === pc.BODYTYPE_KINEMATIC) {
          this.data.group = pc.BODYGROUP_KINEMATIC;
          this.data.mask = pc.BODYMASK_ALL;
        } else {
          this.data.group = pc.BODYGROUP_STATIC;
          this.data.mask = pc.BODYMASK_NOT_STATIC;
        }
      }
      this.createBody();
    }
  }, onSetGroupOrMask:function(name, oldValue, newValue) {
    if (newValue !== oldValue) {
      var isEnabled = this.enabled && this.entity.enabled;
      if (isEnabled) {
        this.disableSimulation();
        this.enableSimulation();
      }
    }
  }, onSetBody:function(name, oldValue, newValue) {
    if (this.body && this.data.simulationEnabled) {
      this.body.activate();
    }
  }});
  return {RigidBodyComponent:RigidBodyComponent};
}());
Object.assign(pc, function() {
  var ammoRayStart, ammoRayEnd;
  var collisions = {};
  var frameCollisions = {};
  var WARNED_RAYCAST_CALLBACK = false;
  var RaycastResult = function RaycastResult(entity, point, normal) {
    this.entity = entity;
    this.point = point;
    this.normal = normal;
  };
  var SingleContactResult = function SingleContactResult(a, b, contactPoint) {
    if (arguments.length === 0) {
      this.a = null;
      this.b = null;
      this.localPointA = new pc.Vec3;
      this.localPointB = new pc.Vec3;
      this.pointA = new pc.Vec3;
      this.pointB = new pc.Vec3;
      this.normal = new pc.Vec3;
    } else {
      this.a = a;
      this.b = b;
      this.localPointA = contactPoint.localPoint;
      this.localPointB = contactPoint.localPointOther;
      this.pointA = contactPoint.point;
      this.pointB = contactPoint.pointOther;
      this.normal = contactPoint.normal;
    }
  };
  var ContactPoint = function ContactPoint(localPoint, localPointOther, point, pointOther, normal) {
    if (arguments.length === 0) {
      this.localPoint = new pc.Vec3;
      this.localPointOther = new pc.Vec3;
      this.point = new pc.Vec3;
      this.pointOther = new pc.Vec3;
      this.normal = new pc.Vec3;
    } else {
      this.localPoint = localPoint;
      this.localPointOther = localPointOther;
      this.point = point;
      this.pointOther = pointOther;
      this.normal = normal;
    }
  };
  var ContactResult = function ContactResult(other, contacts) {
    this.other = other;
    this.contacts = contacts;
  };
  var _schema = ["enabled", "type", "mass", "linearDamping", "angularDamping", "linearFactor", "angularFactor", "friction", "restitution", "group", "mask", "body"];
  var RigidBodyComponentSystem = function RigidBodyComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "rigidbody";
    this.description = "Adds the entity to the scene's physical simulation.";
    app.systems.add(this.id, this);
    this._stats = app.stats.frame;
    this.ComponentType = pc.RigidBodyComponent;
    this.DataType = pc.RigidBodyComponentData;
    this.contactPointPool = new pc.AllocatePool(ContactPoint, 1);
    this.contactResultPool = new pc.AllocatePool(ContactResult, 1);
    this.singleContactResultPool = new pc.AllocatePool(SingleContactResult, 1);
    this.schema = _schema;
    this.maxSubSteps = 10;
    this.fixedTimeStep = 1 / 60;
    this.on("remove", this.onRemove, this);
  };
  RigidBodyComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  RigidBodyComponentSystem.prototype.constructor = RigidBodyComponentSystem;
  pc.Component._buildAccessors(pc.RigidBodyComponent.prototype, _schema);
  Object.assign(RigidBodyComponentSystem.prototype, {onLibraryLoaded:function() {
    if (typeof Ammo !== "undefined") {
      var collisionConfiguration = new Ammo.btDefaultCollisionConfiguration;
      var dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
      var overlappingPairCache = new Ammo.btDbvtBroadphase;
      var solver = new Ammo.btSequentialImpulseConstraintSolver;
      this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
      this._ammoGravity = new Ammo.btVector3(0, -9.82, 0);
      this.dynamicsWorld.setGravity(this._ammoGravity);
      ammoRayStart = new Ammo.btVector3;
      ammoRayEnd = new Ammo.btVector3;
      pc.ComponentSystem.on("update", this.onUpdate, this);
    } else {
      pc.ComponentSystem.off("update", this.onUpdate, this);
    }
  }, initializeComponentData:function(component, _data, properties) {
    properties = ["enabled", "mass", "linearDamping", "angularDamping", "linearFactor", "angularFactor", "friction", "restitution", "type", "group", "mask"];
    var data = {};
    properties.forEach(function(prop) {
      data[prop] = _data[prop];
    });
    if (_data.bodyType) {
      data.type = _data.bodyType;
      console.warn("WARNING: rigidbody.bodyType: Property is deprecated. Use type instead.");
    }
    if (data.linearFactor && pc.type(data.linearFactor) === "array") {
      data.linearFactor = new pc.Vec3(data.linearFactor[0], data.linearFactor[1], data.linearFactor[2]);
    }
    if (data.angularFactor && pc.type(data.angularFactor) === "array") {
      data.angularFactor = new pc.Vec3(data.angularFactor[0], data.angularFactor[1], data.angularFactor[2]);
    }
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
  }, cloneComponent:function(entity, clone) {
    var data = {enabled:entity.rigidbody.enabled, mass:entity.rigidbody.mass, linearDamping:entity.rigidbody.linearDamping, angularDamping:entity.rigidbody.angularDamping, linearFactor:[entity.rigidbody.linearFactor.x, entity.rigidbody.linearFactor.y, entity.rigidbody.linearFactor.z], angularFactor:[entity.rigidbody.angularFactor.x, entity.rigidbody.angularFactor.y, entity.rigidbody.angularFactor.z], friction:entity.rigidbody.friction, restitution:entity.rigidbody.restitution, type:entity.rigidbody.type, 
    group:entity.rigidbody.group, mask:entity.rigidbody.mask};
    this.addComponent(clone, data);
  }, onRemove:function(entity, data) {
    if (data.body) {
      this.removeBody(data.body);
      Ammo.destroy(data.body);
    }
    data.body = null;
  }, addBody:function(body, group, mask) {
    if (group !== undefined && mask !== undefined) {
      this.dynamicsWorld.addRigidBody(body, group, mask);
    } else {
      this.dynamicsWorld.addRigidBody(body);
    }
    return body;
  }, removeBody:function(body) {
    this.dynamicsWorld.removeRigidBody(body);
  }, addConstraint:function(constraint) {
    this.dynamicsWorld.addConstraint(constraint);
    return constraint;
  }, removeConstraint:function(constraint) {
    this.dynamicsWorld.removeConstraint(constraint);
  }, setGravity:function() {
    var x, y, z;
    if (arguments.length === 1) {
      x = arguments[0].x;
      y = arguments[0].y;
      z = arguments[0].z;
    } else {
      x = arguments[0];
      y = arguments[1];
      z = arguments[2];
    }
    this._ammoGravity.setValue(x, y, z);
    this.dynamicsWorld.setGravity(this._ammoGravity);
  }, raycastFirst:function(start, end) {
    var result = null;
    ammoRayStart.setValue(start.x, start.y, start.z);
    ammoRayEnd.setValue(end.x, end.y, end.z);
    var rayCallback = new Ammo.ClosestRayResultCallback(ammoRayStart, ammoRayEnd);
    this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);
    if (rayCallback.hasHit()) {
      var collisionObj = rayCallback.get_m_collisionObject();
      var body = Ammo.castObject(collisionObj, Ammo.btRigidBody);
      if (body) {
        var point = rayCallback.get_m_hitPointWorld();
        var normal = rayCallback.get_m_hitNormalWorld();
        result = new RaycastResult(body.entity, new pc.Vec3(point.x(), point.y(), point.z()), new pc.Vec3(normal.x(), normal.y(), normal.z()));
        if (arguments.length > 2) {
          var callback = arguments[2];
          callback(result);
          if (!WARNED_RAYCAST_CALLBACK) {
            console.warn("[DEPRECATED]: pc.RigidBodyComponentSystem#rayCastFirst no longer requires a callback. The result of the raycast is returned by the function instead.");
            WARNED_RAYCAST_CALLBACK = true;
          }
        }
      }
    }
    Ammo.destroy(rayCallback);
    return result;
  }, _storeCollision:function(entity, other) {
    var isNewCollision = false;
    var guid = entity._guid;
    collisions[guid] = collisions[guid] || {others:[], entity:entity};
    if (collisions[guid].others.indexOf(other) < 0) {
      collisions[guid].others.push(other);
      isNewCollision = true;
    }
    frameCollisions[guid] = frameCollisions[guid] || {others:[], entity:entity};
    frameCollisions[guid].others.push(other);
    return isNewCollision;
  }, _createContactPointFromAmmo:function(contactPoint) {
    var contact = this.contactPointPool.allocate();
    contact.localPoint.set(contactPoint.get_m_localPointA().x(), contactPoint.get_m_localPointA().y(), contactPoint.get_m_localPointA().z());
    contact.localPointOther.set(contactPoint.get_m_localPointB().x(), contactPoint.get_m_localPointB().y(), contactPoint.get_m_localPointB().z());
    contact.point.set(contactPoint.getPositionWorldOnA().x(), contactPoint.getPositionWorldOnA().y(), contactPoint.getPositionWorldOnA().z());
    contact.pointOther.set(contactPoint.getPositionWorldOnB().x(), contactPoint.getPositionWorldOnB().y(), contactPoint.getPositionWorldOnB().z());
    contact.normal.set(contactPoint.get_m_normalWorldOnB().x(), contactPoint.get_m_normalWorldOnB().y(), contactPoint.get_m_normalWorldOnB().z());
    return contact;
  }, _createReverseContactPointFromAmmo:function(contactPoint) {
    var contact = this.contactPointPool.allocate();
    contact.localPointOther.set(contactPoint.get_m_localPointA().x(), contactPoint.get_m_localPointA().y(), contactPoint.get_m_localPointA().z());
    contact.localPoint.set(contactPoint.get_m_localPointB().x(), contactPoint.get_m_localPointB().y(), contactPoint.get_m_localPointB().z());
    contact.pointOther.set(contactPoint.getPositionWorldOnA().x(), contactPoint.getPositionWorldOnA().y(), contactPoint.getPositionWorldOnA().z());
    contact.point.set(contactPoint.getPositionWorldOnB().x(), contactPoint.getPositionWorldOnB().y(), contactPoint.getPositionWorldOnB().z());
    contact.normal.set(contactPoint.get_m_normalWorldOnB().x(), contactPoint.get_m_normalWorldOnB().y(), contactPoint.get_m_normalWorldOnB().z());
    return contact;
  }, _createSingleContactResult:function(a, b, contactPoint) {
    var result = this.singleContactResultPool.allocate();
    result.a = a;
    result.b = b;
    result.localPointA = contactPoint.localPoint;
    result.localPointB = contactPoint.localPointOther;
    result.pointA = contactPoint.point;
    result.pointB = contactPoint.pointOther;
    result.normal = contactPoint.normal;
    return result;
  }, _createContactResult:function(other, contacts) {
    var result = this.contactResultPool.allocate();
    result.other = other;
    result.contacts = contacts;
    return result;
  }, _cleanOldCollisions:function() {
    for (var guid in collisions) {
      if (collisions.hasOwnProperty(guid)) {
        var entity = collisions[guid].entity;
        var entityCollision = entity.collision;
        var others = collisions[guid].others;
        var length = others.length;
        var i = length;
        while (i--) {
          var other = others[i];
          if (!frameCollisions[guid] || frameCollisions[guid].others.indexOf(other) < 0) {
            others.splice(i, 1);
            if (entityCollision && other.collision) {
              if (entity.rigidbody && other.rigidbody) {
                entityCollision.fire("collisionend", other);
              } else {
                if (entity.trigger) {
                  entityCollision.fire("triggerleave", other);
                }
              }
            }
          }
        }
        if (others.length === 0) {
          delete collisions[guid];
        }
      }
    }
  }, onUpdate:function(dt) {
    this.dynamicsWorld.stepSimulation(dt, this.maxSubSteps, this.fixedTimeStep);
    var components = this.store;
    for (var id in components) {
      if (components.hasOwnProperty(id)) {
        var entity = components[id].entity;
        var componentData = components[id].data;
        if (componentData.body && componentData.body.isActive() && componentData.enabled && entity.enabled) {
          if (componentData.type === pc.BODYTYPE_DYNAMIC) {
            entity.rigidbody.syncBodyToEntity();
          } else {
            if (componentData.type === pc.BODYTYPE_KINEMATIC) {
              entity.rigidbody._updateKinematic(dt);
            }
          }
        }
      }
    }
    var dispatcher = this.dynamicsWorld.getDispatcher();
    var numManifolds = dispatcher.getNumManifolds();
    var i, j;
    frameCollisions = {};
    for (i = 0;i < numManifolds;i++) {
      var manifold = dispatcher.getManifoldByIndexInternal(i);
      var body0 = manifold.getBody0();
      var body1 = manifold.getBody1();
      var wb0 = Ammo.castObject(body0, Ammo.btRigidBody);
      var wb1 = Ammo.castObject(body1, Ammo.btRigidBody);
      var e0 = wb0.entity;
      var e1 = wb1.entity;
      if (!e0 || !e1) {
        continue;
      }
      var flags0 = body0.getCollisionFlags();
      var flags1 = body1.getCollisionFlags();
      var numContacts = manifold.getNumContacts();
      var forwardContacts = [];
      var reverseContacts = [];
      var newCollision, e0Events, e1Events;
      if (numContacts > 0) {
        if (flags0 & pc.BODYFLAG_NORESPONSE_OBJECT || flags1 & pc.BODYFLAG_NORESPONSE_OBJECT) {
          e0Events = e0.collision ? e0.collision.hasEvent("triggerenter") || e0.collision.hasEvent("triggerleave") : false;
          e1Events = e1.collision ? e1.collision.hasEvent("triggerenter") || e1.collision.hasEvent("triggerleave") : false;
          if (e0Events) {
            newCollision = this._storeCollision(e0, e1);
            if (newCollision) {
              if (e0.collision && !(flags1 & pc.BODYFLAG_NORESPONSE_OBJECT)) {
                e0.collision.fire("triggerenter", e1);
              }
            }
          }
          if (e1Events) {
            newCollision = this._storeCollision(e1, e0);
            if (newCollision) {
              if (e1.collision && !(flags0 & pc.BODYFLAG_NORESPONSE_OBJECT)) {
                e1.collision.fire("triggerenter", e0);
              }
            }
          }
        } else {
          e0Events = e0.collision ? e0.collision.hasEvent("collisionstart") || e0.collision.hasEvent("collisionend") || e0.collision.hasEvent("contact") : false;
          e1Events = e1.collision ? e1.collision.hasEvent("collisionstart") || e1.collision.hasEvent("collisionend") || e1.collision.hasEvent("contact") : false;
          var globalEvents = this.hasEvent("contact");
          if (globalEvents || e0Events || e1Events) {
            for (j = 0;j < numContacts;j++) {
              var btContactPoint = manifold.getContactPoint(j);
              var contactPoint = this._createContactPointFromAmmo(btContactPoint);
              var reverseContactPoint = null;
              if (e0Events || e1Events) {
                reverseContactPoint = this._createReverseContactPointFromAmmo(btContactPoint);
                forwardContacts.push(contactPoint);
                reverseContacts.push(reverseContactPoint);
              }
              if (globalEvents) {
                var result = this._createSingleContactResult(e0, e1, contactPoint);
                this.fire("contact", result);
              }
            }
            if (e0Events) {
              var forwardResult = this._createContactResult(e1, forwardContacts);
              if (e0.collision) {
                e0.collision.fire("contact", forwardResult);
              }
              newCollision = this._storeCollision(e0, e1);
              if (newCollision && e0.collision) {
                e0.collision.fire("collisionstart", forwardResult);
              }
            }
            if (e1Events) {
              var reverseResult = this._createContactResult(e0, reverseContacts);
              if (e1.collision) {
                e1.collision.fire("contact", reverseResult);
              }
              newCollision = this._storeCollision(e1, e0);
              if (newCollision && e1.collision) {
                e1.collision.fire("collisionstart", reverseResult);
              }
            }
          }
        }
      }
    }
    this._cleanOldCollisions();
    this.contactPointPool.freeAll();
    this.contactResultPool.freeAll();
    this.singleContactResultPool.freeAll();
  }});
  return {RIGIDBODY_TYPE_STATIC:"static", RIGIDBODY_TYPE_DYNAMIC:"dynamic", RIGIDBODY_TYPE_KINEMATIC:"kinematic", RIGIDBODY_CF_STATIC_OBJECT:1, RIGIDBODY_CF_KINEMATIC_OBJECT:2, RIGIDBODY_CF_NORESPONSE_OBJECT:4, RIGIDBODY_ACTIVE_TAG:1, RIGIDBODY_ISLAND_SLEEPING:2, RIGIDBODY_WANTS_DEACTIVATION:3, RIGIDBODY_DISABLE_DEACTIVATION:4, RIGIDBODY_DISABLE_SIMULATION:5, RigidBodyComponentSystem:RigidBodyComponentSystem};
}());
Object.assign(pc, function() {
  var RigidBodyComponentData = function() {
    this.enabled = true;
    this.mass = 1;
    this.linearDamping = 0;
    this.angularDamping = 0;
    this.linearFactor = new pc.Vec3(1, 1, 1);
    this.angularFactor = new pc.Vec3(1, 1, 1);
    this.friction = 0.5;
    this.restitution = 0;
    this.type = pc.BODYTYPE_STATIC;
    this.group = pc.BODYGROUP_STATIC;
    this.mask = pc.BODYMASK_NOT_STATIC;
    this.body = null;
    this.simulationEnabled = false;
  };
  return {RigidBodyComponentData:RigidBodyComponentData};
}());
Object.assign(pc, function() {
  var ammoVec1, ammoQuat;
  var Trigger = function Trigger(app, component, data) {
    this.entity = component.entity;
    this.component = component;
    this.app = app;
    if (typeof Ammo !== "undefined") {
      ammoVec1 = new Ammo.btVector3;
      ammoQuat = new Ammo.btQuaternion;
    }
    this.initialize(data);
  };
  Object.assign(Trigger.prototype, {initialize:function(data) {
    var entity = this.entity;
    var shape = data.shape;
    if (shape && typeof Ammo !== "undefined") {
      if (entity.trigger) {
        entity.trigger.destroy();
      }
      var mass = 1;
      var localInertia = new Ammo.btVector3(0, 0, 0);
      shape.calculateLocalInertia(mass, localInertia);
      var pos = entity.getPosition();
      var rot = entity.getRotation();
      ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
      var startTransform = new Ammo.btTransform;
      startTransform.setIdentity();
      startTransform.getOrigin().setValue(pos.x, pos.y, pos.z);
      startTransform.setRotation(ammoQuat);
      var motionState = new Ammo.btDefaultMotionState(startTransform);
      var bodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
      var body = new Ammo.btRigidBody(bodyInfo);
      this.body = body;
      body.setRestitution(0);
      body.setFriction(0);
      body.setDamping(0, 0);
      ammoVec1.setValue(0, 0, 0);
      body.setLinearFactor(ammoVec1);
      body.setAngularFactor(ammoVec1);
      body.setCollisionFlags(body.getCollisionFlags() | pc.BODYFLAG_NORESPONSE_OBJECT);
      body.entity = entity;
      if (this.component.enabled && entity.enabled) {
        this.enable();
      }
    }
  }, destroy:function() {
    if (this.body) {
      this.app.systems.rigidbody.removeBody(this.body);
    }
  }, syncEntityToBody:function() {
    var body = this.body;
    if (body) {
      var position = this.entity.getPosition();
      var rotation = this.entity.getRotation();
      var transform = body.getWorldTransform();
      transform.getOrigin().setValue(position.x, position.y, position.z);
      ammoQuat.setValue(rotation.x, rotation.y, rotation.z, rotation.w);
      transform.setRotation(ammoQuat);
      body.activate();
    }
  }, enable:function() {
    var body = this.body;
    if (!body) {
      return;
    }
    this.app.systems.rigidbody.addBody(body, pc.BODYGROUP_TRIGGER, pc.BODYMASK_NOT_STATIC ^ pc.BODYGROUP_TRIGGER);
    body.forceActivationState(pc.BODYSTATE_ACTIVE_TAG);
    body.activate();
    this.syncEntityToBody();
  }, disable:function() {
    var body = this.body;
    if (!body) {
      return;
    }
    this.app.systems.rigidbody.removeBody(body);
    body.forceActivationState(pc.BODYSTATE_DISABLE_SIMULATION);
  }});
  return {Trigger:Trigger};
}());
Object.assign(pc, function() {
  var CollisionComponent = function CollisionComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this.on("set_type", this.onSetType, this);
    this.on("set_halfExtents", this.onSetHalfExtents, this);
    this.on("set_radius", this.onSetRadius, this);
    this.on("set_height", this.onSetHeight, this);
    this.on("set_axis", this.onSetAxis, this);
    this.on("set_asset", this.onSetAsset, this);
    this.on("set_model", this.onSetModel, this);
  };
  CollisionComponent.prototype = Object.create(pc.Component.prototype);
  CollisionComponent.prototype.constructor = CollisionComponent;
  Object.assign(CollisionComponent.prototype, {onSetType:function(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this.system.changeType(this, oldValue, newValue);
    }
  }, onSetHalfExtents:function(name, oldValue, newValue) {
    if (this.data.initialized && this.data.type === "box") {
      this.system.recreatePhysicalShapes(this);
    }
  }, onSetRadius:function(name, oldValue, newValue) {
    if (this.data.initialized && (this.data.type === "sphere" || this.data.type === "capsule" || this.data.type === "cylinder")) {
      this.system.recreatePhysicalShapes(this);
    }
  }, onSetHeight:function(name, oldValue, newValue) {
    if (this.data.initialized && (this.data.type === "capsule" || this.data.type === "cylinder")) {
      this.system.recreatePhysicalShapes(this);
    }
  }, onSetAxis:function(name, oldValue, newValue) {
    if (this.data.initialized && (this.data.type === "capsule" || this.data.type === "cylinder")) {
      this.system.recreatePhysicalShapes(this);
    }
  }, onSetAsset:function(name, oldValue, newValue) {
    var asset;
    var assets = this.system.app.assets;
    if (oldValue) {
      asset = assets.get(oldValue);
      if (asset) {
        asset.off("remove", this.onAssetRemoved, this);
      }
    }
    if (newValue) {
      if (newValue instanceof pc.Asset) {
        this.data.asset = newValue.id;
      }
      asset = assets.get(this.data.asset);
      if (asset) {
        asset.off("remove", this.onAssetRemoved, this);
        asset.on("remove", this.onAssetRemoved, this);
      }
    }
    if (this.data.initialized && this.data.type === "mesh") {
      if (!newValue) {
        this.data.model = null;
      }
      this.system.recreatePhysicalShapes(this);
    }
  }, onSetModel:function(name, oldValue, newValue) {
    if (this.data.initialized && this.data.type === "mesh") {
      this.system.implementations.mesh.doRecreatePhysicalShape(this);
    }
  }, onAssetRemoved:function(asset) {
    asset.off("remove", this.onAssetRemoved, this);
    if (this.data.asset === asset.id) {
      this.asset = null;
    }
  }, onEnable:function() {
    pc.Component.prototype.onEnable.call(this);
    if (this.data.type === "mesh" && this.data.asset && this.data.initialized) {
      var asset = this.system.app.assets.get(this.data.asset);
      if (asset && (!asset.resource || !this.data.shape)) {
        this.system.recreatePhysicalShapes(this);
        return;
      }
    }
    if (this.entity.trigger) {
      this.entity.trigger.enable();
    } else {
      if (this.entity.rigidbody) {
        if (this.entity.rigidbody.enabled) {
          this.entity.rigidbody.enableSimulation();
        }
      }
    }
  }, onDisable:function() {
    pc.Component.prototype.onDisable.call(this);
    if (this.entity.trigger) {
      this.entity.trigger.disable();
    } else {
      if (this.entity.rigidbody) {
        this.entity.rigidbody.disableSimulation();
      }
    }
  }});
  return {CollisionComponent:CollisionComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled", "type", "halfExtents", "radius", "axis", "height", "asset", "shape", "model"];
  var CollisionSystemImpl = function(system) {
    this.system = system;
  };
  Object.assign(CollisionSystemImpl.prototype, {beforeInitialize:function(component, data) {
    data.shape = this.createPhysicalShape(component.entity, data);
    data.model = new pc.Model;
    data.model.graph = new pc.GraphNode;
  }, afterInitialize:function(component, data) {
    this.recreatePhysicalShapes(component);
    component.data.initialized = true;
  }, reset:function(component, data) {
    this.beforeInitialize(component, data);
    this.afterInitialize(component, data);
  }, recreatePhysicalShapes:function(component) {
    var entity = component.entity;
    var data = component.data;
    if (typeof Ammo !== "undefined") {
      data.shape = this.createPhysicalShape(component.entity, data);
      if (entity.rigidbody) {
        entity.rigidbody.disableSimulation();
        entity.rigidbody.createBody();
      } else {
        if (!entity.trigger) {
          entity.trigger = new pc.Trigger(this.system.app, component, data);
        } else {
          entity.trigger.initialize(data);
        }
      }
    }
  }, createPhysicalShape:function(entity, data) {
    return undefined;
  }, updateTransform:function(component, position, rotation, scale) {
    if (component.entity.trigger) {
      component.entity.trigger.syncEntityToBody();
    }
  }, remove:function(entity, data) {
    var app = this.system.app;
    if (entity.rigidbody && entity.rigidbody.body) {
      app.systems.rigidbody.removeBody(entity.rigidbody.body);
      entity.rigidbody.disableSimulation();
    }
    if (entity.trigger) {
      entity.trigger.destroy();
      delete entity.trigger;
    }
    if (app.scene.containsModel(data.model)) {
      app.root.removeChild(data.model.graph);
      app.scene.removeModel(data.model);
    }
  }, clone:function(entity, clone) {
    var src = this.system.dataStore[entity._guid];
    var data = {enabled:src.data.enabled, type:src.data.type, halfExtents:[src.data.halfExtents.x, src.data.halfExtents.y, src.data.halfExtents.z], radius:src.data.radius, axis:src.data.axis, height:src.data.height, asset:src.data.asset, model:src.data.model};
    return this.system.addComponent(clone, data);
  }});
  var CollisionBoxSystemImpl = function(system) {
    CollisionSystemImpl.call(this, system);
  };
  CollisionBoxSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
  CollisionBoxSystemImpl.prototype.constructor = CollisionBoxSystemImpl;
  Object.assign(CollisionBoxSystemImpl.prototype, {createPhysicalShape:function(entity, data) {
    if (typeof Ammo !== "undefined") {
      var he = data.halfExtents;
      var ammoHe = new Ammo.btVector3(he ? he.x : 0.5, he ? he.y : 0.5, he ? he.z : 0.5);
      return new Ammo.btBoxShape(ammoHe);
    }
    return undefined;
  }});
  var CollisionSphereSystemImpl = function(system) {
    CollisionSystemImpl.call(this, system);
  };
  CollisionSphereSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
  CollisionSphereSystemImpl.prototype.constructor = CollisionSphereSystemImpl;
  Object.assign(CollisionSphereSystemImpl.prototype, {createPhysicalShape:function(entity, data) {
    if (typeof Ammo !== "undefined") {
      return new Ammo.btSphereShape(data.radius);
    }
    return undefined;
  }});
  var CollisionCapsuleSystemImpl = function(system) {
    CollisionSystemImpl.call(this, system);
  };
  CollisionCapsuleSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
  CollisionCapsuleSystemImpl.prototype.constructor = CollisionCapsuleSystemImpl;
  Object.assign(CollisionCapsuleSystemImpl.prototype, {createPhysicalShape:function(entity, data) {
    var shape = null;
    var axis = data.axis !== undefined ? data.axis : 1;
    var radius = data.radius || 0.5;
    var height = Math.max((data.height || 2) - 2 * radius, 0);
    if (typeof Ammo !== "undefined") {
      switch(axis) {
        case 0:
          shape = new Ammo.btCapsuleShapeX(radius, height);
          break;
        case 1:
          shape = new Ammo.btCapsuleShape(radius, height);
          break;
        case 2:
          shape = new Ammo.btCapsuleShapeZ(radius, height);
          break;
      }
    }
    return shape;
  }});
  var CollisionCylinderSystemImpl = function(system) {
    CollisionSystemImpl.call(this, system);
  };
  CollisionCylinderSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
  CollisionCylinderSystemImpl.prototype.constructor = CollisionCylinderSystemImpl;
  Object.assign(CollisionCylinderSystemImpl.prototype, {createPhysicalShape:function(entity, data) {
    var halfExtents = null;
    var shape = null;
    var axis = data.axis !== undefined ? data.axis : 1;
    var radius = data.radius !== undefined ? data.radius : 0.5;
    var height = data.height !== undefined ? data.height : 1;
    if (typeof Ammo !== "undefined") {
      switch(axis) {
        case 0:
          halfExtents = new Ammo.btVector3(height * 0.5, radius, radius);
          shape = new Ammo.btCylinderShapeX(halfExtents);
          break;
        case 1:
          halfExtents = new Ammo.btVector3(radius, height * 0.5, radius);
          shape = new Ammo.btCylinderShape(halfExtents);
          break;
        case 2:
          halfExtents = new Ammo.btVector3(radius, radius, height * 0.5);
          shape = new Ammo.btCylinderShapeZ(halfExtents);
          break;
      }
    }
    return shape;
  }});
  var CollisionMeshSystemImpl = function(system) {
    CollisionSystemImpl.call(this, system);
  };
  CollisionMeshSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
  CollisionMeshSystemImpl.prototype.constructor = CollisionMeshSystemImpl;
  Object.assign(CollisionMeshSystemImpl.prototype, {beforeInitialize:function(component, data) {
  }, createPhysicalShape:function(entity, data) {
    if (typeof Ammo !== "undefined" && data.model) {
      var model = data.model;
      var shape = new Ammo.btCompoundShape;
      var i, j;
      for (i = 0;i < model.meshInstances.length;i++) {
        var meshInstance = model.meshInstances[i];
        var mesh = meshInstance.mesh;
        var ib = mesh.indexBuffer[pc.RENDERSTYLE_SOLID];
        var vb = mesh.vertexBuffer;
        var format = vb.getFormat();
        var stride = format.size / 4;
        var positions;
        for (j = 0;j < format.elements.length;j++) {
          var element = format.elements[j];
          if (element.name === pc.SEMANTIC_POSITION) {
            positions = new Float32Array(vb.lock(), element.offset);
          }
        }
        var indices = new Uint16Array(ib.lock());
        var numTriangles = mesh.primitive[0].count / 3;
        var v1 = new Ammo.btVector3;
        var v2 = new Ammo.btVector3;
        var v3 = new Ammo.btVector3;
        var i1, i2, i3;
        var base = mesh.primitive[0].base;
        var triMesh = new Ammo.btTriangleMesh;
        for (j = 0;j < numTriangles;j++) {
          i1 = indices[base + j * 3] * stride;
          i2 = indices[base + j * 3 + 1] * stride;
          i3 = indices[base + j * 3 + 2] * stride;
          v1.setValue(positions[i1], positions[i1 + 1], positions[i1 + 2]);
          v2.setValue(positions[i2], positions[i2 + 1], positions[i2 + 2]);
          v3.setValue(positions[i3], positions[i3 + 1], positions[i3 + 2]);
          triMesh.addTriangle(v1, v2, v3, true);
        }
        var useQuantizedAabbCompression = true;
        var triMeshShape = new Ammo.btBvhTriangleMeshShape(triMesh, useQuantizedAabbCompression);
        var wtm = meshInstance.node.getWorldTransform();
        var scl = wtm.getScale();
        triMeshShape.setLocalScaling(new Ammo.btVector3(scl.x, scl.y, scl.z));
        var pos = meshInstance.node.getPosition();
        var rot = meshInstance.node.getRotation();
        var transform = new Ammo.btTransform;
        transform.setIdentity();
        transform.getOrigin().setValue(pos.x, pos.y, pos.z);
        var ammoQuat = new Ammo.btQuaternion;
        ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
        transform.setRotation(ammoQuat);
        shape.addChildShape(transform, triMeshShape);
      }
      var entityTransform = entity.getWorldTransform();
      var scale = entityTransform.getScale();
      var vec = new Ammo.btVector3;
      vec.setValue(scale.x, scale.y, scale.z);
      shape.setLocalScaling(vec);
      return shape;
    }
    return undefined;
  }, recreatePhysicalShapes:function(component) {
    var data = component.data;
    if (data.asset !== null && component.enabled && component.entity.enabled) {
      this.loadModelAsset(component);
    } else {
      this.doRecreatePhysicalShape(component);
    }
  }, loadModelAsset:function(component) {
    var self = this;
    var id = component.data.asset;
    var data = component.data;
    var assets = this.system.app.assets;
    var asset = assets.get(id);
    if (asset) {
      asset.ready(function(asset) {
        data.model = asset.resource;
        self.doRecreatePhysicalShape(component);
      });
      assets.load(asset);
    } else {
      assets.once("add:" + id, function(asset) {
        asset.ready(function(asset) {
          data.model = asset.resource;
          self.doRecreatePhysicalShape(component);
        });
        assets.load(asset);
      });
    }
  }, doRecreatePhysicalShape:function(component) {
    var entity = component.entity;
    var data = component.data;
    if (data.model) {
      if (data.shape) {
        Ammo.destroy(data.shape);
      }
      data.shape = this.createPhysicalShape(entity, data);
      if (entity.rigidbody) {
        entity.rigidbody.createBody();
      } else {
        if (!entity.trigger) {
          entity.trigger = new pc.Trigger(this.system.app, component, data);
        } else {
          entity.trigger.initialize(data);
        }
      }
    } else {
      this.remove(entity, data);
    }
  }, updateTransform:function(component, position, rotation, scale) {
    if (component.shape) {
      var entityTransform = component.entity.getWorldTransform();
      var worldScale = entityTransform.getScale();
      var previousScale = component.shape.getLocalScaling();
      if (worldScale.x !== previousScale.x() || worldScale.y !== previousScale.y() || worldScale.z !== previousScale.z()) {
        this.doRecreatePhysicalShape(component);
      }
    }
    pc.CollisionSystemImpl.prototype.updateTransform.call(this, component, position, rotation, scale);
  }});
  var CollisionComponentSystem = function CollisionComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "collision";
    this.description = "Specifies a collision volume.";
    app.systems.add(this.id, this);
    this.ComponentType = pc.CollisionComponent;
    this.DataType = pc.CollisionComponentData;
    this.schema = _schema;
    this.implementations = {};
    this.on("remove", this.onRemove, this);
    pc.ComponentSystem.on("update", this.onUpdate, this);
  };
  CollisionComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  CollisionComponentSystem.prototype.constructor = CollisionComponentSystem;
  pc.Component._buildAccessors(pc.CollisionComponent.prototype, _schema);
  Object.assign(CollisionComponentSystem.prototype, {onLibraryLoaded:function() {
    if (typeof Ammo !== "undefined") {
    } else {
      pc.ComponentSystem.off("update", this.onUpdate, this);
    }
  }, initializeComponentData:function(component, _data, properties) {
    var idx;
    var data = {};
    properties = ["type", "halfExtents", "radius", "axis", "height", "shape", "model", "asset", "enabled"];
    properties.forEach(function(prop) {
      data[prop] = _data[prop];
    });
    if (_data.hasOwnProperty("asset")) {
      idx = properties.indexOf("model");
      if (idx !== -1) {
        properties.splice(idx, 1);
      }
    } else {
      if (_data.hasOwnProperty("model")) {
        idx = properties.indexOf("asset");
        if (idx !== -1) {
          properties.splice(idx, 1);
        }
      }
    }
    if (!data.type) {
      data.type = component.data.type;
    }
    component.data.type = data.type;
    if (data.halfExtents && pc.type(data.halfExtents) === "array") {
      data.halfExtents = new pc.Vec3(data.halfExtents[0], data.halfExtents[1], data.halfExtents[2]);
    }
    var impl = this._createImplementation(data.type);
    impl.beforeInitialize(component, data);
    pc.ComponentSystem.prototype.initializeComponentData.call(this.system, component, data, properties);
    impl.afterInitialize(component, data);
  }, _createImplementation:function(type) {
    if (this.implementations[type] === undefined) {
      var impl;
      switch(type) {
        case "box":
          impl = new CollisionBoxSystemImpl(this);
          break;
        case "sphere":
          impl = new CollisionSphereSystemImpl(this);
          break;
        case "capsule":
          impl = new CollisionCapsuleSystemImpl(this);
          break;
        case "cylinder":
          impl = new CollisionCylinderSystemImpl(this);
          break;
        case "mesh":
          impl = new CollisionMeshSystemImpl(this);
          break;
        default:
      }
      this.implementations[type] = impl;
    }
    return this.implementations[type];
  }, _getImplementation:function(entity) {
    return this.implementations[entity.collision.data.type];
  }, cloneComponent:function(entity, clone) {
    return this._getImplementation(entity).clone(entity, clone);
  }, onRemove:function(entity, data) {
    this.implementations[data.type].remove(entity, data);
  }, onUpdate:function(dt) {
    var id, entity, data;
    var components = this.store;
    for (id in components) {
      entity = components[id].entity;
      data = components[id].data;
      if (data.enabled && entity.enabled) {
        if (!entity.rigidbody && entity.trigger) {
          entity.trigger.syncEntityToBody();
        }
      }
    }
  }, onTransformChanged:function(component, position, rotation, scale) {
    this.implementations[component.data.type].updateTransform(component, position, rotation, scale);
  }, changeType:function(component, previousType, newType) {
    this.implementations[previousType].remove(component.entity, component.data);
    this._createImplementation(newType).reset(component, component.data);
  }, recreatePhysicalShapes:function(component) {
    this.implementations[component.data.type].recreatePhysicalShapes(component);
  }});
  return {CollisionComponentSystem:CollisionComponentSystem};
}());
Object.assign(pc, function() {
  var CollisionComponentData = function() {
    this.enabled = true;
    this.type = "box";
    this.halfExtents = new pc.Vec3(0.5, 0.5, 0.5);
    this.radius = 0.5;
    this.axis = 1;
    this.height = 2;
    this.asset = null;
    this.shape = null;
    this.model = null;
    this.initialized = false;
  };
  return {CollisionComponentData:CollisionComponentData};
}());
Object.assign(pc, function() {
  var SIMPLE_PROPERTIES = ["emitterExtents", "emitterRadius", "loop", "initialVelocity", "animSpeed", "normalMap"];
  var COMPLEX_PROPERTIES = ["numParticles", "lifetime", "rate", "rate2", "startAngle", "startAngle2", "lighting", "halfLambert", "intensity", "wrap", "wrapBounds", "depthWrite", "noFog", "sort", "stretch", "alignToMotion", "preWarm", "emitterShape", "animTilesX", "animTilesY", "animFrames", "animLoop", "colorMap", "localSpace"];
  var GRAPH_PROPERTIES = ["scaleGraph", "scaleGraph2", "colorGraph", "colorGraph2", "alphaGraph", "alphaGraph2", "velocityGraph", "velocityGraph2", "localVelocityGraph", "localVelocityGraph2", "rotationSpeedGraph", "rotationSpeedGraph2"];
  var ASSET_PROPERTIES = ["colorMapAsset", "normalMapAsset", "mesh"];
  var depthLayer;
  var ParticleSystemComponent = function ParticleSystemComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this.on("set_colorMapAsset", this.onSetColorMapAsset, this);
    this.on("set_normalMapAsset", this.onSetNormalMapAsset, this);
    this.on("set_mesh", this.onSetMesh, this);
    this.on("set_loop", this.onSetLoop, this);
    this.on("set_blendType", this.onSetBlendType, this);
    this.on("set_depthSoftening", this.onSetDepthSoftening, this);
    this.on("set_layers", this.onSetLayers, this);
    SIMPLE_PROPERTIES.forEach(function(prop) {
      this.on("set_" + prop, this.onSetSimpleProperty, this);
    }.bind(this));
    COMPLEX_PROPERTIES.forEach(function(prop) {
      this.on("set_" + prop, this.onSetComplexProperty, this);
    }.bind(this));
    GRAPH_PROPERTIES.forEach(function(prop) {
      this.on("set_" + prop, this.onSetGraphProperty, this);
    }.bind(this));
    this._requestedDepth = false;
  };
  ParticleSystemComponent.prototype = Object.create(pc.Component.prototype);
  ParticleSystemComponent.prototype.constructor = ParticleSystemComponent;
  Object.assign(ParticleSystemComponent.prototype, {addModelToLayers:function() {
    if (!this.data.model) {
      return;
    }
    var layer;
    for (var i = 0;i < this.layers.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer.addMeshInstances(this.data.model.meshInstances);
      this.emitter._layer = layer;
    }
  }, removeModelFromLayers:function(model) {
    if (!this.data.model) {
      return;
    }
    var layer;
    for (var i = 0;i < this.layers.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer.removeMeshInstances(this.data.model.meshInstances);
    }
  }, onSetLayers:function(name, oldValue, newValue) {
    if (!this.data.model) {
      return;
    }
    var i, layer;
    for (i = 0;i < oldValue.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
      if (!layer) {
        continue;
      }
      layer.removeMeshInstances(this.data.model.meshInstances);
    }
    if (!this.enabled || !this.entity.enabled) {
      return;
    }
    for (i = 0;i < newValue.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(newValue[i]);
      if (!layer) {
        continue;
      }
      layer.addMeshInstances(this.data.model.meshInstances);
    }
  }, onLayersChanged:function(oldComp, newComp) {
    this.addModelToLayers();
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
  }, onLayerAdded:function(layer) {
    if (!this.data.model) {
      return;
    }
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    layer.addMeshInstances(this.data.model.meshInstances);
  }, onLayerRemoved:function(layer) {
    if (!this.data.model) {
      return;
    }
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    layer.removeMeshInstances(this.data.model.meshInstances);
  }, onSetColorMapAsset:function(name, oldValue, newValue) {
    var self = this;
    var asset;
    var assets = this.system.app.assets;
    if (oldValue) {
      asset = assets.get(oldValue);
      if (asset) {
        asset.off("remove", this.onColorMapRemoved, this);
      }
    }
    if (newValue) {
      if (newValue instanceof pc.Asset) {
        this.data.colorMapAsset = newValue.id;
        newValue = newValue.id;
      }
      asset = assets.get(newValue);
      if (asset) {
        asset.on("remove", this.onColorMapRemoved, this);
        asset.ready(function(asset) {
          self.colorMap = asset.resource;
        });
        if (self.enabled && self.entity.enabled) {
          assets.load(asset);
        }
      } else {
        assets.once("add:" + newValue, function(asset) {
          asset.on("remove", this.onColorMapRemoved, this);
          asset.ready(function(asset) {
            self.colorMap = asset.resource;
          });
          if (self.enabled && self.entity.enabled) {
            assets.load(asset);
          }
        });
      }
    } else {
      this.colorMap = null;
    }
  }, onColorMapRemoved:function(asset) {
    asset.off("remove", this.onColorMapRemoved, this);
    this.colorMapAsset = null;
  }, onSetNormalMapAsset:function(name, oldValue, newValue) {
    var self = this;
    var asset;
    var assets = this.system.app.assets;
    if (oldValue) {
      asset = assets.get(oldValue);
      if (asset) {
        asset.off("remove", this.onNormalMapRemoved, this);
      }
    }
    if (newValue) {
      if (newValue instanceof pc.Asset) {
        this.data.normalMapAsset = newValue.id;
        newValue = newValue.id;
      }
      asset = assets.get(newValue);
      if (asset) {
        asset.on("remove", this.onNormalMapRemoved, this);
        asset.ready(function(asset) {
          self.normalMap = asset.resource;
        });
        if (self.enabled && self.entity.enabled) {
          assets.load(asset);
        }
      } else {
        assets.once("add:" + newValue, function(asset) {
          asset.on("remove", this.onNormalMapRemoved, this);
          asset.ready(function(asset) {
            self.normalMap = asset.resource;
          });
          if (self.enabled && self.entity.enabled) {
            assets.load(asset);
          }
        });
      }
    } else {
      this.normalMap = null;
    }
  }, onNormalMapRemoved:function(asset) {
    asset.off("remove", this.onNormalMapRemoved, this);
    this.normalMapAsset = null;
  }, onSetMesh:function(name, oldValue, newValue) {
    var self = this;
    var asset;
    var assets = this.system.app.assets;
    if (oldValue && typeof oldValue === "number") {
      asset = assets.get(oldValue);
      if (asset) {
        asset.off("remove", this.onMeshRemoved, this);
      }
    }
    if (newValue) {
      if (newValue instanceof pc.Asset) {
        this.data.mesh = newValue.id;
        newValue = newValue.id;
      }
      if (typeof newValue === "number") {
        asset = assets.get(newValue);
        if (asset) {
          asset.on("remove", this.onMeshRemoved, this);
          asset.ready(function(asset) {
            self._onMeshChanged(asset.resource);
          });
          if (self.enabled && self.entity.enabled) {
            assets.load(asset);
          }
        } else {
          assets.once("add:" + newValue, function(asset) {
            asset.on("remove", this.onMeshRemoved, this);
            asset.ready(function(asset) {
              self._onMeshChanged(asset.resource);
            });
            if (self.enabled && self.entity.enabled) {
              assets.load(asset);
            }
          });
        }
      } else {
        this._onMeshChanged(newValue);
      }
    } else {
      this._onMeshChanged(null);
    }
  }, _onMeshChanged:function(mesh) {
    if (mesh && !(mesh instanceof pc.Mesh)) {
      if (mesh.meshInstances[0]) {
        mesh = mesh.meshInstances[0].mesh;
      } else {
        mesh = null;
      }
    }
    this.data.mesh = mesh;
    if (this.emitter) {
      this.emitter.mesh = mesh;
      this.emitter.resetMaterial();
      this.rebuild();
    }
  }, onMeshRemoved:function(asset) {
    asset.off("remove", this.onMeshRemoved, this);
    this.mesh = null;
  }, onSetLoop:function(name, oldValue, newValue) {
    if (this.emitter) {
      this.emitter[name] = newValue;
      this.emitter.resetTime();
    }
  }, onSetBlendType:function(name, oldValue, newValue) {
    if (this.emitter) {
      this.emitter[name] = newValue;
      this.emitter.material.blendType = newValue;
      this.emitter.resetMaterial();
      this.rebuild();
    }
  }, _requestDepth:function() {
    if (this._requestedDepth) {
      return;
    }
    if (!depthLayer) {
      depthLayer = this.system.app.scene.layers.getLayerById(pc.LAYERID_DEPTH);
    }
    if (depthLayer) {
      depthLayer.incrementCounter();
      this._requestedDepth = true;
    }
  }, _releaseDepth:function() {
    if (!this._requestedDepth) {
      return;
    }
    if (depthLayer) {
      depthLayer.decrementCounter();
      this._requestedDepth = false;
    }
  }, onSetDepthSoftening:function(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      if (newValue) {
        if (this.enabled && this.entity.enabled) {
          this._requestDepth();
        }
        if (this.emitter) {
          this.emitter[name] = newValue;
        }
      } else {
        if (this.enabled && this.entity.enabled) {
          this._releaseDepth();
        }
        if (this.emitter) {
          this.emitter[name] = newValue;
        }
      }
      if (this.emitter) {
        this.reset();
        this.emitter.resetMaterial();
        this.rebuild();
      }
    }
  }, onSetSimpleProperty:function(name, oldValue, newValue) {
    if (this.emitter) {
      this.emitter[name] = newValue;
      this.emitter.resetMaterial();
    }
  }, onSetComplexProperty:function(name, oldValue, newValue) {
    if (this.emitter) {
      this.emitter[name] = newValue;
      this.reset();
      this.emitter.resetMaterial();
      this.rebuild();
    }
  }, onSetGraphProperty:function(name, oldValue, newValue) {
    if (this.emitter) {
      this.emitter[name] = newValue;
      this.emitter.rebuildGraphs();
      this.emitter.resetMaterial();
    }
  }, onEnable:function() {
    var data = this.data;
    for (var i = 0, len = ASSET_PROPERTIES.length;i < len;i++) {
      var asset = data[ASSET_PROPERTIES[i]];
      if (asset) {
        if (!(asset instanceof pc.Asset)) {
          var id = parseInt(asset, 10);
          if (id >= 0) {
            asset = this.system.app.assets.get(asset);
          } else {
            continue;
          }
        }
        if (asset && !asset.resource) {
          this.system.app.assets.load(asset);
        }
      }
    }
    if (!this.emitter) {
      var mesh = data.mesh;
      if (!(mesh instanceof pc.Mesh)) {
        mesh = null;
      }
      this.emitter = new pc.ParticleEmitter(this.system.app.graphicsDevice, {numParticles:data.numParticles, emitterExtents:data.emitterExtents, emitterRadius:data.emitterRadius, emitterShape:data.emitterShape, initialVelocity:data.initialVelocity, wrap:data.wrap, localSpace:data.localSpace, wrapBounds:data.wrapBounds, lifetime:data.lifetime, rate:data.rate, rate2:data.rate2, animTilesX:data.animTilesX, animTilesY:data.animTilesY, animNumFrames:data.animNumFrames, animSpeed:data.animSpeed, animLoop:data.animLoop, 
      startAngle:data.startAngle, startAngle2:data.startAngle2, scaleGraph:data.scaleGraph, scaleGraph2:data.scaleGraph2, colorGraph:data.colorGraph, colorGraph2:data.colorGraph2, alphaGraph:data.alphaGraph, alphaGraph2:data.alphaGraph2, localVelocityGraph:data.localVelocityGraph, localVelocityGraph2:data.localVelocityGraph2, velocityGraph:data.velocityGraph, velocityGraph2:data.velocityGraph2, rotationSpeedGraph:data.rotationSpeedGraph, rotationSpeedGraph2:data.rotationSpeedGraph2, colorMap:data.colorMap, 
      normalMap:data.normalMap, loop:data.loop, preWarm:data.preWarm, sort:data.sort, stretch:data.stretch, alignToMotion:data.alignToMotion, lighting:data.lighting, halfLambert:data.halfLambert, intensity:data.intensity, depthSoftening:data.depthSoftening, scene:this.system.app.scene, mesh:mesh, depthWrite:data.depthWrite, noFog:data.noFog, node:this.entity, blendType:data.blendType});
      this.emitter.meshInstance.node = this.entity;
      this.psys = new pc.Model;
      this.psys.graph = this.entity;
      this.psys.emitter = this.emitter;
      this.psys.meshInstances = [this.emitter.meshInstance];
      data.model = this.psys;
      this.emitter.psys = this.psys;
      if (!data.autoPlay) {
        this.pause();
        this.emitter.meshInstance.visible = false;
      }
    }
    if (data.model && this.emitter.colorMap) {
      this.addModelToLayers();
    }
    this.system.app.scene.on("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.on("add", this.onLayerAdded, this);
      this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
    }
    if (this.enabled && this.entity.enabled && data.depthSoftening) {
      this._requestDepth();
    }
    pc.Component.prototype.onEnable.call(this);
  }, onDisable:function() {
    pc.Component.prototype.onDisable.call(this);
    this.system.app.scene.off("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.off("add", this.onLayerAdded, this);
      this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
    }
    if (this.data.model) {
      this.removeModelFromLayers();
      if (this.data.depthSoftening) {
        this._releaseDepth();
      }
    }
  }, reset:function() {
    if (this.emitter) {
      this.emitter.reset();
    }
  }, stop:function() {
    if (this.emitter) {
      this.emitter.loop = false;
      this.emitter.resetTime();
      this.emitter.addTime(0, true);
    }
  }, pause:function() {
    this.data.paused = true;
  }, unpause:function() {
    this.data.paused = false;
  }, play:function() {
    this.data.paused = false;
    if (this.emitter) {
      this.emitter.meshInstance.visible = true;
      this.emitter.loop = this.data.loop;
      this.emitter.resetTime();
    }
  }, isPlaying:function() {
    if (this.data.paused) {
      return false;
    }
    if (this.emitter && this.emitter.loop) {
      return true;
    }
    return Date.now() <= this.emitter.endTime;
  }, rebuild:function() {
    var enabled = this.enabled;
    this.enabled = false;
    if (this.emitter) {
      this.emitter.rebuild();
      this.emitter.meshInstance.node = this.entity;
      this.data.model.meshInstances = [this.emitter.meshInstance];
    }
    this.enabled = enabled;
  }});
  return {ParticleSystemComponent:ParticleSystemComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled", "autoPlay", "numParticles", "lifetime", "rate", "rate2", "startAngle", "startAngle2", "loop", "preWarm", "lighting", "halfLambert", "intensity", "depthWrite", "noFog", "depthSoftening", "sort", "blendType", "stretch", "alignToMotion", "emitterShape", "emitterExtents", "emitterRadius", "initialVelocity", "wrap", "wrapBounds", "localSpace", "colorMapAsset", "normalMapAsset", "mesh", "localVelocityGraph", "localVelocityGraph2", "velocityGraph", "velocityGraph2", "rotationSpeedGraph", 
  "rotationSpeedGraph2", "scaleGraph", "scaleGraph2", "colorGraph", "colorGraph2", "alphaGraph", "alphaGraph2", "colorMap", "normalMap", "animTilesX", "animTilesY", "animNumFrames", "animSpeed", "animLoop", "layers"];
  var ParticleSystemComponentSystem = function ParticleSystemComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "particlesystem";
    this.description = "Updates and renders particle system in the scene.";
    app.systems.add(this.id, this);
    this.ComponentType = pc.ParticleSystemComponent;
    this.DataType = pc.ParticleSystemComponentData;
    this.schema = _schema;
    this.propertyTypes = {emitterExtents:"vec3", wrapBounds:"vec3", localVelocityGraph:"curveset", localVelocityGraph2:"curveset", velocityGraph:"curveset", velocityGraph2:"curveset", colorGraph:"curveset", colorGraph2:"curveset", alphaGraph:"curve", alphaGraph2:"curve", rotationSpeedGraph:"curve", rotationSpeedGraph2:"curve", scaleGraph:"curve", scaleGraph2:"curve"};
    this.on("beforeremove", this.onRemove, this);
    pc.ComponentSystem.on("update", this.onUpdate, this);
  };
  ParticleSystemComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  ParticleSystemComponentSystem.prototype.constructor = ParticleSystemComponentSystem;
  pc.Component._buildAccessors(pc.ParticleSystemComponent.prototype, _schema);
  Object.assign(ParticleSystemComponentSystem.prototype, {initializeComponentData:function(component, _data, properties) {
    var data = {};
    properties = [];
    var types = this.propertyTypes;
    var type;
    for (var prop in _data) {
      if (_data.hasOwnProperty(prop)) {
        properties.push(prop);
        data[prop] = _data[prop];
      }
      if (types[prop] === "vec3") {
        if (pc.type(data[prop]) === "array") {
          data[prop] = new pc.Vec3(data[prop][0], data[prop][1], data[prop][2]);
        }
      } else {
        if (types[prop] === "curve") {
          if (!(data[prop] instanceof pc.Curve)) {
            type = data[prop].type;
            data[prop] = new pc.Curve(data[prop].keys);
            data[prop].type = type;
          }
        } else {
          if (types[prop] === "curveset") {
            if (!(data[prop] instanceof pc.CurveSet)) {
              type = data[prop].type;
              data[prop] = new pc.CurveSet(data[prop].keys);
              data[prop].type = type;
            }
          }
        }
      }
      if (data.layers && pc.type(data.layers) === "array") {
        data.layers = data.layers.slice(0);
      }
    }
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
  }, cloneComponent:function(entity, clone) {
    var source = entity.particlesystem.data;
    var schema = this.schema;
    var data = {};
    for (var i = 0, len = schema.length;i < len;i++) {
      var prop = schema[i];
      var sourceProp = source[prop];
      if (sourceProp instanceof pc.Vec3 || sourceProp instanceof pc.Curve || sourceProp instanceof pc.CurveSet) {
        sourceProp = sourceProp.clone();
        data[prop] = sourceProp;
      } else {
        if (prop === "layers") {
          data.layers = source.layers.slice(0);
        } else {
          if (sourceProp !== null && sourceProp !== undefined) {
            data[prop] = sourceProp;
          }
        }
      }
    }
    return this.addComponent(clone, data);
  }, onUpdate:function(dt) {
    var components = this.store;
    var numSteps, i, j, c;
    var stats = this.app.stats.particles;
    for (var id in components) {
      if (components.hasOwnProperty(id)) {
        c = components[id];
        var entity = c.entity;
        var data = c.data;
        if (data.enabled && entity.enabled) {
          var emitter = data.model.emitter;
          if (!emitter.meshInstance.visible) {
            continue;
          }
          if (emitter.lighting) {
            var layer, lightCube;
            var layers = data.layers;
            for (i = 0;i < layers.length;i++) {
              layer = this.app.scene.layers.getLayerById(layers[i]);
              if (!layer) {
                continue;
              }
              if (!layer._lightCube) {
                layer._lightCube = new Float32Array(6 * 3);
              }
              lightCube = layer._lightCube;
              for (i = 0;i < 6;i++) {
                lightCube[i * 3] = this.app.scene.ambientLight.data[0];
                lightCube[i * 3 + 1] = this.app.scene.ambientLight.data[1];
                lightCube[i * 3 + 2] = this.app.scene.ambientLight.data[2];
              }
              var dirs = layer._sortedLights[pc.LIGHTTYPE_DIRECTIONAL];
              for (j = 0;j < dirs.length;j++) {
                for (c = 0;c < 6;c++) {
                  var weight = Math.max(emitter.lightCubeDir[c].dot(dirs[j]._direction), 0) * dirs[j]._intensity;
                  lightCube[c * 3] += dirs[j]._color.data[0] * weight;
                  lightCube[c * 3 + 1] += dirs[j]._color.data[1] * weight;
                  lightCube[c * 3 + 2] += dirs[j]._color.data[2] * weight;
                }
              }
            }
            emitter.constantLightCube.setValue(lightCube);
          }
          if (!data.paused) {
            emitter.simTime += dt;
            numSteps = 0;
            if (emitter.simTime > emitter.fixedTimeStep) {
              numSteps = Math.floor(emitter.simTime / emitter.fixedTimeStep);
              emitter.simTime -= numSteps * emitter.fixedTimeStep;
            }
            if (numSteps) {
              numSteps = Math.min(numSteps, emitter.maxSubSteps);
              for (i = 0;i < numSteps;i++) {
                emitter.addTime(emitter.fixedTimeStep);
              }
              stats._updatesPerFrame += numSteps;
              stats._frameTime += emitter._addTimeTime;
              emitter._addTimeTime = 0;
            }
            emitter.finishFrame();
          }
        }
      }
    }
  }, onRemove:function(entity, component) {
    var data = component.data;
    if (data.model) {
      entity.removeChild(data.model.getGraph());
      data.model = null;
    }
    if (component.emitter) {
      component.emitter.destroy();
      component.emitter = null;
    }
  }});
  return {ParticleSystemComponentSystem:ParticleSystemComponentSystem};
}());
Object.assign(pc, function() {
  var ParticleSystemComponentData = function() {
    this.numParticles = 1;
    this.rate = 1;
    this.rate2 = null;
    this.startAngle = 0;
    this.startAngle2 = null;
    this.lifetime = 50;
    this.emitterExtents = new pc.Vec3;
    this.emitterRadius = 0;
    this.emitterShape = pc.EMITTERSHAPE_BOX;
    this.initialVelocity = 0;
    this.wrapBounds = new pc.Vec3;
    this.localSpace = false;
    this.colorMap = null;
    this.colorMapAsset = null;
    this.normalMap = null;
    this.normalMapAsset = null;
    this.loop = true;
    this.preWarm = false;
    this.sort = 0;
    this.mode = pc.PARTICLEMODE_GPU;
    this.scene = null;
    this.lighting = false;
    this.halfLambert = false;
    this.intensity = 1;
    this.stretch = 0.0;
    this.alignToMotion = false;
    this.depthSoftening = 0;
    this.mesh = null;
    this.depthWrite = false;
    this.noFog = false;
    this.animTilesX = 1;
    this.animTilesY = 1;
    this.animNumFrames = 1;
    this.animSpeed = 1;
    this.animLoop = true;
    this.scaleGraph = null;
    this.scaleGraph2 = null;
    this.colorGraph = null;
    this.colorGraph2 = null;
    this.alphaGraph = null;
    this.alphaGraph2 = null;
    this.localVelocityGraph = null;
    this.localVelocityGraph2 = null;
    this.velocityGraph = null;
    this.velocityGraph2 = null;
    this.rotationSpeedGraph = null;
    this.rotationSpeedGraph2 = null;
    this.blendType = pc.BLEND_NORMAL;
    this.model = null;
    this.enabled = true;
    this.paused = false;
    this.autoPlay = true;
    this.layers = [pc.LAYERID_WORLD];
  };
  return {ParticleSystemComponentData:ParticleSystemComponentData};
}());
Object.assign(pc, function() {
  var SpriteAnimationClip = function(component, data) {
    this._component = component;
    this._frame = 0;
    this._sprite = null;
    this._spriteAsset = null;
    this.spriteAsset = data.spriteAsset;
    this.name = data.name;
    this.fps = data.fps || 0;
    this.loop = data.loop || false;
    this._playing = false;
    this._paused = false;
    this._time = 0;
    pc.events.attach(this);
  };
  Object.assign(SpriteAnimationClip.prototype, {_onSpriteAssetAdded:function(asset) {
    this._component.system.app.assets.off("add:" + asset.id, this._onSpriteAssetAdded, this);
    if (this._spriteAsset === asset.id) {
      this._bindSpriteAsset(asset);
    }
  }, _bindSpriteAsset:function(asset) {
    asset.on("load", this._onSpriteAssetLoad, this);
    asset.on("remove", this._onSpriteAssetRemove, this);
    if (asset.resource) {
      this._onSpriteAssetLoad(asset);
    } else {
      this._component.system.app.assets.load(asset);
    }
  }, _onSpriteAssetLoad:function(asset) {
    if (!asset.resource) {
      this.sprite = null;
    } else {
      if (!asset.resource.atlas) {
        var atlasAssetId = asset.data.textureAtlasAsset;
        var assets = this._component.system.app.assets;
        assets.off("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
        assets.once("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
      } else {
        this.sprite = asset.resource;
      }
    }
  }, _onTextureAtlasLoad:function(atlasAsset) {
    var spriteAsset = this._spriteAsset;
    if (spriteAsset instanceof pc.Asset) {
      this._onSpriteAssetLoad(spriteAsset);
    } else {
      this._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));
    }
  }, _onSpriteAssetRemove:function(asset) {
    this.sprite = null;
  }, _onSpriteMeshesChange:function() {
    if (this._component.currentClip === this) {
      this._component._showFrame(this.frame);
    }
  }, _onSpritePpuChanged:function() {
    if (this._component.currentClip === this) {
      if (this.sprite.renderMode !== pc.SPRITE_RENDERMODE_SIMPLE) {
        this._component._showFrame(this.frame);
      }
    }
  }, _update:function(dt) {
    if (this.fps === 0) {
      return;
    }
    if (!this._playing || this._paused || !this._sprite) {
      return;
    }
    var dir = this.fps < 0 ? -1 : 1;
    var time = this._time + dt * this._component.speed * dir;
    var duration = this.duration;
    var end = time > duration || time < 0;
    this._setTime(time);
    var frame = this.frame;
    if (this._sprite) {
      frame = Math.floor(this._sprite.frameKeys.length * this._time / duration);
    } else {
      frame = 0;
    }
    if (frame !== this._frame) {
      this._setFrame(frame);
    }
    if (end) {
      if (this.loop) {
        this.fire("loop");
        this._component.fire("loop", this);
      } else {
        this._playing = false;
        this._paused = false;
        this.fire("end");
        this._component.fire("end", this);
      }
    }
  }, _setTime:function(value) {
    this._time = value;
    var duration = this.duration;
    if (this._time < 0) {
      if (this.loop) {
        this._time = this._time % duration + duration;
      } else {
        this._time = 0;
      }
    } else {
      if (this._time > duration) {
        if (this.loop) {
          this._time = this._time % duration;
        } else {
          this._time = duration;
        }
      }
    }
  }, _setFrame:function(value) {
    if (this._sprite) {
      this._frame = pc.math.clamp(value, 0, this._sprite.frameKeys.length - 1);
    } else {
      this._frame = value;
    }
    if (this._component.currentClip === this) {
      this._component._showFrame(this._frame);
    }
  }, _destroy:function() {
    if (this._sprite) {
      this._sprite = null;
    }
    if (this._spriteAsset) {
      this._spriteAsset = null;
    }
  }, play:function() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    this._paused = false;
    this.frame = 0;
    this.fire("play");
    this._component.fire("play", this);
  }, pause:function() {
    if (!this._playing || this._paused) {
      return;
    }
    this._paused = true;
    this.fire("pause");
    this._component.fire("pause", this);
  }, resume:function() {
    if (!this._paused) {
      return;
    }
    this._paused = false;
    this.fire("resume");
    this._component.fire("resume", this);
  }, stop:function() {
    if (!this._playing) {
      return;
    }
    this._playing = false;
    this._paused = false;
    this._time = 0;
    this.frame = 0;
    this.fire("stop");
    this._component.fire("stop", this);
  }});
  Object.defineProperty(SpriteAnimationClip.prototype, "spriteAsset", {get:function() {
    return this._spriteAsset;
  }, set:function(value) {
    var assets = this._component.system.app.assets;
    var id = value;
    if (value instanceof pc.Asset) {
      id = value.id;
    }
    if (this._spriteAsset !== id) {
      if (this._spriteAsset) {
        var prev = assets.get(this._spriteAsset);
        if (prev) {
          prev.off("load", this._onSpriteAssetLoad, this);
          prev.off("remove", this._onSpriteAssetRemove, this);
          var atlasAssetId = prev.data && prev.data.textureAtlasAsset;
          if (atlasAssetId) {
            assets.off("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
          }
        }
      }
      this._spriteAsset = id;
      if (this._spriteAsset) {
        var asset = assets.get(this._spriteAsset);
        if (!asset) {
          this.sprite = null;
          assets.on("add:" + this._spriteAsset, this._onSpriteAssetAdded, this);
        } else {
          this._bindSpriteAsset(asset);
        }
      } else {
        this.sprite = null;
      }
    }
  }});
  Object.defineProperty(SpriteAnimationClip.prototype, "sprite", {get:function() {
    return this._sprite;
  }, set:function(value) {
    if (this._sprite) {
      this._sprite.off("set:meshes", this._onSpriteMeshesChange, this);
      this._sprite.off("set:pixelsPerUnit", this._onSpritePpuChanged, this);
      this._sprite.off("set:atlas", this._onSpriteMeshesChange, this);
      if (this._sprite.atlas) {
        this._sprite.atlas.off("set:texture", this._onSpriteMeshesChange, this);
      }
    }
    this._sprite = value;
    if (this._sprite) {
      this._sprite.on("set:meshes", this._onSpriteMeshesChange, this);
      this._sprite.on("set:pixelsPerUnit", this._onSpritePpuChanged, this);
      this._sprite.on("set:atlas", this._onSpriteMeshesChange, this);
      if (this._sprite.atlas) {
        this._sprite.atlas.on("set:texture", this._onSpriteMeshesChange, this);
      }
    }
    if (this._component.currentClip === this) {
      var mi;
      if (!value || !value.atlas) {
        mi = this._component._meshInstance;
        if (mi) {
          mi.deleteParameter("texture_emissiveMap");
          mi.deleteParameter("texture_opacityMap");
        }
        this._component._hideModel();
      } else {
        if (value.atlas.texture) {
          mi = this._component._meshInstance;
          if (mi) {
            mi.setParameter("texture_emissiveMap", value.atlas.texture);
            mi.setParameter("texture_opacityMap", value.atlas.texture);
          }
          if (this._component.enabled && this._component.entity.enabled) {
            this._component._showModel();
          }
        }
        if (this.time && this.fps) {
          this.time = this.time;
        } else {
          this.frame = this.frame;
        }
      }
    }
  }});
  Object.defineProperty(SpriteAnimationClip.prototype, "frame", {get:function() {
    return this._frame;
  }, set:function(value) {
    this._setFrame(value);
    var fps = this.fps || Number.MIN_VALUE;
    this._setTime(this._frame / fps);
  }});
  Object.defineProperty(SpriteAnimationClip.prototype, "isPlaying", {get:function() {
    return this._playing;
  }});
  Object.defineProperty(SpriteAnimationClip.prototype, "isPaused", {get:function() {
    return this._paused;
  }});
  Object.defineProperty(SpriteAnimationClip.prototype, "duration", {get:function() {
    if (this._sprite) {
      var fps = this.fps || Number.MIN_VALUE;
      return this._sprite.frameKeys.length / Math.abs(fps);
    }
    return 0;
  }});
  Object.defineProperty(SpriteAnimationClip.prototype, "time", {get:function() {
    return this._time;
  }, set:function(value) {
    this._setTime(value);
    if (this._sprite) {
      this.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps)));
    } else {
      this.frame = 0;
    }
  }});
  return {SpriteAnimationClip:SpriteAnimationClip};
}());
Object.assign(pc, function() {
  pc.SPRITETYPE_SIMPLE = "simple";
  pc.SPRITETYPE_ANIMATED = "animated";
  var PARAM_EMISSIVE_MAP = "texture_emissiveMap";
  var PARAM_OPACITY_MAP = "texture_opacityMap";
  var PARAM_EMISSIVE = "material_emissive";
  var PARAM_OPACITY = "material_opacity";
  var PARAM_INNER_OFFSET = "innerOffset";
  var PARAM_OUTER_SCALE = "outerScale";
  var PARAM_ATLAS_RECT = "atlasRect";
  var SpriteComponent = function SpriteComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this._type = pc.SPRITETYPE_SIMPLE;
    this._material = system.defaultMaterial;
    this._color = new pc.Color(1, 1, 1, 1);
    this._speed = 1;
    this._flipX = false;
    this._flipY = false;
    this._width = 1;
    this._height = 1;
    this._drawOrder = 0;
    this._layers = [pc.LAYERID_WORLD];
    this._outerScale = new pc.Vec2(1, 1);
    this._innerOffset = new pc.Vec4;
    this._atlasRect = new pc.Vec4;
    this._batchGroupId = -1;
    this._batchGroup = null;
    this._node = new pc.GraphNode;
    this._model = new pc.Model;
    this._model.graph = this._node;
    this._meshInstance = null;
    entity.addChild(this._model.graph);
    this._model._entity = entity;
    this._updateAabbFunc = this._updateAabb.bind(this);
    this._addedModel = false;
    this._autoPlayClip = null;
    this._clips = {};
    this._defaultClip = new pc.SpriteAnimationClip(this, {name:this.entity.name, fps:0, loop:false, spriteAsset:null});
    this._currentClip = this._defaultClip;
  };
  SpriteComponent.prototype = Object.create(pc.Component.prototype);
  SpriteComponent.prototype.constructor = SpriteComponent;
  Object.assign(SpriteComponent.prototype, {onEnable:function() {
    pc.Component.prototype.onEnable.call(this);
    this.system.app.scene.on("set:layers", this._onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.on("add", this._onLayerAdded, this);
      this.system.app.scene.layers.on("remove", this._onLayerRemoved, this);
    }
    this._showModel();
    if (this._autoPlayClip) {
      this._tryAutoPlay();
    }
  }, onDisable:function() {
    pc.Component.prototype.onDisable.call(this);
    this.system.app.scene.off("set:layers", this._onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.off("add", this._onLayerAdded, this);
      this.system.app.scene.layers.off("remove", this._onLayerRemoved, this);
    }
    this.stop();
    this._hideModel();
    if (this._batchGroupId >= 0) {
      this.system.app.batcher.markGroupDirty(this.batchGroupId);
    }
  }, onDestroy:function() {
    this._currentClip = null;
    if (this._defaultClip) {
      this._defaultClip._destroy();
      this._defaultClip = null;
    }
    for (var key in this._clips) {
      this._clips[key]._destroy();
    }
    this._clips = null;
    this._hideModel();
    this._model = null;
    if (this._node) {
      if (this._node.parent) {
        this._node.parent.removeChild(this._node);
      }
      this._node = null;
    }
    if (this._meshInstance) {
      this._meshInstance.material = null;
      this._meshInstance.mesh = null;
      this._meshInstance = null;
    }
  }, _showModel:function() {
    if (this._addedModel) {
      return;
    }
    if (!this._meshInstance) {
      return;
    }
    var i;
    var len;
    var meshInstances = [this._meshInstance];
    for (i = 0, len = this._layers.length;i < len;i++) {
      var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
      if (layer) {
        layer.addMeshInstances(meshInstances);
      }
    }
    this._addedModel = true;
  }, _hideModel:function() {
    if (!this._addedModel || !this._meshInstance) {
      return;
    }
    var i;
    var len;
    var meshInstances = [this._meshInstance];
    for (i = 0, len = this._layers.length;i < len;i++) {
      var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
      if (layer) {
        layer.removeMeshInstances(meshInstances);
      }
    }
    this._addedModel = false;
  }, _showFrame:function(frame) {
    if (!this.sprite) {
      return;
    }
    var mesh = this.sprite.meshes[frame];
    if (!mesh) {
      if (this._meshInstance) {
        this._meshInstance.mesh = null;
        this._meshInstance.visible = false;
      }
      return;
    }
    var material = this.system.defaultMaterial;
    if (this.sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED) {
      material = this.system.default9SlicedMaterialSlicedMode;
    } else {
      if (this.sprite.renderMode === pc.SPRITE_RENDERMODE_TILED) {
        material = this.system.default9SlicedMaterialTiledMode;
      }
    }
    if (!this._meshInstance) {
      this._meshInstance = new pc.MeshInstance(this._node, mesh, this._material);
      this._meshInstance.castShadow = false;
      this._meshInstance.receiveShadow = false;
      this._meshInstance.drawOrder = this._drawOrder;
      this._model.meshInstances.push(this._meshInstance);
      this._meshInstance.setParameter(PARAM_EMISSIVE, this._color.data3);
      this._meshInstance.setParameter(PARAM_OPACITY, this._color.data[3]);
      if (this.enabled && this.entity.enabled) {
        this._showModel();
      }
    }
    if (this._meshInstance.material !== material) {
      this._meshInstance.material = material;
    }
    if (this._meshInstance.mesh !== mesh) {
      this._meshInstance.mesh = mesh;
      this._meshInstance.visible = true;
      this._meshInstance._aabbVer = -1;
    }
    if (this.sprite.atlas && this.sprite.atlas.texture) {
      this._meshInstance.setParameter(PARAM_EMISSIVE_MAP, this.sprite.atlas.texture);
      this._meshInstance.setParameter(PARAM_OPACITY_MAP, this.sprite.atlas.texture);
    } else {
      this._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);
      this._meshInstance.deleteParameter(PARAM_OPACITY_MAP);
    }
    if (this.sprite.atlas && (this.sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === pc.SPRITE_RENDERMODE_TILED)) {
      this._meshInstance._updateAabbFunc = this._updateAabbFunc;
      var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[frame]];
      if (frameData) {
        var borderWidthScale = 2 / frameData.rect.z;
        var borderHeightScale = 2 / frameData.rect.w;
        this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);
        var tex = this.sprite.atlas.texture;
        this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);
      } else {
        this._innerOffset.set(0, 0, 0, 0);
      }
      this._meshInstance.setParameter(PARAM_INNER_OFFSET, this._innerOffset.data);
      this._meshInstance.setParameter(PARAM_ATLAS_RECT, this._atlasRect.data);
    } else {
      this._meshInstance._updateAabbFunc = null;
    }
    this._updateTransform();
  }, _updateTransform:function() {
    var scaleX = this.flipX ? -1 : 1;
    var scaleY = this.flipY ? -1 : 1;
    var posX = 0;
    var posY = 0;
    if (this.sprite && (this.sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === pc.SPRITE_RENDERMODE_TILED)) {
      var w = 1;
      var h = 1;
      if (this.sprite.atlas) {
        var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];
        if (frameData) {
          w = frameData.rect.z;
          h = frameData.rect.w;
          posX = (0.5 - frameData.pivot.x) * this._width;
          posY = (0.5 - frameData.pivot.y) * this._height;
        }
      }
      var scaleMulX = w / this.sprite.pixelsPerUnit;
      var scaleMulY = h / this.sprite.pixelsPerUnit;
      this._outerScale.set(Math.max(this._width, this._innerOffset.x * scaleMulX), Math.max(this._height, this._innerOffset.y * scaleMulY));
      scaleX *= scaleMulX;
      scaleY *= scaleMulY;
      this._outerScale.x /= scaleMulX;
      this._outerScale.y /= scaleMulY;
      scaleX *= pc.math.clamp(this._width / (this._innerOffset.x * scaleMulX), 0.0001, 1);
      scaleY *= pc.math.clamp(this._height / (this._innerOffset.y * scaleMulY), 0.0001, 1);
      if (this._meshInstance) {
        this._meshInstance.setParameter(PARAM_OUTER_SCALE, this._outerScale.data, 4294967295);
      }
    }
    this._node.setLocalScale(scaleX, scaleY, 1);
    this._node.setLocalPosition(posX, posY, 0);
  }, _updateAabb:function(aabb) {
    aabb.center.set(0, 0, 0);
    aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
    aabb.setFromTransformedAabb(aabb, this._node.getWorldTransform());
    return aabb;
  }, _tryAutoPlay:function() {
    if (!this._autoPlayClip) {
      return;
    }
    if (this.type !== pc.SPRITETYPE_ANIMATED) {
      return;
    }
    var clip = this._clips[this._autoPlayClip];
    if (clip && !clip.isPlaying && (!this._currentClip || !this._currentClip.isPlaying)) {
      if (this.enabled && this.entity.enabled) {
        this.play(clip.name);
      }
    }
  }, _onLayersChanged:function(oldComp, newComp) {
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
    if (this.enabled && this.entity.enabled) {
      this._showModel();
    }
  }, _onLayerAdded:function(layer) {
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    if (this._addedModel && this.enabled && this.entity.enabled && this._meshInstance) {
      layer.addMeshInstances([this._meshInstance]);
    }
  }, _onLayerRemoved:function(layer) {
    if (!this._meshInstance) {
      return;
    }
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    layer.removeMeshInstances([this._meshInstance]);
  }, addClip:function(data) {
    var clip = new pc.SpriteAnimationClip(this, {name:data.name, fps:data.fps, loop:data.loop, spriteAsset:data.spriteAsset});
    this._clips[data.name] = clip;
    if (clip.name && clip.name === this._autoPlayClip) {
      this._tryAutoPlay();
    }
    return clip;
  }, removeClip:function(name) {
    delete this._clips[name];
  }, clip:function(name) {
    return this._clips[name];
  }, play:function(name) {
    var clip = this._clips[name];
    var current = this._currentClip;
    if (current && current !== clip) {
      current._playing = false;
    }
    this._currentClip = clip;
    if (this._currentClip) {
      this._currentClip = clip;
      this._currentClip.play();
    } else {
      logWARNING("Trying to play sprite animation " + name + " which does not exist.");
    }
    return clip;
  }, pause:function() {
    if (this._currentClip === this._defaultClip) {
      return;
    }
    if (this._currentClip.isPlaying) {
      this._currentClip.pause();
    }
  }, resume:function() {
    if (this._currentClip === this._defaultClip) {
      return;
    }
    if (this._currentClip.isPaused) {
      this._currentClip.resume();
    }
  }, stop:function() {
    if (this._currentClip === this._defaultClip) {
      return;
    }
    this._currentClip.stop();
  }});
  Object.defineProperty(SpriteComponent.prototype, "type", {get:function() {
    return this._type;
  }, set:function(value) {
    if (this._type === value) {
      return;
    }
    this._type = value;
    if (this._type === pc.SPRITETYPE_SIMPLE) {
      this.stop();
      this._currentClip = this._defaultClip;
      if (this.enabled && this.entity.enabled) {
        this._currentClip.frame = this.frame;
        if (this._currentClip.sprite) {
          this._showModel();
        } else {
          this._hideModel();
        }
      }
    } else {
      if (this._type === pc.SPRITETYPE_ANIMATED) {
        this.stop();
        if (this._autoPlayClip) {
          this._tryAutoPlay();
        }
        if (this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled) {
          this._showModel();
        } else {
          this._hideModel();
        }
      }
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "frame", {get:function() {
    return this._currentClip.frame;
  }, set:function(value) {
    this._currentClip.frame = value;
  }});
  Object.defineProperty(SpriteComponent.prototype, "spriteAsset", {get:function() {
    return this._defaultClip._spriteAsset;
  }, set:function(value) {
    this._defaultClip.spriteAsset = value;
  }});
  Object.defineProperty(SpriteComponent.prototype, "sprite", {get:function() {
    return this._currentClip.sprite;
  }, set:function(value) {
    this._currentClip.sprite = value;
  }});
  Object.defineProperty(SpriteComponent.prototype, "material", {get:function() {
    return this._material;
  }, set:function(value) {
    this._material = value;
    if (this._meshInstance) {
      this._meshInstance.material = value;
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "color", {get:function() {
    return this._color;
  }, set:function(value) {
    this._color.data[0] = value.data[0];
    this._color.data[1] = value.data[1];
    this._color.data[2] = value.data[2];
    if (this._meshInstance) {
      this._meshInstance.setParameter(PARAM_EMISSIVE, this._color.data3);
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "opacity", {get:function() {
    return this._color.data[3];
  }, set:function(value) {
    this._color.data[3] = value;
    if (this._meshInstance) {
      this._meshInstance.setParameter(PARAM_OPACITY, value);
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "clips", {get:function() {
    return this._clips;
  }, set:function(value) {
    var name, key;
    if (!value) {
      for (name in this._clips) {
        this.removeClip(name);
      }
      return;
    }
    for (name in this._clips) {
      var found = false;
      for (key in value) {
        if (value[key].name === name) {
          found = true;
          this._clips[name].fps = value[key].fps;
          this._clips[name].loop = value[key].loop;
          if (value[key].hasOwnProperty("sprite")) {
            this._clips[name].sprite = value[key].sprite;
          } else {
            if (value[key].hasOwnProperty("spriteAsset")) {
              this._clips[name].spriteAsset = value[key].spriteAsset;
            }
          }
          break;
        }
      }
      if (!found) {
        this.removeClip(name);
      }
    }
    for (key in value) {
      if (this._clips[value[key].name]) {
        continue;
      }
      this.addClip(value[key]);
    }
    if (this._autoPlayClip) {
      this._tryAutoPlay();
    }
    if (!this._currentClip || !this._currentClip.sprite) {
      this._hideModel();
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "currentClip", {get:function() {
    return this._currentClip;
  }});
  Object.defineProperty(SpriteComponent.prototype, "speed", {get:function() {
    return this._speed;
  }, set:function(value) {
    this._speed = value;
  }});
  Object.defineProperty(SpriteComponent.prototype, "flipX", {get:function() {
    return this._flipX;
  }, set:function(value) {
    if (this._flipX === value) {
      return;
    }
    this._flipX = value;
    this._updateTransform();
  }});
  Object.defineProperty(SpriteComponent.prototype, "flipY", {get:function() {
    return this._flipY;
  }, set:function(value) {
    if (this._flipY === value) {
      return;
    }
    this._flipY = value;
    this._updateTransform();
  }});
  Object.defineProperty(SpriteComponent.prototype, "width", {get:function() {
    return this._width;
  }, set:function(value) {
    if (value === this._width) {
      return;
    }
    this._width = value;
    this._outerScale.x = this._width;
    if (this.sprite && (this.sprite.renderMode === pc.SPRITE_RENDERMODE_TILED || this.sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED)) {
      this._updateTransform();
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "height", {get:function() {
    return this._height;
  }, set:function(value) {
    if (value === this._height) {
      return;
    }
    this._height = value;
    this._outerScale.y = this.height;
    if (this.sprite && (this.sprite.renderMode === pc.SPRITE_RENDERMODE_TILED || this.sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED)) {
      this._updateTransform();
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "batchGroupId", {get:function() {
    return this._batchGroupId;
  }, set:function(value) {
    if (this._batchGroupId === value) {
      return;
    }
    var prev = this._batchGroupId;
    this._batchGroupId = value;
    if (prev >= 0) {
      this.system.app.batcher.markGroupDirty(prev);
    }
    if (this._batchGroupId >= 0) {
      this.system.app.batcher.markGroupDirty(this._batchGroupId);
    } else {
      if (prev >= 0) {
        if (this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled) {
          this._showModel();
        }
      }
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "autoPlayClip", {get:function() {
    return this._autoPlayClip;
  }, set:function(value) {
    this._autoPlayClip = value instanceof pc.SpriteAnimationClip ? value.name : value;
    this._tryAutoPlay();
  }});
  Object.defineProperty(SpriteComponent.prototype, "drawOrder", {get:function() {
    return this._drawOrder;
  }, set:function(value) {
    this._drawOrder = value;
    if (this._meshInstance) {
      this._meshInstance.drawOrder = value;
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "layers", {get:function() {
    return this._layers;
  }, set:function(value) {
    if (this._addedModel) {
      this._hideModel();
    }
    this._layers = value;
    if (!this._meshInstance) {
      return;
    }
    if (this.enabled && this.entity.enabled) {
      this._showModel();
    }
  }});
  return {SpriteComponent:SpriteComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled"];
  var warningShown = false;
  var nineSliceBasePS = ["varying vec2 vMask;", "varying vec2 vTiledUv;", "uniform vec4 innerOffset;", "uniform vec2 outerScale;", "uniform vec4 atlasRect;", "vec2 nineSlicedUv;"].join("\n");
  var nineSliceUvPs = ["vec2 tileMask = step(vMask, vec2(0.99999));", "vec2 clampedUv = mix(innerOffset.xy*0.5, vec2(1.0) - innerOffset.zw*0.5, fract(vTiledUv));", "clampedUv = clampedUv * atlasRect.zw + atlasRect.xy;", "nineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);"].join("\n");
  var SpriteComponentSystem = function SpriteComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "sprite";
    this.app = app;
    app.systems.add(this.id, this);
    this.ComponentType = pc.SpriteComponent;
    this.DataType = pc.SpriteComponentData;
    this.schema = _schema;
    this._defaultTexture = new pc.Texture(app.graphicsDevice, {width:1, height:1, format:pc.PIXELFORMAT_R8_G8_B8_A8});
    var pixels = this._defaultTexture.lock();
    var pixelData = new Uint8Array(4);
    pixelData[0] = 255.0;
    pixelData[1] = 255.0;
    pixelData[2] = 255.0;
    pixelData[3] = 255.0;
    pixels.set(pixelData);
    this._defaultTexture.unlock();
    this.defaultMaterial = new pc.StandardMaterial;
    this.defaultMaterial.diffuse = new pc.Color(0, 0, 0, 1);
    this.defaultMaterial.emissive = new pc.Color(0.5, 0.5, 0.5, 1);
    this.defaultMaterial.emissiveMap = this._defaultTexture;
    this.defaultMaterial.emissiveMapTint = true;
    this.defaultMaterial.opacityMap = this._defaultTexture;
    this.defaultMaterial.opacityMapChannel = "a";
    this.defaultMaterial.opacityTint = true;
    this.defaultMaterial.opacity = 0;
    this.defaultMaterial.useLighting = false;
    this.defaultMaterial.useGammaTonemap = false;
    this.defaultMaterial.useFog = false;
    this.defaultMaterial.useSkybox = false;
    this.defaultMaterial.blendType = pc.BLEND_PREMULTIPLIED;
    this.defaultMaterial.depthWrite = false;
    this.defaultMaterial.pixelSnap = false;
    this.defaultMaterial.cull = pc.CULLFACE_NONE;
    this.defaultMaterial.update();
    this.default9SlicedMaterialSlicedMode = this.defaultMaterial.clone();
    this.default9SlicedMaterialSlicedMode.chunks.basePS = pc.shaderChunks.basePS + nineSliceBasePS;
    this.default9SlicedMaterialSlicedMode.chunks.startPS = pc.shaderChunks.startPS + "nineSlicedUv = vUv0;\n";
    this.default9SlicedMaterialSlicedMode.chunks.emissivePS = pc.shaderChunks.emissivePS.replace("$UV", "nineSlicedUv");
    this.default9SlicedMaterialSlicedMode.chunks.opacityPS = pc.shaderChunks.opacityPS.replace("$UV", "nineSlicedUv");
    this.default9SlicedMaterialSlicedMode.chunks.transformVS = "#define NINESLICED\n" + pc.shaderChunks.transformVS;
    this.default9SlicedMaterialSlicedMode.chunks.uv0VS = pc.shaderChunks.uv9SliceVS;
    this.default9SlicedMaterialSlicedMode.update();
    this.default9SlicedMaterialTiledMode = this.defaultMaterial.clone();
    this.default9SlicedMaterialTiledMode.chunks.basePS = pc.shaderChunks.basePS + "#define NINESLICETILED\n" + nineSliceBasePS;
    this.default9SlicedMaterialTiledMode.chunks.startPS = pc.shaderChunks.startPS + nineSliceUvPs;
    this.default9SlicedMaterialTiledMode.chunks.emissivePS = pc.shaderChunks.emissivePS.replace("$UV", "nineSlicedUv, -1000.0");
    this.default9SlicedMaterialTiledMode.chunks.opacityPS = pc.shaderChunks.opacityPS.replace("$UV", "nineSlicedUv, -1000.0");
    this.default9SlicedMaterialTiledMode.chunks.transformVS = "#define NINESLICED\n" + pc.shaderChunks.transformVS;
    this.default9SlicedMaterialTiledMode.chunks.uv0VS = pc.shaderChunks.uv9SliceVS;
    this.default9SlicedMaterialTiledMode.update();
    pc.ComponentSystem.on("update", this.onUpdate, this);
    this.on("beforeremove", this.onBeforeRemove, this);
  };
  SpriteComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  SpriteComponentSystem.prototype.constructor = SpriteComponentSystem;
  pc.Component._buildAccessors(pc.SpriteComponent.prototype, _schema);
  Object.assign(SpriteComponentSystem.prototype, {initializeComponentData:function(component, data, properties) {
    if (data.enabled !== undefined) {
      component.enabled = data.enabled;
    }
    component.type = data.type;
    if (data.layers && pc.type(data.layers) === "array") {
      component.layers = data.layers.slice(0);
    }
    if (data.drawOrder !== undefined) {
      component.drawOrder = data.drawOrder;
    }
    if (data.color !== undefined) {
      if (data.color instanceof pc.Color) {
        component.color.set(data.color.data[0], data.color.data[1], data.color.data[2], data.opacity !== undefined ? data.opacity : 1);
      } else {
        component.color.set(data.color[0], data.color[1], data.color[2], data.opacity !== undefined ? data.opacity : 1);
      }
      component.color = component.color;
    }
    if (data.opacity !== undefined) {
      component.opacity = data.opacity;
    }
    if (data.flipX !== undefined) {
      component.flipX = data.flipX;
    }
    if (data.flipY !== undefined) {
      component.flipY = data.flipY;
    }
    if (data.width !== undefined) {
      component.width = data.width;
    }
    if (data.height !== undefined) {
      component.height = data.height;
    }
    if (data.spriteAsset !== undefined) {
      component.spriteAsset = data.spriteAsset;
    }
    if (data.sprite) {
      component.sprite = data.sprite;
    }
    if (data.frame !== undefined) {
      component.frame = data.frame;
    }
    if (data.clips) {
      for (var name in data.clips) {
        component.addClip(data.clips[name]);
      }
    }
    if (data.speed !== undefined) {
      component.speed = data.speed;
    }
    if (data.autoPlayClip) {
      component.autoPlayClip = data.autoPlayClip;
    }
    component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
    if (!warningShown) {
      console.warn("The Sprite component is in beta and might change without notice.");
      warningShown = true;
    }
  }, cloneComponent:function(entity, clone) {
    var source = entity.sprite;
    return this.addComponent(clone, {enabled:source.enabled, type:source.type, spriteAsset:source.spriteAsset, sprite:source.sprite, frame:source.frame, color:source.color.clone(), opacity:source.opacity, flipX:source.flipX, flipY:source.flipY, speed:source.speed, clips:source.clips, batchGroupId:source.batchGroupId});
  }, onUpdate:function(dt) {
    var components = this.store;
    for (var id in components) {
      if (components.hasOwnProperty(id)) {
        var component = components[id];
        if (component.data.enabled && component.entity.enabled) {
          var sprite = component.entity.sprite;
          if (sprite._currentClip) {
            sprite._currentClip._update(dt);
          }
        }
      }
    }
  }, onBeforeRemove:function(entity, component) {
    component.onDestroy();
  }});
  return {SpriteComponentSystem:SpriteComponentSystem};
}());
Object.assign(pc, function() {
  var SpriteComponentData = function() {
    this.enabled = true;
  };
  return {SpriteComponentData:SpriteComponentData};
}());
Object.assign(pc, function() {
  pc.SCALEMODE_NONE = "none";
  pc.SCALEMODE_BLEND = "blend";
  var ScreenComponent = function ScreenComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this._resolution = new pc.Vec2(640, 320);
    this._referenceResolution = new pc.Vec2(640, 320);
    this._scaleMode = pc.SCALEMODE_NONE;
    this.scale = 1;
    this._scaleBlend = 0.5;
    this._screenSpace = false;
    this._screenMatrix = new pc.Mat4;
    system.app.graphicsDevice.on("resizecanvas", this._onResize, this);
  };
  ScreenComponent.prototype = Object.create(pc.Component.prototype);
  ScreenComponent.prototype.constructor = ScreenComponent;
  var _transform = new pc.Mat4;
  Object.assign(ScreenComponent.prototype, {syncDrawOrder:function() {
    var i = 1;
    var recurse = function(e) {
      if (e.element) {
        e.element.drawOrder = i++;
      }
      var children = e.getChildren();
      for (var j = 0;j < children.length;j++) {
        recurse(children[j]);
      }
    };
    recurse(this.entity);
  }, _calcProjectionMatrix:function() {
    var left;
    var right;
    var bottom;
    var top;
    var near = 1;
    var far = -1;
    var w = this._resolution.x / this.scale;
    var h = this._resolution.y / this.scale;
    left = 0;
    right = w;
    bottom = -h;
    top = 0;
    this._screenMatrix.setOrtho(left, right, bottom, top, near, far);
    if (!this._screenSpace) {
      _transform.setScale(0.5 * w, 0.5 * h, 1);
      this._screenMatrix.mul2(_transform, this._screenMatrix);
    }
  }, _updateScale:function() {
    this.scale = this._calcScale(this._resolution, this.referenceResolution);
  }, _calcScale:function(resolution, referenceResolution) {
    var lx = Math.log2(resolution.x / referenceResolution.x);
    var ly = Math.log2(resolution.y / referenceResolution.y);
    return Math.pow(2, lx * (1 - this._scaleBlend) + ly * this._scaleBlend);
  }, _onResize:function(width, height) {
    if (this._screenSpace) {
      this._resolution.set(width, height);
      this.resolution = this._resolution;
    }
  }, onRemove:function() {
    this.system.app.graphicsDevice.off("resizecanvas", this._onResize, this);
    this.fire("remove");
  }});
  Object.defineProperty(ScreenComponent.prototype, "resolution", {set:function(value) {
    if (!this._screenSpace) {
      this._resolution.set(value.x, value.y);
    } else {
      this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
    }
    this._updateScale();
    this._calcProjectionMatrix();
    if (!this.entity._dirtyLocal) {
      this.entity._dirtify(true);
    }
    this.fire("set:resolution", this._resolution);
  }, get:function() {
    return this._resolution;
  }});
  Object.defineProperty(ScreenComponent.prototype, "referenceResolution", {set:function(value) {
    this._referenceResolution.set(value.x, value.y);
    this._updateScale();
    this._calcProjectionMatrix();
    if (!this.entity._dirtyLocal) {
      this.entity._dirtify(true);
    }
    this.fire("set:referenceresolution", this._resolution);
  }, get:function() {
    if (this._scaleMode === pc.SCALEMODE_NONE) {
      return this._resolution;
    }
    return this._referenceResolution;
  }});
  Object.defineProperty(ScreenComponent.prototype, "screenSpace", {set:function(value) {
    this._screenSpace = value;
    if (this._screenSpace) {
      this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
    }
    this.resolution = this._resolution;
    if (!this.entity._dirtyLocal) {
      this.entity._dirtify(true);
    }
    this.fire("set:screenspace", this._screenSpace);
  }, get:function() {
    return this._screenSpace;
  }});
  Object.defineProperty(ScreenComponent.prototype, "scaleMode", {set:function(value) {
    if (value !== pc.SCALEMODE_NONE && value !== pc.SCALEMODE_BLEND) {
      value = pc.SCALEMODE_NONE;
    }
    if (!this._screenSpace && value !== pc.SCALEMODE_NONE) {
      value = pc.SCALEMODE_NONE;
    }
    this._scaleMode = value;
    this.resolution = this._resolution;
    this.fire("set:scalemode", this._scaleMode);
  }, get:function() {
    return this._scaleMode;
  }});
  Object.defineProperty(ScreenComponent.prototype, "scaleBlend", {set:function(value) {
    this._scaleBlend = value;
    this._updateScale();
    this._calcProjectionMatrix();
    if (!this.entity._dirtyLocal) {
      this.entity._dirtify(true);
    }
    this.fire("set:scaleblend", this._scaleBlend);
  }, get:function() {
    return this._scaleBlend;
  }});
  return {ScreenComponent:ScreenComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled"];
  var ScreenComponentSystem = function ScreenComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "screen";
    this.app = app;
    app.systems.add(this.id, this);
    this.ComponentType = pc.ScreenComponent;
    this.DataType = pc.ScreenComponentData;
    this.schema = _schema;
    this.windowResolution = new pc.Vec2;
    this.app.graphicsDevice.on("resizecanvas", this._onResize, this);
    pc.ComponentSystem.on("update", this._onUpdate, this);
    this.on("beforeremove", this.onRemoveComponent, this);
  };
  ScreenComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  ScreenComponentSystem.prototype.constructor = ScreenComponentSystem;
  pc.Component._buildAccessors(pc.ScreenComponent.prototype, _schema);
  Object.assign(ScreenComponentSystem.prototype, {initializeComponentData:function(component, data, properties) {
    if (data.screenSpace !== undefined) {
      component.screenSpace = data.screenSpace;
    }
    if (data.scaleMode !== undefined) {
      component.scaleMode = data.scaleMode;
    }
    if (data.scaleBlend !== undefined) {
      component.scaleBlend = data.scaleBlend;
    }
    if (data.resolution !== undefined) {
      if (data.resolution instanceof pc.Vec2) {
        component._resolution.copy(data.resolution);
      } else {
        component._resolution.set(data.resolution[0], data.resolution[1]);
      }
      component.resolution = component._resolution;
    }
    if (data.referenceResolution !== undefined) {
      if (data.referenceResolution instanceof pc.Vec2) {
        component._referenceResolution.copy(data.referenceResolution);
      } else {
        component._referenceResolution.set(data.referenceResolution[0], data.referenceResolution[1]);
      }
      component.referenceResolution = component._referenceResolution;
    }
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
  }, _onUpdate:function(dt) {
    var components = this.store;
    for (var id in components) {
      if (components[id].entity.screen.update) {
        components[id].entity.screen.update(dt);
      }
    }
  }, _onResize:function(width, height) {
    this.windowResolution.x = width;
    this.windowResolution.y = height;
  }, cloneComponent:function(entity, clone) {
    var screen = entity.screen;
    return this.addComponent(clone, {enabled:screen.enabled, screenSpace:screen.screenSpace, scaleMode:screen.scaleMode, resolution:screen.resolution.clone(), referenceResolution:screen.referenceResolution.clone()});
  }, onRemoveComponent:function(entity, component) {
    component.onRemove();
  }});
  return {ScreenComponentSystem:ScreenComponentSystem};
}());
Object.assign(pc, function() {
  var ScreenComponentData = function() {
    this.enabled = true;
  };
  return {ScreenComponentData:ScreenComponentData};
}());
Object.assign(pc, function() {
  var topMasks = [];
  var _debugLogging = false;
  pc.ELEMENTTYPE_GROUP = "group";
  pc.ELEMENTTYPE_IMAGE = "image";
  pc.ELEMENTTYPE_TEXT = "text";
  var vecA = new pc.Vec3;
  var vecB = new pc.Vec3;
  var matA = new pc.Mat4;
  var matB = new pc.Mat4;
  var matC = new pc.Mat4;
  var matD = new pc.Mat4;
  var ElementComponent = function ElementComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this._anchor = new pc.Vec4;
    this._localAnchor = new pc.Vec4;
    this._pivot = new pc.Vec2;
    this._width = this._calculatedWidth = 32;
    this._height = this._calculatedHeight = 32;
    this._margin = new pc.Vec4(0, 0, -32, -32);
    this._modelTransform = new pc.Mat4;
    this._screenToWorld = new pc.Mat4;
    this._anchorTransform = new pc.Mat4;
    this._anchorDirty = true;
    this._parentWorldTransform = new pc.Mat4;
    this._screenTransform = new pc.Mat4;
    this._screenCorners = [new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3];
    this._canvasCorners = [new pc.Vec2, new pc.Vec2, new pc.Vec2, new pc.Vec2];
    this._worldCorners = [new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3];
    this._cornersDirty = true;
    this._canvasCornersDirty = true;
    this._worldCornersDirty = true;
    this.entity.on("insert", this._onInsert, this);
    this._patch();
    this.screen = null;
    this._type = pc.ELEMENTTYPE_GROUP;
    this._image = null;
    this._text = null;
    this._group = null;
    this._useInput = false;
    this._layers = [pc.LAYERID_UI];
    this._addedModel = null;
    this._batchGroupId = -1;
  };
  ElementComponent.prototype = Object.create(pc.Component.prototype);
  ElementComponent.prototype.constructor = ElementComponent;
  Object.assign(ElementComponent.prototype, {_patch:function() {
    this.entity._sync = this._sync;
    this.entity.setPosition = this._setPosition;
    this.entity.setLocalPosition = this._setLocalPosition;
  }, _unpatch:function() {
    this.entity._sync = pc.Entity.prototype._sync;
    this.entity.setPosition = pc.Entity.prototype.setPosition;
    this.entity.setLocalPosition = pc.Entity.prototype.setLocalPosition;
  }, _setPosition:function() {
    var position = new pc.Vec3;
    var invParentWtm = new pc.Mat4;
    return function(x, y, z) {
      if (!this.element.screen) {
        return pc.Entity.prototype.setPosition.call(this, x, y, z);
      }
      if (x instanceof pc.Vec3) {
        position.copy(x);
      } else {
        position.set(x, y, z);
      }
      this.getWorldTransform();
      invParentWtm.copy(this.element._screenToWorld).invert();
      invParentWtm.transformPoint(position, this.localPosition);
      if (!this._dirtyLocal) {
        this._dirtify(true);
      }
    };
  }(), _setLocalPosition:function(x, y, z) {
    if (x instanceof pc.Vec3) {
      this.localPosition.copy(x);
    } else {
      this.localPosition.set(x, y, z);
    }
    var element = this.element;
    var p = this.localPosition.data;
    var pvt = element._pivot.data;
    element._margin.data[0] = p[0] - element._calculatedWidth * pvt[0];
    element._margin.data[2] = element._localAnchor.data[2] - element._localAnchor.data[0] - element._calculatedWidth - element._margin.data[0];
    element._margin.data[1] = p[1] - element._calculatedHeight * pvt[1];
    element._margin.data[3] = element._localAnchor.data[3] - element._localAnchor.data[1] - element._calculatedHeight - element._margin.data[1];
    if (!this._dirtyLocal) {
      this._dirtify(true);
    }
  }, _sync:function() {
    var element = this.element;
    var screen = element.screen;
    if (screen) {
      if (element._anchorDirty) {
        var resx = 0;
        var resy = 0;
        var px = 0;
        var py = 1;
        if (this._parent && this._parent.element) {
          resx = this._parent.element.calculatedWidth;
          resy = this._parent.element.calculatedHeight;
          px = this._parent.element.pivot.x;
          py = this._parent.element.pivot.y;
        } else {
          var resolution = screen.screen.resolution;
          resx = resolution.x / screen.screen.scale;
          resy = resolution.y / screen.screen.scale;
        }
        element._anchorTransform.setTranslate(resx * (element.anchor.x - px), -(resy * (py - element.anchor.y)), 0);
        element._anchorDirty = false;
        element._calculateLocalAnchors();
      }
      if (element._sizeDirty) {
        element._calculateSize();
      }
    }
    if (this._dirtyLocal) {
      this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
      var p = this.localPosition.data;
      var pvt = element._pivot.data;
      element._margin.data[0] = p[0] - element._calculatedWidth * pvt[0];
      element._margin.data[2] = element._localAnchor.data[2] - element._localAnchor.data[0] - element._calculatedWidth - element._margin.data[0];
      element._margin.data[1] = p[1] - element._calculatedHeight * pvt[1];
      element._margin.data[3] = element._localAnchor.data[3] - element._localAnchor.data[1] - element._calculatedHeight - element._margin.data[1];
      this._dirtyLocal = false;
    }
    if (!screen) {
      if (this._dirtyWorld) {
        element._cornersDirty = true;
        element._canvasCornersDirty = true;
        element._worldCornersDirty = true;
      }
      return pc.Entity.prototype._sync.call(this);
    }
    if (this._dirtyWorld) {
      if (this._parent === null) {
        this.worldTransform.copy(this.localTransform);
      } else {
        if (this._parent.element) {
          element._screenToWorld.mul2(this._parent.element._modelTransform, element._anchorTransform);
        } else {
          element._screenToWorld.copy(element._anchorTransform);
        }
        element._modelTransform.mul2(element._screenToWorld, this.localTransform);
        if (screen) {
          element._screenToWorld.mul2(screen.screen._screenMatrix, element._screenToWorld);
          if (!screen.screen.screenSpace) {
            element._screenToWorld.mul2(screen.worldTransform, element._screenToWorld);
          }
          this.worldTransform.mul2(element._screenToWorld, this.localTransform);
          var parentWorldTransform = element._parentWorldTransform;
          parentWorldTransform.setIdentity();
          var parent = this._parent;
          if (parent && parent.element && parent !== screen) {
            matA.setTRS(pc.Vec3.ZERO, parent.getLocalRotation(), parent.getLocalScale());
            parentWorldTransform.mul2(parent.element._parentWorldTransform, matA);
          }
          var depthOffset = vecA;
          depthOffset.set(0, 0, this.localPosition.z);
          var pivotOffset = vecB;
          pivotOffset.set(element._absLeft + element._pivot.x * element.calculatedWidth, element._absBottom + element._pivot.y * element.calculatedHeight, 0);
          matA.setTranslate(-pivotOffset.x, -pivotOffset.y, -pivotOffset.z);
          matB.setTRS(depthOffset, this.getLocalRotation(), this.getLocalScale());
          matC.setTranslate(pivotOffset.x, pivotOffset.y, pivotOffset.z);
          element._screenTransform.mul2(element._parentWorldTransform, matC).mul(matB).mul(matA);
          element._cornersDirty = true;
          element._canvasCornersDirty = true;
          element._worldCornersDirty = true;
        } else {
          this.worldTransform.copy(element._modelTransform);
        }
      }
      this._dirtyWorld = false;
    }
  }, _onInsert:function(parent) {
    var result = this._parseUpToScreen();
    this.entity._dirtify();
    this._updateScreen(result.screen);
    this._dirtifyMask();
  }, _dirtifyMask:function() {
    var parent = this.entity;
    while (parent) {
      var next = parent.getParent();
      if ((next === null || next.screen) && parent.element) {
        if (!this.system._prerender || !this.system._prerender.length) {
          this.system._prerender = [];
          this.system.app.once("prerender", this._onPrerender, this);
          if (_debugLogging) {
            console.log("register prerender");
          }
        }
        var i = this.system._prerender.indexOf(this.entity);
        if (i >= 0) {
          this.system._prerender.splice(i, 1);
        }
        var j = this.system._prerender.indexOf(parent);
        if (j < 0) {
          this.system._prerender.push(parent);
        }
        if (_debugLogging) {
          console.log("set prerender root to: " + parent.name);
        }
      }
      parent = next;
    }
  }, _onPrerender:function() {
    var ref = 0;
    for (var i = 0;i < this.system._prerender.length;i++) {
      var mask = this.system._prerender[i];
      if (_debugLogging) {
        console.log("prerender from: " + mask.name);
      }
      if (mask.element) {
        ref = mask.element.syncMask(ref) + 1;
      }
    }
    this.system._prerender.length = 0;
  }, _updateScreen:function(screen) {
    if (this.screen && this.screen !== screen) {
      this.screen.screen.off("set:resolution", this._onScreenResize, this);
      this.screen.screen.off("set:referenceresolution", this._onScreenResize, this);
      this.screen.screen.off("set:scaleblend", this._onScreenResize, this);
      this.screen.screen.off("set:screenspace", this._onScreenSpaceChange, this);
      this.screen.screen.off("remove", this._onScreenRemove, this);
    }
    this.screen = screen;
    if (this.screen) {
      this.screen.screen.on("set:resolution", this._onScreenResize, this);
      this.screen.screen.on("set:referenceresolution", this._onScreenResize, this);
      this.screen.screen.on("set:scaleblend", this._onScreenResize, this);
      this.screen.screen.on("set:screenspace", this._onScreenSpaceChange, this);
      this.screen.screen.on("remove", this._onScreenRemove, this);
    }
    this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
    this.fire("set:screen", this.screen);
    this._anchorDirty = true;
    var children = this.entity.getChildren();
    for (var i = 0, l = children.length;i < l;i++) {
      if (children[i].element) {
        children[i].element._updateScreen(screen);
      }
    }
    if (this.screen) {
      this.screen.screen.syncDrawOrder();
    }
  }, syncMask:function(ref) {
    var result = this._parseUpToScreen();
    return this._updateMask(result.mask, ref);
  }, _setMaskedBy:function(mask) {
    var i, mi, len;
    var elem = this._image || this._text;
    if (!elem) {
      return;
    }
    if (mask) {
      var ref = mask.element._image._maskRef;
      if (_debugLogging) {
        console.log("masking: " + this.entity.name + " with " + ref);
      }
      var sp = new pc.StencilParameters({ref:ref, func:pc.FUNC_EQUAL});
      for (i = 0, len = elem._model.meshInstances.length;i < len;i++) {
        mi = elem._model.meshInstances[i];
        mi.stencilFront = mi.stencilBack = sp;
      }
      elem._maskedBy = mask;
    } else {
      if (_debugLogging) {
        console.log("no masking on: " + this.entity.name);
      }
      for (i = 0, len = elem._model.meshInstances.length;i < len;i++) {
        mi = elem._model.meshInstances[i];
        mi.stencilFront = mi.stencilBack = null;
      }
      elem._maskedBy = null;
    }
  }, _getMaskDepth:function() {
    var depth = 1;
    var parent = this.entity;
    while (parent) {
      parent = parent.getParent();
      if (parent && parent.element && parent.element.mask) {
        depth++;
      }
    }
    return depth;
  }, _updateMask:function(mask, ref) {
    var i, l, sp, children;
    if (!ref) {
      ref = 1;
    }
    if (mask) {
      this._setMaskedBy(mask);
      if (this.mask) {
        if (_debugLogging) {
          console.log("masking: " + this.entity.name + " with " + ref);
        }
        sp = new pc.StencilParameters({ref:ref++, func:pc.FUNC_EQUAL, zpass:pc.STENCILOP_INCREMENT});
        this._image._meshInstance.stencilFront = sp;
        this._image._meshInstance.stencilBack = sp;
        this._image._maskRef = ref;
        if (_debugLogging) {
          console.log("masking from: " + this.entity.name + " with " + ref);
        }
        mask = this.entity;
      }
      children = this.entity.getChildren();
      for (i = 0, l = children.length;i < l;i++) {
        if (children[i].element) {
          children[i].element._updateMask(mask, ref);
        }
      }
    } else {
      this._setMaskedBy(null);
      if (this.mask) {
        sp = new pc.StencilParameters({func:pc.FUNC_ALWAYS, zpass:pc.STENCILOP_REPLACE, ref:ref});
        this._image._meshInstance.stencilFront = sp;
        this._image._meshInstance.stencilBack = sp;
        this._image._maskRef = ref;
        if (_debugLogging) {
          console.log("masking from: " + this.entity.name + " with " + ref);
        }
        mask = this.entity;
      }
      children = this.entity.getChildren();
      for (i = 0, l = children.length;i < l;i++) {
        if (children[i].element) {
          children[i].element._updateMask(mask, ref);
        }
      }
    }
    return ref;
  }, _parseUpToScreen:function() {
    var result = {screen:null, mask:null};
    var parent = this.entity._parent;
    while (parent && !parent.screen) {
      if (parent.element && parent.element.mask) {
        if (!result.mask) {
          result.mask = parent;
        }
      }
      parent = parent.parent;
    }
    if (parent && parent.screen) {
      result.screen = parent;
    }
    return result;
  }, _onScreenResize:function(res) {
    this._anchorDirty = true;
    this._cornersDirty = true;
    this._worldCornersDirty = true;
    this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
    this.fire("screen:set:resolution", res);
  }, _onScreenSpaceChange:function() {
    this.fire("screen:set:screenspace", this.screen.screen.screenSpace);
  }, _onScreenRemove:function() {
    this._updateScreen(null);
  }, _calculateLocalAnchors:function() {
    var resx = 1000;
    var resy = 1000;
    var parent = this.entity._parent;
    if (parent && parent.element) {
      resx = parent.element.calculatedWidth;
      resy = parent.element.calculatedHeight;
    } else {
      if (this.screen) {
        var res = this.screen.screen.resolution;
        var scale = this.screen.screen.scale;
        resx = res.x / scale;
        resy = res.y / scale;
      }
    }
    this._localAnchor.set(this._anchor.x * resx, this._anchor.y * resy, this._anchor.z * resx, this._anchor.w * resy);
  }, getOffsetPosition:function(x, y) {
    var p = this.entity.getLocalPosition().clone();
    p.x += x;
    p.y += y;
    this._screenToWorld.transformPoint(p, p);
    return p;
  }, onLayersChanged:function(oldComp, newComp) {
    this.addModelToLayers(this._image ? this._image._model : this._text._model);
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
  }, onLayerAdded:function(layer) {
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    if (this._image) {
      layer.addMeshInstances(this._image._model.meshInstances);
    } else {
      if (this._text) {
        layer.addMeshInstances(this._text._model.meshInstances);
      }
    }
  }, onLayerRemoved:function(layer) {
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    if (this._image) {
      layer.removeMeshInstances(this._image._model.meshInstances);
    } else {
      if (this._text) {
        layer.removeMeshInstances(this._text._model.meshInstances);
      }
    }
  }, onEnable:function() {
    pc.Component.prototype.onEnable.call(this);
    if (this._image) {
      this._image.onEnable();
    }
    if (this._text) {
      this._text.onEnable();
    }
    if (this._group) {
      this._group.onEnable();
    }
    if (this.useInput && this.system.app.elementInput) {
      this.system.app.elementInput.addElement(this);
    }
    if (this.mask) {
      var maskDepth = this._getMaskDepth();
      if (maskDepth === 1) {
        this._topMask = true;
        if (topMasks.indexOf(this) < 0) {
          topMasks.push(this);
        }
      }
    }
    this.system.app.scene.on("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.on("add", this.onLayerAdded, this);
      this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
    }
    this.fire("enableelement");
  }, onDisable:function() {
    pc.Component.prototype.onDisable.call(this);
    this.system.app.scene.off("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.off("add", this.onLayerAdded, this);
      this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
    }
    if (this._image) {
      this._image.onDisable();
    }
    if (this._text) {
      this._text.onDisable();
    }
    if (this._group) {
      this._group.onDisable();
    }
    if (this.system.app.elementInput && this.useInput) {
      this.system.app.elementInput.removeElement(this);
    }
    if (this._topMask) {
      var index = topMasks.indexOf(this);
      if (index >= 0) {
        topMasks.splice(index, 1);
      }
      this._topMask = false;
    }
    if (this._batchGroupId >= 0) {
      this.system.app.batcher.markGroupDirty(this.batchGroupId);
    }
    this.fire("disableelement");
  }, onRemove:function() {
    this.entity.off("insert", this._onInsert, this);
    this._unpatch();
    if (this._image) {
      this._image.destroy();
    }
    if (this._text) {
      this._text.destroy();
    }
    if (this.system.app.elementInput && this.useInput) {
      this.system.app.elementInput.removeElement(this);
    }
    if (this._topMask) {
      var index = topMasks.indexOf(this);
      if (index >= 0) {
        topMasks.splice(index, 1);
      }
      this._topMask = false;
    }
  }, _calculateSize:function(propagateCalculatedWidth, propagateCalculatedHeight) {
    if (!this.entity._parent && !this.screen) {
      return;
    }
    this._calculateLocalAnchors();
    var newWidth = this._absRight - this._absLeft;
    var newHeight = this._absTop - this._absBottom;
    if (propagateCalculatedWidth) {
      this._setWidth(newWidth);
    } else {
      this._setCalculatedWidth(newWidth, false);
    }
    if (propagateCalculatedHeight) {
      this._setHeight(newHeight);
    } else {
      this._setCalculatedHeight(newHeight, false);
    }
    var p = this.entity.getLocalPosition();
    p.x = this._margin.data[0] + this._calculatedWidth * this._pivot.data[0];
    p.y = this._margin.data[1] + this._calculatedHeight * this._pivot.data[1];
    this.entity.setLocalPosition(p);
    this._sizeDirty = false;
  }, _setWidth:function(w) {
    this._width = w;
    this._setCalculatedWidth(w, false);
    this.fire("set:width", this._width);
  }, _setHeight:function(h) {
    this._height = h;
    this._setCalculatedHeight(h, false);
    this.fire("set:height", this._height);
  }, _setCalculatedWidth:function(value, updateMargins) {
    var didChange = Math.abs(value - this._calculatedWidth) > 1e-4;
    this._calculatedWidth = value;
    if (updateMargins) {
      var p = this.entity.getLocalPosition().data;
      var pvt = this._pivot.data;
      this._margin.data[0] = p[0] - this._calculatedWidth * pvt[0];
      this._margin.data[2] = this._localAnchor.data[2] - this._localAnchor.data[0] - this._calculatedWidth - this._margin.data[0];
    }
    this._flagChildrenAsDirty();
    this.fire("set:calculatedWidth", this._calculatedWidth);
    if (didChange) {
      this.fire("resize", this._calculatedWidth, this._calculatedHeight);
    }
  }, _setCalculatedHeight:function(value, updateMargins) {
    var didChange = Math.abs(value - this._calculatedHeight) > 1e-4;
    this._calculatedHeight = value;
    if (updateMargins) {
      var p = this.entity.getLocalPosition().data;
      var pvt = this._pivot.data;
      this._margin.data[1] = p[1] - this._calculatedHeight * pvt[1];
      this._margin.data[3] = this._localAnchor.data[3] - this._localAnchor.data[1] - this._calculatedHeight - this._margin.data[1];
    }
    this._flagChildrenAsDirty();
    this.fire("set:calculatedHeight", this._calculatedHeight);
    if (didChange) {
      this.fire("resize", this._calculatedWidth, this._calculatedHeight);
    }
  }, _flagChildrenAsDirty:function() {
    var i, l;
    var c = this.entity._children;
    for (i = 0, l = c.length;i < l;i++) {
      if (c[i].element) {
        c[i].element._anchorDirty = true;
        c[i].element._sizeDirty = true;
      }
    }
  }, addModelToLayers:function(model) {
    var layer;
    this._addedModel = model;
    for (var i = 0;i < this.layers.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer.addMeshInstances(model.meshInstances);
    }
  }, removeModelFromLayers:function(model) {
    var layer;
    this._addedModel = null;
    for (var i = 0;i < this.layers.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer.removeMeshInstances(model.meshInstances);
    }
  }});
  Object.defineProperty(ElementComponent.prototype, "type", {get:function() {
    return this._type;
  }, set:function(value) {
    if (value !== this._type) {
      this._type = value;
      if (this._image) {
        this._image.destroy();
        this._image = null;
      }
      if (this._text) {
        this._text.destroy();
        this._text = null;
      }
      if (value === pc.ELEMENTTYPE_IMAGE) {
        this._image = new pc.ImageElement(this);
      } else {
        if (value === pc.ELEMENTTYPE_TEXT) {
          this._text = new pc.TextElement(this);
        }
      }
    }
  }});
  Object.defineProperty(ElementComponent.prototype, "layers", {get:function() {
    return this._layers;
  }, set:function(value) {
    var i, layer;
    if (this._addedModel) {
      for (i = 0;i < this._layers.length;i++) {
        layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
        if (layer) {
          layer.removeMeshInstances(this._addedModel.meshInstances);
        }
      }
    }
    this._layers = value;
    if (!this.enabled || !this.entity.enabled || !this._addedModel) {
      return;
    }
    for (i = 0;i < this._layers.length;i++) {
      layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
      if (layer) {
        layer.addMeshInstances(this._addedModel.meshInstances);
      }
    }
  }});
  Object.defineProperty(ElementComponent.prototype, "drawOrder", {get:function() {
    return this._drawOrder;
  }, set:function(value) {
    this._drawOrder = value;
    this.fire("set:draworder", this._drawOrder);
  }});
  Object.defineProperty(ElementComponent.prototype, "_absLeft", {get:function() {
    return this._localAnchor.data[0] + this._margin.data[0];
  }});
  Object.defineProperty(ElementComponent.prototype, "_absRight", {get:function() {
    return this._localAnchor.data[2] - this._margin.data[2];
  }});
  Object.defineProperty(ElementComponent.prototype, "_absTop", {get:function() {
    return this._localAnchor.data[3] - this._margin.data[3];
  }});
  Object.defineProperty(ElementComponent.prototype, "_absBottom", {get:function() {
    return this._localAnchor.data[1] + this._margin.data[1];
  }});
  Object.defineProperty(ElementComponent.prototype, "margin", {get:function() {
    return this._margin;
  }, set:function(value) {
    this._margin.copy(value);
    this._calculateSize(true, true);
    this.fire("set:margin", this._margin);
  }});
  Object.defineProperty(ElementComponent.prototype, "left", {get:function() {
    return this._margin.data[0];
  }, set:function(value) {
    this._margin.data[0] = value;
    var p = this.entity.getLocalPosition();
    var wr = this._absRight;
    var wl = this._localAnchor.data[0] + value;
    this._setWidth(wr - wl);
    p.x = value + this._calculatedWidth * this._pivot.data[0];
    this.entity.setLocalPosition(p);
  }});
  Object.defineProperty(ElementComponent.prototype, "right", {get:function() {
    return this._margin.data[2];
  }, set:function(value) {
    this._margin.data[2] = value;
    var p = this.entity.getLocalPosition();
    var wl = this._absLeft;
    var wr = this._localAnchor.data[2] - value;
    this._setWidth(wr - wl);
    p.x = this._localAnchor.data[2] - this._localAnchor.data[0] - value - this._calculatedWidth * (1 - this._pivot.data[0]);
    this.entity.setLocalPosition(p);
  }});
  Object.defineProperty(ElementComponent.prototype, "top", {get:function() {
    return this._margin.data[3];
  }, set:function(value) {
    this._margin.data[3] = value;
    var p = this.entity.getLocalPosition();
    var wb = this._absBottom;
    var wt = this._localAnchor.data[3] - value;
    this._setHeight(wt - wb);
    p.y = this._localAnchor.data[3] - this._localAnchor.data[1] - value - this._calculatedHeight * (1 - this._pivot.data[1]);
    this.entity.setLocalPosition(p);
  }});
  Object.defineProperty(ElementComponent.prototype, "bottom", {get:function() {
    return this._margin.data[1];
  }, set:function(value) {
    this._margin.data[1] = value;
    var p = this.entity.getLocalPosition();
    var wt = this._absTop;
    var wb = this._localAnchor.data[1] + value;
    this._setHeight(wt - wb);
    p.y = value + this._calculatedHeight * this._pivot.data[1];
    this.entity.setLocalPosition(p);
  }});
  Object.defineProperty(ElementComponent.prototype, "width", {get:function() {
    return this._width;
  }, set:function(value) {
    this._width = value;
    this._setCalculatedWidth(value, true);
    this.fire("set:width", this._width);
  }});
  Object.defineProperty(ElementComponent.prototype, "height", {get:function() {
    return this._height;
  }, set:function(value) {
    this._height = value;
    this._setCalculatedHeight(value, true);
    this.fire("set:height", this._height);
  }});
  Object.defineProperty(ElementComponent.prototype, "calculatedWidth", {get:function() {
    return this._calculatedWidth;
  }, set:function(value) {
    this._setCalculatedWidth(value, true);
  }});
  Object.defineProperty(ElementComponent.prototype, "calculatedHeight", {get:function() {
    return this._calculatedHeight;
  }, set:function(value) {
    this._setCalculatedHeight(value, true);
  }});
  Object.defineProperty(ElementComponent.prototype, "pivot", {get:function() {
    return this._pivot;
  }, set:function(value) {
    var prevX = this._pivot.x;
    var prevY = this._pivot.y;
    if (value instanceof pc.Vec2) {
      this._pivot.set(value.x, value.y);
    } else {
      this._pivot.set(value[0], value[1]);
    }
    var mx = this._margin.data[0] + this._margin.data[2];
    var dx = this._pivot.x - prevX;
    this._margin.data[0] += mx * dx;
    this._margin.data[2] -= mx * dx;
    var my = this._margin.data[1] + this._margin.data[3];
    var dy = this._pivot.y - prevY;
    this._margin.data[1] += my * dy;
    this._margin.data[3] -= my * dy;
    this._anchorDirty = true;
    this._cornersDirty = true;
    this._worldCornersDirty = true;
    this._calculateSize();
    this.fire("set:pivot", this._pivot);
  }});
  Object.defineProperty(ElementComponent.prototype, "anchor", {get:function() {
    return this._anchor;
  }, set:function(value) {
    if (value instanceof pc.Vec4) {
      this._anchor.set(value.x, value.y, value.z, value.w);
    } else {
      this._anchor.set(value[0], value[1], value[2], value[3]);
    }
    if (!this.entity._parent && !this.screen) {
      this._calculateLocalAnchors();
    } else {
      this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
    }
    this._anchorDirty = true;
    if (!this.entity._dirtyLocal) {
      this.entity._dirtify(true);
    }
    this.fire("set:anchor", this._anchor);
  }});
  Object.defineProperty(ElementComponent.prototype, "_hasSplitAnchorsX", {get:function() {
    return Math.abs(this._anchor.data[0] - this._anchor.data[2]) > 0.001;
  }});
  Object.defineProperty(ElementComponent.prototype, "_hasSplitAnchorsY", {get:function() {
    return Math.abs(this._anchor.data[1] - this._anchor.data[3]) > 0.001;
  }});
  Object.defineProperty(ElementComponent.prototype, "screenCorners", {get:function() {
    if (!this._cornersDirty || !this.screen) {
      return this._screenCorners;
    }
    var parentBottomLeft = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];
    this._screenCorners[0].set(this._absLeft, this._absBottom, 0);
    this._screenCorners[1].set(this._absRight, this._absBottom, 0);
    this._screenCorners[2].set(this._absRight, this._absTop, 0);
    this._screenCorners[3].set(this._absLeft, this._absTop, 0);
    var screenSpace = this.screen.screen.screenSpace;
    for (var i = 0;i < 4;i++) {
      this._screenTransform.transformPoint(this._screenCorners[i], this._screenCorners[i]);
      if (screenSpace) {
        this._screenCorners[i].scale(this.screen.screen.scale);
      }
      if (parentBottomLeft) {
        this._screenCorners[i].add(parentBottomLeft);
      }
    }
    this._cornersDirty = false;
    this._canvasCornersDirty = true;
    this._worldCornersDirty = true;
    return this._screenCorners;
  }});
  Object.defineProperty(ElementComponent.prototype, "canvasCorners", {get:function() {
    if (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace) {
      return this._canvasCorners;
    }
    var device = this.system.app.graphicsDevice;
    var screenCorners = this.screenCorners;
    var sx = device.canvas.clientWidth / device.width;
    var sy = device.canvas.clientHeight / device.height;
    for (var i = 0;i < 4;i++) {
      this._canvasCorners[i].set(screenCorners[i].x * sx, (device.height - screenCorners[i].y) * sy);
    }
    this._canvasCornersDirty = false;
    return this._canvasCorners;
  }});
  Object.defineProperty(ElementComponent.prototype, "worldCorners", {get:function() {
    if (!this._worldCornersDirty) {
      return this._worldCorners;
    }
    if (this.screen) {
      var screenCorners = this.screenCorners;
      if (!this.screen.screen.screenSpace) {
        matA.copy(this.screen.screen._screenMatrix);
        matA.data[13] = -matA.data[13];
        matA.mul2(this.screen.getWorldTransform(), matA);
        for (var i = 0;i < 4;i++) {
          matA.transformPoint(screenCorners[i], this._worldCorners[i]);
        }
      }
    } else {
      var localPos = this.entity.getLocalPosition();
      matA.setTranslate(-localPos.x, -localPos.y, -localPos.z);
      matB.setTRS(pc.Vec3.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale());
      matC.setTranslate(localPos.x, localPos.y, localPos.z);
      matD.copy(this.entity.parent.getWorldTransform());
      matD.mul(matC).mul(matB).mul(matA);
      vecA.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
      matD.transformPoint(vecA, this._worldCorners[0]);
      vecA.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
      matD.transformPoint(vecA, this._worldCorners[1]);
      vecA.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
      matD.transformPoint(vecA, this._worldCorners[2]);
      vecA.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
      matD.transformPoint(vecA, this._worldCorners[3]);
    }
    this._worldCornersDirty = false;
    return this._worldCorners;
  }});
  Object.defineProperty(ElementComponent.prototype, "textWidth", {get:function() {
    return this._text ? this._text.width : 0;
  }});
  Object.defineProperty(ElementComponent.prototype, "textHeight", {get:function() {
    return this._text ? this._text.height : 0;
  }});
  Object.defineProperty(ElementComponent.prototype, "useInput", {get:function() {
    return this._useInput;
  }, set:function(value) {
    if (this._useInput === value) {
      return;
    }
    this._useInput = value;
    if (this.system.app.elementInput) {
      if (value) {
        if (this.enabled && this.entity.enabled) {
          this.system.app.elementInput.addElement(this);
        }
      } else {
        this.system.app.elementInput.removeElement(this);
      }
    }
    this.fire("set:useInput", value);
  }});
  Object.defineProperty(ElementComponent.prototype, "batchGroupId", {get:function() {
    return this._batchGroupId;
  }, set:function(value) {
    if (this._batchGroupId === value) {
      return;
    }
    if (this._batchGroupId >= 0) {
      this.system.app.batcher.markGroupDirty(this._batchGroupId);
    }
    if (value >= 0) {
      this.system.app.batcher.markGroupDirty(value);
    }
    if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
      if (this._image._model) {
        this.addModelToLayers(this._image._model);
      } else {
        if (this._text._model) {
          this.addModelToLayers(this._text._model);
        }
      }
    }
    this._batchGroupId = value;
  }});
  var _define = function(name) {
    Object.defineProperty(ElementComponent.prototype, name, {get:function() {
      if (this._text) {
        return this._text[name];
      } else {
        if (this._image) {
          return this._image[name];
        }
      }
      return null;
    }, set:function(value) {
      if (this._text) {
        this._text[name] = value;
      } else {
        if (this._image) {
          this._image[name] = value;
        }
      }
    }});
  };
  _define("fontSize");
  _define("color");
  _define("font");
  _define("fontAsset");
  _define("spacing");
  _define("lineHeight");
  _define("wrapLines");
  _define("lines");
  _define("alignment");
  _define("autoWidth");
  _define("autoHeight");
  _define("text");
  _define("texture");
  _define("textureAsset");
  _define("material");
  _define("materialAsset");
  _define("sprite");
  _define("spriteAsset");
  _define("spriteFrame");
  _define("pixelsPerUnit");
  _define("opacity");
  _define("rect");
  _define("mask");
  return {ElementComponent:ElementComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled"];
  var nineSliceBasePS = ["varying vec2 vMask;", "varying vec2 vTiledUv;", "uniform vec4 innerOffset;", "uniform vec2 outerScale;", "uniform vec4 atlasRect;", "vec2 nineSlicedUv;"].join("\n");
  var nineSliceUvPs = ["vec2 tileMask = step(vMask, vec2(0.99999));", "vec2 clampedUv = mix(innerOffset.xy*0.5, vec2(1.0) - innerOffset.zw*0.5, fract(vTiledUv));", "clampedUv = clampedUv * atlasRect.zw + atlasRect.xy;", "nineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);"].join("\n");
  var ElementComponentSystem = function ElementComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "element";
    this.app = app;
    app.systems.add(this.id, this);
    this.ComponentType = pc.ElementComponent;
    this.DataType = pc.ElementComponentData;
    this.schema = _schema;
    this._defaultTexture = new pc.Texture(app.graphicsDevice, {width:1, height:1, format:pc.PIXELFORMAT_R8_G8_B8_A8});
    var pixels = this._defaultTexture.lock();
    var pixelData = new Uint8Array(4);
    pixelData[0] = 255.0;
    pixelData[1] = 255.0;
    pixelData[2] = 255.0;
    pixelData[3] = 255.0;
    pixels.set(pixelData);
    this._defaultTexture.unlock();
    this._maskMaterials = {};
    this.defaultImageMaterial = new pc.StandardMaterial;
    this.defaultImageMaterial.diffuse.set(0, 0, 0);
    this.defaultImageMaterial.emissive.set(0.5, 0.5, 0.5);
    this.defaultImageMaterial.emissiveMap = this._defaultTexture;
    this.defaultImageMaterial.emissiveTint = true;
    this.defaultImageMaterial.opacityMap = this._defaultTexture;
    this.defaultImageMaterial.opacityMapChannel = "a";
    this.defaultImageMaterial.opacityTint = true;
    this.defaultImageMaterial.opacity = 0;
    this.defaultImageMaterial.useLighting = false;
    this.defaultImageMaterial.useGammaTonemap = false;
    this.defaultImageMaterial.useFog = false;
    this.defaultImageMaterial.useSkybox = false;
    this.defaultImageMaterial.blendType = pc.BLEND_PREMULTIPLIED;
    this.defaultImageMaterial.depthWrite = false;
    this.defaultImageMaterial.update();
    this.defaultImageMaskMaterial = this.defaultImageMaterial.clone();
    this.defaultImageMaskMaterial.alphaTest = 1;
    this.defaultImageMaskMaterial.redWrite = false;
    this.defaultImageMaskMaterial.greenWrite = false;
    this.defaultImageMaskMaterial.blueWrite = false;
    this.defaultImageMaskMaterial.alphaWrite = false;
    this.defaultImageMaskMaterial.update();
    this.defaultImage9SlicedMaterial = this.defaultImageMaterial.clone();
    this.defaultImage9SlicedMaterial.chunks.basePS = pc.shaderChunks.basePS + nineSliceBasePS;
    this.defaultImage9SlicedMaterial.chunks.startPS = pc.shaderChunks.startPS + "nineSlicedUv = vUv0;\n";
    this.defaultImage9SlicedMaterial.chunks.emissivePS = pc.shaderChunks.emissivePS.replace("$UV", "nineSlicedUv");
    this.defaultImage9SlicedMaterial.chunks.opacityPS = pc.shaderChunks.opacityPS.replace("$UV", "nineSlicedUv");
    this.defaultImage9SlicedMaterial.chunks.transformVS = "#define NINESLICED\n" + pc.shaderChunks.transformVS;
    this.defaultImage9SlicedMaterial.chunks.uv0VS = pc.shaderChunks.uv9SliceVS;
    this.defaultImage9SlicedMaterial.update();
    this.defaultImage9TiledMaterial = this.defaultImage9SlicedMaterial.clone();
    this.defaultImage9TiledMaterial.chunks.basePS = pc.shaderChunks.basePS + "#define NINESLICETILED\n" + nineSliceBasePS;
    this.defaultImage9TiledMaterial.chunks.startPS = pc.shaderChunks.startPS + nineSliceUvPs;
    this.defaultImage9TiledMaterial.chunks.emissivePS = pc.shaderChunks.emissivePS.replace("$UV", "nineSlicedUv, -1000.0");
    this.defaultImage9TiledMaterial.chunks.opacityPS = pc.shaderChunks.opacityPS.replace("$UV", "nineSlicedUv, -1000.0");
    this.defaultImage9TiledMaterial.update();
    this.defaultImage9SlicedMaskMaterial = this.defaultImage9SlicedMaterial.clone();
    this.defaultImage9SlicedMaskMaterial.alphaTest = 1;
    this.defaultImage9SlicedMaskMaterial.redWrite = false;
    this.defaultImage9SlicedMaskMaterial.greenWrite = false;
    this.defaultImage9SlicedMaskMaterial.blueWrite = false;
    this.defaultImage9SlicedMaskMaterial.alphaWrite = false;
    this.defaultImage9SlicedMaskMaterial.update();
    this.defaultImage9TiledMaskMaterial = this.defaultImage9TiledMaterial.clone();
    this.defaultImage9TiledMaskMaterial.alphaTest = 1;
    this.defaultImage9TiledMaskMaterial.redWrite = false;
    this.defaultImage9TiledMaskMaterial.greenWrite = false;
    this.defaultImage9TiledMaskMaterial.blueWrite = false;
    this.defaultImage9TiledMaskMaterial.alphaWrite = false;
    this.defaultImage9TiledMaskMaterial.update();
    this.defaultScreenSpaceImageMaterial = this.defaultImageMaterial.clone();
    this.defaultScreenSpaceImageMaterial.depthTest = false;
    this.defaultScreenSpaceImageMaterial.update();
    this.defaultScreenSpaceImage9SlicedMaterial = this.defaultImage9SlicedMaterial.clone();
    this.defaultScreenSpaceImage9SlicedMaterial.depthTest = false;
    this.defaultScreenSpaceImage9SlicedMaterial.update();
    this.defaultScreenSpaceImage9TiledMaterial = this.defaultScreenSpaceImage9SlicedMaterial.clone();
    this.defaultScreenSpaceImage9TiledMaterial.chunks.basePS = pc.shaderChunks.basePS + "#define NINESLICETILED\n" + nineSliceBasePS;
    this.defaultScreenSpaceImage9TiledMaterial.chunks.startPS = pc.shaderChunks.startPS + nineSliceUvPs;
    this.defaultScreenSpaceImage9TiledMaterial.chunks.emissivePS = pc.shaderChunks.emissivePS.replace("$UV", "nineSlicedUv, -1000.0");
    this.defaultScreenSpaceImage9TiledMaterial.chunks.opacityPS = pc.shaderChunks.opacityPS.replace("$UV", "nineSlicedUv, -1000.0");
    this.defaultScreenSpaceImage9TiledMaterial.update();
    this.defaultScreenSpaceImageMask9SlicedMaterial = this.defaultScreenSpaceImage9SlicedMaterial.clone();
    this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1;
    this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = false;
    this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = false;
    this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = false;
    this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = false;
    this.defaultScreenSpaceImageMask9SlicedMaterial.update();
    this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone();
    this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1;
    this.defaultScreenSpaceImageMask9TiledMaterial.redWrite = false;
    this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = false;
    this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = false;
    this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = false;
    this.defaultScreenSpaceImageMask9TiledMaterial.update();
    this.defaultScreenSpaceImageMaskMaterial = this.defaultScreenSpaceImageMaterial.clone();
    this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1;
    this.defaultScreenSpaceImageMaskMaterial.redWrite = false;
    this.defaultScreenSpaceImageMaskMaterial.greenWrite = false;
    this.defaultScreenSpaceImageMaskMaterial.blueWrite = false;
    this.defaultScreenSpaceImageMaskMaterial.alphaWrite = false;
    this.defaultScreenSpaceImageMaskMaterial.update();
    this.defaultTextMaterial = new pc.StandardMaterial;
    this.defaultTextMaterial.msdfMap = this._defaultTexture;
    this.defaultTextMaterial.useLighting = false;
    this.defaultTextMaterial.useGammaTonemap = false;
    this.defaultTextMaterial.useFog = false;
    this.defaultTextMaterial.useSkybox = false;
    this.defaultTextMaterial.diffuse.set(0, 0, 0);
    this.defaultTextMaterial.emissive.set(1, 1, 1);
    this.defaultTextMaterial.opacity = 0.5;
    this.defaultTextMaterial.blendType = pc.BLEND_PREMULTIPLIED;
    this.defaultTextMaterial.depthWrite = false;
    this.defaultTextMaterial.update();
    this.defaultScreenSpaceTextMaterial = this.defaultTextMaterial.clone();
    this.defaultScreenSpaceTextMaterial.depthTest = false;
    this.defaultScreenSpaceTextMaterial.update();
    this.defaultImageMaterials = [this.defaultImageMaterial, this.defaultImageMaskMaterial, this.defaultImage9SlicedMaterial, this.defaultImage9TiledMaterial, this.defaultImage9SlicedMaskMaterial, this.defaultImage9TiledMaskMaterial, this.defaultScreenSpaceImageMaterial, this.defaultScreenSpaceImage9SlicedMaterial, this.defaultScreenSpaceImage9TiledMaterial, this.defaultScreenSpaceImageMask9SlicedMaterial, this.defaultScreenSpaceImageMask9TiledMaterial, this.defaultScreenSpaceImageMaskMaterial];
    this.on("beforeremove", this.onRemoveComponent, this);
  };
  ElementComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  ElementComponentSystem.prototype.constructor = ElementComponentSystem;
  pc.Component._buildAccessors(pc.ElementComponent.prototype, _schema);
  Object.assign(ElementComponentSystem.prototype, {initializeComponentData:function(component, data, properties) {
    if (data.anchor !== undefined) {
      if (data.anchor instanceof pc.Vec4) {
        component.anchor.copy(data.anchor);
      } else {
        component.anchor.set(data.anchor[0], data.anchor[1], data.anchor[2], data.anchor[3]);
      }
    }
    if (data.pivot !== undefined) {
      if (data.pivot instanceof pc.Vec2) {
        component.pivot.copy(data.pivot);
      } else {
        component.pivot.set(data.pivot[0], data.pivot[1]);
      }
    }
    var splitHorAnchors = Math.abs(component.anchor.x - component.anchor.z) > 0.001;
    var splitVerAnchors = Math.abs(component.anchor.y - component.anchor.w) > 0.001;
    var _marginChange = false;
    if (data.margin !== undefined) {
      if (data.margin instanceof pc.Vec4) {
        component.margin.copy(data.margin);
      } else {
        component._margin.set(data.margin[0], data.margin[1], data.margin[2], data.margin[3]);
      }
      _marginChange = true;
    }
    if (data.left !== undefined) {
      component._margin.x = data.left;
      _marginChange = true;
    }
    if (data.bottom !== undefined) {
      component._margin.y = data.bottom;
      _marginChange = true;
    }
    if (data.right !== undefined) {
      component._margin.z = data.right;
      _marginChange = true;
    }
    if (data.top !== undefined) {
      component._margin.w = data.top;
      _marginChange = true;
    }
    if (_marginChange) {
      component.margin = component._margin;
    }
    var shouldForceSetAnchor = false;
    if (data.width !== undefined && !splitHorAnchors) {
      component.width = data.width;
    } else {
      if (splitHorAnchors) {
        shouldForceSetAnchor = true;
      }
    }
    if (data.height !== undefined && !splitVerAnchors) {
      component.height = data.height;
    } else {
      if (splitVerAnchors) {
        shouldForceSetAnchor = true;
      }
    }
    if (shouldForceSetAnchor) {
      component.anchor = component.anchor;
    }
    if (data.enabled !== undefined) {
      component.enabled = data.enabled;
    }
    if (data.useInput !== undefined) {
      component.useInput = data.useInput;
    }
    component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;
    if (data.layers && pc.type(data.layers) === "array") {
      component.layers = data.layers.slice(0);
    }
    component.type = data.type;
    if (component.type === pc.ELEMENTTYPE_IMAGE) {
      if (data.rect !== undefined) {
        if (data.rect instanceof pc.Vec4) {
          component.rect.copy(data.rect);
        } else {
          component.rect.set(data.rect[0], data.rect[1], data.rect[2], data.rect[3]);
        }
      }
      if (data.color !== undefined) {
        if (data.color instanceof pc.Color) {
          component.color.set(data.color.data[0], data.color.data[1], data.color.data[2], data.opacity !== undefined ? data.opacity : 1);
        } else {
          component.color.set(data.color[0], data.color[1], data.color[2], data.opacity !== undefined ? data.opacity : 1);
        }
        component.color = component.color;
      } else {
        var opacity = data.opacity || 1;
        component.color.set(1, 1, 1, opacity);
        component.color = component.color;
      }
      if (data.opacity !== undefined) {
        component.opacity = data.opacity;
      } else {
        component.opacity = 1;
      }
      if (data.textureAsset !== undefined) {
        component.textureAsset = data.textureAsset;
      }
      if (data.texture) {
        component.texture = data.texture;
      }
      if (data.spriteAsset !== undefined) {
        component.spriteAsset = data.spriteAsset;
      }
      if (data.sprite) {
        component.sprite = data.sprite;
      }
      if (data.spriteFrame !== undefined) {
        component.spriteFrame = data.spriteFrame;
      }
      if (data.pixelsPerUnit !== undefined && data.pixelsPerUnit !== null) {
        component.pixelsPerUnit = data.pixelsPerUnit;
      }
      if (data.materialAsset !== undefined) {
        component.materialAsset = data.materialAsset;
      }
      if (data.material) {
        component.material = data.material;
      }
      if (data.mask !== undefined) {
        component.mask = data.mask;
      }
    } else {
      if (component.type === pc.ELEMENTTYPE_TEXT) {
        if (data.autoWidth !== undefined) {
          component.autoWidth = data.autoWidth;
        }
        if (data.autoHeight !== undefined) {
          component.autoHeight = data.autoHeight;
        }
        if (data.text !== undefined) {
          component.text = data.text;
        }
        if (data.color !== undefined) {
          if (data.color instanceof pc.Color) {
            component.color.set(data.color.data[0], data.color.data[1], data.color.data[2], data.opacity !== undefined ? data.opacity : 1);
          } else {
            component.color.set(data.color[0], data.color[1], data.color[2], data.opacity !== undefined ? data.opacity : 1);
          }
          component.color = component.color;
        }
        if (data.opacity !== undefined) {
          component.opacity = data.opacity;
        }
        if (data.spacing !== undefined) {
          component.spacing = data.spacing;
        }
        if (data.fontSize !== undefined) {
          component.fontSize = data.fontSize;
          if (!data.lineHeight) {
            component.lineHeight = data.fontSize;
          }
        }
        if (data.lineHeight !== undefined) {
          component.lineHeight = data.lineHeight;
        }
        if (data.wrapLines !== undefined) {
          component.wrapLines = data.wrapLines;
        }
        if (data.fontAsset !== undefined) {
          component.fontAsset = data.fontAsset;
        }
        if (data.font !== undefined) {
          component.font = data.font;
        }
        if (data.alignment !== undefined) {
          component.alignment = data.alignment;
        }
      } else {
      }
    }
    var result = component._parseUpToScreen();
    if (result.screen) {
      component._updateScreen(result.screen);
    }
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
  }, onRemoveComponent:function(entity, component) {
    component.onRemove();
  }, cloneComponent:function(entity, clone) {
    var source = entity.element;
    return this.addComponent(clone, {enabled:source.enabled, width:source.width, height:source.height, anchor:source.anchor.clone(), pivot:source.pivot.clone(), margin:source.margin.clone(), alignment:source.alignment && source.alignment.clone() || source.alignment, autoWidth:source.autoWidth, autoHeight:source.autoHeight, type:source.type, rect:source.rect && source.rect.clone() || source.rect, materialAsset:source.materialAsset, material:source.material, color:source.color && source.color.clone() || 
    source.color, opacity:source.opacity, textureAsset:source.textureAsset, texture:source.texture, spriteAsset:source.spriteAsset, sprite:source.sprite, spriteFrame:source.spriteFrame, pixelsPerUnit:source.pixelsPerUnit, text:source.text, spacing:source.spacing, lineHeight:source.lineHeight, wrapLines:source.wrapLines, layers:source.layers, fontSize:source.fontSize, fontAsset:source.fontAsset, font:source.font, useInput:source.useInput, batchGroupId:source.batchGroupId, mask:source.mask});
  }});
  return {ElementComponentSystem:ElementComponentSystem};
}());
Object.assign(pc, function() {
  var ElementComponentData = function() {
    this.enabled = true;
  };
  return {ElementComponentData:ElementComponentData};
}());
Object.assign(pc, function() {
  var ImageElement = function ImageElement(element) {
    this._element = element;
    this._entity = element.entity;
    this._system = element.system;
    this._textureAsset = null;
    this._texture = null;
    this._materialAsset = null;
    this._material = null;
    this._spriteAsset = null;
    this._sprite = null;
    this._spriteFrame = 0;
    this._pixelsPerUnit = null;
    this._rect = new pc.Vec4(0, 0, 1, 1);
    this._color = new pc.Color(1, 1, 1, 1);
    this._mask = false;
    this._maskRef = 0;
    this._positions = [];
    this._normals = [];
    this._uvs = [];
    this._indices = [];
    this._outerScale = new pc.Vec2;
    this._innerOffset = new pc.Vec4;
    this._atlasRect = new pc.Vec4;
    this._defaultMesh = this._createMesh();
    this._mesh = this._defaultMesh;
    this._node = new pc.GraphNode;
    this._model = new pc.Model;
    this._model.graph = this._node;
    this._meshInstance = new pc.MeshInstance(this._node, this._mesh, this._material);
    this._meshInstance.castShadow = false;
    this._meshInstance.receiveShadow = false;
    this._model.meshInstances.push(this._meshInstance);
    this._drawOrder = 0;
    this._updateAabbFunc = this._updateAabb.bind(this);
    this._entity.addChild(this._model.graph);
    this._model._entity = this._entity;
    this._onScreenChange(this._element.screen);
    this._element.on("resize", this._onParentResizeOrPivotChange, this);
    this._element.on("set:pivot", this._onParentResizeOrPivotChange, this);
    this._element.on("screen:set:screenspace", this._onScreenSpaceChange, this);
    this._element.on("set:screen", this._onScreenChange, this);
    this._element.on("set:draworder", this._onDrawOrderChange, this);
    this._element.on("screen:set:resolution", this._onResolutionChange, this);
  };
  Object.assign(ImageElement.prototype, {destroy:function() {
    if (this._model) {
      this._element.removeModelFromLayers(this._model);
      this._meshInstance.mesh = this._defaultMesh;
      this._model.destroy();
      this._model = null;
    }
    this._element.off("resize", this._onParentResizeOrPivotChange, this);
    this._element.off("set:pivot", this._onParentResizeOrPivotChange, this);
    this._element.off("screen:set:screenspace", this._onScreenSpaceChange, this);
    this._element.off("set:screen", this._onScreenChange, this);
    this._element.off("set:draworder", this._onDrawOrderChange, this);
    this._element.off("screen:set:resolution", this._onResolutionChange, this);
    var asset;
    var app = this._system.app;
    asset = this._textureAsset ? app.assets.get(this._textureAsset) : null;
    if (asset) {
      asset.off("load", this._onTextureLoad, this);
      asset.off("change", this._onTextureChange, this);
      asset.off("remove", this._onTextureRemove, this);
    }
    asset = this._spriteAsset ? app.assets.get(this._spriteAsset) : null;
    if (asset) {
      asset.off("load", this._onSpriteAssetLoad, this);
      asset.off("change", this._onSpriteAssetChange, this);
      asset.off("remove", this._onSpriteAssetRemove, this);
    }
    asset = this._materialAsset ? app.assets.get(this._materialAsset) : null;
    if (asset) {
      asset.off("load", this._onMaterialLoad, this);
      asset.off("change", this._onMaterialChange, this);
      asset.off("remove", this._onMaterialRemove, this);
    }
  }, _onResolutionChange:function(res) {
  }, _onParentResizeOrPivotChange:function() {
    if (this._mesh) {
      this._updateMesh(this._mesh);
    }
  }, _onScreenSpaceChange:function(value) {
    this._updateMaterial(value);
  }, _onScreenChange:function(screen) {
    if (screen) {
      this._updateMaterial(screen.screen.screenSpace);
    } else {
      this._updateMaterial(false);
    }
  }, _onDrawOrderChange:function(order) {
    this._drawOrder = order;
    if (this._meshInstance) {
      this._meshInstance.drawOrder = order;
    }
  }, _hasUserMaterial:function() {
    return !!this._materialAsset || !!this._material && this._system.defaultImageMaterials.indexOf(this._material) === -1;
  }, _use9Slicing:function() {
    return this.sprite && (this.sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === pc.SPRITE_RENDERMODE_TILED);
  }, _updateMaterial:function(screenSpace) {
    if (screenSpace) {
      if (!this._hasUserMaterial()) {
        if (this._mask) {
          if (this.sprite) {
            if (this.sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED) {
              this._material = this._system.defaultScreenSpaceImageMask9SlicedMaterial;
            } else {
              if (this.sprite.renderMode === pc.SPRITE_RENDERMODE_TILED) {
                this._material = this._system.defaultScreenSpaceImageMask9TiledMaterial;
              } else {
                this._material = this._system.defaultScreenSpaceImageMaskMaterial;
              }
            }
          } else {
            this._material = this._system.defaultScreenSpaceImageMaskMaterial;
          }
        } else {
          if (this.sprite) {
            if (this.sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED) {
              this._material = this._system.defaultScreenSpaceImage9SlicedMaterial;
            } else {
              if (this.sprite.renderMode === pc.SPRITE_RENDERMODE_TILED) {
                this._material = this._system.defaultScreenSpaceImage9TiledMaterial;
              } else {
                this._material = this._system.defaultScreenSpaceImageMaterial;
              }
            }
          } else {
            this._material = this._system.defaultScreenSpaceImageMaterial;
          }
        }
      }
      if (this._meshInstance) {
        this._meshInstance.cull = false;
      }
    } else {
      if (!this._hasUserMaterial()) {
        if (this._mask) {
          if (this.sprite) {
            if (this.sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED) {
              this._material = this._system.defaultImage9SlicedMaskMaterial;
            } else {
              if (this.sprite.renderMode === pc.SPRITE_RENDERMODE_TILED) {
                this._material = this._system.defaultImage9TiledMaskMaterial;
              } else {
                this._material = this._system.defaultImageMaskMaterial;
              }
            }
          } else {
            this._material = this._system.defaultImageMaskMaterial;
          }
        } else {
          if (this.sprite) {
            if (this.sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED) {
              this._material = this._system.defaultImage9SlicedMaterial;
            } else {
              if (this.sprite.renderMode === pc.SPRITE_RENDERMODE_TILED) {
                this._material = this._system.defaultImage9TiledMaterial;
              } else {
                this._material = this._system.defaultImageMaterial;
              }
            }
          } else {
            this._material = this._system.defaultImageMaterial;
          }
        }
      }
      if (this._meshInstance) {
        this._meshInstance.cull = true;
      }
    }
    if (this._meshInstance) {
      this._meshInstance.material = this._material;
      this._meshInstance.screenSpace = screenSpace;
      this._meshInstance.layer = screenSpace ? pc.scene.LAYER_HUD : pc.scene.LAYER_WORLD;
    }
  }, _createMesh:function() {
    var w = this._element.calculatedWidth;
    var h = this._element.calculatedHeight;
    this._positions[0] = 0;
    this._positions[1] = 0;
    this._positions[2] = 0;
    this._positions[3] = w;
    this._positions[4] = 0;
    this._positions[5] = 0;
    this._positions[6] = w;
    this._positions[7] = h;
    this._positions[8] = 0;
    this._positions[9] = 0;
    this._positions[10] = h;
    this._positions[11] = 0;
    for (var i = 0;i < 12;i += 3) {
      this._normals[i] = 0;
      this._normals[i + 1] = 0;
      this._normals[i + 2] = 1;
    }
    this._uvs[0] = this._rect.data[0];
    this._uvs[1] = this._rect.data[1];
    this._uvs[2] = this._rect.data[0] + this._rect.data[2];
    this._uvs[3] = this._rect.data[1];
    this._uvs[4] = this._rect.data[0] + this._rect.data[2];
    this._uvs[5] = this._rect.data[1] + this._rect.data[3];
    this._uvs[6] = this._rect.data[0];
    this._uvs[7] = this._rect.data[1] + this._rect.data[3];
    this._indices[0] = 0;
    this._indices[1] = 1;
    this._indices[2] = 3;
    this._indices[3] = 2;
    this._indices[4] = 3;
    this._indices[5] = 1;
    var mesh = pc.createMesh(this._system.app.graphicsDevice, this._positions, {uvs:this._uvs, normals:this._normals, indices:this._indices});
    this._updateMesh(mesh);
    return mesh;
  }, _updateMesh:function(mesh) {
    var i;
    var w = this._element.calculatedWidth;
    var h = this._element.calculatedHeight;
    if (this._element.screen) {
      this._updateMaterial(this._element.screen.screen.screenSpace);
    } else {
      this._updateMaterial();
    }
    if (this._meshInstance) {
      this._meshInstance._aabbVer = -1;
    }
    if (this.sprite && (this.sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === pc.SPRITE_RENDERMODE_TILED)) {
      var frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
      var borderWidthScale = 2 / frameData.rect.z;
      var borderHeightScale = 2 / frameData.rect.w;
      this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);
      var tex = this.sprite.atlas.texture;
      this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);
      var ppu = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit;
      var scaleMulX = frameData.rect.z / ppu;
      var scaleMulY = frameData.rect.w / ppu;
      this._outerScale.set(Math.max(w, this._innerOffset.x * scaleMulX), Math.max(h, this._innerOffset.y * scaleMulY));
      var scaleX = scaleMulX;
      var scaleY = scaleMulY;
      this._outerScale.x /= scaleMulX;
      this._outerScale.y /= scaleMulY;
      scaleX *= pc.math.clamp(w / (this._innerOffset.x * scaleMulX), 0.0001, 1);
      scaleY *= pc.math.clamp(h / (this._innerOffset.y * scaleMulY), 0.0001, 1);
      if (this._meshInstance) {
        this._meshInstance.setParameter("innerOffset", this._innerOffset.data);
        this._meshInstance.setParameter("atlasRect", this._atlasRect.data);
        this._meshInstance.setParameter("outerScale", this._outerScale.data, 4294967295);
        this._meshInstance._updateAabbFunc = this._updateAabbFunc;
      }
      if (this._node) {
        this._node.setLocalScale(scaleX, scaleY, 1);
        this._node.setLocalPosition((0.5 - this._element.pivot.x) * w, (0.5 - this._element.pivot.y) * h, 0);
      }
    } else {
      this._positions[0] = 0;
      this._positions[1] = 0;
      this._positions[2] = 0;
      this._positions[3] = w;
      this._positions[4] = 0;
      this._positions[5] = 0;
      this._positions[6] = w;
      this._positions[7] = h;
      this._positions[8] = 0;
      this._positions[9] = 0;
      this._positions[10] = h;
      this._positions[11] = 0;
      var hp = this._element.pivot.data[0];
      var vp = this._element.pivot.data[1];
      for (i = 0;i < this._positions.length;i += 3) {
        this._positions[i] -= hp * w;
        this._positions[i + 1] -= vp * h;
      }
      w = 1;
      h = 1;
      var rect = this._rect;
      if (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {
        var frame = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
        if (frame) {
          rect = frame.rect;
          w = this._sprite.atlas.texture.width;
          h = this._sprite.atlas.texture.height;
        }
      }
      this._uvs[0] = rect.data[0] / w;
      this._uvs[1] = rect.data[1] / h;
      this._uvs[2] = (rect.data[0] + rect.data[2]) / w;
      this._uvs[3] = rect.data[1] / h;
      this._uvs[4] = (rect.data[0] + rect.data[2]) / w;
      this._uvs[5] = (rect.data[1] + rect.data[3]) / h;
      this._uvs[6] = rect.data[0] / w;
      this._uvs[7] = (rect.data[1] + rect.data[3]) / h;
      var vb = mesh.vertexBuffer;
      var it = new pc.VertexIterator(vb);
      var numVertices = 4;
      for (i = 0;i < numVertices;i++) {
        it.element[pc.SEMANTIC_POSITION].set(this._positions[i * 3 + 0], this._positions[i * 3 + 1], this._positions[i * 3 + 2]);
        it.element[pc.SEMANTIC_NORMAL].set(this._normals[i * 3 + 0], this._normals[i * 3 + 1], this._normals[i * 3 + 2]);
        it.element[pc.SEMANTIC_TEXCOORD0].set(this._uvs[i * 2 + 0], this._uvs[i * 2 + 1]);
        it.next();
      }
      it.end();
      mesh.aabb.compute(this._positions);
      if (this._node) {
        this._node.setLocalScale(1, 1, 1);
        this._node.setLocalPosition(0, 0, 0);
      }
      if (this._meshInstance) {
        this._meshInstance._updateAabbFunc = null;
      }
    }
  }, _updateAabb:function(aabb) {
    aabb.center.set(0, 0, 0);
    aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
    aabb.setFromTransformedAabb(aabb, this._node.getWorldTransform());
    return aabb;
  }, _getHigherMask:function() {
    var parent = this._entity;
    while (parent) {
      parent = parent.getParent();
      if (parent && parent.element && parent.element.mask) {
        return parent;
      }
    }
    return null;
  }, _toggleMask:function() {
    this._element._dirtifyMask();
    var screenSpace = this._element.screen ? this._element.screen.screen.screenSpace : false;
    this._updateMaterial(screenSpace);
  }, _onMaterialLoad:function(asset) {
    this.material = asset.resource;
  }, _onMaterialAdded:function(asset) {
    this._system.app.assets.off("add:" + asset.id, this._onMaterialAdded, this);
    if (this._materialAsset === asset.id) {
      this._bindMaterialAsset(asset);
    }
  }, _bindMaterialAsset:function(asset) {
    asset.on("load", this._onMaterialLoad, this);
    asset.on("change", this._onMaterialChange, this);
    asset.on("remove", this._onMaterialRemove, this);
    if (asset.resource) {
      this._onMaterialLoad(asset);
    } else {
      this._system.app.assets.load(asset);
    }
  }, _onMaterialChange:function() {
  }, _onMaterialRemove:function() {
  }, _onTextureAdded:function(asset) {
    this._system.app.assets.off("add:" + asset.id, this._onTextureAdded, this);
    if (this._textureAsset === asset.id) {
      this._bindTextureAsset(asset);
    }
  }, _bindTextureAsset:function(asset) {
    asset.on("load", this._onTextureLoad, this);
    asset.on("change", this._onTextureChange, this);
    asset.on("remove", this._onTextureRemove, this);
    if (asset.resource) {
      this._onTextureLoad(asset);
    } else {
      this._system.app.assets.load(asset);
    }
  }, _onTextureLoad:function(asset) {
    this.texture = asset.resource;
  }, _onTextureChange:function(asset) {
  }, _onTextureRemove:function(asset) {
  }, _onSpriteAssetAdded:function(asset) {
    this._system.app.assets.off("add:" + asset.id, this._onSpriteAssetAdded, this);
    if (this._spriteAsset === asset.id) {
      this._bindSpriteAsset(asset);
    }
  }, _bindSpriteAsset:function(asset) {
    asset.on("load", this._onSpriteAssetLoad, this);
    asset.on("change", this._onSpriteAssetChange, this);
    asset.on("remove", this._onSpriteAssetRemove, this);
    if (asset.resource) {
      this._onSpriteAssetLoad(asset);
    } else {
      this._system.app.assets.load(asset);
    }
  }, _onSpriteAssetLoad:function(asset) {
    if (!asset.resource) {
      this.sprite = null;
    } else {
      if (!asset.resource.atlas) {
        var atlasAssetId = asset.data.textureAtlasAsset;
        var assets = this._system.app.assets;
        assets.off("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
        assets.once("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
      } else {
        this.sprite = asset.resource;
      }
    }
  }, _onSpriteMeshesChange:function() {
    this.spriteFrame = this.spriteFrame;
  }, _onSpritePpuChange:function() {
    if (this.sprite.renderMode !== pc.SPRITE_RENDERMODE_SIMPLE && this._pixelsPerUnit === null) {
      this.spriteFrame = this.spriteFrame;
    }
  }, _onAtlasTextureChange:function() {
    if (this.sprite && this.sprite.atlas && this.sprite.atlas.texture) {
      this._meshInstance.setParameter("texture_emissiveMap", this._sprite.atlas.texture);
      this._meshInstance.setParameter("texture_opacityMap", this._sprite.atlas.texture);
    } else {
      this._meshInstance.deleteParameter("texture_emissiveMap");
      this._meshInstance.deleteParameter("texture_opacityMap");
    }
  }, _onTextureAtlasLoad:function(atlasAsset) {
    var spriteAsset = this._spriteAsset;
    if (spriteAsset instanceof pc.Asset) {
      this._onSpriteAssetLoad(spriteAsset);
    } else {
      this._onSpriteAssetLoad(this._system.app.assets.get(spriteAsset));
    }
  }, _onSpriteAssetChange:function(asset) {
    this._onSpriteAssetLoad(asset);
  }, _onSpriteAssetRemove:function(asset) {
  }, onEnable:function() {
    if (this._model) {
      this._element.addModelToLayers(this._model);
    }
  }, onDisable:function() {
    if (this._model) {
      this._element.removeModelFromLayers(this._model);
    }
  }});
  Object.defineProperty(ImageElement.prototype, "color", {get:function() {
    return this._color;
  }, set:function(value) {
    this._color.data[0] = value.data[0];
    this._color.data[1] = value.data[1];
    this._color.data[2] = value.data[2];
    if (this._meshInstance) {
      this._meshInstance.setParameter("material_emissive", this._color.data3);
    }
    if (this._element) {
      this._element.fire("set:color", this._color);
    }
  }});
  Object.defineProperty(ImageElement.prototype, "opacity", {get:function() {
    return this._color.data[3];
  }, set:function(value) {
    this._color.data[3] = value;
    this._meshInstance.setParameter("material_opacity", value);
    if (this._element) {
      this._element.fire("set:opacity", this._color.data[3]);
    }
  }});
  Object.defineProperty(ImageElement.prototype, "rect", {get:function() {
    return this._rect;
  }, set:function(value) {
    if (value instanceof pc.Vec4) {
      this._rect.set(value.x, value.y, value.z, value.w);
    } else {
      this._rect.set(value[0], value[1], value[2], value[3]);
    }
    if (this._mesh) {
      this._updateMesh(this._mesh);
    }
  }});
  Object.defineProperty(ImageElement.prototype, "material", {get:function() {
    return this._material;
  }, set:function(value) {
    if (!value) {
      var screenSpace = this._element.screen ? this._element.screen.screen.screenSpace : false;
      value = screenSpace ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial;
      value = this._mask ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial;
    }
    this._material = value;
    if (value) {
      this._meshInstance.material = value;
      if (this._hasUserMaterial()) {
        this._meshInstance.deleteParameter("material_opacity");
        this._meshInstance.deleteParameter("material_emissive");
      } else {
        this._meshInstance.setParameter("material_emissive", this._color.data3);
        this._meshInstance.setParameter("material_opacity", this._color.data[3]);
      }
    }
  }});
  Object.defineProperty(ImageElement.prototype, "materialAsset", {get:function() {
    return this._materialAsset;
  }, set:function(value) {
    var assets = this._system.app.assets;
    var _id = value;
    if (value instanceof pc.Asset) {
      _id = value.id;
    }
    if (this._materialAsset !== _id) {
      if (this._materialAsset) {
        var _prev = assets.get(this._materialAsset);
        if (_prev) {
          _prev.off("load", this._onMaterialLoad, this);
          _prev.off("change", this._onMaterialChange, this);
          _prev.off("remove", this._onMaterialRemove, this);
        }
      }
      this._materialAsset = _id;
      if (this._materialAsset) {
        var asset = assets.get(this._materialAsset);
        if (!asset) {
          this.material = null;
          assets.on("add:" + this._materialAsset, this._onMaterialAdded, this);
        } else {
          this._bindMaterialAsset(asset);
        }
      } else {
        this.material = null;
      }
    }
  }});
  Object.defineProperty(ImageElement.prototype, "texture", {get:function() {
    return this._texture;
  }, set:function(value) {
    this._texture = value;
    if (value) {
      this._meshInstance.setParameter("texture_emissiveMap", this._texture);
      this._meshInstance.setParameter("texture_opacityMap", this._texture);
      this._meshInstance.setParameter("material_emissive", this._color.data3);
      this._meshInstance.setParameter("material_opacity", this._color.data[3]);
    } else {
      this._meshInstance.deleteParameter("texture_emissiveMap");
      this._meshInstance.deleteParameter("texture_opacityMap");
    }
  }});
  Object.defineProperty(ImageElement.prototype, "textureAsset", {get:function() {
    return this._textureAsset;
  }, set:function(value) {
    var assets = this._system.app.assets;
    var _id = value;
    if (value instanceof pc.Asset) {
      _id = value.id;
    }
    if (this._textureAsset !== _id) {
      if (this._textureAsset) {
        var _prev = assets.get(this._textureAsset);
        if (_prev) {
          _prev.off("load", this._onTextureLoad, this);
          _prev.off("change", this._onTextureChange, this);
          _prev.off("remove", this._onTextureRemove, this);
        }
      }
      this._textureAsset = _id;
      if (this._textureAsset) {
        var asset = assets.get(this._textureAsset);
        if (!asset) {
          this.texture = null;
          assets.on("add:" + this._textureAsset, this._onTextureAdded, this);
        } else {
          this._bindTextureAsset(asset);
        }
      } else {
        this.texture = null;
      }
    }
  }});
  Object.defineProperty(ImageElement.prototype, "spriteAsset", {get:function() {
    return this._spriteAsset;
  }, set:function(value) {
    var assets = this._system.app.assets;
    var _id = value;
    if (value instanceof pc.Asset) {
      _id = value.id;
    }
    if (this._spriteAsset !== _id) {
      if (this._spriteAsset) {
        var _prev = assets.get(this._spriteAsset);
        if (_prev) {
          _prev.off("load", this._onSpriteAssetLoad, this);
          _prev.off("change", this._onSpriteAssetChange, this);
          _prev.off("remove", this._onSpriteAssetRemove, this);
        }
      }
      this._spriteAsset = _id;
      if (this._spriteAsset) {
        var asset = assets.get(this._spriteAsset);
        if (!asset) {
          this.sprite = null;
          assets.on("add:" + this._spriteAsset, this._onSpriteAssetAdded, this);
        } else {
          this._bindSpriteAsset(asset);
        }
      } else {
        this.sprite = null;
      }
      if (this._element) {
        this._element.fire("set:spriteAsset", _id);
      }
    }
  }});
  Object.defineProperty(ImageElement.prototype, "sprite", {get:function() {
    return this._sprite;
  }, set:function(value) {
    if (this._sprite) {
      this._sprite.off("set:meshes", this._onSpriteMeshesChange, this);
      this._sprite.off("set:pixelsPerUnit", this._onSpritePpuChange, this);
      this._sprite.off("set:atlas", this._onAtlasTextureChange, this);
      if (this._sprite.atlas) {
        this._sprite.atlas.off("set:texture", this._onAtlasTextureChange, this);
      }
    }
    this._sprite = value;
    if (this._sprite) {
      this._sprite.on("set:meshes", this._onSpriteMeshesChange, this);
      this._sprite.on("set:pixelsPerUnit", this._onSpritePpuChange, this);
      this._sprite.on("set:atlas", this._onAtlasTextureChange, this);
      if (this._sprite.atlas) {
        this._sprite.atlas.on("set:texture", this._onAtlasTextureChange, this);
      }
    }
    if (this._meshInstance) {
      if (this._sprite && this._sprite.atlas && this._sprite.atlas.texture) {
        this._meshInstance.setParameter("texture_emissiveMap", this._sprite.atlas.texture);
        this._meshInstance.setParameter("texture_opacityMap", this._sprite.atlas.texture);
      } else {
        this._meshInstance.deleteParameter("texture_emissiveMap");
        this._meshInstance.deleteParameter("texture_opacityMap");
      }
    }
    this.spriteFrame = this.spriteFrame;
  }});
  Object.defineProperty(ImageElement.prototype, "spriteFrame", {get:function() {
    return this._spriteFrame;
  }, set:function(value) {
    if (this._sprite) {
      this._spriteFrame = pc.math.clamp(value, 0, this._sprite.frameKeys.length - 1);
    } else {
      this._spriteFrame = value;
    }
    var nineSlice = false;
    var mesh = null;
    if (this._sprite && this._sprite.atlas) {
      mesh = this._sprite.meshes[this.spriteFrame];
      nineSlice = this._sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === pc.SPRITE_RENDERMODE_TILED;
    }
    this.mesh = nineSlice ? mesh : this._defaultMesh;
    if (this.mesh) {
      this._updateMesh(this.mesh);
    }
    if (this._element) {
      this._element.fire("set:spriteFrame", value);
    }
  }});
  Object.defineProperty(ImageElement.prototype, "mesh", {get:function() {
    return this._mesh;
  }, set:function(value) {
    this._mesh = value;
    if (this._meshInstance) {
      this._meshInstance.mesh = this._mesh;
      this._meshInstance.visible = !!this._mesh;
      this._meshInstance._aabbVer = -1;
      if (this._mesh === this._defaultMesh) {
        this._meshInstance._updateAabbFunc = null;
      } else {
        this._meshInstance._updateAabbFunc = this._updateAabbFunc;
      }
    }
  }});
  Object.defineProperty(ImageElement.prototype, "mask", {get:function() {
    return this._mask;
  }, set:function(value) {
    if (this._mask !== value) {
      this._mask = value;
      this._toggleMask();
    }
  }});
  Object.defineProperty(ImageElement.prototype, "pixelsPerUnit", {get:function() {
    return this._pixelsPerUnit;
  }, set:function(value) {
    if (this._pixelsPerUnit === value) {
      return;
    }
    this._pixelsPerUnit = value;
    if (this._sprite && (this._sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === pc.SPRITE_RENDERMODE_TILED)) {
      this.spriteFrame = this.spriteFrame;
    }
  }});
  return {ImageElement:ImageElement};
}());
Object.assign(pc, function() {
  var TextElement = function TextElement(element) {
    this._element = element;
    this._system = element.system;
    this._entity = element.entity;
    this._text = "";
    this._fontAsset = null;
    this._font = null;
    this._color = new pc.Color(1, 1, 1, 1);
    this._spacing = 1;
    this._fontSize = 32;
    this._lineHeight = 32;
    this._wrapLines = false;
    this._drawOrder = 0;
    this._alignment = new pc.Vec2(0.5, 0.5);
    this._autoWidth = true;
    this._autoHeight = true;
    this.width = 0;
    this.height = 0;
    this._node = new pc.GraphNode;
    this._model = new pc.Model;
    this._model.graph = this._node;
    this._entity.addChild(this._node);
    this._meshInfo = [];
    this._material = null;
    this._noResize = false;
    this._currentMaterialType = null;
    this._maskedMaterialSrc = null;
    this._onScreenChange(this._element.screen);
    element.on("resize", this._onParentResize, this);
    this._element.on("set:screen", this._onScreenChange, this);
    element.on("screen:set:screenspace", this._onScreenSpaceChange, this);
    element.on("set:draworder", this._onDrawOrderChange, this);
    element.on("set:pivot", this._onPivotChange, this);
  };
  var LINE_BREAK_CHAR = /^[\r\n]$/;
  var WHITESPACE_CHAR = /^[ \t]$/;
  var WORD_BOUNDARY_CHAR = /^[ \t\-]$/;
  Object.assign(TextElement.prototype, {destroy:function() {
    if (this._model) {
      this._element.removeModelFromLayers(this._model);
      this._model.destroy();
      this._model = null;
    }
    this._element.off("resize", this._onParentResize, this);
    this._element.off("set:screen", this._onScreenChange, this);
    this._element.off("screen:set:screenspace", this._onScreenSpaceChange, this);
    this._element.off("set:draworder", this._onDrawOrderChange, this);
    this._element.off("set:pivot", this._onPivotChange, this);
  }, _onParentResize:function(width, height) {
    if (this._noResize) {
      return;
    }
    if (this._font) {
      this._updateText(this._text);
    }
  }, _onScreenChange:function(screen) {
    if (screen) {
      this._updateMaterial(screen.screen.screenSpace);
    } else {
      this._updateMaterial(false);
    }
  }, _onScreenSpaceChange:function(value) {
    this._updateMaterial(value);
  }, _onDrawOrderChange:function(order) {
    this._drawOrder = order;
    if (this._model) {
      var i;
      var len;
      for (i = 0, len = this._model.meshInstances.length;i < len;i++) {
        this._model.meshInstances[i].drawOrder = order;
      }
    }
  }, _onPivotChange:function(pivot) {
    if (this._font) {
      this._updateText();
    }
  }, _updateText:function(text) {
    var i;
    var len;
    if (text === undefined) {
      text = this._text;
    }
    var textLength = text.length;
    if (textLength === 0) {
      textLength = 1;
      text = " ";
    }
    var charactersPerTexture = {};
    for (i = 0;i < textLength;i++) {
      var code = text.charCodeAt(i);
      var info = this._font.data.chars[code];
      if (!info) {
        continue;
      }
      var map = info.map;
      if (!charactersPerTexture[map]) {
        charactersPerTexture[map] = 0;
      }
      charactersPerTexture[map]++;
    }
    var removedModel = false;
    var screenSpace = this._element.screen && this._element.screen.screen.screenSpace;
    for (i = 0, len = this._meshInfo.length;i < len;i++) {
      var l = charactersPerTexture[i] || 0;
      var meshInfo = this._meshInfo[i];
      if (meshInfo.count !== l) {
        if (!removedModel) {
          this._element.removeModelFromLayers(this._model);
          removedModel = true;
        }
        meshInfo.count = l;
        meshInfo.positions.length = meshInfo.normals.length = l * 3 * 4;
        meshInfo.indices.length = l * 3 * 2;
        meshInfo.uvs.length = l * 2 * 4;
        if (meshInfo.meshInstance) {
          this._removeMeshInstance(meshInfo.meshInstance);
        }
        if (l === 0) {
          meshInfo.meshInstance = null;
          continue;
        }
        for (var v = 0;v < l;v++) {
          meshInfo.indices[v * 3 * 2 + 0] = v * 4;
          meshInfo.indices[v * 3 * 2 + 1] = v * 4 + 1;
          meshInfo.indices[v * 3 * 2 + 2] = v * 4 + 3;
          meshInfo.indices[v * 3 * 2 + 3] = v * 4 + 2;
          meshInfo.indices[v * 3 * 2 + 4] = v * 4 + 3;
          meshInfo.indices[v * 3 * 2 + 5] = v * 4 + 1;
          meshInfo.normals[v * 4 * 3 + 0] = 0;
          meshInfo.normals[v * 4 * 3 + 1] = 0;
          meshInfo.normals[v * 4 * 3 + 2] = -1;
          meshInfo.normals[v * 4 * 3 + 3] = 0;
          meshInfo.normals[v * 4 * 3 + 4] = 0;
          meshInfo.normals[v * 4 * 3 + 5] = -1;
          meshInfo.normals[v * 4 * 3 + 6] = 0;
          meshInfo.normals[v * 4 * 3 + 7] = 0;
          meshInfo.normals[v * 4 * 3 + 8] = -1;
          meshInfo.normals[v * 4 * 3 + 9] = 0;
          meshInfo.normals[v * 4 * 3 + 10] = 0;
          meshInfo.normals[v * 4 * 3 + 11] = -1;
        }
        var mesh = pc.createMesh(this._system.app.graphicsDevice, meshInfo.positions, {uvs:meshInfo.uvs, normals:meshInfo.normals, indices:meshInfo.indices});
        var mi = new pc.MeshInstance(this._node, mesh, this._material);
        mi.castShadow = false;
        mi.receiveShadow = false;
        mi.drawOrder = this._drawOrder;
        if (screenSpace) {
          mi.cull = false;
        }
        mi.screenSpace = screenSpace;
        mi.setParameter("texture_msdfMap", this._font.textures[i]);
        mi.setParameter("material_emissive", this._color.data3);
        mi.setParameter("material_opacity", this._color.data[3]);
        mi.setParameter("font_sdfIntensity", this._font.intensity);
        mi.setParameter("font_pxrange", this._getPxRange(this._font));
        mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);
        meshInfo.meshInstance = mi;
        this._model.meshInstances.push(mi);
      }
    }
    if (this._maskedBy) {
      this._element._setMaskedBy(this._maskedBy);
    }
    if (removedModel && this._element.enabled && this._entity.enabled) {
      this._element.addModelToLayers(this._model);
    }
    this._updateMeshes(text);
  }, _removeMeshInstance:function(meshInstance) {
    var ib;
    var iblen;
    var oldMesh = meshInstance.mesh;
    if (oldMesh) {
      if (oldMesh.vertexBuffer) {
        oldMesh.vertexBuffer.destroy();
      }
      if (oldMesh.indexBuffer) {
        for (ib = 0, iblen = oldMesh.indexBuffer.length;ib < iblen;ib++) {
          oldMesh.indexBuffer[ib].destroy();
        }
      }
    }
    var idx = this._model.meshInstances.indexOf(meshInstance);
    if (idx !== -1) {
      this._model.meshInstances.splice(idx, 1);
    }
  }, _setMaterial:function(material) {
    var i;
    var len;
    this._material = material;
    if (this._model) {
      for (i = 0, len = this._model.meshInstances.length;i < len;i++) {
        var mi = this._model.meshInstances[i];
        mi.material = material;
      }
    }
  }, _updateMaterial:function(screenSpace) {
    var cull;
    if (screenSpace) {
      this._material = this._system.defaultScreenSpaceTextMaterial;
      cull = false;
    } else {
      this._material = this._system.defaultTextMaterial;
      cull = true;
    }
    if (this._model) {
      for (var i = 0, len = this._model.meshInstances.length;i < len;i++) {
        var mi = this._model.meshInstances[i];
        mi.cull = cull;
        mi.material = this._material;
        mi.screenSpace = screenSpace;
      }
    }
  }, _updateMeshes:function(text) {
    var json = this._font.data;
    var self = this;
    this.width = 0;
    this.height = 0;
    this._lineWidths = [];
    this._lineContents = [];
    var l = text.length;
    var _x = 0;
    var _xMinusTrailingWhitespace = 0;
    var _y = 0;
    var _z = 0;
    var lines = 1;
    var wordStartX = 0;
    var wordStartIndex = 0;
    var lineStartIndex = 0;
    var numWordsThisLine = 0;
    var numCharsThisLine = 0;
    var splitHorizontalAnchors = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 0.0001;
    var maxLineWidth = this._element.calculatedWidth;
    if (this.autoWidth && !splitHorizontalAnchors || !this._wrapLines) {
      maxLineWidth = Number.POSITIVE_INFINITY;
    }
    var fontMinY = 0;
    var fontMaxY = 0;
    var scale = 1;
    var MAGIC = 32;
    var char, charCode, data, i, quad;
    for (charCode in json.chars) {
      data = json.chars[charCode];
      scale = data.height / MAGIC * this._fontSize / data.height;
      if (data.bounds) {
        fontMinY = Math.min(fontMinY, data.bounds[1] * scale);
        fontMaxY = Math.max(fontMaxY, data.bounds[3] * scale);
      }
    }
    for (i = 0;i < this._meshInfo.length;i++) {
      this._meshInfo[i].quad = 0;
      this._meshInfo[i].lines = {};
    }
    function breakLine(lineBreakIndex, lineBreakX) {
      self._lineWidths.push(lineBreakX);
      self._lineContents.push(text.substring(lineStartIndex, lineBreakIndex));
      _x = 0;
      _y -= self._lineHeight;
      lines++;
      numWordsThisLine = 0;
      numCharsThisLine = 0;
      wordStartX = 0;
      lineStartIndex = lineBreakIndex;
    }
    for (i = 0;i < l;i++) {
      char = text.charAt(i);
      charCode = text.charCodeAt(i);
      var x = 0;
      var y = 0;
      var advance = 0;
      var quadsize = 1;
      var glyphMinX = 0;
      var glyphWidth = 0;
      data = json.chars[charCode];
      if (data && data.scale) {
        var size = (data.width + data.height) / 2;
        scale = size / MAGIC * this._fontSize / size;
        quadsize = size / MAGIC * this._fontSize / data.scale;
        advance = data.xadvance * scale;
        x = data.xoffset * scale;
        y = data.yoffset * scale;
        if (data.bounds) {
          glyphWidth = (data.bounds[2] - data.bounds[0]) * scale;
          glyphMinX = data.bounds[0] * scale;
        } else {
          glyphWidth = x;
          glyphMinX = 0;
        }
      } else {
        advance = 1;
        x = 0;
        y = 0;
        quadsize = this._fontSize;
      }
      var isLineBreak = LINE_BREAK_CHAR.test(char);
      var isWordBoundary = WORD_BOUNDARY_CHAR.test(char);
      var isWhitespace = WHITESPACE_CHAR.test(char);
      if (isLineBreak) {
        breakLine(i, _xMinusTrailingWhitespace);
        wordStartIndex = i + 1;
        lineStartIndex = i + 1;
        continue;
      }
      var meshInfo = this._meshInfo[data && data.map || 0];
      var candidateLineWidth = _x + glyphWidth + glyphMinX;
      if (candidateLineWidth >= maxLineWidth && numCharsThisLine > 0 && !isWhitespace) {
        if (numWordsThisLine === 0) {
          wordStartIndex = i;
          breakLine(i, _xMinusTrailingWhitespace);
        } else {
          var backtrack = Math.max(i - wordStartIndex, 0);
          i -= backtrack + 1;
          meshInfo.lines[lines - 1] -= backtrack;
          meshInfo.quad -= backtrack;
          breakLine(wordStartIndex, wordStartX);
          continue;
        }
      }
      quad = meshInfo.quad;
      meshInfo.lines[lines - 1] = quad;
      meshInfo.positions[quad * 4 * 3 + 0] = _x - x;
      meshInfo.positions[quad * 4 * 3 + 1] = _y - y;
      meshInfo.positions[quad * 4 * 3 + 2] = _z;
      meshInfo.positions[quad * 4 * 3 + 3] = _x - x + quadsize;
      meshInfo.positions[quad * 4 * 3 + 4] = _y - y;
      meshInfo.positions[quad * 4 * 3 + 5] = _z;
      meshInfo.positions[quad * 4 * 3 + 6] = _x - x + quadsize;
      meshInfo.positions[quad * 4 * 3 + 7] = _y - y + quadsize;
      meshInfo.positions[quad * 4 * 3 + 8] = _z;
      meshInfo.positions[quad * 4 * 3 + 9] = _x - x;
      meshInfo.positions[quad * 4 * 3 + 10] = _y - y + quadsize;
      meshInfo.positions[quad * 4 * 3 + 11] = _z;
      this.width = Math.max(this.width, _x + glyphWidth + glyphMinX);
      this.height = Math.max(this.height, fontMaxY - (_y + fontMinY));
      _x += this._spacing * advance;
      if (!isWhitespace && !isLineBreak) {
        _xMinusTrailingWhitespace = _x;
      }
      if (isWordBoundary) {
        numWordsThisLine++;
        wordStartX = _xMinusTrailingWhitespace;
        wordStartIndex = i + 1;
      }
      numCharsThisLine++;
      var uv = this._getUv(charCode);
      meshInfo.uvs[quad * 4 * 2 + 0] = uv[0];
      meshInfo.uvs[quad * 4 * 2 + 1] = uv[1];
      meshInfo.uvs[quad * 4 * 2 + 2] = uv[2];
      meshInfo.uvs[quad * 4 * 2 + 3] = uv[1];
      meshInfo.uvs[quad * 4 * 2 + 4] = uv[2];
      meshInfo.uvs[quad * 4 * 2 + 5] = uv[3];
      meshInfo.uvs[quad * 4 * 2 + 6] = uv[0];
      meshInfo.uvs[quad * 4 * 2 + 7] = uv[3];
      meshInfo.quad++;
    }
    if (lineStartIndex < l) {
      breakLine(l, _x);
    }
    this._noResize = true;
    this.autoWidth = this._autoWidth;
    this.autoHeight = this._autoHeight;
    this._noResize = false;
    var hp = this._element.pivot.data[0];
    var vp = this._element.pivot.data[1];
    var ha = this._alignment.x;
    var va = this._alignment.y;
    for (i = 0;i < this._meshInfo.length;i++) {
      if (this._meshInfo[i].count === 0) {
        continue;
      }
      var prevQuad = 0;
      for (var line in this._meshInfo[i].lines) {
        var index = this._meshInfo[i].lines[line];
        var hoffset = -hp * this._element.calculatedWidth + ha * (this._element.calculatedWidth - this._lineWidths[parseInt(line, 10)]);
        var voffset = (1 - vp) * this._element.calculatedHeight - fontMaxY - (1 - va) * (this._element.calculatedHeight - this.height);
        for (quad = prevQuad;quad <= index;quad++) {
          this._meshInfo[i].positions[quad * 4 * 3] += hoffset;
          this._meshInfo[i].positions[quad * 4 * 3 + 3] += hoffset;
          this._meshInfo[i].positions[quad * 4 * 3 + 6] += hoffset;
          this._meshInfo[i].positions[quad * 4 * 3 + 9] += hoffset;
          this._meshInfo[i].positions[quad * 4 * 3 + 1] += voffset;
          this._meshInfo[i].positions[quad * 4 * 3 + 4] += voffset;
          this._meshInfo[i].positions[quad * 4 * 3 + 7] += voffset;
          this._meshInfo[i].positions[quad * 4 * 3 + 10] += voffset;
        }
        prevQuad = index + 1;
      }
      var numVertices = this._meshInfo[i].quad * 4;
      var it = new pc.VertexIterator(this._meshInfo[i].meshInstance.mesh.vertexBuffer);
      for (var v = 0;v < numVertices;v++) {
        it.element[pc.SEMANTIC_POSITION].set(this._meshInfo[i].positions[v * 3 + 0], this._meshInfo[i].positions[v * 3 + 1], this._meshInfo[i].positions[v * 3 + 2]);
        it.element[pc.SEMANTIC_TEXCOORD0].set(this._meshInfo[i].uvs[v * 2 + 0], this._meshInfo[i].uvs[v * 2 + 1]);
        it.next();
      }
      it.end();
      this._meshInfo[i].meshInstance.mesh.aabb.compute(this._meshInfo[i].positions);
      this._meshInfo[i].meshInstance._aabbVer = -1;
    }
  }, _onFontAdded:function(asset) {
    this._system.app.assets.off("add:" + asset.id, this._onFontAdded, this);
    if (asset.id === this._fontAsset) {
      this._bindFont(asset);
    }
  }, _bindFont:function(asset) {
    asset.on("load", this._onFontLoad, this);
    asset.on("change", this._onFontChange, this);
    asset.on("remove", this._onFontRemove, this);
    if (asset.resource) {
      this._onFontLoad(asset);
    } else {
      this._system.app.assets.load(asset);
    }
  }, _onFontLoad:function(asset) {
    if (this.font !== asset.resource) {
      this.font = asset.resource;
    }
  }, _onFontChange:function(asset, name, _new, _old) {
    if (name === "data") {
      this._font.data = _new;
      var maps = this._font.data.info.maps.length;
      for (var i = 0;i < maps;i++) {
        if (!this._meshInfo[i]) {
          continue;
        }
        var mi = this._meshInfo[i].meshInstance;
        if (mi) {
          mi.setParameter("font_sdfIntensity", this._font.intensity);
          mi.setParameter("font_pxrange", this._getPxRange(this._font));
          mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);
        }
      }
    }
  }, _onFontRemove:function(asset) {
  }, _getPxRange:function(font) {
    var keys = Object.keys(this._font.data.chars);
    for (var i = 0;i < keys.length;i++) {
      var char = this._font.data.chars[keys[i]];
      if (char.scale && char.range) {
        return char.scale * char.range;
      }
    }
    return 2;
  }, _getUv:function(char) {
    var data = this._font.data;
    if (!data.chars[char]) {
      if (data.chars[32]) {
        return this._getUv(32);
      }
      return [0, 0, 1, 1];
    }
    var map = data.chars[char].map;
    var width = data.info.maps[map].width;
    var height = data.info.maps[map].height;
    var x = data.chars[char].x;
    var y = data.chars[char].y;
    var x1 = x;
    var y1 = y;
    var x2 = x + data.chars[char].width;
    var y2 = y - data.chars[char].height;
    var edge = 1 - data.chars[char].height / height;
    return [x1 / width, edge - y1 / height, x2 / width, edge - y2 / height];
  }, onEnable:function() {
    if (this._model) {
      this._element.addModelToLayers(this._model);
    }
  }, onDisable:function() {
    if (this._model) {
      this._element.removeModelFromLayers(this._model);
    }
  }});
  Object.defineProperty(TextElement.prototype, "text", {get:function() {
    return this._text;
  }, set:function(value) {
    var str = value.toString();
    if (this._text !== str) {
      if (this._font) {
        this._updateText(str);
      }
      this._text = str;
    }
  }});
  Object.defineProperty(TextElement.prototype, "color", {get:function() {
    return this._color;
  }, set:function(value) {
    this._color.data[0] = value.data[0];
    this._color.data[1] = value.data[1];
    this._color.data[2] = value.data[2];
    if (this._model) {
      for (var i = 0, len = this._model.meshInstances.length;i < len;i++) {
        var mi = this._model.meshInstances[i];
        mi.setParameter("material_emissive", this._color.data3);
      }
    }
  }});
  Object.defineProperty(TextElement.prototype, "opacity", {get:function() {
    return this._color.data[3];
  }, set:function(value) {
    this._color.data[3] = value;
    if (this._model) {
      for (var i = 0, len = this._model.meshInstances.length;i < len;i++) {
        var mi = this._model.meshInstances[i];
        mi.setParameter("material_opacity", value);
      }
    }
  }});
  Object.defineProperty(TextElement.prototype, "lineHeight", {get:function() {
    return this._lineHeight;
  }, set:function(value) {
    var _prev = this._lineHeight;
    this._lineHeight = value;
    if (_prev !== value && this._font) {
      this._updateText();
    }
  }});
  Object.defineProperty(TextElement.prototype, "wrapLines", {get:function() {
    return this._wrapLines;
  }, set:function(value) {
    var _prev = this._wrapLines;
    this._wrapLines = value;
    if (_prev !== value && this._font) {
      this._updateText();
    }
  }});
  Object.defineProperty(TextElement.prototype, "lines", {get:function() {
    return this._lineContents;
  }});
  Object.defineProperty(TextElement.prototype, "spacing", {get:function() {
    return this._spacing;
  }, set:function(value) {
    var _prev = this._spacing;
    this._spacing = value;
    if (_prev !== value && this._font) {
      this._updateText();
    }
  }});
  Object.defineProperty(TextElement.prototype, "fontSize", {get:function() {
    return this._fontSize;
  }, set:function(value) {
    var _prev = this._fontSize;
    this._fontSize = value;
    if (_prev !== value && this._font) {
      this._updateText();
    }
  }});
  Object.defineProperty(TextElement.prototype, "fontAsset", {get function() {
    return this._fontAsset;
  }, set:function(value) {
    var assets = this._system.app.assets;
    var _id = value;
    if (value instanceof pc.Asset) {
      _id = value.id;
    }
    if (this._fontAsset !== _id) {
      if (this._fontAsset) {
        var _prev = assets.get(this._fontAsset);
        if (_prev) {
          _prev.off("load", this._onFontLoad, this);
          _prev.off("change", this._onFontChange, this);
          _prev.off("remove", this._onFontRemove, this);
        }
      }
      this._fontAsset = _id;
      if (this._fontAsset) {
        var asset = assets.get(this._fontAsset);
        if (!asset) {
          assets.on("add:" + this._fontAsset, this._onFontAdded, this);
        } else {
          this._bindFont(asset);
        }
      }
    }
  }});
  Object.defineProperty(TextElement.prototype, "font", {get:function() {
    return this._font;
  }, set:function(value) {
    var i;
    var len;
    this._font = value;
    if (!value) {
      return;
    }
    for (i = 0, len = this._font.textures.length;i < len;i++) {
      if (!this._meshInfo[i]) {
        this._meshInfo[i] = {count:0, quad:0, lines:{}, positions:[], normals:[], uvs:[], indices:[], meshInstance:null};
      } else {
        var mi = this._meshInfo[i].meshInstance;
        if (mi) {
          mi.setParameter("font_sdfIntensity", this._font.intensity);
          mi.setParameter("font_pxrange", this._getPxRange(this._font));
          mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);
          mi.setParameter("texture_msdfMap", this._font.textures[i]);
        }
      }
    }
    var removedModel = false;
    for (i = this._font.textures.length;i < this._meshInfo.length;i++) {
      if (this._meshInfo[i].meshInstance) {
        if (!removedModel) {
          this._element.removeModelFromLayers(this._model);
          removedModel = true;
        }
        this._removeMeshInstance(this._meshInfo[i].meshInstance);
      }
    }
    if (this._meshInfo.length > this._font.textures.length) {
      this._meshInfo.length = this._font.textures.length;
    }
    this._updateText();
  }});
  Object.defineProperty(TextElement.prototype, "alignment", {get:function() {
    return this._alignment;
  }, set:function(value) {
    if (value instanceof pc.Vec2) {
      this._alignment.set(value.x, value.y);
    } else {
      this._alignment.set(value[0], value[1]);
    }
    if (this._font) {
      this._updateText();
    }
  }});
  Object.defineProperty(TextElement.prototype, "autoWidth", {get:function() {
    return this._autoWidth;
  }, set:function(value) {
    this._autoWidth = value;
    if (value && Math.abs(this._element.anchor.x - this._element.anchor.z) < 0.0001) {
      this._element.width = this.width;
    }
  }});
  Object.defineProperty(TextElement.prototype, "autoHeight", {get:function() {
    return this._autoHeight;
  }, set:function(value) {
    this._autoHeight = value;
    if (value && Math.abs(this._element.anchor.y - this._element.anchor.w) < 0.0001) {
      this._element.height = this.height;
    }
  }});
  return {TextElement:TextElement};
}());
Object.assign(pc, function() {
  var _inputScreenPosition = new pc.Vec2;
  var _inputWorldPosition = new pc.Vec3;
  var _rayOrigin = new pc.Vec3;
  var _rayDirection = new pc.Vec3;
  var _planeOrigin = new pc.Vec3;
  var _planeNormal = new pc.Vec3;
  var _entityRotation = new pc.Quat;
  var OPPOSITE_AXIS = {x:"y", y:"x"};
  var ElementDragHelper = function ElementDragHelper(element, axis) {
    if (!element || !(element instanceof pc.ElementComponent)) {
      throw new Error("Element was null or not an ElementComponent");
    }
    if (axis && axis !== "x" && axis !== "y") {
      throw new Error("Unrecognized axis: " + axis);
    }
    this._element = element;
    this._app = element.system.app;
    this._axis = axis || null;
    this._enabled = true;
    this._dragScale = new pc.Vec3;
    this._dragStartMousePosition = new pc.Vec3;
    this._dragStartHandlePosition = new pc.Vec3;
    this._deltaMousePosition = new pc.Vec3;
    this._deltaHandlePosition = new pc.Vec3;
    this._isDragging = false;
    pc.events.attach(this);
    this._toggleLifecycleListeners("on");
  };
  Object.assign(ElementDragHelper.prototype, {_toggleLifecycleListeners:function(onOrOff) {
    this._element[onOrOff]("mousedown", this._onMouseDownOrTouchStart, this);
    this._element[onOrOff]("touchstart", this._onMouseDownOrTouchStart, this);
  }, _toggleDragListeners:function(onOrOff) {
    var isOn = onOrOff === "on";
    var addOrRemoveEventListener = isOn ? "addEventListener" : "removeEventListener";
    if (this._hasDragListeners && isOn) {
      return;
    }
    if (!this._handleMouseUpOrTouchEnd) {
      this._handleMouseUpOrTouchEnd = this._onMouseUpOrTouchEnd.bind(this);
    }
    this._app.mouse[onOrOff]("mousemove", this._onMove, this);
    window[addOrRemoveEventListener]("mouseup", this._handleMouseUpOrTouchEnd, false);
    if ("ontouchstart" in window) {
      this._app.touch[onOrOff]("touchmove", this._onMove, this);
      window[addOrRemoveEventListener]("touchend", this._handleMouseUpOrTouchEnd, false);
      window[addOrRemoveEventListener]("touchcancel", this._handleMouseUpOrTouchEnd, false);
    }
    this._hasDragListeners = isOn;
  }, _onMouseDownOrTouchStart:function(event) {
    if (this._element && !this._isDragging && this.enabled) {
      this._dragCamera = event.camera;
      this._calculateDragScale();
      var currentMousePosition = this._screenToLocal(event);
      if (currentMousePosition) {
        this._toggleDragListeners("on");
        this._isDragging = true;
        this._dragStartMousePosition.copy(currentMousePosition);
        this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition());
        this.fire("drag:start");
      }
    }
  }, _onMouseUpOrTouchEnd:function() {
    if (this._isDragging) {
      this._isDragging = false;
      this._toggleDragListeners("off");
      this.fire("drag:end");
    }
  }, _screenToLocal:function(event) {
    this._determineInputPosition(event);
    this._chooseRayOriginAndDirection();
    _planeOrigin.copy(this._element.entity.getPosition());
    _planeNormal.copy(this._element.entity.forward).scale(-1);
    var denominator = _planeNormal.dot(_rayDirection);
    if (Math.abs(denominator) > 0) {
      var rayOriginToPlaneOrigin = _planeOrigin.sub(_rayOrigin);
      var collisionDistance = rayOriginToPlaneOrigin.dot(_planeNormal) / denominator;
      var position = _rayOrigin.add(_rayDirection.scale(collisionDistance));
      _entityRotation.copy(this._element.entity.getRotation()).invert().transformVector(position, position);
      position.mul(this._dragScale);
      return position;
    }
    return null;
  }, _determineInputPosition:function(event) {
    if (typeof event.x !== "undefined" && typeof event.y !== "undefined") {
      _inputScreenPosition.x = event.x;
      _inputScreenPosition.y = event.y;
    } else {
      if (event.changedTouches) {
        _inputScreenPosition.x = event.changedTouches[0].x;
        _inputScreenPosition.y = event.changedTouches[0].y;
      } else {
        console.warn("Could not determine position from input event");
      }
    }
  }, _chooseRayOriginAndDirection:function() {
    if (this._element.screen && this._element.screen.screen.screenSpace) {
      _rayOrigin.set(_inputScreenPosition.x, -_inputScreenPosition.y, 0);
      _rayDirection.set(0, 0, -1);
    } else {
      _inputWorldPosition.copy(this._dragCamera.screenToWorld(_inputScreenPosition.x, _inputScreenPosition.y, 1));
      _rayOrigin.copy(this._dragCamera.entity.getPosition());
      _rayDirection.copy(_inputWorldPosition).sub(_rayOrigin).normalize();
    }
  }, _calculateDragScale:function() {
    var current = this._element.entity.parent;
    var screen = this._element.screen && this._element.screen.screen;
    var isWithin2DScreen = screen && screen.screenSpace;
    var screenScale = isWithin2DScreen ? screen.scale : 1;
    var dragScale = this._dragScale;
    dragScale.set(screenScale, screenScale, screenScale);
    while (current) {
      dragScale.mul(current.getLocalScale());
      current = current.parent;
      if (isWithin2DScreen && current.screen) {
        break;
      }
    }
    dragScale.data[0] = 1 / dragScale.data[0];
    dragScale.data[1] = 1 / dragScale.data[1];
    dragScale.data[2] = 1 / dragScale.data[2];
  }, _onMove:function(event) {
    if (this._element && this._isDragging && this.enabled && this._element.enabled && this._element.entity.enabled) {
      var currentMousePosition = this._screenToLocal(event);
      if (this._dragStartMousePosition && currentMousePosition) {
        this._deltaMousePosition.copy(currentMousePosition).sub(this._dragStartMousePosition);
        this._deltaHandlePosition.copy(this._dragStartHandlePosition).add(this._deltaMousePosition);
        if (this._axis) {
          var currentPosition = this._element.entity.getLocalPosition();
          var constrainedAxis = OPPOSITE_AXIS[this._axis];
          this._deltaHandlePosition[constrainedAxis] = currentPosition[constrainedAxis];
        }
        this._element.entity.setLocalPosition(this._deltaHandlePosition);
        this.fire("drag:move", this._deltaHandlePosition);
      }
    }
  }, destroy:function() {
    this._toggleLifecycleListeners("off");
    this._toggleDragListeners("off");
  }});
  Object.defineProperty(ElementDragHelper.prototype, "enabled", {get:function() {
    return this._enabled;
  }, set:function(value) {
    this._enabled = value;
  }});
  Object.defineProperty(ElementDragHelper.prototype, "isDragging", {get:function() {
    return this._isDragging;
  }});
  return {ElementDragHelper:ElementDragHelper};
}());
Object.assign(pc, {BUTTON_TRANSITION_MODE_TINT:0, BUTTON_TRANSITION_MODE_SPRITE_CHANGE:1});
Object.assign(pc, function() {
  var VisualState = {DEFAULT:"DEFAULT", HOVER:"HOVER", PRESSED:"PRESSED", INACTIVE:"INACTIVE"};
  var STATES_TO_TINT_NAMES = {};
  STATES_TO_TINT_NAMES[VisualState.DEFAULT] = "_defaultTint";
  STATES_TO_TINT_NAMES[VisualState.HOVER] = "hoverTint";
  STATES_TO_TINT_NAMES[VisualState.PRESSED] = "pressedTint";
  STATES_TO_TINT_NAMES[VisualState.INACTIVE] = "inactiveTint";
  var STATES_TO_SPRITE_ASSET_NAMES = {};
  STATES_TO_SPRITE_ASSET_NAMES[VisualState.DEFAULT] = "_defaultSpriteAsset";
  STATES_TO_SPRITE_ASSET_NAMES[VisualState.HOVER] = "hoverSpriteAsset";
  STATES_TO_SPRITE_ASSET_NAMES[VisualState.PRESSED] = "pressedSpriteAsset";
  STATES_TO_SPRITE_ASSET_NAMES[VisualState.INACTIVE] = "inactiveSpriteAsset";
  var STATES_TO_SPRITE_FRAME_NAMES = {};
  STATES_TO_SPRITE_FRAME_NAMES[VisualState.DEFAULT] = "_defaultSpriteFrame";
  STATES_TO_SPRITE_FRAME_NAMES[VisualState.HOVER] = "hoverSpriteFrame";
  STATES_TO_SPRITE_FRAME_NAMES[VisualState.PRESSED] = "pressedSpriteFrame";
  STATES_TO_SPRITE_FRAME_NAMES[VisualState.INACTIVE] = "inactiveSpriteFrame";
  var ButtonComponent = function ButtonComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this._visualState = VisualState.DEFAULT;
    this._isHovering = false;
    this._isPressed = false;
    this._defaultTint = new pc.Color(1, 1, 1, 1);
    this._defaultSpriteAsset = null;
    this._defaultSpriteFrame = 0;
    this._imageReference = new pc.EntityReference(this, "imageEntity", {"element#gain":this._onImageElementGain, "element#lose":this._onImageElementLose, "element#set:color":this._onSetColor, "element#set:opacity":this._onSetOpacity, "element#set:spriteAsset":this._onSetSpriteAsset, "element#set:spriteFrame":this._onSetSpriteFrame});
    this._toggleLifecycleListeners("on", system);
  };
  ButtonComponent.prototype = Object.create(pc.Component.prototype);
  ButtonComponent.prototype.constructor = ButtonComponent;
  Object.assign(ButtonComponent.prototype, {_toggleLifecycleListeners:function(onOrOff, system) {
    this[onOrOff]("set_active", this._onSetActive, this);
    this[onOrOff]("set_transitionMode", this._onSetTransitionMode, this);
    this[onOrOff]("set_hoverTint", this._onSetTransitionValue, this);
    this[onOrOff]("set_pressedTint", this._onSetTransitionValue, this);
    this[onOrOff]("set_inactiveTint", this._onSetTransitionValue, this);
    this[onOrOff]("set_hoverSpriteAsset", this._onSetTransitionValue, this);
    this[onOrOff]("set_hoverSpriteFrame", this._onSetTransitionValue, this);
    this[onOrOff]("set_pressedSpriteAsset", this._onSetTransitionValue, this);
    this[onOrOff]("set_pressedSpriteFrame", this._onSetTransitionValue, this);
    this[onOrOff]("set_inactiveSpriteAsset", this._onSetTransitionValue, this);
    this[onOrOff]("set_inactiveSpriteFrame", this._onSetTransitionValue, this);
    pc.ComponentSystem[onOrOff]("update", this._onUpdate, this);
    system.app.systems.element[onOrOff]("add", this._onElementComponentAdd, this);
    system.app.systems.element[onOrOff]("beforeremove", this._onElementComponentRemove, this);
  }, _onSetActive:function(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this._updateVisualState();
    }
  }, _onSetTransitionMode:function(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this._cancelTween();
      this._resetToDefaultVisualState(oldValue);
      this._forceReapplyVisualState();
    }
  }, _onSetTransitionValue:function(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this._forceReapplyVisualState();
    }
  }, _onElementComponentRemove:function(entity) {
    if (this.entity === entity) {
      this._toggleHitElementListeners("off");
    }
  }, _onElementComponentAdd:function(entity) {
    if (this.entity === entity) {
      this._toggleHitElementListeners("on");
    }
  }, _onImageElementLose:function() {
    this._cancelTween();
    this._resetToDefaultVisualState(this.transitionMode);
  }, _onImageElementGain:function() {
    this._storeDefaultVisualState();
    this._forceReapplyVisualState();
  }, _toggleHitElementListeners:function(onOrOff) {
    if (this.entity.element) {
      var isAdding = onOrOff === "on";
      if (isAdding && this._hasHitElementListeners) {
        return;
      }
      this.entity.element[onOrOff]("mouseenter", this._onMouseEnter, this);
      this.entity.element[onOrOff]("mouseleave", this._onMouseLeave, this);
      this.entity.element[onOrOff]("mousedown", this._onMouseDown, this);
      this.entity.element[onOrOff]("mouseup", this._onMouseUp, this);
      this.entity.element[onOrOff]("touchstart", this._onTouchStart, this);
      this.entity.element[onOrOff]("touchend", this._onTouchEnd, this);
      this.entity.element[onOrOff]("touchleave", this._onTouchLeave, this);
      this.entity.element[onOrOff]("touchcancel", this._onTouchCancel, this);
      this.entity.element[onOrOff]("click", this._onClick, this);
      this._hasHitElementListeners = isAdding;
    }
  }, _storeDefaultVisualState:function() {
    if (this._imageReference.hasComponent("element")) {
      this._storeDefaultColor(this._imageReference.entity.element.color);
      this._storeDefaultOpacity(this._imageReference.entity.element.opacity);
      this._storeDefaultSpriteAsset(this._imageReference.entity.element.spriteAsset);
      this._storeDefaultSpriteFrame(this._imageReference.entity.element.spriteFrame);
    }
  }, _storeDefaultColor:function(color) {
    this._defaultTint.r = color.r;
    this._defaultTint.g = color.g;
    this._defaultTint.b = color.b;
  }, _storeDefaultOpacity:function(opacity) {
    this._defaultTint.a = opacity;
  }, _storeDefaultSpriteAsset:function(spriteAsset) {
    this._defaultSpriteAsset = spriteAsset;
  }, _storeDefaultSpriteFrame:function(spriteFrame) {
    this._defaultSpriteFrame = spriteFrame;
  }, _onSetColor:function(color) {
    if (!this._isApplyingTint) {
      this._storeDefaultColor(color);
      this._forceReapplyVisualState();
    }
  }, _onSetOpacity:function(opacity) {
    if (!this._isApplyingTint) {
      this._storeDefaultOpacity(opacity);
      this._forceReapplyVisualState();
    }
  }, _onSetSpriteAsset:function(spriteAsset) {
    if (!this._isApplyingSprite) {
      this._storeDefaultSpriteAsset(spriteAsset);
      this._forceReapplyVisualState();
    }
  }, _onSetSpriteFrame:function(spriteFrame) {
    if (!this._isApplyingSprite) {
      this._storeDefaultSpriteFrame(spriteFrame);
      this._forceReapplyVisualState();
    }
  }, _onMouseEnter:function(event) {
    this._isHovering = true;
    this._updateVisualState();
    this.fire("mouseenter", event);
  }, _onMouseLeave:function(event) {
    this._isHovering = false;
    this._isPressed = false;
    this._updateVisualState();
    this.fire("mouseleave", event);
  }, _onMouseDown:function(event) {
    this._isPressed = true;
    this._updateVisualState();
    this.fire("mousedown", event);
  }, _onMouseUp:function(event) {
    this._isPressed = false;
    this._updateVisualState();
    this.fire("mouseup", event);
  }, _onTouchStart:function(event) {
    this._isPressed = true;
    this._updateVisualState();
    this.fire("touchstart", event);
  }, _onTouchEnd:function(event) {
    event.event.preventDefault();
    this._isPressed = false;
    this._updateVisualState();
    this.fire("touchend", event);
  }, _onTouchLeave:function(event) {
    this._isPressed = false;
    this._updateVisualState();
    this.fire("touchleave", event);
  }, _onTouchCancel:function(event) {
    this._isPressed = false;
    this._updateVisualState();
    this.fire("touchcancel", event);
  }, _onClick:function(event) {
    this.fire("click", event);
  }, _updateVisualState:function(force) {
    var oldVisualState = this._visualState;
    var newVisualState = this._determineVisualState();
    if ((oldVisualState !== newVisualState || force) && this.enabled) {
      this._visualState = newVisualState;
      if (oldVisualState === VisualState.HOVER) {
        this.fire("hoverend");
      }
      if (oldVisualState === VisualState.PRESSED) {
        this.fire("pressedend");
      }
      if (newVisualState === VisualState.HOVER) {
        this.fire("hoverstart");
      }
      if (newVisualState === VisualState.PRESSED) {
        this.fire("pressedstart");
      }
      switch(this.transitionMode) {
        case pc.BUTTON_TRANSITION_MODE_TINT:
          var tintName = STATES_TO_TINT_NAMES[this._visualState];
          var tintColor = this[tintName];
          this._applyTint(tintColor);
          break;
        case pc.BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
          var spriteAssetName = STATES_TO_SPRITE_ASSET_NAMES[this._visualState];
          var spriteFrameName = STATES_TO_SPRITE_FRAME_NAMES[this._visualState];
          var spriteAsset = this[spriteAssetName];
          var spriteFrame = this[spriteFrameName];
          this._applySprite(spriteAsset, spriteFrame);
          break;
      }
    }
  }, _forceReapplyVisualState:function() {
    this._updateVisualState(true);
  }, _resetToDefaultVisualState:function(transitionMode) {
    if (this._imageReference.hasComponent("element")) {
      switch(transitionMode) {
        case pc.BUTTON_TRANSITION_MODE_TINT:
          this._cancelTween();
          this._applyTintImmediately(this._defaultTint);
          break;
        case pc.BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
          this._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);
          break;
      }
    }
  }, _determineVisualState:function() {
    if (!this.active) {
      return VisualState.INACTIVE;
    } else {
      if (this._isPressed) {
        return VisualState.PRESSED;
      } else {
        if (this._isHovering) {
          return VisualState.HOVER;
        }
      }
    }
    return VisualState.DEFAULT;
  }, _applySprite:function(spriteAsset, spriteFrame) {
    spriteFrame = spriteFrame || 0;
    if (this._imageReference.hasComponent("element")) {
      this._isApplyingSprite = true;
      this._imageReference.entity.element.spriteAsset = spriteAsset;
      this._imageReference.entity.element.spriteFrame = spriteFrame;
      this._isApplyingSprite = false;
    }
  }, _applyTint:function(tintColor) {
    this._cancelTween();
    if (this.fadeDuration === 0) {
      this._applyTintImmediately(tintColor);
    } else {
      this._applyTintWithTween(tintColor);
    }
  }, _applyTintImmediately:function(tintColor) {
    if (this._imageReference.hasComponent("element") && tintColor) {
      this._isApplyingTint = true;
      this._imageReference.entity.element.color = toColor3(tintColor);
      this._imageReference.entity.element.opacity = tintColor.a;
      this._isApplyingTint = false;
    }
  }, _applyTintWithTween:function(tintColor) {
    if (this._imageReference.hasComponent("element") && tintColor) {
      var color = this._imageReference.entity.element.color;
      var opacity = this._imageReference.entity.element.opacity;
      this._tweenInfo = {startTime:pc.now(), from:new pc.Color(color.r, color.g, color.b, opacity), to:tintColor.clone(), lerpVec:new pc.Vec4};
    }
  }, _updateTintTween:function() {
    var elapsedTime = pc.now() - this._tweenInfo.startTime;
    var elapsedProportion = this.fadeDuration === 0 ? 1 : elapsedTime / this.fadeDuration;
    elapsedProportion = pc.math.clamp(elapsedProportion, 0, 1);
    if (Math.abs(elapsedProportion - 1) > 1e-5) {
      this._tweenInfo.lerpVec.lerp(this._tweenInfo.from, this._tweenInfo.to, elapsedProportion);
      this._applyTintImmediately(new pc.Color(this._tweenInfo.lerpVec.data));
    } else {
      this._applyTintImmediately(this._tweenInfo.to);
      this._cancelTween();
    }
  }, _cancelTween:function() {
    delete this._tweenInfo;
  }, _onUpdate:function() {
    if (this._tweenInfo) {
      this._updateTintTween();
    }
  }, onEnable:function() {
    this._toggleHitElementListeners("on");
    this._forceReapplyVisualState();
  }, onDisable:function() {
    this._toggleHitElementListeners("off");
    this._resetToDefaultVisualState(this.transitionMode);
  }, onRemove:function() {
    this._toggleLifecycleListeners("off", this.system);
    this.onDisable();
  }});
  function toColor3(color4) {
    return new pc.Color(color4.r, color4.g, color4.b);
  }
  return {ButtonComponent:ButtonComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled", "active", {name:"imageEntity", type:"entity"}, {name:"hitPadding", type:"vec4"}, "transitionMode", {name:"hoverTint", type:"rgba"}, {name:"pressedTint", type:"rgba"}, {name:"inactiveTint", type:"rgba"}, "fadeDuration", "hoverSpriteAsset", "hoverSpriteFrame", "pressedSpriteAsset", "pressedSpriteFrame", "inactiveSpriteAsset", "inactiveSpriteFrame"];
  var ButtonComponentSystem = function ButtonComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "button";
    this.app = app;
    app.systems.add(this.id, this);
    this.ComponentType = pc.ButtonComponent;
    this.DataType = pc.ButtonComponentData;
    this.schema = _schema;
    this.on("beforeremove", this._onRemoveComponent, this);
  };
  ButtonComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  ButtonComponentSystem.prototype.constructor = ButtonComponentSystem;
  pc.Component._buildAccessors(pc.ButtonComponent.prototype, _schema);
  Object.assign(ButtonComponentSystem.prototype, {initializeComponentData:function(component, data, properties) {
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema);
  }, _onRemoveComponent:function(entity, component) {
    component.onRemove();
  }});
  return {ButtonComponentSystem:ButtonComponentSystem};
}());
Object.assign(pc, function() {
  var ButtonComponentData = function() {
    this.enabled = true;
    this.active = true;
    this.imageEntity = null;
    this.hitPadding = new pc.Vec4;
    this.transitionMode = pc.BUTTON_TRANSITION_MODE_TINT;
    this.hoverTint = new pc.Color(0.75, 0.75, 0.75);
    this.pressedTint = new pc.Color(0.5, 0.5, 0.5);
    this.inactiveTint = new pc.Color(0.25, 0.25, 0.25);
    this.fadeDuration = 0;
    this.hoverSpriteAsset = null;
    this.hoverSpriteFrame = 0;
    this.pressedSpriteAsset = null;
    this.pressedSpriteFrame = 0;
    this.inactiveSpriteAsset = null;
    this.inactiveSpriteFrame = 0;
  };
  return {ButtonComponentData:ButtonComponentData};
}());
Object.assign(pc, {SCROLL_MODE_CLAMP:0, SCROLL_MODE_BOUNCE:1, SCROLL_MODE_INFINITE:2, SCROLLBAR_VISIBILITY_SHOW_ALWAYS:0, SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:1});
Object.assign(pc, function() {
  var _tempScrollValue = new pc.Vec2;
  var ScrollViewComponent = function ScrollViewComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this._viewportReference = new pc.EntityReference(this, "viewportEntity", {"element#gain":this._onViewportElementGain, "element#resize":this._onSetContentOrViewportSize});
    this._contentReference = new pc.EntityReference(this, "contentEntity", {"element#gain":this._onContentElementGain, "element#lose":this._onContentElementLose, "element#resize":this._onSetContentOrViewportSize});
    this._scrollbarUpdateFlags = {};
    this._scrollbarReferences = {};
    this._scrollbarReferences[pc.ORIENTATION_HORIZONTAL] = new pc.EntityReference(this, "horizontalScrollbarEntity", {"scrollbar#set:value":this._onSetHorizontalScrollbarValue, "scrollbar#gain":this._onHorizontalScrollbarGain});
    this._scrollbarReferences[pc.ORIENTATION_VERTICAL] = new pc.EntityReference(this, "verticalScrollbarEntity", {"scrollbar#set:value":this._onSetVerticalScrollbarValue, "scrollbar#gain":this._onVerticalScrollbarGain});
    this._scroll = new pc.Vec2;
    this._velocity = new pc.Vec3;
    this._toggleLifecycleListeners("on", system);
    this._toggleElementListeners("on");
  };
  ScrollViewComponent.prototype = Object.create(pc.Component.prototype);
  ScrollViewComponent.prototype.constructor = ScrollViewComponent;
  Object.assign(ScrollViewComponent.prototype, {_toggleLifecycleListeners:function(onOrOff, system) {
    this[onOrOff]("set_horizontal", this._onSetHorizontalScrollingEnabled, this);
    this[onOrOff]("set_vertical", this._onSetVerticalScrollingEnabled, this);
    pc.ComponentSystem[onOrOff]("update", this._onUpdate, this);
    system.app.systems.element[onOrOff]("add", this._onElementComponentAdd, this);
    system.app.systems.element[onOrOff]("beforeremove", this._onElementComponentRemove, this);
  }, _toggleElementListeners:function(onOrOff) {
    if (this.entity.element) {
      if (onOrOff === "on" && this._hasElementListeners) {
        return;
      }
      this.entity.element[onOrOff]("resize", this._onSetContentOrViewportSize, this);
      this._hasElementListeners = onOrOff === "on";
    }
  }, _onElementComponentAdd:function(entity) {
    if (this.entity === entity) {
      this._toggleElementListeners("on");
    }
  }, _onElementComponentRemove:function(entity) {
    if (this.entity === entity) {
      this._toggleElementListeners("off");
    }
  }, _onViewportElementGain:function() {
    this._syncAll();
  }, _onContentElementGain:function() {
    this._destroyDragHelper();
    this._contentDragHelper = new pc.ElementDragHelper(this._contentReference.entity.element);
    this._contentDragHelper.on("drag:end", this._onContentDragEnd, this);
    this._contentDragHelper.on("drag:move", this._onContentDragMove, this);
    this._syncAll();
  }, _onContentElementLose:function() {
    this._destroyDragHelper();
  }, _onContentDragEnd:function() {
    this._prevContentDragPosition = null;
  }, _onContentDragMove:function(position) {
    if (this._contentReference.entity && this.enabled && this.entity.enabled) {
      this._setScrollFromContentPosition(position);
      this._setVelocityFromContentPositionDelta(position);
    }
  }, _onSetContentOrViewportSize:function() {
    this._syncAll();
  }, _onSetHorizontalScrollbarValue:function(scrollValueX) {
    if (!this._scrollbarUpdateFlags[pc.ORIENTATION_HORIZONTAL] && this.enabled && this.entity.enabled) {
      this._velocity.set(0, 0, 0);
      this._onSetScroll(scrollValueX, null);
    }
  }, _onSetVerticalScrollbarValue:function(scrollValueY) {
    if (!this._scrollbarUpdateFlags[pc.ORIENTATION_VERTICAL] && this.enabled && this.entity.enabled) {
      this._velocity.set(0, 0, 0);
      this._onSetScroll(null, scrollValueY);
    }
  }, _onSetHorizontalScrollingEnabled:function() {
    this._syncScrollbarEnabledState(pc.ORIENTATION_HORIZONTAL);
  }, _onSetVerticalScrollingEnabled:function() {
    this._syncScrollbarEnabledState(pc.ORIENTATION_VERTICAL);
  }, _onHorizontalScrollbarGain:function() {
    this._syncScrollbarEnabledState(pc.ORIENTATION_HORIZONTAL);
    this._syncScrollbarPosition(pc.ORIENTATION_HORIZONTAL);
  }, _onVerticalScrollbarGain:function() {
    this._syncScrollbarEnabledState(pc.ORIENTATION_VERTICAL);
    this._syncScrollbarPosition(pc.ORIENTATION_VERTICAL);
  }, _onSetScroll:function(x, y) {
    var hasChanged = false;
    hasChanged |= this._updateAxis(x, "x", pc.ORIENTATION_HORIZONTAL);
    hasChanged |= this._updateAxis(y, "y", pc.ORIENTATION_VERTICAL);
    if (hasChanged) {
      this.fire("set:scroll", this._scroll);
    }
  }, _updateAxis:function(scrollValue, axis, orientation) {
    var hasChanged = scrollValue !== null && Math.abs(scrollValue - this._scroll[axis]) > 1e-5;
    if (hasChanged) {
      this._scroll[axis] = this._determineNewScrollValue(scrollValue, axis, orientation);
      this._syncContentPosition(orientation);
      this._syncScrollbarPosition(orientation);
    }
    return hasChanged;
  }, _determineNewScrollValue:function(scrollValue, axis, orientation) {
    if (!this._getScrollingEnabled(orientation)) {
      return this._scroll[axis];
    }
    switch(this.scrollMode) {
      case pc.SCROLL_MODE_CLAMP:
        return pc.math.clamp(scrollValue, 0, this._getMaxScrollValue(orientation));
      case pc.SCROLL_MODE_BOUNCE:
        this._setVelocityFromOvershoot(scrollValue, axis, orientation);
        return scrollValue;
      case pc.SCROLL_MODE_INFINITE:
        return scrollValue;
      default:
        console.warn("Unhandled scroll mode:" + this.scrollMode);
        return scrollValue;
    }
  }, _syncAll:function() {
    this._syncContentPosition(pc.ORIENTATION_HORIZONTAL);
    this._syncContentPosition(pc.ORIENTATION_VERTICAL);
    this._syncScrollbarPosition(pc.ORIENTATION_HORIZONTAL);
    this._syncScrollbarPosition(pc.ORIENTATION_VERTICAL);
    this._syncScrollbarEnabledState(pc.ORIENTATION_HORIZONTAL);
    this._syncScrollbarEnabledState(pc.ORIENTATION_VERTICAL);
  }, _syncContentPosition:function(orientation) {
    var axis = this._getAxis(orientation);
    var sign = this._getSign(orientation);
    var contentEntity = this._contentReference.entity;
    if (contentEntity) {
      var offset = this._scroll[axis] * this._getMaxOffset(orientation);
      var contentPosition = contentEntity.getLocalPosition();
      contentPosition[axis] = offset * sign;
      contentEntity.setLocalPosition(contentPosition);
    }
  }, _syncScrollbarPosition:function(orientation) {
    var axis = this._getAxis(orientation);
    var scrollbarEntity = this._scrollbarReferences[orientation].entity;
    if (scrollbarEntity && scrollbarEntity.scrollbar) {
      this._scrollbarUpdateFlags[orientation] = true;
      scrollbarEntity.scrollbar.value = this._scroll[axis];
      scrollbarEntity.scrollbar.handleSize = this._getScrollbarHandleSize(axis, orientation);
      this._scrollbarUpdateFlags[orientation] = false;
    }
  }, _syncScrollbarEnabledState:function(orientation) {
    var entity = this._scrollbarReferences[orientation].entity;
    if (entity) {
      var isScrollingEnabled = this._getScrollingEnabled(orientation);
      var requestedVisibility = this._getScrollbarVisibility(orientation);
      switch(requestedVisibility) {
        case pc.SCROLLBAR_VISIBILITY_SHOW_ALWAYS:
          entity.enabled = isScrollingEnabled;
          return;
        case pc.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:
          entity.enabled = isScrollingEnabled && this._contentIsLargerThanViewport(orientation);
          return;
        default:
          console.warn("Unhandled scrollbar visibility:" + requestedVisibility);
          entity.enabled = isScrollingEnabled;
      }
    }
  }, _contentIsLargerThanViewport:function(orientation) {
    return this._getContentSize(orientation) > this._getViewportSize(orientation);
  }, _contentPositionToScrollValue:function(contentPosition) {
    return _tempScrollValue.set(contentPosition.x / this._getMaxOffset(pc.ORIENTATION_HORIZONTAL), contentPosition.y / -this._getMaxOffset(pc.ORIENTATION_VERTICAL));
  }, _getMaxOffset:function(orientation) {
    var viewportSize = this._getViewportSize(orientation);
    var contentSize = this._getContentSize(orientation);
    if (contentSize < viewportSize) {
      return -this._getViewportSize(orientation);
    }
    return viewportSize - contentSize;
  }, _getMaxScrollValue:function(orientation) {
    return this._contentIsLargerThanViewport(orientation) ? 1 : 0;
  }, _getScrollbarHandleSize:function(axis, orientation) {
    var viewportSize = this._getViewportSize(orientation);
    var contentSize = this._getContentSize(orientation);
    if (Math.abs(contentSize) < 0.001) {
      return 1;
    }
    var handleSize = Math.min(viewportSize / contentSize, 1);
    var overshoot = this._toOvershoot(this._scroll[axis], orientation);
    if (overshoot === 0) {
      return handleSize;
    }
    return handleSize / (1 + Math.abs(overshoot));
  }, _getViewportSize:function(orientation) {
    return this._getSize(orientation, this._viewportReference);
  }, _getContentSize:function(orientation) {
    return this._getSize(orientation, this._contentReference);
  }, _getSize:function(orientation, entityReference) {
    if (entityReference.entity && entityReference.entity.element) {
      return entityReference.entity.element[this._getCalculatedDimension(orientation)];
    }
    return 0;
  }, _getScrollingEnabled:function(orientation) {
    if (orientation === pc.ORIENTATION_HORIZONTAL) {
      return this.horizontal;
    } else {
      if (orientation === pc.ORIENTATION_VERTICAL) {
        return this.vertical;
      }
    }
    console.warn("Unrecognized orientation: " + orientation);
  }, _getScrollbarVisibility:function(orientation) {
    if (orientation === pc.ORIENTATION_HORIZONTAL) {
      return this.horizontalScrollbarVisibility;
    } else {
      if (orientation === pc.ORIENTATION_VERTICAL) {
        return this.verticalScrollbarVisibility;
      }
    }
    console.warn("Unrecognized orientation: " + orientation);
  }, _getSign:function(orientation) {
    return orientation === pc.ORIENTATION_HORIZONTAL ? 1 : -1;
  }, _getAxis:function(orientation) {
    return orientation === pc.ORIENTATION_HORIZONTAL ? "x" : "y";
  }, _getCalculatedDimension:function(orientation) {
    return orientation === pc.ORIENTATION_HORIZONTAL ? "calculatedWidth" : "calculatedHeight";
  }, _destroyDragHelper:function() {
    if (this._contentDragHelper) {
      this._contentDragHelper.destroy();
    }
  }, _onUpdate:function() {
    if (this._contentReference.entity && this.enabled && this.entity.enabled) {
      this._updateVelocity();
      this._syncScrollbarEnabledState(pc.ORIENTATION_HORIZONTAL);
      this._syncScrollbarEnabledState(pc.ORIENTATION_VERTICAL);
    }
  }, _updateVelocity:function() {
    if (!this._isDragging()) {
      if (this.scrollMode === pc.SCROLL_MODE_BOUNCE) {
        if (this._hasOvershoot("x", pc.ORIENTATION_HORIZONTAL)) {
          this._setVelocityFromOvershoot(this.scroll.x, "x", pc.ORIENTATION_HORIZONTAL);
        }
        if (this._hasOvershoot("y", pc.ORIENTATION_VERTICAL)) {
          this._setVelocityFromOvershoot(this.scroll.y, "y", pc.ORIENTATION_VERTICAL);
        }
      }
      this._velocity.data[0] *= 1 - this.friction;
      this._velocity.data[1] *= 1 - this.friction;
      if (Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {
        var position = this._contentReference.entity.getLocalPosition();
        position.x += this._velocity.data[0];
        position.y += this._velocity.data[1];
        this._contentReference.entity.setLocalPosition(position);
        this._setScrollFromContentPosition(position);
      }
    }
  }, _hasOvershoot:function(axis, orientation) {
    return Math.abs(this._toOvershoot(this.scroll[axis], orientation)) > 0.001;
  }, _toOvershoot:function(scrollValue, orientation) {
    var maxScrollValue = this._getMaxScrollValue(orientation);
    if (scrollValue < 0) {
      return scrollValue;
    } else {
      if (scrollValue > maxScrollValue) {
        return scrollValue - maxScrollValue;
      }
    }
    return 0;
  }, _setVelocityFromOvershoot:function(scrollValue, axis, orientation) {
    var overshootValue = this._toOvershoot(scrollValue, orientation);
    var overshootPixels = overshootValue * this._getMaxOffset(orientation) * this._getSign(orientation);
    if (Math.abs(overshootPixels) > 0) {
      this._velocity[axis] = -overshootPixels / (this.bounceAmount * 50 + 1);
    }
  }, _setVelocityFromContentPositionDelta:function(position) {
    if (this._prevContentDragPosition) {
      this._velocity.sub2(position, this._prevContentDragPosition);
      this._prevContentDragPosition.copy(position);
    } else {
      this._velocity.set(0, 0, 0);
      this._prevContentDragPosition = position.clone();
    }
  }, _setScrollFromContentPosition:function(position) {
    var scrollValue = this._contentPositionToScrollValue(position);
    this._onSetScroll(scrollValue.x, scrollValue.y);
  }, _isDragging:function() {
    return this._contentDragHelper && this._contentDragHelper.isDragging;
  }, _setScrollbarComponentsEnabled:function(enabled) {
    if (this._scrollbarReferences[pc.ORIENTATION_HORIZONTAL].hasComponent("scrollbar")) {
      this._scrollbarReferences[pc.ORIENTATION_HORIZONTAL].entity.scrollbar.enabled = enabled;
    }
    if (this._scrollbarReferences[pc.ORIENTATION_VERTICAL].hasComponent("scrollbar")) {
      this._scrollbarReferences[pc.ORIENTATION_VERTICAL].entity.scrollbar.enabled = enabled;
    }
  }, _setContentDraggingEnabled:function(enabled) {
    if (this._contentDragHelper) {
      this._contentDragHelper.enabled = enabled;
    }
  }, onEnable:function() {
    this._setScrollbarComponentsEnabled(true);
    this._setContentDraggingEnabled(true);
    this._syncAll();
  }, onDisable:function() {
    this._setScrollbarComponentsEnabled(false);
    this._setContentDraggingEnabled(false);
  }, onRemove:function() {
    this._toggleLifecycleListeners("off", this.system);
    this._toggleElementListeners("off");
    this._destroyDragHelper();
  }});
  Object.defineProperty(ScrollViewComponent.prototype, "scroll", {get:function() {
    return this._scroll;
  }, set:function(value) {
    this._onSetScroll(value.x, value.y);
  }});
  return {ScrollViewComponent:ScrollViewComponent};
}());
Object.assign(pc, function() {
  var _schema = [{name:"enabled", type:"boolean"}, {name:"horizontal", type:"boolean"}, {name:"vertical", type:"boolean"}, {name:"scrollMode", type:"number"}, {name:"bounceAmount", type:"number"}, {name:"friction", type:"number"}, {name:"horizontalScrollbarVisibility", type:"number"}, {name:"verticalScrollbarVisibility", type:"number"}, {name:"viewportEntity", type:"entity"}, {name:"contentEntity", type:"entity"}, {name:"horizontalScrollbarEntity", type:"entity"}, {name:"verticalScrollbarEntity", 
  type:"entity"}];
  var ScrollViewComponentSystem = function ScrollViewComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "scrollview";
    this.app = app;
    app.systems.add(this.id, this);
    this.ComponentType = pc.ScrollViewComponent;
    this.DataType = pc.ScrollViewComponentData;
    this.schema = _schema;
    this.on("beforeremove", this._onRemoveComponent, this);
  };
  ScrollViewComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  ScrollViewComponentSystem.prototype.constructor = ScrollViewComponentSystem;
  pc.Component._buildAccessors(pc.ScrollViewComponent.prototype, _schema);
  Object.assign(ScrollViewComponentSystem.prototype, {initializeComponentData:function(component, data, properties) {
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema);
  }, _onRemoveComponent:function(entity, component) {
    component.onRemove();
  }});
  return {ScrollViewComponentSystem:ScrollViewComponentSystem};
}());
Object.assign(pc, function() {
  var ScrollViewComponentData = function() {
    this.enabled = true;
  };
  return {ScrollViewComponentData:ScrollViewComponentData};
}());
Object.assign(pc, function() {
  var ScrollbarComponent = function ScrollbarComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this._app = system.app;
    this._handleReference = new pc.EntityReference(this, "handleEntity", {"element#gain":this._onHandleElementGain, "element#lose":this._onHandleElementLose, "element#set:anchor":this._onSetHandleAlignment, "element#set:margin":this._onSetHandleAlignment, "element#set:pivot":this._onSetHandleAlignment});
    this._toggleLifecycleListeners("on");
  };
  ScrollbarComponent.prototype = Object.create(pc.Component.prototype);
  ScrollbarComponent.prototype.constructor = ScrollbarComponent;
  Object.assign(ScrollbarComponent.prototype, {_toggleLifecycleListeners:function(onOrOff) {
    this[onOrOff]("set_value", this._onSetValue, this);
    this[onOrOff]("set_handleSize", this._onSetHandleSize, this);
    this[onOrOff]("set_orientation", this._onSetOrientation, this);
  }, _onHandleElementGain:function() {
    this._destroyDragHelper();
    this._handleDragHelper = new pc.ElementDragHelper(this._handleReference.entity.element, this._getAxis());
    this._handleDragHelper.on("drag:move", this._onHandleDrag, this);
    this._updateHandlePositionAndSize();
  }, _onHandleElementLose:function() {
    this._destroyDragHelper();
  }, _onHandleDrag:function(position) {
    if (this._handleReference.entity && this.enabled && this.entity.enabled) {
      this.value = this._handlePositionToScrollValue(position[this._getAxis()]);
    }
  }, _onSetValue:function(name, oldValue, newValue) {
    if (Math.abs(newValue - oldValue) > 1e-5) {
      this.data.value = pc.math.clamp(newValue, 0, 1);
      this._updateHandlePositionAndSize();
      this.fire("set:value", this.data.value);
    }
  }, _onSetHandleSize:function(name, oldValue, newValue) {
    if (Math.abs(newValue - oldValue) > 1e-5) {
      this.data.handleSize = pc.math.clamp(newValue, 0, 1);
      this._updateHandlePositionAndSize();
    }
  }, _onSetHandleAlignment:function() {
    this._updateHandlePositionAndSize();
  }, _onSetOrientation:function(name, oldValue, newValue) {
    if (newValue !== oldValue && this._handleReference.hasComponent("element")) {
      this._handleReference.entity.element[this._getOppositeDimension()] = 0;
    }
  }, _updateHandlePositionAndSize:function() {
    var handleEntity = this._handleReference.entity;
    var handleElement = handleEntity && handleEntity.element;
    if (handleEntity) {
      var position = handleEntity.getLocalPosition();
      position[this._getAxis()] = this._getHandlePosition();
      this._handleReference.entity.setLocalPosition(position);
    }
    if (handleElement) {
      handleElement[this._getDimension()] = this._getHandleLength();
    }
  }, _handlePositionToScrollValue:function(handlePosition) {
    return handlePosition * this._getSign() / this._getUsableTrackLength();
  }, _scrollValueToHandlePosition:function(value) {
    return value * this._getSign() * this._getUsableTrackLength();
  }, _getUsableTrackLength:function() {
    return Math.max(this._getTrackLength() - this._getHandleLength(), 0.001);
  }, _getTrackLength:function() {
    if (this.entity.element) {
      return this.orientation === pc.ORIENTATION_HORIZONTAL ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight;
    }
    return 0;
  }, _getHandleLength:function() {
    return this._getTrackLength() * this.handleSize;
  }, _getHandlePosition:function() {
    return this._scrollValueToHandlePosition(this.value);
  }, _getSign:function() {
    return this.orientation === pc.ORIENTATION_HORIZONTAL ? 1 : -1;
  }, _getAxis:function() {
    return this.orientation === pc.ORIENTATION_HORIZONTAL ? "x" : "y";
  }, _getDimension:function() {
    return this.orientation === pc.ORIENTATION_HORIZONTAL ? "width" : "height";
  }, _getOppositeDimension:function() {
    return this.orientation === pc.ORIENTATION_HORIZONTAL ? "height" : "width";
  }, _destroyDragHelper:function() {
    if (this._handleDragHelper) {
      this._handleDragHelper.destroy();
    }
  }, _setHandleDraggingEnabled:function(enabled) {
    if (this._handleDragHelper) {
      this._handleDragHelper.enabled = enabled;
    }
  }, onEnable:function() {
    this._setHandleDraggingEnabled(true);
  }, onDisable:function() {
    this._setHandleDraggingEnabled(false);
  }, onRemove:function() {
    this._destroyDragHelper();
    this._toggleLifecycleListeners("off");
  }});
  return {ScrollbarComponent:ScrollbarComponent};
}());
Object.assign(pc, function() {
  var _schema = [{name:"enabled", type:"boolean"}, {name:"orientation", type:"number"}, {name:"value", type:"number"}, {name:"handleSize", type:"number"}, {name:"handleEntity", type:"entity"}];
  var ScrollbarComponentSystem = function ScrollbarComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "scrollbar";
    this.app = app;
    app.systems.add(this.id, this);
    this.ComponentType = pc.ScrollbarComponent;
    this.DataType = pc.ScrollbarComponentData;
    this.schema = _schema;
    this.on("beforeremove", this._onRemoveComponent, this);
  };
  ScrollbarComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  ScrollbarComponentSystem.prototype.constructor = ScrollbarComponentSystem;
  pc.Component._buildAccessors(pc.ScrollbarComponent.prototype, _schema);
  Object.assign(ScrollbarComponentSystem.prototype, {initializeComponentData:function(component, data, properties) {
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema);
  }, _onRemoveComponent:function(entity, component) {
    component.onRemove();
  }});
  return {ScrollbarComponentSystem:ScrollbarComponentSystem};
}());
Object.assign(pc, function() {
  var ScrollbarComponentData = function() {
    this.enabled = true;
  };
  return {ScrollbarComponentData:ScrollbarComponentData};
}());
Object.assign(pc, {FITTING_NONE:0, FITTING_STRETCH:1, FITTING_SHRINK:2, FITTING_BOTH:3});
Object.assign(pc, function() {
  var LayoutGroupComponent = function LayoutGroupComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this._orientation = pc.ORIENTATION_HORIZONTAL;
    this._reverseX = false;
    this._reverseY = true;
    this._alignment = new pc.Vec2(0, 1);
    this._padding = new pc.Vec4;
    this._spacing = new pc.Vec2;
    this._widthFitting = pc.FITTING_NONE;
    this._heightFitting = pc.FITTING_NONE;
    this._wrap = false;
    this._layoutCalculator = new pc.LayoutCalculator;
    this._listenForReflowEvents(this.entity, "on");
    this.entity.children.forEach(function(child) {
      this._listenForReflowEvents(child, "on");
    }.bind(this));
    this.entity.on("childinsert", this._onChildInsert, this);
    this.entity.on("childremove", this._onChildRemove, this);
    system.app.systems.element.on("add", this._onElementOrLayoutComponentAdd, this);
    system.app.systems.element.on("beforeremove", this._onElementOrLayoutComponentRemove, this);
    system.app.systems.layoutchild.on("add", this._onElementOrLayoutComponentAdd, this);
    system.app.systems.layoutchild.on("beforeremove", this._onElementOrLayoutComponentRemove, this);
  };
  LayoutGroupComponent.prototype = Object.create(pc.Component.prototype);
  LayoutGroupComponent.prototype.constructor = LayoutGroupComponent;
  Object.assign(LayoutGroupComponent.prototype, {_isSelfOrChild:function(entity) {
    return entity === this.entity || this.entity.children.indexOf(entity) !== -1;
  }, _listenForReflowEvents:function(target, onOff) {
    if (target.element) {
      target.element[onOff]("enableelement", this._scheduleReflow, this);
      target.element[onOff]("disableelement", this._scheduleReflow, this);
      target.element[onOff]("resize", this._scheduleReflow, this);
      target.element[onOff]("set:pivot", this._scheduleReflow, this);
    }
    if (target.layoutchild) {
      target.layoutchild[onOff]("set_enabled", this._scheduleReflow, this);
      target.layoutchild[onOff]("resize", this._scheduleReflow, this);
    }
  }, _onElementOrLayoutComponentAdd:function(entity) {
    if (this._isSelfOrChild(entity)) {
      this._listenForReflowEvents(entity, "on");
      this._scheduleReflow();
    }
  }, _onElementOrLayoutComponentRemove:function(entity) {
    if (this._isSelfOrChild(entity)) {
      this._listenForReflowEvents(entity, "off");
      this._scheduleReflow();
    }
  }, _onChildInsert:function(child) {
    this._listenForReflowEvents(child, "on");
    this._scheduleReflow();
  }, _onChildRemove:function(child) {
    this._listenForReflowEvents(child, "off");
    this._scheduleReflow();
  }, _scheduleReflow:function() {
    if (this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow) {
      this.system.scheduleReflow(this);
    }
  }, reflow:function() {
    var container = getElement(this.entity);
    var elements = this.entity.children.filter(isEnabledAndHasEnabledElement).map(getElement);
    if (!container || elements.length === 0) {
      return;
    }
    var containerWidth = Math.max(container.calculatedWidth, 0);
    var containerHeight = Math.max(container.calculatedHeight, 0);
    var options = {orientation:this._orientation, reverseX:this._reverseX, reverseY:this._reverseY, alignment:this._alignment, padding:this._padding, spacing:this._spacing, widthFitting:this._widthFitting, heightFitting:this._heightFitting, wrap:this._wrap, containerSize:new pc.Vec2(containerWidth, containerHeight)};
    this._isPerformingReflow = true;
    var layoutInfo = this._layoutCalculator.calculateLayout(elements, options);
    this._isPerformingReflow = false;
    this.fire("reflow", layoutInfo);
  }, onEnable:function() {
    this._scheduleReflow();
  }, onRemove:function() {
    this.entity.off("childinsert", this._onChildInsert, this);
    this.entity.off("childremove", this._onChildRemove, this);
    this._listenForReflowEvents(this.entity, "off");
    this.entity.children.forEach(function(child) {
      this._listenForReflowEvents(child, "off");
    }.bind(this));
    this.system.app.systems.element.off("add", this._onElementOrLayoutComponentAdd, this);
    this.system.app.systems.element.off("beforeremove", this._onElementOrLayoutComponentRemove, this);
    this.system.app.systems.layoutchild.off("add", this._onElementOrLayoutComponentAdd, this);
    this.system.app.systems.layoutchild.off("beforeremove", this._onElementOrLayoutComponentRemove, this);
  }});
  function getElement(entity) {
    return entity.element;
  }
  function isEnabledAndHasEnabledElement(entity) {
    return entity.enabled && entity.element && entity.element.enabled;
  }
  function defineReflowSchedulingProperty(name) {
    var _name = "_" + name;
    Object.defineProperty(LayoutGroupComponent.prototype, name, {get:function() {
      return this[_name];
    }, set:function(value) {
      if (this[_name] !== value) {
        this[_name] = value;
        this._scheduleReflow();
      }
    }});
  }
  defineReflowSchedulingProperty("orientation");
  defineReflowSchedulingProperty("reverseX");
  defineReflowSchedulingProperty("reverseY");
  defineReflowSchedulingProperty("alignment");
  defineReflowSchedulingProperty("padding");
  defineReflowSchedulingProperty("spacing");
  defineReflowSchedulingProperty("widthFitting");
  defineReflowSchedulingProperty("heightFitting");
  defineReflowSchedulingProperty("wrap");
  return {LayoutGroupComponent:LayoutGroupComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled"];
  var LayoutGroupComponentSystem = function LayoutGroupComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "layoutgroup";
    this.app = app;
    app.systems.add(this.id, this);
    this.ComponentType = pc.LayoutGroupComponent;
    this.DataType = pc.LayoutGroupComponentData;
    this.schema = _schema;
    this._reflowQueue = [];
    this.on("beforeremove", this._onRemoveComponent, this);
    pc.ComponentSystem.on("postUpdate", this._onPostUpdate, this);
  };
  LayoutGroupComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  LayoutGroupComponentSystem.prototype.constructor = LayoutGroupComponentSystem;
  pc.Component._buildAccessors(pc.LayoutGroupComponent.prototype, _schema);
  Object.assign(LayoutGroupComponentSystem.prototype, {initializeComponentData:function(component, data, properties) {
    if (data.enabled !== undefined) {
      component.enabled = data.enabled;
    }
    if (data.orientation !== undefined) {
      component.orientation = data.orientation;
    }
    if (data.reverseX !== undefined) {
      component.reverseX = data.reverseX;
    }
    if (data.reverseY !== undefined) {
      component.reverseY = data.reverseY;
    }
    if (data.alignment !== undefined) {
      if (data.alignment instanceof pc.Vec2) {
        component.alignment.copy(data.alignment);
      } else {
        component.alignment.set(data.alignment[0], data.alignment[1]);
      }
      component.alignment = component.alignment;
    }
    if (data.padding !== undefined) {
      if (data.padding instanceof pc.Vec4) {
        component.padding.copy(data.padding);
      } else {
        component.padding.set(data.padding[0], data.padding[1], data.padding[2], data.padding[3]);
      }
      component.padding = component.padding;
    }
    if (data.spacing !== undefined) {
      if (data.spacing instanceof pc.Vec2) {
        component.spacing.copy(data.spacing);
      } else {
        component.spacing.set(data.spacing[0], data.spacing[1]);
      }
      component.spacing = component.spacing;
    }
    if (data.widthFitting !== undefined) {
      component.widthFitting = data.widthFitting;
    }
    if (data.heightFitting !== undefined) {
      component.heightFitting = data.heightFitting;
    }
    if (data.wrap !== undefined) {
      component.wrap = data.wrap;
    }
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
  }, cloneComponent:function(entity, clone) {
    var layoutGroup = entity.layoutgroup;
    return this.addComponent(clone, {enabled:layoutGroup.enabled, orientation:layoutGroup.orientation, reverseX:layoutGroup.reverseX, reverseY:layoutGroup.reverseY, alignment:layoutGroup.alignment, padding:layoutGroup.padding, spacing:layoutGroup.spacing, widthFitting:layoutGroup.widthFitting, heightFitting:layoutGroup.heightFitting, wrap:layoutGroup.wrap});
  }, scheduleReflow:function(component) {
    if (this._reflowQueue.indexOf(component) === -1) {
      this._reflowQueue.push(component);
    }
  }, _onPostUpdate:function() {
    this._processReflowQueue();
  }, _processReflowQueue:function() {
    if (this._reflowQueue.length === 0) {
      return;
    }
    this._reflowQueue.sort(function(componentA, componentB) {
      return componentA.entity.graphDepth < componentB.entity.graphDepth;
    });
    while (this._reflowQueue.length > 0) {
      this._reflowQueue[0].reflow();
      this._reflowQueue.shift();
    }
    this._reflowQueue = [];
  }, _onRemoveComponent:function(entity, component) {
    component.onRemove();
  }});
  return {LayoutGroupComponentSystem:LayoutGroupComponentSystem};
}());
Object.assign(pc, function() {
  var LayoutGroupComponentData = function() {
    this.enabled = true;
  };
  return {LayoutGroupComponentData:LayoutGroupComponentData};
}());
Object.assign(pc, function() {
  function LayoutCalculator() {
  }
  var AXIS_MAPPINGS = {};
  AXIS_MAPPINGS[pc.ORIENTATION_HORIZONTAL] = {axis:"x", size:"width", calculatedSize:"calculatedWidth", minSize:"minWidth", maxSize:"maxWidth", fitting:"widthFitting", fittingProportion:"fitWidthProportion"};
  AXIS_MAPPINGS[pc.ORIENTATION_VERTICAL] = {axis:"y", size:"height", calculatedSize:"calculatedHeight", minSize:"minHeight", maxSize:"maxHeight", fitting:"heightFitting", fittingProportion:"fitHeightProportion"};
  var OPPOSITE_ORIENTATION = {};
  OPPOSITE_ORIENTATION[pc.ORIENTATION_HORIZONTAL] = pc.ORIENTATION_VERTICAL;
  OPPOSITE_ORIENTATION[pc.ORIENTATION_VERTICAL] = pc.ORIENTATION_HORIZONTAL;
  var PROPERTY_DEFAULTS = {minWidth:0, minHeight:0, maxWidth:Number.POSITIVE_INFINITY, maxHeight:Number.POSITIVE_INFINITY, width:null, height:null, fitWidthProportion:0, fitHeightProportion:0};
  var FITTING_ACTION = {NONE:"NONE", APPLY_STRETCHING:"APPLY_STRETCHING", APPLY_SHRINKING:"APPLY_SHRINKING"};
  var availableSpace = new pc.Vec2;
  function createCalculator(orientation) {
    var options;
    var a = AXIS_MAPPINGS[orientation];
    var b = AXIS_MAPPINGS[OPPOSITE_ORIENTATION[orientation]];
    function minExtentA(element, size) {
      return -size[a.size] * element.pivot[a.axis];
    }
    function minExtentB(element, size) {
      return -size[b.size] * element.pivot[b.axis];
    }
    function maxExtentA(element, size) {
      return size[a.size] * (1 - element.pivot[a.axis]);
    }
    function maxExtentB(element, size) {
      return size[b.size] * (1 - element.pivot[b.axis]);
    }
    function calculateAll(allElements, layoutOptions) {
      allElements = allElements.filter(shouldIncludeInLayout);
      options = layoutOptions;
      availableSpace.x = options.containerSize.x - options.padding.data[0] - options.padding.data[2];
      availableSpace.y = options.containerSize.y - options.padding.data[1] - options.padding.data[3];
      resetAnchors(allElements);
      var lines = reverseLinesIfRequired(splitLines(allElements));
      var sizes = calculateSizesOnAxisB(lines, calculateSizesOnAxisA(lines));
      var positions = calculateBasePositions(lines, sizes);
      applyAlignmentAndPadding(lines, sizes, positions);
      applySizesAndPositions(lines, sizes, positions);
      return createLayoutInfo(lines, sizes, positions);
    }
    function shouldIncludeInLayout(element) {
      var layoutChildComponent = element.entity.layoutchild;
      return !layoutChildComponent || !layoutChildComponent.enabled || !layoutChildComponent.excludeFromLayout;
    }
    function resetAnchors(allElements) {
      for (var i = 0;i < allElements.length;++i) {
        var element = allElements[i];
        var anchor = element.anchor.data;
        if (anchor[0] !== 0 || anchor[1] !== 0 || anchor[2] !== 0 || anchor[3] !== 0) {
          element.anchor = [0, 0, 0, 0];
        }
      }
    }
    function splitLines(allElements) {
      if (!options.wrap) {
        return [allElements];
      }
      var lines = [[]];
      var sizes = getElementSizeProperties(allElements);
      var runningSize = 0;
      var allowOverrun = options[a.fitting] === pc.FITTING_SHRINK;
      for (var i = 0;i < allElements.length;++i) {
        if (lines[lines.length - 1].length > 0) {
          runningSize += options.spacing[a.axis];
        }
        var idealElementSize = sizes[i][a.size];
        runningSize += idealElementSize;
        if (!allowOverrun && runningSize > availableSpace[a.axis] && lines[lines.length - 1].length !== 0) {
          runningSize = idealElementSize;
          lines.push([]);
        }
        lines[lines.length - 1].push(allElements[i]);
        if (allowOverrun && runningSize > availableSpace[a.axis] && i !== allElements.length - 1) {
          runningSize = 0;
          lines.push([]);
        }
      }
      return lines;
    }
    function reverseLinesIfRequired(lines) {
      var reverseAxisA = options.orientation === pc.ORIENTATION_HORIZONTAL && options.reverseX || options.orientation === pc.ORIENTATION_VERTICAL && options.reverseY;
      var reverseAxisB = options.orientation === pc.ORIENTATION_HORIZONTAL && options.reverseY || options.orientation === pc.ORIENTATION_VERTICAL && options.reverseX;
      if (reverseAxisA) {
        for (var lineIndex = 0;lineIndex < lines.length;++lineIndex) {
          if (reverseAxisA) {
            lines[lineIndex].reverse();
          }
        }
      }
      if (reverseAxisB) {
        lines.reverse();
      }
      return lines;
    }
    function calculateSizesOnAxisA(lines) {
      var sizesAllLines = [];
      for (var lineIndex = 0;lineIndex < lines.length;++lineIndex) {
        var line = lines[lineIndex];
        var sizesThisLine = getElementSizeProperties(line);
        var idealRequiredSpace = calculateTotalSpace(sizesThisLine, a);
        var fittingAction = determineFittingAction(options[a.fitting], idealRequiredSpace, availableSpace[a.axis]);
        if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
          stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
        } else {
          if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
            shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
          }
        }
        sizesAllLines.push(sizesThisLine);
      }
      return sizesAllLines;
    }
    function calculateSizesOnAxisB(lines, sizesAllLines) {
      var largestElementsForEachLine = [];
      var largestSizesForEachLine = [];
      var elementIndex;
      var lineIndex;
      var line;
      for (lineIndex = 0;lineIndex < lines.length;++lineIndex) {
        line = lines[lineIndex];
        line.largestElement = null;
        line.largestSize = {width:Number.NEGATIVE_INFINITY, height:Number.NEGATIVE_INFINITY};
        for (elementIndex = 0;elementIndex < line.length;++elementIndex) {
          var sizesThisElement = sizesAllLines[lineIndex][elementIndex];
          if (sizesThisElement[b.size] > line.largestSize[b.size]) {
            line.largestElement = line[elementIndex];
            line.largestSize = sizesThisElement;
          }
        }
        largestElementsForEachLine.push(line.largestElement);
        largestSizesForEachLine.push(line.largestSize);
      }
      var idealRequiredSpace = calculateTotalSpace(largestSizesForEachLine, b);
      var fittingAction = determineFittingAction(options[b.fitting], idealRequiredSpace, availableSpace[b.axis]);
      if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
        stretchSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
      } else {
        if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
          shrinkSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
        }
      }
      for (lineIndex = 0;lineIndex < lines.length;++lineIndex) {
        line = lines[lineIndex];
        for (elementIndex = 0;elementIndex < line.length;++elementIndex) {
          var sizesForThisElement = sizesAllLines[lineIndex][elementIndex];
          var currentSize = sizesForThisElement[b.size];
          var availableSize = lines.length === 1 ? availableSpace[b.axis] : line.largestSize[b.size];
          var elementFittingAction = determineFittingAction(options[b.fitting], currentSize, availableSize);
          if (elementFittingAction === FITTING_ACTION.APPLY_STRETCHING) {
            sizesForThisElement[b.size] = Math.min(availableSize, sizesForThisElement[b.maxSize]);
          } else {
            if (elementFittingAction === FITTING_ACTION.APPLY_SHRINKING) {
              sizesForThisElement[b.size] = Math.max(availableSize, sizesForThisElement[b.minSize]);
            }
          }
        }
      }
      return sizesAllLines;
    }
    function determineFittingAction(fittingMode, currentSize, availableSize) {
      switch(fittingMode) {
        case pc.FITTING_NONE:
          return FITTING_ACTION.NONE;
        case pc.FITTING_STRETCH:
          if (currentSize < availableSize) {
            return FITTING_ACTION.APPLY_STRETCHING;
          }
          return FITTING_ACTION.NONE;
        case pc.FITTING_SHRINK:
          if (currentSize >= availableSize) {
            return FITTING_ACTION.APPLY_SHRINKING;
          }
          return FITTING_ACTION.NONE;
        case pc.FITTING_BOTH:
          if (currentSize < availableSize) {
            return FITTING_ACTION.APPLY_STRETCHING;
          } else {
            if (currentSize >= availableSize) {
              return FITTING_ACTION.APPLY_SHRINKING;
            }
          }
          return FITTING_ACTION.NONE;
        default:
          throw new Error("Unrecognized fitting mode: " + fittingMode);
      }
    }
    function calculateTotalSpace(sizes, axis) {
      var totalSizes = sumValues(sizes, axis.size);
      var totalSpacing = (sizes.length - 1) * options.spacing[axis.axis];
      return totalSizes + totalSpacing;
    }
    function stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
      var ascendingMaxSizeOrder = getTraversalOrder(sizesThisLine, axis.maxSize);
      var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
      var fittingProportionSums = createSumArray(fittingProportions, ascendingMaxSizeOrder);
      var remainingUndershoot = availableSpace[axis.axis] - idealRequiredSpace;
      for (var i = 0;i < sizesThisLine.length;++i) {
        var index = ascendingMaxSizeOrder[i];
        var targetIncrease = calculateAdjustment(index, remainingUndershoot, fittingProportions, fittingProportionSums);
        var targetSize = sizesThisLine[index][axis.size] + targetIncrease;
        var maxSize = sizesThisLine[index][axis.maxSize];
        var actualSize = Math.min(targetSize, maxSize);
        sizesThisLine[index][axis.size] = actualSize;
        var actualIncrease = Math.max(targetSize - actualSize, 0);
        var appliedIncrease = targetIncrease - actualIncrease;
        remainingUndershoot -= appliedIncrease;
      }
    }
    function shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
      var descendingMinSizeOrder = getTraversalOrder(sizesThisLine, axis.minSize, true);
      var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
      var inverseFittingProportions = invertNormalizedValues(fittingProportions);
      var inverseFittingProportionSums = createSumArray(inverseFittingProportions, descendingMinSizeOrder);
      var remainingOvershoot = idealRequiredSpace - availableSpace[axis.axis];
      for (var i = 0;i < sizesThisLine.length;++i) {
        var index = descendingMinSizeOrder[i];
        var targetReduction = calculateAdjustment(index, remainingOvershoot, inverseFittingProportions, inverseFittingProportionSums);
        var targetSize = sizesThisLine[index][axis.size] - targetReduction;
        var minSize = sizesThisLine[index][axis.minSize];
        var actualSize = Math.max(targetSize, minSize);
        sizesThisLine[index][axis.size] = actualSize;
        var actualReduction = Math.max(actualSize - targetSize, 0);
        var appliedReduction = targetReduction - actualReduction;
        remainingOvershoot -= appliedReduction;
      }
    }
    function calculateAdjustment(index, remainingAdjustment, fittingProportions, fittingProportionSums) {
      var proportion = fittingProportions[index];
      var sumOfRemainingProportions = fittingProportionSums[index];
      if (Math.abs(proportion) < 1e-5 && Math.abs(sumOfRemainingProportions) < 1e-5) {
        return remainingAdjustment;
      }
      return remainingAdjustment * proportion / sumOfRemainingProportions;
    }
    function calculateBasePositions(lines, sizes) {
      var cursor = {};
      cursor[a.axis] = 0;
      cursor[b.axis] = 0;
      lines[a.size] = Number.NEGATIVE_INFINITY;
      var positionsAllLines = [];
      for (var lineIndex = 0;lineIndex < lines.length;++lineIndex) {
        var line = lines[lineIndex];
        if (line.length === 0) {
          return;
        }
        var positionsThisLine = [];
        var sizesThisLine = sizes[lineIndex];
        for (var elementIndex = 0;elementIndex < line.length;++elementIndex) {
          var element = line[elementIndex];
          var sizesThisElement = sizesThisLine[elementIndex];
          cursor[b.axis] -= minExtentB(element, sizesThisElement);
          cursor[a.axis] -= minExtentA(element, sizesThisElement);
          positionsThisLine[elementIndex] = {};
          positionsThisLine[elementIndex][a.axis] = cursor[a.axis];
          positionsThisLine[elementIndex][b.axis] = cursor[b.axis];
          cursor[b.axis] += minExtentB(element, sizesThisElement);
          cursor[a.axis] += maxExtentA(element, sizesThisElement) + options.spacing[a.axis];
        }
        line[a.size] = cursor[a.axis] - options.spacing[a.axis];
        line[b.size] = line.largestSize[b.size];
        lines[a.size] = Math.max(lines[a.size], line[a.size]);
        cursor[a.axis] = 0;
        cursor[b.axis] += line[b.size] + options.spacing[b.axis];
        positionsAllLines.push(positionsThisLine);
      }
      lines[b.size] = cursor[b.axis] - options.spacing[b.axis];
      return positionsAllLines;
    }
    function applyAlignmentAndPadding(lines, sizes, positions) {
      var alignmentA = options.alignment[a.axis];
      var alignmentB = options.alignment[b.axis];
      var paddingA = options.padding[a.axis];
      var paddingB = options.padding[b.axis];
      for (var lineIndex = 0;lineIndex < lines.length;++lineIndex) {
        var line = lines[lineIndex];
        var sizesThisLine = sizes[lineIndex];
        var positionsThisLine = positions[lineIndex];
        var axisAOffset = (availableSpace[a.axis] - line[a.size]) * alignmentA + paddingA;
        var axisBOffset = (availableSpace[b.axis] - lines[b.size]) * alignmentB + paddingB;
        for (var elementIndex = 0;elementIndex < line.length;++elementIndex) {
          var withinLineAxisBOffset = (line[b.size] - sizesThisLine[elementIndex][b.size]) * options.alignment[b.axis];
          positionsThisLine[elementIndex][a.axis] += axisAOffset;
          positionsThisLine[elementIndex][b.axis] += axisBOffset + withinLineAxisBOffset;
        }
      }
    }
    function applySizesAndPositions(lines, sizes, positions) {
      for (var lineIndex = 0;lineIndex < lines.length;++lineIndex) {
        var line = lines[lineIndex];
        var sizesThisLine = sizes[lineIndex];
        var positionsThisLine = positions[lineIndex];
        for (var elementIndex = 0;elementIndex < line.length;++elementIndex) {
          var element = line[elementIndex];
          element[a.calculatedSize] = sizesThisLine[elementIndex][a.size];
          element[b.calculatedSize] = sizesThisLine[elementIndex][b.size];
          if (options.orientation === pc.ORIENTATION_HORIZONTAL) {
            element.entity.setLocalPosition(positionsThisLine[elementIndex][a.axis], positionsThisLine[elementIndex][b.axis], element.entity.getLocalPosition().z);
          } else {
            element.entity.setLocalPosition(positionsThisLine[elementIndex][b.axis], positionsThisLine[elementIndex][a.axis], element.entity.getLocalPosition().z);
          }
        }
      }
    }
    function createLayoutInfo(lines) {
      var layoutWidth = lines.width;
      var layoutHeight = lines.height;
      var xOffset = (availableSpace.x - layoutWidth) * options.alignment.x + options.padding.x;
      var yOffset = (availableSpace.y - layoutHeight) * options.alignment.y + options.padding.y;
      return {bounds:new pc.Vec4(xOffset, yOffset, layoutWidth, layoutHeight)};
    }
    function getElementSizeProperties(elements) {
      var sizeProperties = [];
      for (var i = 0;i < elements.length;++i) {
        var element = elements[i];
        var minWidth = Math.max(getProperty(element, "minWidth"), 0);
        var minHeight = Math.max(getProperty(element, "minHeight"), 0);
        var maxWidth = Math.max(getProperty(element, "maxWidth"), minWidth);
        var maxHeight = Math.max(getProperty(element, "maxHeight"), minHeight);
        var width = clamp(getProperty(element, "width"), minWidth, maxWidth);
        var height = clamp(getProperty(element, "height"), minHeight, maxHeight);
        var fitWidthProportion = getProperty(element, "fitWidthProportion");
        var fitHeightProportion = getProperty(element, "fitHeightProportion");
        sizeProperties.push({minWidth:minWidth, minHeight:minHeight, maxWidth:maxWidth, maxHeight:maxHeight, width:width, height:height, fitWidthProportion:fitWidthProportion, fitHeightProportion:fitHeightProportion});
      }
      return sizeProperties;
    }
    function getProperty(element, propertyName) {
      var layoutChildComponent = element.entity.layoutchild;
      if (layoutChildComponent && layoutChildComponent.enabled && layoutChildComponent[propertyName] !== undefined && layoutChildComponent[propertyName] !== null) {
        return layoutChildComponent[propertyName];
      } else {
        if (element[propertyName] !== undefined) {
          return element[propertyName];
        }
      }
      return PROPERTY_DEFAULTS[propertyName];
    }
    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }
    function sumValues(items, propertyName) {
      return items.reduce(function(accumulator, current) {
        return accumulator + current[propertyName];
      }, 0);
    }
    function getNormalizedValues(items, propertyName) {
      var sum = sumValues(items, propertyName);
      var normalizedValues = [];
      var numItems = items.length;
      var i;
      if (sum === 0) {
        for (i = 0;i < numItems;++i) {
          normalizedValues.push(1 / numItems);
        }
      } else {
        for (i = 0;i < numItems;++i) {
          normalizedValues.push(items[i][propertyName] / sum);
        }
      }
      return normalizedValues;
    }
    function invertNormalizedValues(values) {
      if (values.length === 1) {
        return [1];
      }
      var invertedValues = [];
      var numValues = values.length;
      for (var i = 0;i < numValues;++i) {
        invertedValues.push((1 - values[i]) / (numValues - 1));
      }
      return invertedValues;
    }
    function getTraversalOrder(items, orderBy, descending) {
      items.forEach(assignIndex);
      return items.slice().sort(function(itemA, itemB) {
        return descending ? itemB[orderBy] - itemA[orderBy] : itemA[orderBy] - itemB[orderBy];
      }).map(getIndex);
    }
    function assignIndex(item, index) {
      item.index = index;
    }
    function getIndex(item) {
      return item.index;
    }
    function createSumArray(values, order) {
      var sumArray = [];
      sumArray[order[values.length - 1]] = values[order[values.length - 1]];
      for (var i = values.length - 2;i >= 0;--i) {
        sumArray[order[i]] = sumArray[order[i + 1]] + values[order[i]];
      }
      return sumArray;
    }
    return calculateAll;
  }
  var CALCULATE_FNS = {};
  CALCULATE_FNS[pc.ORIENTATION_HORIZONTAL] = createCalculator(pc.ORIENTATION_HORIZONTAL);
  CALCULATE_FNS[pc.ORIENTATION_VERTICAL] = createCalculator(pc.ORIENTATION_VERTICAL);
  Object.assign(LayoutCalculator.prototype, {calculateLayout:function(elements, options) {
    var calculateFn = CALCULATE_FNS[options.orientation];
    if (!calculateFn) {
      throw new Error("Unrecognized orientation value: " + options.orientation);
    } else {
      return calculateFn(elements, options);
    }
  }});
  return {LayoutCalculator:LayoutCalculator};
}());
Object.assign(pc, function() {
  var LayoutChildComponent = function LayoutChildComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this._minWidth = 0;
    this._minHeight = 0;
    this._maxWidth = null;
    this._maxHeight = null;
    this._fitWidthProportion = 0;
    this._fitHeightProportion = 0;
    this._excludeFromLayout = false;
  };
  LayoutChildComponent.prototype = Object.create(pc.Component.prototype);
  LayoutChildComponent.prototype.constructor = LayoutChildComponent;
  function defineResizeProperty(name) {
    var _name = "_" + name;
    Object.defineProperty(LayoutChildComponent.prototype, name, {get:function() {
      return this[_name];
    }, set:function(value) {
      if (this[_name] !== value) {
        this[_name] = value;
        this.fire("resize");
      }
    }});
  }
  defineResizeProperty("minWidth");
  defineResizeProperty("minHeight");
  defineResizeProperty("maxWidth");
  defineResizeProperty("maxHeight");
  defineResizeProperty("fitWidthProportion");
  defineResizeProperty("fitHeightProportion");
  defineResizeProperty("excludeFromLayout");
  return {LayoutChildComponent:LayoutChildComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled"];
  var LayoutChildComponentSystem = function LayoutChildComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "layoutchild";
    this.app = app;
    app.systems.add(this.id, this);
    this.ComponentType = pc.LayoutChildComponent;
    this.DataType = pc.LayoutChildComponentData;
    this.schema = _schema;
  };
  LayoutChildComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  LayoutChildComponentSystem.prototype.constructor = LayoutChildComponentSystem;
  pc.Component._buildAccessors(pc.LayoutChildComponent.prototype, _schema);
  Object.assign(LayoutChildComponentSystem.prototype, {initializeComponentData:function(component, data, properties) {
    if (data.enabled !== undefined) {
      component.enabled = data.enabled;
    }
    if (data.minWidth !== undefined) {
      component.minWidth = data.minWidth;
    }
    if (data.minHeight !== undefined) {
      component.minHeight = data.minHeight;
    }
    if (data.maxWidth !== undefined) {
      component.maxWidth = data.maxWidth;
    }
    if (data.maxHeight !== undefined) {
      component.maxHeight = data.maxHeight;
    }
    if (data.fitWidthProportion !== undefined) {
      component.fitWidthProportion = data.fitWidthProportion;
    }
    if (data.fitHeightProportion !== undefined) {
      component.fitHeightProportion = data.fitHeightProportion;
    }
    if (data.excludeFromLayout !== undefined) {
      component.excludeFromLayout = data.excludeFromLayout;
    }
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
  }, cloneComponent:function(entity, clone) {
    var layoutChild = entity.layoutchild;
    return this.addComponent(clone, {enabled:layoutChild.enabled, minWidth:layoutChild.minWidth, minHeight:layoutChild.minHeight, maxWidth:layoutChild.maxWidth, maxHeight:layoutChild.maxHeight, fitWidthProportion:layoutChild.fitWidthProportion, fitHeightProportion:layoutChild.fitHeightProportion, excludeFromLayout:layoutChild.excludeFromLayout});
  }});
  return {LayoutChildComponentSystem:LayoutChildComponentSystem};
}());
Object.assign(pc, function() {
  var LayoutChildComponentData = function() {
    this.enabled = true;
  };
  return {LayoutChildComponentData:LayoutChildComponentData};
}());
Object.assign(pc, function() {
  pc.FONT_MSDF = "msdf";
  var Font = function(textures, data) {
    this.type = pc.FONT_MSDF;
    this.em = 1;
    this.textures = textures;
    this.intensity = 0.0;
    this._data = null;
    this.data = data;
  };
  Object.defineProperty(Font.prototype, "data", {get:function() {
    return this._data;
  }, set:function(value) {
    this._data = value;
    if (!value) {
      return;
    }
    if (this._data.intensity !== undefined) {
      this.intensity = this._data.intensity;
    }
    if (!this._data.info) {
      this._data.info = {};
    }
    if (!this._data.version || this._data.version < 2) {
      this._data.info.maps = [{width:this._data.info.width, height:this._data.info.height}];
      if (this._data.chars) {
        for (var key in this._data.chars) {
          this._data.chars[key].map = 0;
        }
      }
    }
  }});
  return {FONT_MSDF:pc.FONT_MSDF, Font:Font};
}());
Object.assign(pc, function() {
  var ZoneComponent = function ZoneComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this._oldState = true;
    this._size = new pc.Vec3;
    this.on("set_enabled", this._onSetEnabled, this);
  };
  ZoneComponent.prototype = Object.create(pc.Component.prototype);
  ZoneComponent.prototype.constructor = ZoneComponent;
  Object.assign(ZoneComponent.prototype, {onEnable:function() {
    pc.Component.prototype.onEnable.call(this);
    this._checkState();
  }, onDisable:function() {
    pc.Component.prototype.onDisable.call(this);
    this._checkState();
  }, _onSetEnabled:function(prop, old, value) {
    this._checkState();
  }, _checkState:function() {
    var state = this.enabled && this.entity.enabled;
    if (state === this._oldState) {
      return;
    }
    this._oldState = state;
    this.fire("enable");
    this.fire("state", this.enabled);
  }, _onBeforeRemove:function() {
    this.fire("remove");
  }});
  Object.defineProperty(ZoneComponent.prototype, "size", {set:function(data) {
    if (data instanceof pc.Vec3) {
      this._size.copy(data);
    } else {
      if (data instanceof Array && data.length >= 3) {
        this.size.set(data[0], data[1], data[2]);
      }
    }
  }, get:function() {
    return this._size;
  }});
  return {ZoneComponent:ZoneComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled"];
  var ZoneComponentSystem = function ZoneComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "zone";
    this.app = app;
    app.systems.add(this.id, this);
    this.ComponentType = pc.ZoneComponent;
    this.DataType = pc.ZoneComponentData;
    this.schema = _schema;
    this.on("beforeremove", this._onBeforeRemove, this);
  };
  ZoneComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  ZoneComponentSystem.prototype.constructor = ZoneComponentSystem;
  pc.Component._buildAccessors(pc.ZoneComponent.prototype, _schema);
  Object.assign(ZoneComponentSystem.prototype, {initializeComponentData:function(component, data, properties) {
    component.enabled = data.hasOwnProperty("enabled") ? !!data.enabled : true;
    if (data.size) {
      if (data.size instanceof pc.Vec3) {
        component.size.copy(data.size);
      } else {
        if (data.size instanceof Array && data.size.length >= 3) {
          component.size.set(data.size[0], data.size[1], data.size[2]);
        }
      }
    }
  }, cloneComponent:function(entity, clone) {
    var data = {size:entity.zone.size};
    return this.addComponent(clone, data);
  }, _onBeforeRemove:function(entity, component) {
    component._onBeforeRemove();
  }});
  return {ZoneComponentSystem:ZoneComponentSystem};
}());
Object.assign(pc, function() {
  var ZoneComponentData = function() {
    this.enabled = true;
  };
  return {ZoneComponentData:ZoneComponentData};
}());
Object.assign(pc, function() {
  var Entity = function(name, app) {
    pc.GraphNode.call(this, name);
    if (name instanceof pc.Application) {
      app = name;
    }
    this._guid = pc.guid.create();
    this._batchHandle = null;
    this.c = {};
    this._app = app;
    if (!app) {
      this._app = pc.Application.getApplication();
      if (!this._app) {
        console.error("Couldn't find current application");
      }
    }
    pc.events.attach(this);
  };
  Entity.prototype = Object.create(pc.GraphNode.prototype);
  Entity.prototype.constructor = Entity;
  Entity.prototype.addComponent = function(type, data) {
    var system = this._app.systems[type];
    if (!system) {
      return null;
    }
    if (this.c[type]) {
      return null;
    }
    return system.addComponent(this, data);
  };
  Entity.prototype.removeComponent = function(type) {
    var system = this._app.systems[type];
    if (!system) {
      return;
    }
    if (!this.c[type]) {
      return;
    }
    system.removeComponent(this);
  };
  Entity.prototype.getGuid = function() {
    return this._guid;
  };
  Entity.prototype.setGuid = function(guid) {
    this._guid = guid;
  };
  Entity.prototype._notifyHierarchyStateChanged = function(node, enabled) {
    var enableFirst = false;
    if (node === this && this._app._enableList.length === 0) {
      enableFirst = true;
    }
    node._beingEnabled = true;
    node._onHierarchyStateChanged(enabled);
    if (node._onHierarchyStatePostChanged) {
      this._app._enableList.push(node);
    }
    var i, len;
    var c = node._children;
    for (i = 0, len = c.length;i < len;i++) {
      if (c[i]._enabled) {
        this._notifyHierarchyStateChanged(c[i], enabled);
      }
    }
    node._beingEnabled = false;
    if (enableFirst) {
      for (i = 0, len = this._app._enableList.length;i < len;i++) {
        this._app._enableList[i]._onHierarchyStatePostChanged();
      }
      this._app._enableList.length = 0;
    }
  };
  Entity.prototype._onHierarchyStateChanged = function(enabled) {
    pc.GraphNode.prototype._onHierarchyStateChanged.call(this, enabled);
    var component;
    var components = this.c;
    for (var type in components) {
      if (components.hasOwnProperty(type)) {
        component = components[type];
        if (component.enabled) {
          if (enabled) {
            component.onEnable();
          } else {
            component.onDisable();
          }
        }
      }
    }
  };
  Entity.prototype._onHierarchyStatePostChanged = function() {
    var components = this.c;
    for (var type in components) {
      if (components.hasOwnProperty(type)) {
        components[type].onPostStateChange();
      }
    }
  };
  Entity.prototype.setRequest = function(request) {
    this._request = request;
  };
  Entity.prototype.getRequest = function() {
    return this._request;
  };
  Entity.prototype.findByGuid = function(guid) {
    if (this._guid === guid) {
      return this;
    }
    for (var i = 0;i < this._children.length;i++) {
      if (this._children[i].findByGuid) {
        var found = this._children[i].findByGuid(guid);
        if (found !== null) {
          return found;
        }
      }
    }
    return null;
  };
  Entity.prototype.destroy = function() {
    var name;
    for (name in this.c) {
      this.c[name].enabled = false;
    }
    for (name in this.c) {
      this.c[name].system.removeComponent(this);
    }
    if (this._parent) {
      this._parent.removeChild(this);
    }
    var children = this._children;
    var child = children.shift();
    while (child) {
      if (child instanceof pc.Entity) {
        child.destroy();
      }
      child._parent = null;
      child = children.shift();
    }
    this.fire("destroy", this);
    if (this._callbacks) {
      this._callbacks = null;
    }
    if (this._callbackActive) {
      this._callbackActive = null;
    }
  };
  Entity.prototype.clone = function() {
    var duplicatedIdsMap = {};
    var c = this._cloneRecursively(duplicatedIdsMap);
    duplicatedIdsMap[this.getGuid()] = c.getGuid();
    resolveDuplicatedEntityReferenceProperties(this, this, c, duplicatedIdsMap);
    return c;
  };
  Entity.prototype._cloneRecursively = function(duplicatedIdsMap) {
    var type;
    var c = new pc.Entity(this._app);
    pc.GraphNode.prototype._cloneInternal.call(this, c);
    for (type in this.c) {
      var component = this.c[type];
      component.system.cloneComponent(this, c);
    }
    var i;
    for (i = 0;i < this._children.length;i++) {
      var oldChild = this._children[i];
      if (oldChild instanceof pc.Entity) {
        var newChild = oldChild._cloneRecursively(duplicatedIdsMap);
        c.addChild(newChild);
        duplicatedIdsMap[oldChild.getGuid()] = newChild.getGuid();
      }
    }
    return c;
  };
  function resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldEntity, newEntity, duplicatedIdsMap) {
    if (oldEntity instanceof pc.Entity) {
      var components = oldEntity.c;
      Object.keys(components).forEach(function(componentName) {
        var component = components[componentName];
        var entityProperties = component.system.getPropertiesOfType("entity");
        entityProperties.forEach(function(propertyDescriptor) {
          var propertyName = propertyDescriptor.name;
          var oldEntityReferenceId = component[propertyName];
          var entityIsWithinOldSubtree = !!oldSubtreeRoot.findByGuid(oldEntityReferenceId);
          if (entityIsWithinOldSubtree) {
            var newEntityReferenceId = duplicatedIdsMap[oldEntityReferenceId];
            if (newEntityReferenceId) {
              newEntity.c[componentName][propertyName] = newEntityReferenceId;
            } else {
              console.warn("Could not find corresponding entity id when resolving duplicated entity references");
            }
          }
        });
      });
      var _old = oldEntity.children.filter(function(e) {
        return e instanceof pc.Entity;
      });
      var _new = newEntity.children.filter(function(e) {
        return e instanceof pc.Entity;
      });
      _old.forEach(function(oldChild, index) {
        resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldChild, _new[index], duplicatedIdsMap);
      });
    }
  }
  return {Entity:Entity};
}());
Object.assign(pc, function() {
  function EntityReference(parentComponent, entityPropertyName, eventConfig) {
    if (!parentComponent || !(parentComponent instanceof pc.Component)) {
      throw new Error("The parentComponent argument is required and must be a Component");
    } else {
      if (!entityPropertyName || typeof entityPropertyName !== "string") {
        throw new Error("The propertyName argument is required and must be a string");
      } else {
        if (eventConfig && typeof eventConfig !== "object") {
          throw new Error("If provided, the eventConfig argument must be an object");
        }
      }
    }
    this._parentComponent = parentComponent;
    this._entityPropertyName = entityPropertyName;
    this._entity = null;
    this._app = parentComponent.system.app;
    this._configureEventListeners(eventConfig || {}, {"entity#destroy":this._onEntityDestroy});
    this._toggleLifecycleListeners("on");
  }
  Object.assign(EntityReference.prototype, {_configureEventListeners:function(externalEventConfig, internalEventConfig) {
    var externalEventListenerConfigs = this._parseEventListenerConfig(externalEventConfig, "external", this._parentComponent);
    var internalEventListenerConfigs = this._parseEventListenerConfig(internalEventConfig, "internal", this);
    this._eventListenerConfigs = externalEventListenerConfigs.concat(internalEventListenerConfigs);
    this._listenerStatusFlags = {};
    this._gainListeners = {};
    this._loseListeners = {};
  }, _parseEventListenerConfig:function(eventConfig, prefix, scope) {
    return Object.keys(eventConfig).map(function(listenerDescription, index) {
      var listenerDescriptionParts = listenerDescription.split("#");
      var sourceName = listenerDescriptionParts[0];
      var eventName = listenerDescriptionParts[1];
      var callback = eventConfig[listenerDescription];
      if (listenerDescriptionParts.length !== 2 || typeof sourceName !== "string" || sourceName.length === 0 || typeof eventName !== "string" || eventName.length === 0) {
        throw new Error("Invalid event listener description: `" + listenerDescription + "`");
      }
      if (typeof callback !== "function") {
        throw new Error("Invalid or missing callback for event listener `" + listenerDescription + "`");
      }
      return {id:prefix + "_" + index + "_" + listenerDescription, sourceName:sourceName, eventName:eventName, callback:callback, scope:scope};
    }, this);
  }, _toggleLifecycleListeners:function(onOrOff) {
    this._parentComponent[onOrOff]("set_" + this._entityPropertyName, this._onSetEntity, this);
    this._parentComponent.system[onOrOff]("beforeremove", this._onParentComponentRemove, this);
    pc.ComponentSystem[onOrOff]("postInitialize", this._onPostInitialize, this);
    this._app.on("tools:sceneloaded", this._onSceneLoaded, this);
    var allComponentSystems = [];
    for (var i = 0;i < this._eventListenerConfigs.length;++i) {
      var config = this._eventListenerConfigs[i];
      var componentSystem = this._app.systems[config.sourceName];
      if (componentSystem) {
        if (allComponentSystems.indexOf(componentSystem) === -1) {
          allComponentSystems.push(componentSystem);
        }
        if (componentSystem && config.eventName === "gain") {
          this._gainListeners[config.sourceName] = config;
        }
        if (componentSystem && config.eventName === "lose") {
          this._loseListeners[config.sourceName] = config;
        }
      }
    }
    for (var j = 0;j < allComponentSystems.length;++j) {
      allComponentSystems[j][onOrOff]("add", this._onComponentAdd, this);
      allComponentSystems[j][onOrOff]("beforeremove", this._onComponentRemove, this);
    }
  }, _onSetEntity:function(name, oldValue, newValue) {
    if (newValue instanceof pc.Entity) {
      this._updateEntityReference();
    } else {
      if (newValue !== null && newValue !== undefined && typeof newValue !== "string") {
        console.warn("Entity field `" + this._entityPropertyName + "` was set to unexpected type '" + typeof newValue + "'");
        return;
      }
      if (oldValue !== newValue) {
        this._updateEntityReference();
      }
    }
  }, _onPostInitialize:function() {
    this._updateEntityReference();
  }, _onSceneLoaded:function() {
    this._updateEntityReference();
  }, _updateEntityReference:function() {
    var nextEntityGuid = this._parentComponent.data[this._entityPropertyName];
    var nextEntity;
    if (nextEntityGuid instanceof pc.Entity) {
      nextEntity = nextEntityGuid;
      nextEntityGuid = nextEntity.getGuid();
      this._parentComponent.data[this._entityPropertyName] = nextEntityGuid;
    } else {
      nextEntity = nextEntityGuid ? this._parentComponent.system.app.root.findByGuid(nextEntityGuid) : null;
    }
    var hasChanged = this._entity !== nextEntity;
    if (hasChanged) {
      if (this._entity) {
        this._onBeforeEntityChange();
      }
      this._entity = nextEntity;
      if (this._entity) {
        this._onAfterEntityChange();
      }
    }
  }, _onBeforeEntityChange:function() {
    this._toggleEntityListeners("off");
    this._callAllGainOrLoseListeners(this._loseListeners);
  }, _onAfterEntityChange:function() {
    this._toggleEntityListeners("on");
    this._callAllGainOrLoseListeners(this._gainListeners);
  }, _onComponentAdd:function(entity, component) {
    var componentName = component.system.name;
    if (entity === this._entity) {
      this._callGainOrLoseListener(componentName, this._gainListeners);
      this._toggleComponentListeners("on", componentName);
    }
  }, _onComponentRemove:function(entity, component) {
    var componentName = component.system.name;
    if (entity === this._entity) {
      this._callGainOrLoseListener(componentName, this._loseListeners);
      this._toggleComponentListeners("off", componentName, true);
    }
  }, _callAllGainOrLoseListeners:function(listenerMap) {
    for (var componentName in this._entity.c) {
      this._callGainOrLoseListener(componentName, listenerMap);
    }
  }, _callGainOrLoseListener:function(componentName, listenerMap) {
    if (this._entity.c.hasOwnProperty(componentName) && listenerMap[componentName]) {
      var config = listenerMap[componentName];
      config.callback.call(config.scope);
    }
  }, _toggleEntityListeners:function(onOrOff, isDestroying) {
    if (this._entity) {
      for (var i = 0;i < this._eventListenerConfigs.length;++i) {
        this._safeToggleListener(onOrOff, this._eventListenerConfigs[i], isDestroying);
      }
    }
  }, _toggleComponentListeners:function(onOrOff, componentName, isDestroying) {
    for (var i = 0;i < this._eventListenerConfigs.length;++i) {
      var config = this._eventListenerConfigs[i];
      if (config.sourceName === componentName) {
        this._safeToggleListener(onOrOff, config, isDestroying);
      }
    }
  }, _safeToggleListener:function(onOrOff, config, isDestroying) {
    var isAdding = onOrOff === "on";
    if (isAdding && this._listenerStatusFlags[config.id]) {
      return;
    }
    var source = this._getEventSource(config.sourceName, isDestroying);
    if (source) {
      source[onOrOff](config.eventName, config.callback, config.scope);
      this._listenerStatusFlags[config.id] = isAdding;
    }
  }, _getEventSource:function(sourceName, isDestroying) {
    if (sourceName === "entity") {
      return this._entity;
    }
    var component = this._entity[sourceName];
    if (component) {
      return component;
    }
    if (!isDestroying) {
      console.warn("Entity has no component with name " + sourceName);
    }
    return null;
  }, _onEntityDestroy:function(entity) {
    if (this._entity === entity) {
      this._toggleEntityListeners("off", true);
      this._entity = null;
    }
  }, _onParentComponentRemove:function(entity, component) {
    if (component === this._parentComponent) {
      this._toggleLifecycleListeners("off");
      this._toggleEntityListeners("off", true);
    }
  }, hasComponent:function(componentName) {
    return this._entity && this._entity.c ? !!this._entity.c[componentName] : false;
  }});
  Object.defineProperty(EntityReference.prototype, "entity", {get:function() {
    return this._entity;
  }});
  return {EntityReference:EntityReference};
}());
Object.assign(pc, function() {
  var ResourceLoader = function() {
    this._handlers = {};
    this._requests = {};
    this._cache = {};
  };
  Object.assign(ResourceLoader.prototype, {addHandler:function(type, handler) {
    this._handlers[type] = handler;
    handler._loader = this;
  }, removeHandler:function(type) {
    delete this._handlers[type];
  }, getHandler:function(type) {
    return this._handlers[type];
  }, load:function(url, type, callback, asset) {
    var handler = this._handlers[type];
    if (!handler) {
      var err = "No handler for asset type: " + type;
      callback(err);
      return;
    }
    var key = url + type;
    if (this._cache[key] !== undefined) {
      callback(null, this._cache[key]);
    } else {
      if (this._requests[key]) {
        this._requests[key].push(callback);
      } else {
        this._requests[key] = [callback];
        handler.load(url, function(err, data, extra) {
          if (!this._requests[key]) {
            return;
          }
          var i, len = this._requests[key].length;
          if (!err) {
            var resource = handler.open(url, data, asset);
            this._cache[key] = resource;
            for (i = 0;i < len;i++) {
              this._requests[key][i](null, resource, extra);
            }
          } else {
            for (i = 0;i < len;i++) {
              this._requests[key][i](err);
            }
          }
          delete this._requests[key];
        }.bind(this), asset);
      }
    }
  }, open:function(type, data) {
    var handler = this._handlers[type];
    if (!handler) {
      console.warn("No resource handler found for: " + type);
      return data;
    }
    return handler.open(null, data);
  }, patch:function(asset, assets) {
    var handler = this._handlers[asset.type];
    if (!handler) {
      console.warn("No resource handler found for: " + asset.type);
      return;
    }
    if (handler.patch) {
      handler.patch(asset, assets);
    }
  }, clearCache:function(url, type) {
    delete this._cache[url + type];
  }, getFromCache:function(url, type) {
    if (this._cache[url + type]) {
      return this._cache[url + type];
    }
  }, destroy:function() {
    this._handlers = {};
    this._requests = {};
    this._cache = {};
  }});
  return {ResourceLoader:ResourceLoader};
}());
Object.assign(pc, function() {
  var AnimationHandler = function() {
  };
  Object.assign(AnimationHandler.prototype, {load:function(url, callback) {
    pc.http.get(url, function(err, response) {
      if (err) {
        callback(pc.string.format("Error loading animation resource: {0} [{1}]", url, err));
      } else {
        callback(null, response);
      }
    });
  }, open:function(url, data) {
    return this["_parseAnimationV" + data.animation.version](data);
  }, _parseAnimationV3:function(data) {
    var animData = data.animation;
    var anim = new pc.Animation;
    anim.setName(animData.name);
    anim.duration = animData.duration;
    for (var i = 0;i < animData.nodes.length;i++) {
      var node = new pc.Node;
      var n = animData.nodes[i];
      node._name = n.name;
      for (var j = 0;j < n.keys.length;j++) {
        var k = n.keys[j];
        var t = k.time;
        var p = k.pos;
        var r = k.rot;
        var s = k.scale;
        var pos = new pc.Vec3(p[0], p[1], p[2]);
        var rot = (new pc.Quat).setFromEulerAngles(r[0], r[1], r[2]);
        var scl = new pc.Vec3(s[0], s[1], s[2]);
        var key = new pc.Key(t, pos, rot, scl);
        node._keys.push(key);
      }
      anim.addNode(node);
    }
    return anim;
  }, _parseAnimationV4:function(data) {
    var animData = data.animation;
    var anim = new pc.Animation;
    anim.setName(animData.name);
    anim.duration = animData.duration;
    for (var i = 0;i < animData.nodes.length;i++) {
      var node = new pc.Node;
      var n = animData.nodes[i];
      node._name = n.name;
      var defPos = n.defaults.p;
      var defRot = n.defaults.r;
      var defScl = n.defaults.s;
      for (var j = 0;j < n.keys.length;j++) {
        var k = n.keys[j];
        var t = k.t;
        var p = defPos ? defPos : k.p;
        var r = defRot ? defRot : k.r;
        var s = defScl ? defScl : k.s;
        var pos = new pc.Vec3(p[0], p[1], p[2]);
        var rot = (new pc.Quat).setFromEulerAngles(r[0], r[1], r[2]);
        var scl = new pc.Vec3(s[0], s[1], s[2]);
        var key = new pc.Key(t, pos, rot, scl);
        node._keys.push(key);
      }
      anim.addNode(node);
    }
    return anim;
  }});
  return {AnimationHandler:AnimationHandler};
}());
Object.assign(pc, function() {
  var ie = function() {
    var ua = window.navigator.userAgent;
    var msie = ua.indexOf("MSIE ");
    if (msie > 0) {
      return parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)), 10);
    }
    var trident = ua.indexOf("Trident/");
    if (trident > 0) {
      var rv = ua.indexOf("rv:");
      return parseInt(ua.substring(rv + 3, ua.indexOf(".", rv)), 10);
    }
    return false;
  }();
  var AudioHandler = function(manager) {
    this.manager = manager;
  };
  Object.assign(AudioHandler.prototype, {_isSupported:function(url) {
    var toMIME = {".ogg":"audio/ogg", ".mp3":"audio/mpeg", ".wav":"audio/x-wav", ".mp4a":"audio/mp4", ".m4a":"audio/mp4", ".mp4":"audio/mp4", ".aac":"audio/aac"};
    var ext = pc.path.getExtension(url);
    if (toMIME[ext]) {
      return true;
    }
    return false;
  }, load:function(url, callback) {
    var success = function(resource) {
      callback(null, new pc.Sound(resource));
    };
    var error = function(msg) {
      msg = msg || "Error loading audio url: " + url;
      console.warn(msg);
      callback(msg);
    };
    if (this._createSound) {
      if (!this._isSupported(url)) {
        error(pc.string.format("Audio format for {0} not supported", url));
        return;
      }
      this._createSound(url, success, error);
    } else {
      error(null);
    }
  }, open:function(url, data) {
    return data;
  }});
  if (pc.SoundManager.hasAudioContext()) {
    AudioHandler.prototype._createSound = function(url, success, error) {
      var manager = this.manager;
      if (!manager.context) {
        error("Audio manager has no audio context");
        return;
      }
      pc.http.get(url, function(err, response) {
        if (err) {
          error(err);
          return;
        }
        manager.context.decodeAudioData(response, success, error);
      });
    };
  } else {
    if (pc.SoundManager.hasAudio()) {
      AudioHandler.prototype._createSound = function(url, success, error) {
        var audio = null;
        try {
          audio = new Audio;
        } catch (e) {
          error("No support for Audio element");
          return;
        }
        if (ie) {
          document.body.appendChild(audio);
        }
        var onReady = function() {
          audio.removeEventListener("canplaythrough", onReady);
          if (ie) {
            document.body.removeChild(audio);
          }
          success(audio);
        };
        audio.onerror = function() {
          audio.onerror = null;
          if (ie) {
            document.body.removeChild(audio);
          }
          error();
        };
        audio.addEventListener("canplaythrough", onReady);
        audio.src = url;
      };
    }
  }
  return {AudioHandler:AudioHandler};
}());
Object.assign(pc, function() {
  var CubemapHandler = function(device, assets, loader) {
    this._device = device;
    this._assets = assets;
    this._loader = loader;
  };
  Object.assign(CubemapHandler.prototype, {load:function(url, callback) {
  }, open:function(url, data) {
  }, patch:function(assetCubeMap, assets) {
    var self = this;
    var loaded = false;
    if (!assetCubeMap.resources[0]) {
      assetCubeMap.resources[0] = new pc.Texture(this._device, {format:pc.PIXELFORMAT_R8_G8_B8_A8, cubemap:true, mipmaps:true, fixCubemapSeams:!!assetCubeMap._dds});
      loaded = true;
    }
    if (!assetCubeMap.file) {
      delete assetCubeMap._dds;
    } else {
      if (assetCubeMap.file && !assetCubeMap._dds) {
        var url = assetCubeMap.getFileUrl();
        assets._loader.load(url + "?t=" + assetCubeMap.file.hash, "texture", function(err, texture) {
          if (!err) {
            assets._loader.patch({resource:texture, type:"texture", data:assetCubeMap.data}, assets);
            assetCubeMap._dds = texture;
            self.patch(assetCubeMap, assets);
          } else {
            assets.fire("error", err, assetCubeMap);
            assets.fire("error:" + assetCubeMap.id, err, assetCubeMap);
            assetCubeMap.fire("error", err, assetCubeMap);
          }
        });
      }
    }
    if ((!assetCubeMap.file || !assetCubeMap._dds) && assetCubeMap.resources[1]) {
      assetCubeMap.resources = [assetCubeMap.resources[0]];
      loaded = true;
    } else {
      if (assetCubeMap._dds && !assetCubeMap.resources[1]) {
        assetCubeMap.resources = [assetCubeMap.resources[0]];
        assetCubeMap._dds.fixCubemapSeams = true;
        assetCubeMap._dds.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
        assetCubeMap._dds.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
        var startIndex = 0;
        if (this._device.useTexCubeLod) {
          assetCubeMap.resources.push(assetCubeMap._dds);
          startIndex = 1;
        }
        for (var i = startIndex;i < 6;i++) {
          var mip = new pc.Texture(this._device, {cubemap:true, fixCubemapSeams:true, mipmaps:true, format:assetCubeMap._dds.format, rgbm:assetCubeMap._dds.rgbm, width:Math.pow(2, 7 - i), height:Math.pow(2, 7 - i)});
          mip._levels[0] = assetCubeMap._dds._levels[i];
          mip.upload();
          assetCubeMap.resources.push(mip);
        }
        loaded = true;
      }
    }
    var cubemap = assetCubeMap.resource;
    if (cubemap.name !== assetCubeMap.name) {
      cubemap.name = assetCubeMap.name;
    }
    var rgbm = !!assetCubeMap.data.rgbm;
    if (assetCubeMap.data.hasOwnProperty("rgbm") && cubemap.rgbm !== rgbm) {
      cubemap.rgbm = rgbm;
    }
    cubemap.fixCubemapSeams = !!assetCubeMap._dds;
    if (assetCubeMap.data.hasOwnProperty("minFilter") && cubemap.minFilter !== assetCubeMap.data.minFilter) {
      cubemap.minFilter = assetCubeMap.data.minFilter;
    }
    if (assetCubeMap.data.hasOwnProperty("magFilter") && cubemap.magFilter !== assetCubeMap.data.magFilter) {
      cubemap.magFilter = assetCubeMap.data.magFilter;
    }
    if (assetCubeMap.data.hasOwnProperty("anisotropy") && cubemap.anisotropy !== assetCubeMap.data.anisotropy) {
      cubemap.anisotropy = assetCubeMap.data.anisotropy;
    }
    if (cubemap.addressU !== pc.ADDRESS_CLAMP_TO_EDGE) {
      cubemap.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
    }
    if (cubemap.addressV !== pc.ADDRESS_CLAMP_TO_EDGE) {
      cubemap.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
    }
    this._patchTextureFaces(assetCubeMap, assets);
    if (loaded) {
      assets.fire("load", assetCubeMap);
      assets.fire("load:" + assetCubeMap.id, assetCubeMap);
      assetCubeMap.fire("load", assetCubeMap);
    }
  }, _patchTexture:function() {
    this.registry._loader._handlers.cubemap._patchTextureFaces(this, this.registry);
  }, _patchTextureFaces:function(assetCubeMap, assets) {
    if (!assetCubeMap.loadFaces && assetCubeMap.file) {
      return;
    }
    var cubemap = assetCubeMap.resource;
    var sources = [];
    var count = 0;
    var levelsUpdated = false;
    var self = this;
    if (!assetCubeMap._levelsEvents) {
      assetCubeMap._levelsEvents = [null, null, null, null, null, null];
    }
    assetCubeMap.data.textures.forEach(function(id, index) {
      var assetReady = function(asset) {
        count++;
        sources[index] = asset && asset.resource.getSource() || null;
        var evtAsset = assetCubeMap._levelsEvents[index];
        if (evtAsset !== asset) {
          if (evtAsset) {
            evtAsset.off("load", self._patchTexture, assetCubeMap);
          }
          if (asset) {
            asset.on("load", self._patchTexture, assetCubeMap);
          }
          assetCubeMap._levelsEvents[index] = asset || null;
        }
        if (sources[index] !== cubemap._levels[0][index]) {
          levelsUpdated = true;
        }
        if (count === 6 && levelsUpdated) {
          cubemap.setSource(sources);
          assets.fire("load", assetCubeMap);
          assets.fire("load:" + assetCubeMap.id, assetCubeMap);
          assetCubeMap.fire("load", assetCubeMap);
        }
      };
      var assetAdded = function(asset) {
        asset.ready(assetReady);
        assets.load(asset);
      };
      var asset = assets.get(id);
      if (asset) {
        asset.ready(assetReady);
        assets.load(asset);
      } else {
        if (id) {
          assets.once("load:" + id, assetReady);
          assets.once("add:" + id, assetAdded);
        } else {
          assetReady(null);
        }
      }
    });
  }});
  return {CubemapHandler:CubemapHandler};
}());
Object.assign(pc, function() {
  var JsonHandler = function() {
  };
  Object.assign(JsonHandler.prototype, {load:function(url, callback) {
    pc.http.get(url, function(err, response) {
      if (!err) {
        callback(null, response);
      } else {
        callback(pc.string.format("Error loading JSON resource: {0} [{1}]", url, err));
      }
    });
  }, open:function(url, data) {
    return data;
  }, patch:function(asset, assets) {
  }});
  return {JsonHandler:JsonHandler};
}());
Object.assign(pc, function() {
  var PARAMETER_TYPES = {ambient:"vec3", ambientTnumber:"boolean", aoMap:"texture", aoVertexColor:"boolean", aoVertexColorChannel:"string", aoMapChannel:"string", aoMapUv:"number", aoMapTiling:"vec2", aoMapOffset:"vec2", occludeSpecular:"boolean", diffuse:"vec3", diffuseMap:"texture", diffuseTint:"boolean", diffuseVertexColor:"boolean", diffuseVertexColorChannel:"string", diffuseMapChannel:"string", diffuseMapUv:"number", diffuseMapTiling:"vec2", diffuseMapOffset:"vec2", diffuseMapTnumber:"boolean", 
  specular:"vec3", specularVertexColor:"boolean", specularVertexColorChannel:"string", specularMapChannel:"string", specularMapUv:"number", specularMap:"texture", specularTint:"boolean", specularMapTiling:"vec2", specularMapOffset:"vec2", specularMapTnumber:"boolean", specularAntialias:"boolean", useMetalness:"boolean", metalnessMap:"texture", metalnessVertexColor:"boolean", metalnessVertexColorChannel:"string", metalnessMapChannel:"string", metalnessMapUv:"number", metalnessMapTiling:"vec2", metalnessMapOffset:"vec2", 
  metalnessMapTnumber:"boolean", metalness:"number", conserveEnergy:"boolean", shininess:"number", glossMap:"texture", glossVertexColor:"boolean", glossVertexColorChannel:"string", glossMapChannel:"string", glossMapUv:"number", glossMapTiling:"vec2", glossMapOffset:"vec2", fresnelModel:"number", fresnelFactor:"float", emissive:"vec3", emissiveMap:"texture", emissiveVertexColor:"boolean", emissiveVertexColorChannel:"string", emissiveMapChannel:"string", emissiveMapUv:"number", emissiveMapTiling:"vec2", 
  emissiveMapOffset:"vec2", emissiveTint:"boolean", emissiveIntensity:"number", normalMap:"texture", normalMapTiling:"vec2", normalMapOffset:"vec2", normalMapUv:"number", bumpMapFactor:"number", heightMap:"texture", heightMapChannel:"string", heightMapUv:"number", heightMapTiling:"vec2", heightMapOffset:"vec2", heightMapFactor:"number", alphaTest:"number", opacity:"number", opacityMap:"texture", opacityVertexColor:"boolean", opacityVertexColorChannel:"string", opacityMapChannel:"string", opacityMapUv:"number", 
  opacityMapTiling:"vec2", opacityMapOffset:"vec2", reflectivity:"number", refraction:"number", refractionIndex:"number", sphereMap:"texture", cubeMap:"cubemap", cubeMapProjection:"number", cubeMapProjectionBox:"boundingbox", lightMap:"texture", lightVertexColor:"boolean", lightVertexColorChannel:"string", lightMapChannel:"string", lightMapUv:"number", lightMapTiling:"vec2", lightMapOffset:"vec2", depthTest:"boolean", depthWrite:"boolean", depthBias:"number", slopeDepthBias:"number", cull:"number", 
  blendType:"number", shadingModel:"number"};
  var placeholders = {};
  var placeholdersMapping = {aoMap:"white", diffuseMap:"gray", specularMap:"gray", metalnessMap:"black", glossMap:"gray", emissiveMap:"gray", normalMap:"normal", heightMap:"gray", opacityMap:"gray", sphereMap:"gray", lightMap:"white"};
  var onCubemapAssetLoad = function(asset, attribute, newValue, oldValue) {
    var props = ["cubeMap", "prefilteredCubeMap128", "prefilteredCubeMap64", "prefilteredCubeMap32", "prefilteredCubeMap16", "prefilteredCubeMap8", "prefilteredCubeMap4"];
    for (var i = 0;i < props.length;i++) {
      if (this[props[i]] !== asset.resources[i]) {
        this[props[i]] = asset.resources[i];
      }
    }
    this.update();
  };
  var MaterialHandler = function(app) {
    this._assets = app.assets;
    this._device = app.graphicsDevice;
    this._createPlaceholders();
  };
  Object.assign(MaterialHandler.prototype, {load:function(url, callback) {
    pc.http.get(url, function(err, response) {
      if (!err) {
        if (callback) {
          callback(null, response);
        }
      } else {
        if (callback) {
          callback(pc.string.format("Error loading material: {0} [{1}]", url, err));
        }
      }
    });
  }, open:function(url, data) {
    var material = new pc.StandardMaterial;
    if (!data.parameters) {
      this._createParameters(data);
    }
    material.init(data);
    material._data = data;
    return material;
  }, _createPlaceholders:function() {
    var textures = {white:[255, 255, 255, 255], gray:[128, 128, 128, 255], black:[0, 0, 0, 255], normal:[128, 128, 255, 255]};
    for (var key in textures) {
      if (!textures.hasOwnProperty(key)) {
        continue;
      }
      var texture = placeholders[key] = new pc.Texture(this._device, {width:2, height:2, format:pc.PIXELFORMAT_R8_G8_B8_A8});
      var pixels = texture.lock();
      for (var i = 0;i < 4;i++) {
        for (var c = 0;c < 4;c++) {
          pixels[i * 4 + c] = textures[key][c];
        }
      }
      texture.unlock();
    }
  }, _createParameters:function(data) {
    var parameters = [];
    if (!data.shadingModel) {
      data.shadingModel = data.shader === "blinn" ? pc.SPECULAR_BLINN : pc.SPECULAR_PHONG;
    }
    var shader = data.shader;
    delete data.shader;
    for (var key in data) {
      if (!data.hasOwnProperty(key)) {
        continue;
      }
      parameters.push({name:key, type:PARAMETER_TYPES[key], data:data[key]});
    }
    data.shader = shader;
    data.parameters = parameters;
  }, patch:function(asset, assets) {
    if (asset.data.shader === undefined) {
      asset.data = asset.resource._data;
      delete asset.resource._data;
    }
    this._updateStandardMaterial(asset, asset.data, assets);
    asset.off("change", this._onAssetChange, this);
    asset.on("change", this._onAssetChange, this);
    asset.on("unload", this._onAssetUnload, this);
  }, _onAssetChange:function(asset, attribute, value) {
    if (attribute === "data") {
      this._updateStandardMaterial(asset, value, this._assets);
    }
  }, _onAssetUnload:function(asset) {
    delete asset.data.parameters;
    delete asset.data.chunks;
    delete asset.data.name;
  }, _updateStandardMaterial:function(asset, data, assets) {
    var material = asset.resource;
    var dir;
    if (asset.file) {
      dir = pc.path.getDirectory(asset.getFileUrl());
    }
    data.name = asset.name;
    if (!data.parameters) {
      this._createParameters(data);
    }
    var pathMapping = data.mapping_format === "path";
    data.chunks = asset.resource.chunks;
    data.parameters.forEach(function(param, i) {
      var id;
      if (param.type === "texture") {
        if (!material._assetHandlers) {
          material._assetHandlers = {};
        }
        var handler = material._assetHandlers[param.name];
        if (param.data && !(param.data instanceof pc.Texture)) {
          if (pathMapping) {
            asset = assets.getByUrl(pc.path.join(dir, param.data));
          } else {
            id = param.data;
            asset = assets.get(param.data);
          }
          if (handler) {
            assets.off("load:" + handler.id, handler.bind);
            assets.off("add:" + handler.id, handler.add);
            assets.off("remove:" + handler.id, handler.remove);
            if (handler.url) {
              assets.off("add:url:" + handler.url, handler.add);
              assets.off("remove:url:" + handler.url, handler.remove);
            }
            material._assetHandlers[param.name] = null;
          }
          handler = material._assetHandlers[param.name] = {id:id, url:pathMapping ? pc.path.join(dir, param.data) : "", bind:function(asset) {
            data.parameters[i].data = asset.resource;
            material[data.parameters[i].name] = asset.resource;
            material.update();
          }, add:function(asset) {
            assets.load(asset);
          }, remove:function(asset) {
            if (material[data.parameters[i].name] === asset.resource) {
              data.parameters[i].data = null;
              material[data.parameters[i].name] = null;
              material.update();
            }
          }};
          if (id) {
            assets.on("load:" + id, handler.bind);
            assets.on("remove:" + id, handler.remove);
          } else {
            if (pathMapping) {
              assets.on("load:url:" + pc.path.join(dir, param.data), handler.bind);
              assets.on("remove:url:" + pc.path.join(dir, param.data), handler.remove);
            }
          }
          if (asset) {
            if (asset.resource) {
              handler.bind(asset);
            } else {
              if (placeholdersMapping[data.parameters[i].name]) {
                var texture = placeholders[placeholdersMapping[data.parameters[i].name]];
                if (texture) {
                  data.parameters[i].data = texture;
                  material[data.parameters[i].name] = texture;
                }
              }
            }
            assets.load(asset);
          } else {
            if (id) {
              assets.once("add:" + id, handler.add);
            } else {
              if (pathMapping) {
                assets.once("add:url:" + handler.url, handler.add);
              }
            }
          }
        } else {
          if (handler && !param.data) {
            assets.off("load:" + handler.id, handler.bind);
            assets.off("add:" + handler.id, handler.add);
            assets.off("remove:" + handler.id, handler.remove);
            if (handler.url) {
              assets.off("add:url:" + handler.url, handler.add);
              assets.off("remove:url:" + handler.url, handler.remove);
            }
            material._assetHandlers[param.name] = null;
          }
        }
      } else {
        if (param.type === "cubemap" && param.data && !(param.data instanceof pc.Texture)) {
          if (pathMapping) {
            asset = assets.getByUrl(pc.path.join(dir, param.data));
          } else {
            id = param.data;
            asset = assets.get(param.data);
          }
          var onReady = function(asset) {
            param.data = asset.resource;
            if (asset.resources.length > 1) {
              data.parameters.push({name:"prefilteredCubeMap128", data:asset.resources[1]});
              data.parameters.push({name:"prefilteredCubeMap64", data:asset.resources[2]});
              data.parameters.push({name:"prefilteredCubeMap32", data:asset.resources[3]});
              data.parameters.push({name:"prefilteredCubeMap16", data:asset.resources[4]});
              data.parameters.push({name:"prefilteredCubeMap8", data:asset.resources[5]});
              data.parameters.push({name:"prefilteredCubeMap4", data:asset.resources[6]});
            }
            material.init(data);
            asset.off("load", onCubemapAssetLoad, material);
            asset.on("load", onCubemapAssetLoad, material);
          };
          var onAdd = function(asset) {
            if (data.shadingModel === pc.SPECULAR_PHONG) {
              asset.loadFaces = true;
            }
            asset.ready(onReady);
            assets.load(asset);
          };
          if (asset) {
            onAdd(asset);
          } else {
            if (id) {
              assets.once("add:" + id, onAdd);
            } else {
              if (pathMapping) {
                assets.once("add:url:" + pc.path.join(dir, param.data), function(asset) {
                  asset.ready(function(asset) {
                    data.parameters[i].data = asset.resource;
                    material.init(data);
                    asset.off("load", onCubemapAssetLoad, material);
                    asset.on("load", onCubemapAssetLoad, material);
                  });
                  assets.load(asset);
                });
              }
            }
          }
        }
      }
    });
    material.init(data);
  }});
  return {MaterialHandler:MaterialHandler, getMaterialParamType:function(name) {
    return PARAMETER_TYPES[name];
  }};
}());
Object.assign(pc, function() {
  var ModelHandler = function(device) {
    this._device = device;
    this._parsers = [];
    this.addParser(new pc.JsonModelParser(this._device), function(url, data) {
      return pc.path.getExtension(url) === ".json";
    });
  };
  ModelHandler.DEFAULT_MATERIAL = pc.Scene.defaultMaterial;
  Object.assign(ModelHandler.prototype, {load:function(url, callback) {
    pc.http.get(url, function(err, response) {
      if (!callback) {
        return;
      }
      if (!err) {
        callback(null, response);
      } else {
        callback(pc.string.format("Error loading model: {0} [{1}]", url, err));
      }
    });
  }, open:function(url, data) {
    for (var i = 0;i < this._parsers.length;i++) {
      var p = this._parsers[i];
      if (p.decider(url, data)) {
        return p.parser.parse(data);
      }
    }
    logWARNING(pc.string.format("No model parser found for: {0}", url));
    return null;
  }, patch:function(asset, assets) {
    if (!asset.resource) {
      return;
    }
    var data = asset.data;
    asset.resource.meshInstances.forEach(function(meshInstance, i) {
      if (data.mapping) {
        var handleMaterial = function(asset) {
          if (asset.resource) {
            meshInstance.material = asset.resource;
          } else {
            asset.once("load", handleMaterial);
            assets.load(asset);
          }
          asset.once("remove", function(asset) {
            if (meshInstance.material === asset.resource) {
              meshInstance.material = pc.ModelHandler.DEFAULT_MATERIAL;
            }
          });
        };
        if (!data.mapping[i]) {
          meshInstance.material = pc.ModelHandler.DEFAULT_MATERIAL;
          return;
        }
        var id = data.mapping[i].material;
        var url = data.mapping[i].path;
        var material;
        if (id !== undefined) {
          if (!id) {
            meshInstance.material = pc.ModelHandler.DEFAULT_MATERIAL;
          } else {
            material = assets.get(id);
            if (material) {
              handleMaterial(material);
            } else {
              assets.once("add:" + id, handleMaterial);
            }
          }
        } else {
          if (url) {
            var fileUrl = asset.getFileUrl();
            var dirUrl = pc.path.getDirectory(fileUrl);
            var path = pc.path.join(dirUrl, data.mapping[i].path);
            material = assets.getByUrl(path);
            if (material) {
              handleMaterial(material);
            } else {
              assets.once("add:url:" + path, handleMaterial);
            }
          }
        }
      }
    });
  }, addParser:function(parser, decider) {
    this._parsers.push({parser:parser, decider:decider});
  }});
  return {ModelHandler:ModelHandler};
}());
Object.assign(pc, function() {
  var ScriptHandler = function(app) {
    this._app = app;
    this._scripts = {};
    this._cache = {};
  };
  ScriptHandler._types = [];
  ScriptHandler._push = function(Type) {
    if (pc.script.legacy && ScriptHandler._types.length > 0) {
      console.assert("Script Ordering Error. Contact support@playcanvas.com");
    } else {
      ScriptHandler._types.push(Type);
    }
  };
  Object.assign(ScriptHandler.prototype, {load:function(url, callback) {
    var self = this;
    pc.script.app = this._app;
    this._loadScript(url, function(err, url, extra) {
      if (!err) {
        if (pc.script.legacy) {
          var Type = null;
          if (ScriptHandler._types.length) {
            Type = ScriptHandler._types.pop();
          }
          if (Type) {
            this._scripts[url] = Type;
          } else {
            Type = null;
          }
          callback(null, Type, extra);
        } else {
          var obj = {};
          for (var i = 0;i < ScriptHandler._types.length;i++) {
            obj[ScriptHandler._types[i].name] = ScriptHandler._types[i];
          }
          ScriptHandler._types.length = 0;
          callback(null, obj, extra);
          delete self._loader._cache[url + "script"];
        }
      } else {
        callback(err);
      }
    }.bind(this));
  }, open:function(url, data) {
    return data;
  }, patch:function(asset, assets) {
  }, _loadScript:function(url, callback) {
    var head = document.head;
    var element = document.createElement("script");
    this._cache[url] = element;
    element.async = false;
    element.addEventListener("error", function(e) {
      callback(pc.string.format("Script: {0} failed to load", e.target.src));
    }, false);
    var done = false;
    element.onload = element.onreadystatechange = function() {
      if (!done && (!this.readyState || (this.readyState == "loaded" || this.readyState == "complete"))) {
        done = true;
        callback(null, url, element);
      }
    };
    element.src = url;
    head.appendChild(element);
  }});
  return {ScriptHandler:ScriptHandler};
}());
Object.assign(pc, function() {
  var TextHandler = function() {
  };
  Object.assign(TextHandler.prototype, {load:function(url, callback) {
    pc.http.get(url, function(err, response) {
      if (!err) {
        callback(null, response);
      } else {
        callback(pc.string.format("Error loading text resource: {0} [{1}]", url, err));
      }
    });
  }, open:function(url, data) {
    return data;
  }, patch:function(asset, assets) {
  }});
  return {TextHandler:TextHandler};
}());
Object.assign(pc, function() {
  var BinaryHandler = function() {
  };
  Object.assign(BinaryHandler.prototype, {load:function(url, callback) {
    pc.http.get(url, {responseType:pc.Http.ResponseType.ARRAY_BUFFER}, function(err, response) {
      if (!err) {
        callback(null, response);
      } else {
        callback(pc.string.format("Error loading binary resource: {0} [{1}]", url, err));
      }
    });
  }, open:function(url, data) {
    return data;
  }, patch:function(asset, assets) {
  }});
  return {BinaryHandler:BinaryHandler};
}());
Object.assign(pc, function() {
  var JSON_ADDRESS_MODE = {"repeat":pc.ADDRESS_REPEAT, "clamp":pc.ADDRESS_CLAMP_TO_EDGE, "mirror":pc.ADDRESS_MIRRORED_REPEAT};
  var JSON_FILTER_MODE = {"nearest":pc.FILTER_NEAREST, "linear":pc.FILTER_LINEAR, "nearest_mip_nearest":pc.FILTER_NEAREST_MIPMAP_NEAREST, "linear_mip_nearest":pc.FILTER_LINEAR_MIPMAP_NEAREST, "nearest_mip_linear":pc.FILTER_NEAREST_MIPMAP_LINEAR, "linear_mip_linear":pc.FILTER_LINEAR_MIPMAP_LINEAR};
  function arrayBufferCopy(src, dst, dstByteOffset, numBytes) {
    var i;
    var dst32Offset = dstByteOffset / 4;
    var tail = numBytes % 4;
    var src32 = new Uint32Array(src.buffer, 0, (numBytes - tail) / 4);
    var dst32 = new Uint32Array(dst.buffer);
    for (i = 0;i < src32.length;i++) {
      dst32[dst32Offset + i] = src32[i];
    }
    for (i = numBytes - tail;i < numBytes;i++) {
      dst[dstByteOffset + i] = src[i];
    }
  }
  var TextureHandler = function(device, assets, loader) {
    this._device = device;
    this._assets = assets;
    this._loader = loader;
    this.crossOrigin = undefined;
    if (assets.prefix) {
      this.crossOrigin = "anonymous";
    }
  };
  Object.assign(TextureHandler.prototype, {load:function(url, callback) {
    var self = this;
    var image;
    var urlWithoutParams = url.indexOf("?") >= 0 ? url.split("?")[0] : url;
    var ext = pc.path.getExtension(urlWithoutParams).toLowerCase();
    if (ext === ".dds" || ext === ".crn") {
      var options = {cache:true, responseType:"arraybuffer"};
      pc.http.get(url, options, function(err, response) {
        if (!err) {
          callback(null, response);
        } else {
          callback(err);
        }
      });
    } else {
      if (ext === ".jpg" || ext === ".jpeg" || ext === ".gif" || ext === ".png") {
        image = new Image;
        if (self.crossOrigin !== undefined && pc.ABSOLUTE_URL.test(url)) {
          image.crossOrigin = self.crossOrigin;
        }
        image.onload = function() {
          callback(null, image);
        };
        image.onerror = function(event) {
          callback(pc.string.format("Error loading Texture from: '{0}'", url));
        };
        image.src = url;
      } else {
        var blobStart = urlWithoutParams.indexOf("blob:");
        if (blobStart >= 0) {
          urlWithoutParams = urlWithoutParams.substr(blobStart);
          url = urlWithoutParams;
          image = new Image;
          image.onload = function() {
            callback(null, image);
          };
          image.onerror = function(event) {
            callback(pc.string.format("Error loading Texture from: '{0}'", url));
          };
          image.src = url;
        } else {
          setTimeout(function() {
            callback(pc.string.format("Error loading Texture: format not supported: '{0}'", ext));
          }, 0);
        }
      }
    }
  }, open:function(url, data) {
    if (!url) {
      return;
    }
    var texture;
    var ext = pc.path.getExtension(url).toLowerCase();
    var format = null;
    if (data instanceof Image || data instanceof HTMLImageElement) {
      var img = data;
      format = ext === ".jpg" || ext === ".jpeg" ? pc.PIXELFORMAT_R8_G8_B8 : pc.PIXELFORMAT_R8_G8_B8_A8;
      texture = new pc.Texture(this._device, {width:img.width, height:img.height, format:format});
      texture.setSource(img);
    } else {
      if (data instanceof ArrayBuffer) {
        if (ext === ".crn") {
          var srcSize = data.byteLength;
          var bytes = new Uint8Array(data);
          var src = Module._malloc(srcSize);
          arrayBufferCopy(bytes, Module.HEAPU8, src, srcSize);
          var dst = Module._crn_decompress_get_data(src, srcSize);
          var dstSize = Module._crn_decompress_get_size(src, srcSize);
          data = Module.HEAPU8.buffer.slice(dst, dst + dstSize);
        }
        var header = new Uint32Array(data, 0, 128 / 4);
        var width = header[4];
        var height = header[3];
        var mips = Math.max(header[7], 1);
        var isFourCc = header[20] === 4;
        var fcc = header[21];
        var bpp = header[22];
        var isCubemap = header[28] === 65024;
        var FCC_DXT1 = 827611204;
        var FCC_DXT5 = 894720068;
        var FCC_FP32 = 116;
        var FCC_ETC1 = 826496069;
        var FCC_PVRTC_2BPP_RGB_1 = 825438800;
        var FCC_PVRTC_2BPP_RGBA_1 = 825504336;
        var FCC_PVRTC_4BPP_RGB_1 = 825439312;
        var FCC_PVRTC_4BPP_RGBA_1 = 825504848;
        var compressed = false;
        var floating = false;
        var etc1 = false;
        var pvrtc2 = false;
        var pvrtc4 = false;
        if (isFourCc) {
          if (fcc === FCC_DXT1) {
            format = pc.PIXELFORMAT_DXT1;
            compressed = true;
          } else {
            if (fcc === FCC_DXT5) {
              format = pc.PIXELFORMAT_DXT5;
              compressed = true;
            } else {
              if (fcc === FCC_FP32) {
                format = pc.PIXELFORMAT_RGBA32F;
                floating = true;
              } else {
                if (fcc === FCC_ETC1) {
                  format = pc.PIXELFORMAT_ETC1;
                  compressed = true;
                  etc1 = true;
                } else {
                  if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {
                    format = fcc === FCC_PVRTC_2BPP_RGB_1 ? pc.PIXELFORMAT_PVRTC_2BPP_RGB_1 : pc.PIXELFORMAT_PVRTC_2BPP_RGBA_1;
                    compressed = true;
                    pvrtc2 = true;
                  } else {
                    if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {
                      format = fcc === FCC_PVRTC_4BPP_RGB_1 ? pc.PIXELFORMAT_PVRTC_4BPP_RGB_1 : pc.PIXELFORMAT_PVRTC_4BPP_RGBA_1;
                      compressed = true;
                      pvrtc4 = true;
                    }
                  }
                }
              }
            }
          }
        } else {
          if (bpp === 32) {
            format = pc.PIXELFORMAT_R8_G8_B8_A8;
          }
        }
        if (!format) {
          texture = new pc.Texture(this._device, {width:4, height:4, format:pc.PIXELFORMAT_R8_G8_B8});
          return texture;
        }
        var texOptions = {width:width, height:height, format:format, cubemap:isCubemap};
        texture = new pc.Texture(this._device, texOptions);
        if (isCubemap) {
          texture.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
          texture.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
        }
        var offset = 128;
        var faces = isCubemap ? 6 : 1;
        var mipSize;
        var DXT_BLOCK_WIDTH = 4;
        var DXT_BLOCK_HEIGHT = 4;
        var blockSize = fcc === FCC_DXT1 ? 8 : 16;
        var numBlocksAcross, numBlocksDown, numBlocks;
        for (var face = 0;face < faces;face++) {
          var mipWidth = width;
          var mipHeight = height;
          for (var i = 0;i < mips;i++) {
            if (compressed) {
              if (etc1) {
                mipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8;
              } else {
                if (pvrtc2) {
                  mipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;
                } else {
                  if (pvrtc4) {
                    mipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;
                  } else {
                    numBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);
                    numBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);
                    numBlocks = numBlocksAcross * numBlocksDown;
                    mipSize = numBlocks * blockSize;
                  }
                }
              }
            } else {
              mipSize = mipWidth * mipHeight * 4;
            }
            var mipBuff = floating ? new Float32Array(data, offset, mipSize) : new Uint8Array(data, offset, mipSize);
            if (!isCubemap) {
              texture._levels[i] = mipBuff;
            } else {
              if (!texture._levels[i]) {
                texture._levels[i] = [];
              }
              texture._levels[i][face] = mipBuff;
            }
            offset += floating ? mipSize * 4 : mipSize;
            mipWidth = Math.max(mipWidth * 0.5, 1);
            mipHeight = Math.max(mipHeight * 0.5, 1);
          }
        }
        texture.upload();
      }
    }
    return texture;
  }, patch:function(asset, assets) {
    var texture = asset.resource;
    if (!texture) {
      return;
    }
    if (texture.name !== asset.name) {
      texture.name = asset.name;
    }
    if (asset.data.hasOwnProperty("minfilter") && texture.minFilter !== JSON_FILTER_MODE[asset.data.minfilter]) {
      texture.minFilter = JSON_FILTER_MODE[asset.data.minfilter];
    }
    if (asset.data.hasOwnProperty("magfilter") && texture.magFilter !== JSON_FILTER_MODE[asset.data.magfilter]) {
      texture.magFilter = JSON_FILTER_MODE[asset.data.magfilter];
    }
    if (asset.data.hasOwnProperty("addressu") && texture.addressU !== JSON_ADDRESS_MODE[asset.data.addressu]) {
      texture.addressU = JSON_ADDRESS_MODE[asset.data.addressu];
    }
    if (asset.data.hasOwnProperty("addressv") && texture.addressV !== JSON_ADDRESS_MODE[asset.data.addressv]) {
      texture.addressV = JSON_ADDRESS_MODE[asset.data.addressv];
    }
    if (asset.data.hasOwnProperty("mipmaps") && texture.mipmaps !== asset.data.mipmaps) {
      texture.mipmaps = asset.data.mipmaps;
    }
    if (asset.data.hasOwnProperty("anisotropy") && texture.anisotropy !== asset.data.anisotropy) {
      texture.anisotropy = asset.data.anisotropy;
    }
    var rgbm = !!asset.data.rgbm;
    if (asset.data.hasOwnProperty("rgbm") && texture.rgbm !== rgbm) {
      texture.rgbm = rgbm;
    }
  }});
  return {TextureHandler:TextureHandler};
}());
Object.assign(pc, function() {
  var HtmlHandler = function() {
  };
  Object.assign(HtmlHandler.prototype, {load:function(url, callback) {
    pc.http.get(url, function(err, response) {
      if (!err) {
        callback(null, response);
      } else {
        callback(pc.string.format("Error loading html resource: {0} [{1}]", url, err));
      }
    });
  }, open:function(url, data) {
    return data;
  }, patch:function(asset, assets) {
  }});
  return {HtmlHandler:HtmlHandler};
}());
Object.assign(pc, function() {
  var CssHandler = function() {
  };
  Object.assign(CssHandler.prototype, {load:function(url, callback) {
    pc.http.get(url, function(err, response) {
      if (!err) {
        callback(null, response);
      } else {
        callback(pc.string.format("Error loading css resource: {0} [{1}]", url, err));
      }
    });
  }, open:function(url, data) {
    return data;
  }, patch:function(asset, assets) {
  }});
  var createStyle = function(cssString) {
    var result = document.createElement("style");
    result.type = "text/css";
    if (result.styleSheet) {
      result.styleSheet.cssText = cssString;
    } else {
      result.appendChild(document.createTextNode(cssString));
    }
    return result;
  };
  return {CssHandler:CssHandler, createStyle:createStyle};
}());
Object.assign(pc, function() {
  var ShaderHandler = function() {
  };
  Object.assign(ShaderHandler.prototype, {load:function(url, callback) {
    pc.http.get(url, function(err, response) {
      if (!err) {
        callback(null, response);
      } else {
        callback(pc.string.format("Error loading shader resource: {0} [{1}]", url, err));
      }
    });
  }, open:function(url, data) {
    return data;
  }, patch:function(asset, assets) {
  }});
  return {ShaderHandler:ShaderHandler};
}());
Object.assign(pc, function() {
  var SceneHandler = function(app) {
    this._app = app;
  };
  Object.assign(SceneHandler.prototype, {load:function(url, callback) {
    pc.http.get(url, function(err, response) {
      if (!err) {
        callback(null, response);
      } else {
        callback("Error requesting scene: " + url);
      }
    });
  }, open:function(url, data) {
    this._app.systems.script.preloading = true;
    var parser = new pc.SceneParser(this._app);
    var parent = parser.parse(data);
    var scene = this._app.scene;
    scene.root = parent;
    this._app.applySceneSettings(data.settings);
    this._app.systems.script.preloading = false;
    return scene;
  }, patch:function(asset, assets) {
  }});
  return {SceneHandler:SceneHandler};
}());
Object.assign(pc, function() {
  var HierarchyHandler = function(app) {
    this._app = app;
  };
  Object.assign(HierarchyHandler.prototype, {load:function(url, callback) {
    pc.http.get(url, function(err, response) {
      if (!err) {
        callback(null, response);
      } else {
        callback("Error requesting scene: " + url);
      }
    });
  }, open:function(url, data) {
    this._app.systems.script.preloading = true;
    var parser = new pc.SceneParser(this._app);
    var parent = parser.parse(data);
    this._app.systems.script.preloading = false;
    return parent;
  }});
  return {HierarchyHandler:HierarchyHandler};
}());
Object.assign(pc, function() {
  var SceneSettingsHandler = function(app) {
    this._app = app;
  };
  Object.assign(SceneSettingsHandler.prototype, {load:function(url, callback) {
    pc.http.get(url, function(err, response) {
      if (!err) {
        callback(null, response);
      } else {
        callback("Error requesting scene: " + url);
      }
    });
  }, open:function(url, data) {
    return data.settings;
  }});
  return {SceneSettingsHandler:SceneSettingsHandler};
}());
Object.assign(pc, function() {
  var FolderHandler = function() {
  };
  Object.assign(FolderHandler.prototype, {load:function(url, callback) {
    callback(null, null);
  }, open:function(url, data) {
    return data;
  }});
  return {FolderHandler:FolderHandler};
}());
Object.assign(pc, function() {
  var FontHandler = function(loader) {
    this._loader = loader;
  };
  Object.assign(FontHandler.prototype, {load:function(url, callback, asset) {
    var self = this;
    if (pc.path.getExtension(url) === ".json") {
      pc.http.get(url, function(err, response) {
        if (!err) {
          self._loadTextures(url.replace(".json", ".png"), response, function(err, textures) {
            if (err) {
              return callback(err);
            }
            callback(null, {data:response, textures:textures});
          });
        } else {
          callback(pc.string.format("Error loading font resource: {0} [{1}]", url, err));
        }
      });
    } else {
      this._loadTextures(url, asset && asset.data, callback);
    }
  }, _loadTextures:function(url, data, callback) {
    var numTextures = 1;
    var numLoaded = 0;
    var error = null;
    if (data && data.version >= 2) {
      numTextures = data.info.maps.length;
    }
    var textures = new Array(numTextures);
    var loader = this._loader;
    var loadTexture = function(index) {
      var onLoaded = function(err, texture) {
        if (error) {
          return;
        }
        if (err) {
          error = err;
          return callback(err);
        }
        texture.upload();
        textures[index] = texture;
        numLoaded++;
        if (numLoaded === numTextures) {
          callback(null, textures);
        }
      };
      if (index === 0) {
        loader.load(url, "texture", onLoaded);
      } else {
        loader.load(url.replace(".png", index + ".png"), "texture", onLoaded);
      }
    };
    for (var i = 0;i < numTextures;i++) {
      loadTexture(i);
    }
  }, open:function(url, data, asset) {
    var font;
    if (data.textures) {
      font = new pc.Font(data.textures, data.data);
    } else {
      font = new pc.Font(data, null);
    }
    return font;
  }, patch:function(asset, assets) {
    var font = asset.resource;
    if (!font.data && asset.data) {
      font.data = asset.data;
    } else {
      if (!asset.data && font.data) {
        asset.data = font.data;
      }
    }
  }});
  return {FontHandler:FontHandler};
}());
Object.assign(pc, function() {
  var JSON_ADDRESS_MODE = {"repeat":pc.ADDRESS_REPEAT, "clamp":pc.ADDRESS_CLAMP_TO_EDGE, "mirror":pc.ADDRESS_MIRRORED_REPEAT};
  var JSON_FILTER_MODE = {"nearest":pc.FILTER_NEAREST, "linear":pc.FILTER_LINEAR, "nearest_mip_nearest":pc.FILTER_NEAREST_MIPMAP_NEAREST, "linear_mip_nearest":pc.FILTER_LINEAR_MIPMAP_NEAREST, "nearest_mip_linear":pc.FILTER_NEAREST_MIPMAP_LINEAR, "linear_mip_linear":pc.FILTER_LINEAR_MIPMAP_LINEAR};
  var regexFrame = /^data\.frames\.(\d+)$/;
  var TextureAtlasHandler = function(loader) {
    this._loader = loader;
  };
  Object.assign(TextureAtlasHandler.prototype, {load:function(url, callback) {
    var self = this;
    var handler = this._loader.getHandler("texture");
    if (pc.path.getExtension(url) === ".json") {
      pc.http.get(url, function(err, response) {
        if (!err) {
          var textureUrl = url.replace(".json", ".png");
          self._loader.load(textureUrl, "texture", function(err, texture) {
            if (err) {
              callback(err);
            } else {
              callback(null, {data:response, texture:texture});
            }
          });
        } else {
          callback(err);
        }
      });
    } else {
      return handler.load(url, callback);
    }
  }, open:function(url, data) {
    var resource = new pc.TextureAtlas;
    if (data.texture && data.data) {
      resource.texture = data.texture;
      resource.__data = data.data;
    } else {
      var handler = this._loader.getHandler("texture");
      var texture = handler.open(url, data);
      if (!texture) {
        return null;
      }
      resource.texture = texture;
    }
    return resource;
  }, patch:function(asset, assets) {
    if (asset.resource.__data) {
      if (asset.resource.__data.minfilter !== undefined) {
        asset.data.minfilter = asset.resource.__data.minfilter;
      }
      if (asset.resource.__data.magfilter !== undefined) {
        asset.data.magfilter = asset.resource.__data.magfilter;
      }
      if (asset.resource.__data.addressu !== undefined) {
        asset.data.addressu = asset.resource.__data.addressu;
      }
      if (asset.resource.__data.addressv !== undefined) {
        asset.data.addressv = asset.resource.__data.addressv;
      }
      if (asset.resource.__data.mipmaps !== undefined) {
        asset.data.mipmaps = asset.resource.__data.mipmaps;
      }
      if (asset.resource.__data.anisotropy !== undefined) {
        asset.data.anisotropy = asset.resource.__data.anisotropy;
      }
      if (asset.resource.__data.rgbm !== undefined) {
        asset.data.rgbm = !!asset.resource.__data.rgbm;
      }
      asset.data.frames = asset.resource.__data.frames;
      delete asset.resource.__data;
    }
    var texture = asset.resource.texture;
    if (texture) {
      texture.name = asset.name;
      if (asset.data.hasOwnProperty("minfilter") && texture.minFilter !== JSON_FILTER_MODE[asset.data.minfilter]) {
        texture.minFilter = JSON_FILTER_MODE[asset.data.minfilter];
      }
      if (asset.data.hasOwnProperty("magfilter") && texture.magFilter !== JSON_FILTER_MODE[asset.data.magfilter]) {
        texture.magFilter = JSON_FILTER_MODE[asset.data.magfilter];
      }
      if (asset.data.hasOwnProperty("addressu") && texture.addressU !== JSON_ADDRESS_MODE[asset.data.addressu]) {
        texture.addressU = JSON_ADDRESS_MODE[asset.data.addressu];
      }
      if (asset.data.hasOwnProperty("addressv") && texture.addressV !== JSON_ADDRESS_MODE[asset.data.addressv]) {
        texture.addressV = JSON_ADDRESS_MODE[asset.data.addressv];
      }
      if (asset.data.hasOwnProperty("mipmaps") && texture.mipmaps !== asset.data.mipmaps) {
        texture.mipmaps = asset.data.mipmaps;
      }
      if (asset.data.hasOwnProperty("anisotropy") && texture.anisotropy !== asset.data.anisotropy) {
        texture.anisotropy = asset.data.anisotropy;
      }
      var rgbm = !!asset.data.rgbm;
      if (asset.data.hasOwnProperty("rgbm") && texture.rgbm !== rgbm) {
        texture.rgbm = rgbm;
      }
    }
    asset.resource.texture = texture;
    var frames = {};
    for (var key in asset.data.frames) {
      var frame = asset.data.frames[key];
      frames[key] = {rect:new pc.Vec4(frame.rect), pivot:new pc.Vec2(frame.pivot), border:new pc.Vec4(frame.border)};
    }
    asset.resource.frames = frames;
    asset.off("change", this._onAssetChange, this);
    asset.on("change", this._onAssetChange, this);
  }, _onAssetChange:function(asset, attribute, value) {
    var frame;
    if (attribute === "data" || attribute === "data.frames") {
      var frames = {};
      for (var key in value.frames) {
        frame = value.frames[key];
        frames[key] = {rect:new pc.Vec4(frame.rect), pivot:new pc.Vec2(frame.pivot), border:new pc.Vec4(frame.border)};
      }
      asset.resource.frames = frames;
    } else {
      var match = attribute.match(regexFrame);
      if (match) {
        var frameKey = match[1];
        if (value) {
          if (!asset.resource.frames[frameKey]) {
            asset.resource.frames[frameKey] = {rect:new pc.Vec4(value.rect), pivot:new pc.Vec2(value.pivot), border:new pc.Vec4(value.border)};
          } else {
            frame = asset.resource.frames[frameKey];
            frame.rect.set(value.rect[0], value.rect[1], value.rect[2], value.rect[3]);
            frame.pivot.set(value.pivot[0], value.pivot[1]);
            frame.border.set(value.border[0], value.border[1], value.border[2], value.border[3]);
          }
          asset.resource.fire("set:frame", frameKey, asset.resource.frames[frameKey]);
        } else {
          if (asset.resource.frames[frameKey]) {
            delete asset.resource.frames[frameKey];
            asset.resource.fire("remove:frame", frameKey);
          }
        }
      }
    }
  }});
  return {TextureAtlasHandler:TextureAtlasHandler};
}());
Object.assign(pc, function() {
  var SpriteHandler = function(assets, device) {
    this._assets = assets;
    this._device = device;
  };
  var onTextureAtlasLoaded = function(atlasAsset) {
    var spriteAsset = this;
    if (spriteAsset.resource) {
      spriteAsset.resource.atlas = atlasAsset.resource;
    }
  };
  var onTextureAtlasAdded = function(atlasAsset) {
    var spriteAsset = this;
    spriteAsset.registry.load(atlasAsset);
  };
  Object.assign(SpriteHandler.prototype, {load:function(url, callback) {
    if (pc.path.getExtension(url) === ".json") {
      pc.http.get(url, function(err, response) {
        if (!err) {
          callback(null, response);
        } else {
          callback(err);
        }
      });
    }
  }, open:function(url, data) {
    var sprite = new pc.Sprite(this._device);
    if (data) {
      sprite.__data = data;
    }
    return sprite;
  }, patch:function(asset, assets) {
    var sprite = asset.resource;
    if (sprite.__data) {
      asset.data.pixelsPerUnit = sprite.__data.pixelsPerUnit;
      asset.data.renderMode = sprite.__data.renderMode;
      asset.data.frameKeys = sprite.__data.frameKeys;
      var atlas = assets.getByUrl(sprite.__data.textureAtlasAsset);
      if (atlas) {
        asset.data.textureAtlasAsset = atlas.id;
      }
      delete sprite.__data;
    }
    sprite.startUpdate();
    sprite.renderMode = asset.data.renderMode;
    sprite.pixelsPerUnit = asset.data.pixelsPerUnit;
    sprite.frameKeys = asset.data.frameKeys;
    this._updateAtlas(asset);
    sprite.endUpdate();
    asset.off("change", this._onAssetChange, this);
    asset.on("change", this._onAssetChange, this);
  }, _updateAtlas:function(asset) {
    var sprite = asset.resource;
    if (!asset.data.textureAtlasAsset) {
      sprite.atlas = null;
      return;
    }
    this._assets.off("load:" + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);
    this._assets.on("load:" + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);
    var atlasAsset = this._assets.get(asset.data.textureAtlasAsset);
    if (atlasAsset && atlasAsset.resource) {
      sprite.atlas = atlasAsset.resource;
    } else {
      if (!atlasAsset) {
        this._assets.off("add:" + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
        this._assets.on("add:" + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
      } else {
        this._assets.load(atlasAsset);
      }
    }
  }, _onAssetChange:function(asset, attribute, value, oldValue) {
    if (attribute === "data") {
      if (value && value.textureAtlasAsset && oldValue && value.textureAtlasAsset !== oldValue.textureAtlasAsset) {
        this._assets.off("load:" + oldValue.textureAtlasAsset, onTextureAtlasLoaded, asset);
        this._assets.off("add:" + oldValue.textureAtlasAsset, onTextureAtlasAdded, asset);
      }
    }
  }});
  return {SpriteHandler:SpriteHandler};
}());
Object.assign(pc, function() {
  var JSON_PRIMITIVE_TYPE = {"points":pc.PRIMITIVE_POINTS, "lines":pc.PRIMITIVE_LINES, "lineloop":pc.PRIMITIVE_LINELOOP, "linestrip":pc.PRIMITIVE_LINESTRIP, "triangles":pc.PRIMITIVE_TRIANGLES, "trianglestrip":pc.PRIMITIVE_TRISTRIP, "trianglefan":pc.PRIMITIVE_TRIFAN};
  var JSON_VERTEX_ELEMENT_TYPE = {"int8":pc.TYPE_INT8, "uint8":pc.TYPE_UINT8, "int16":pc.TYPE_INT16, "uint16":pc.TYPE_UINT16, "int32":pc.TYPE_INT32, "uint32":pc.TYPE_UINT32, "float32":pc.TYPE_FLOAT32};
  var JsonModelParser = function(device) {
    this._device = device;
  };
  Object.assign(JsonModelParser.prototype, {parse:function(data) {
    var modelData = data.model;
    if (!modelData) {
      return null;
    }
    if (modelData.version <= 1) {
      return null;
    }
    var nodes = this._parseNodes(data);
    var skins = this._parseSkins(data, nodes);
    var morphs = this._parseMorphs(data, nodes);
    var vertexBuffers = this._parseVertexBuffers(data);
    var indices = this._parseIndexBuffers(data, vertexBuffers);
    var meshes = this._parseMeshes(data, skins.skins, morphs.morphs, vertexBuffers, indices.buffer, indices.data);
    this._initMorphs(data, morphs.morphs, vertexBuffers, meshes);
    var meshInstances = this._parseMeshInstances(data, nodes, meshes, skins.skins, skins.instances, morphs.morphs, morphs.instances);
    var model = new pc.Model;
    model.graph = nodes[0];
    model.meshInstances = meshInstances;
    model.skinInstances = skins.instances;
    model.morphInstances = morphs.instances;
    model.getGraph().syncHierarchy();
    return model;
  }, _parseNodes:function(data) {
    var modelData = data.model;
    var nodes = [];
    var i;
    for (i = 0;i < modelData.nodes.length;i++) {
      var nodeData = modelData.nodes[i];
      var node = new pc.GraphNode;
      node.setName(nodeData.name);
      node.setLocalPosition(nodeData.position[0], nodeData.position[1], nodeData.position[2]);
      node.setLocalEulerAngles(nodeData.rotation[0], nodeData.rotation[1], nodeData.rotation[2]);
      node.setLocalScale(nodeData.scale[0], nodeData.scale[1], nodeData.scale[2]);
      node.scaleCompensation = !!nodeData.scaleCompensation;
      nodes.push(node);
    }
    for (i = 1;i < modelData.parents.length;i++) {
      nodes[modelData.parents[i]].addChild(nodes[i]);
    }
    return nodes;
  }, _parseSkins:function(data, nodes) {
    var modelData = data.model;
    var skins = [];
    var skinInstances = [];
    var i, j;
    if (!this._device.supportsBoneTextures && modelData.skins.length > 0) {
      var boneLimit = this._device.getBoneLimit();
      pc.partitionSkin(modelData, null, boneLimit);
    }
    for (i = 0;i < modelData.skins.length;i++) {
      var skinData = modelData.skins[i];
      var inverseBindMatrices = [];
      for (j = 0;j < skinData.inverseBindMatrices.length;j++) {
        var ibm = skinData.inverseBindMatrices[j];
        inverseBindMatrices[j] = new pc.Mat4(ibm[0], ibm[1], ibm[2], ibm[3], ibm[4], ibm[5], ibm[6], ibm[7], ibm[8], ibm[9], ibm[10], ibm[11], ibm[12], ibm[13], ibm[14], ibm[15]);
      }
      var skin = new pc.Skin(this._device, inverseBindMatrices, skinData.boneNames);
      skins.push(skin);
      var skinInstance = new pc.SkinInstance(skin);
      var bones = [];
      for (j = 0;j < skin.boneNames.length;j++) {
        var boneName = skin.boneNames[j];
        var bone = nodes[0].findByName(boneName);
        bones.push(bone);
      }
      skinInstance.bones = bones;
      skinInstances.push(skinInstance);
    }
    return {skins:skins, instances:skinInstances};
  }, _parseMorphs:function(data, nodes) {
    var modelData = data.model;
    var morphs = [];
    var morphInstances = [];
    var i, j;
    var targets, morphTarget, morphTargetArray;
    if (modelData.morphs) {
      for (i = 0;i < modelData.morphs.length;i++) {
        targets = modelData.morphs[i].targets;
        morphTargetArray = [];
        for (j = 0;j < targets.length;j++) {
          var targetAabb = targets[j].aabb;
          var min = targetAabb.min;
          var max = targetAabb.max;
          var aabb = new pc.BoundingBox(new pc.Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new pc.Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
          morphTarget = new pc.MorphTarget({indices:targets[j].indices, deltaPositions:targets[j].deltaPositions, deltaNormals:targets[j].deltaNormals, name:targets[j].name, aabb:aabb});
          morphTargetArray.push(morphTarget);
        }
        var morph = new pc.Morph(morphTargetArray);
        morphs.push(morph);
        var morphInstance = new pc.MorphInstance(morph);
        morphInstances.push(morphInstance);
      }
    }
    return {morphs:morphs, instances:morphInstances};
  }, _calculateTangentsMorphTarget:function(positions, normals, uvs, indices, tan1, tan2, mtIndices, tangents) {
    var sdirx, sdiry, sdirz;
    var tdirx, tdiry, tdirz;
    var v1x, v1y, v1z;
    var v2x, v2y, v2z;
    var v3x, v3y, v3z;
    var w1x, w1y;
    var w2x, w2y;
    var w3x, w3y;
    var t1x, t1y, t1z;
    var t2x, t2y, t2z;
    var nx, ny, nz;
    var triangleCount;
    var i1, i2, i3;
    var x1, x2, y1, y2, z1, z2, s1, s2, t1, t2, r;
    var i, j;
    var area, ndott, mtIndexCount, len;
    triangleCount = indices.length / 3;
    area = 0.0;
    for (i = 0;i < triangleCount;i++) {
      i1 = indices[i * 3];
      i2 = indices[i * 3 + 1];
      i3 = indices[i * 3 + 2];
      v1x = positions[i1 * 3];
      v1y = positions[i1 * 3 + 1];
      v1z = positions[i1 * 3 + 2];
      v2x = positions[i2 * 3];
      v2y = positions[i2 * 3 + 1];
      v2z = positions[i2 * 3 + 2];
      v3x = positions[i3 * 3];
      v3y = positions[i3 * 3 + 1];
      v3z = positions[i3 * 3 + 2];
      w1x = uvs[i1 * 2];
      w1y = uvs[i1 * 2 + 1];
      w2x = uvs[i2 * 2];
      w2y = uvs[i2 * 2 + 1];
      w3x = uvs[i3 * 2];
      w3y = uvs[i3 * 2 + 1];
      x1 = v2x - v1x;
      x2 = v3x - v1x;
      y1 = v2y - v1y;
      y2 = v3y - v1y;
      z1 = v2z - v1z;
      z2 = v3z - v1z;
      s1 = w2x - w1x;
      s2 = w3x - w1x;
      t1 = w2y - w1y;
      t2 = w3y - w1y;
      area = s1 * t2 - s2 * t1;
      if (area == 0.0) {
        sdirx = 0;
        sdiry = 1;
        sdirz = 0;
        tdirx = 1;
        tdiry = 0;
        tdirz = 0;
      } else {
        r = 1.0 / area;
        sdirx = (t2 * x1 - t1 * x2) * r;
        sdiry = (t2 * y1 - t1 * y2) * r;
        sdirz = (t2 * z1 - t1 * z2) * r;
        tdirx = (s1 * x2 - s2 * x1) * r;
        tdiry = (s1 * y2 - s2 * y1) * r;
        tdirz = (s1 * z2 - s2 * z1) * r;
      }
      tan1[i1 * 3 + 0] += sdirx;
      tan1[i1 * 3 + 1] += sdiry;
      tan1[i1 * 3 + 2] += sdirz;
      tan1[i2 * 3 + 0] += sdirx;
      tan1[i2 * 3 + 1] += sdiry;
      tan1[i2 * 3 + 2] += sdirz;
      tan1[i3 * 3 + 0] += sdirx;
      tan1[i3 * 3 + 1] += sdiry;
      tan1[i3 * 3 + 2] += sdirz;
      tan2[i1 * 3 + 0] += tdirx;
      tan2[i1 * 3 + 1] += tdiry;
      tan2[i1 * 3 + 2] += tdirz;
      tan2[i2 * 3 + 0] += tdirx;
      tan2[i2 * 3 + 1] += tdiry;
      tan2[i2 * 3 + 2] += tdirz;
      tan2[i3 * 3 + 0] += tdirx;
      tan2[i3 * 3 + 1] += tdiry;
      tan2[i3 * 3 + 2] += tdirz;
    }
    mtIndexCount = mtIndices.length;
    for (j = 0;j < mtIndexCount;j++) {
      i = mtIndices[j];
      nx = normals[i * 3];
      ny = normals[i * 3 + 1];
      nz = normals[i * 3 + 2];
      t1x = tan1[i * 3];
      t1y = tan1[i * 3 + 1];
      t1z = tan1[i * 3 + 2];
      t2x = tan2[i * 3];
      t2y = tan2[i * 3 + 1];
      t2z = tan2[i * 3 + 2];
      ndott = nx * t1x + ny * t1y + nz * t1z;
      v1x = nx * ndott;
      v1y = ny * ndott;
      v1z = nz * ndott;
      v2x = ny * t1z - t1y * nz;
      v2y = nz * t1x - t1z * nx;
      v2z = nx * t1y - t1x * ny;
      t1x -= v1x;
      t1y -= v1y;
      t1z -= v1z;
      len = 1.0 / Math.sqrt(t1x * t1x + t1y * t1y + t1z * t1z);
      t1x *= len;
      t1y *= len;
      t1z *= len;
      tangents[i * 4] = t1x;
      tangents[i * 4 + 1] = t1y;
      tangents[i * 4 + 2] = t1z;
      tangents[i * 4 + 3] = v2x * t2x + v2y * t2y + v2z * t2z < 0.0 ? -1.0 : 1.0;
    }
    return tangents;
  }, _initMorphs:function(data, morphs, vertexBuffers, meshes) {
    var modelData = data.model;
    var i, j;
    var target, k, l, index;
    var triA, triB, triC;
    var flagged;
    var basePos;
    var baseNorm;
    var baseUv;
    var numVerts;
    var numIndices;
    var tpos, tnorm;
    var vertexData;
    var mtTriIndices = [];
    var processed = [];
    var vid;
    for (i = 0;i < meshes.length;i++) {
      vid = modelData.meshes[i].vertices;
      if (processed[vid]) {
        continue;
      }
      vertexData = modelData.vertices[vid];
      if (!vertexData.tangent) {
        continue;
      }
      var tangents = new Float32Array(vertexData.tangent.data);
      processed[vid] = true;
      if (vertexData.position && vertexData.normal && vertexData.texCoord0) {
        var indices = [];
        for (j = 0;j < modelData.meshes.length;j++) {
          if (modelData.meshes[j].vertices === vid) {
            indices = indices.concat(modelData.meshes[j].indices);
          }
        }
        basePos = vertexData.position.data;
        baseNorm = vertexData.normal.data;
        baseUv = vertexData.texCoord0.data;
        numVerts = basePos.length / 3;
        numIndices = indices.length;
        var targetTangents = new Float32Array(numVerts * 4);
        var tan1 = new Float32Array(numVerts * 3);
        var tan2 = new Float32Array(numVerts * 3);
        tpos = new Float32Array(numVerts * 3);
        tpos.set(basePos);
        tnorm = new Float32Array(numVerts * 3);
        tnorm.set(baseNorm);
        for (j = 0;j < morphs.length;j++) {
          if (modelData.meshes[i].morph !== j) {
            continue;
          }
          for (k = 0;k < morphs[j]._targets.length;k++) {
            target = morphs[j]._targets[k];
            var mtIndices = target.indices;
            var numMtIndices = mtIndices.length;
            if (numMtIndices === 0) {
              continue;
            }
            target.deltaTangents = new Float32Array(numMtIndices * 4);
            if (!flagged || flagged.length < numVerts) {
              flagged = new Uint8Array(numVerts);
            } else {
              for (l = 0;l < numVerts;l++) {
                flagged[l] = 0;
              }
            }
            for (l = 0;l < numMtIndices;l++) {
              index = mtIndices[l];
              flagged[index] = 1;
            }
            var numMtTriIndices = 0;
            for (l = 0;l < numIndices;l += 3) {
              triA = indices[l];
              triB = indices[l + 1];
              triC = indices[l + 2];
              if (flagged[triA] || flagged[triB] || flagged[triC]) {
                mtTriIndices[numMtTriIndices] = triA;
                mtTriIndices[numMtTriIndices + 1] = triB;
                mtTriIndices[numMtTriIndices + 2] = triC;
                numMtTriIndices += 3;
              }
            }
            mtTriIndices.length = numMtTriIndices;
            var deltaPos = target.deltaPositions;
            var deltaNorm = target.deltaNormals;
            for (l = 0;l < numMtIndices;l++) {
              index = mtIndices[l];
              tpos[index * 3] += deltaPos[l * 3];
              tpos[index * 3 + 1] += deltaPos[l * 3 + 1];
              tpos[index * 3 + 2] += deltaPos[l * 3 + 2];
              tnorm[index * 3] += deltaNorm[l * 3];
              tnorm[index * 3 + 1] += deltaNorm[l * 3 + 1];
              tnorm[index * 3 + 2] += deltaNorm[l * 3 + 2];
            }
            this._calculateTangentsMorphTarget(tpos, tnorm, baseUv, mtTriIndices, tan1, tan2, mtIndices, targetTangents);
            var deltaTangents = target.deltaTangents;
            for (l = 0;l < numMtIndices;l++) {
              index = mtIndices[l];
              deltaTangents[l * 4] = targetTangents[l * 4] - tangents[index * 4];
              deltaTangents[l * 4 + 1] = targetTangents[l * 4 + 1] - tangents[index * 4 + 1];
              deltaTangents[l * 4 + 2] = targetTangents[l * 4 + 2] - tangents[index * 4 + 2];
              deltaTangents[l * 4 + 3] = targetTangents[l * 4 + 3] - tangents[index * 4 + 3];
            }
            if (k === morphs[j]._targets.length - 1) {
              continue;
            }
            for (l = 0;l < numIndices;l += 3) {
              triA = indices[l];
              triB = indices[l + 1];
              triC = indices[l + 2];
              tan1[triA * 3 + 0] = 0;
              tan1[triA * 3 + 1] = 0;
              tan1[triA * 3 + 2] = 0;
              tan1[triB * 3 + 0] = 0;
              tan1[triB * 3 + 1] = 0;
              tan1[triB * 3 + 2] = 0;
              tan1[triC * 3 + 0] = 0;
              tan1[triC * 3 + 1] = 0;
              tan1[triC * 3 + 2] = 0;
              tan2[triA * 3 + 0] = 0;
              tan2[triA * 3 + 1] = 0;
              tan2[triA * 3 + 2] = 0;
              tan2[triB * 3 + 0] = 0;
              tan2[triB * 3 + 1] = 0;
              tan2[triB * 3 + 2] = 0;
              tan2[triC * 3 + 0] = 0;
              tan2[triC * 3 + 1] = 0;
              tan2[triC * 3 + 2] = 0;
            }
            for (l = 0;l < numMtIndices;l++) {
              index = target.indices[l];
              tpos[index * 3] = basePos[index * 3];
              tpos[index * 3 + 1] = basePos[index * 3 + 1];
              tpos[index * 3 + 2] = basePos[index * 3 + 2];
              tnorm[index * 3] = baseNorm[index * 3];
              tnorm[index * 3 + 1] = baseNorm[index * 3 + 1];
              tnorm[index * 3 + 2] = baseNorm[index * 3 + 2];
            }
          }
        }
      }
    }
  }, _parseVertexBuffers:function(data) {
    var modelData = data.model;
    var vertexBuffers = [];
    var attribute, attributeName;
    var attributeMap = {position:pc.SEMANTIC_POSITION, normal:pc.SEMANTIC_NORMAL, tangent:pc.SEMANTIC_TANGENT, blendWeight:pc.SEMANTIC_BLENDWEIGHT, blendIndices:pc.SEMANTIC_BLENDINDICES, color:pc.SEMANTIC_COLOR, texCoord0:pc.SEMANTIC_TEXCOORD0, texCoord1:pc.SEMANTIC_TEXCOORD1, texCoord2:pc.SEMANTIC_TEXCOORD2, texCoord3:pc.SEMANTIC_TEXCOORD3, texCoord4:pc.SEMANTIC_TEXCOORD4, texCoord5:pc.SEMANTIC_TEXCOORD5, texCoord6:pc.SEMANTIC_TEXCOORD6, texCoord7:pc.SEMANTIC_TEXCOORD7};
    var i, j;
    for (i = 0;i < modelData.vertices.length;i++) {
      var vertexData = modelData.vertices[i];
      if (!vertexData.tangent && vertexData.position && vertexData.normal && vertexData.texCoord0) {
        var indices = [];
        for (j = 0;j < modelData.meshes.length;j++) {
          if (modelData.meshes[j].vertices === i) {
            indices = indices.concat(modelData.meshes[j].indices);
          }
        }
        var tangents = pc.calculateTangents(vertexData.position.data, vertexData.normal.data, vertexData.texCoord0.data, indices);
        vertexData.tangent = {type:"float32", components:4, data:tangents};
      }
      var formatDesc = [];
      for (attributeName in vertexData) {
        attribute = vertexData[attributeName];
        var attribType = attribute.type;
        if (!this._device.supportsUnsignedByte) {
          if (attribType === "uint8") {
            attribType = "float32";
          }
          if (attribType === "int8") {
            attribType = "float32";
          }
        }
        formatDesc.push({semantic:attributeMap[attributeName], components:attribute.components, type:JSON_VERTEX_ELEMENT_TYPE[attribType], normalize:attributeMap[attributeName] === pc.SEMANTIC_COLOR});
      }
      var vertexFormat = new pc.VertexFormat(this._device, formatDesc);
      var numVertices = vertexData.position.data.length / vertexData.position.components;
      var vertexBuffer = new pc.VertexBuffer(this._device, vertexFormat, numVertices);
      var iterator = new pc.VertexIterator(vertexBuffer);
      for (j = 0;j < numVertices;j++) {
        for (attributeName in vertexData) {
          attribute = vertexData[attributeName];
          switch(attribute.components) {
            case 1:
              iterator.element[attributeMap[attributeName]].set(attribute.data[j]);
              break;
            case 2:
              iterator.element[attributeMap[attributeName]].set(attribute.data[j * 2], attribute.data[j * 2 + 1]);
              break;
            case 3:
              iterator.element[attributeMap[attributeName]].set(attribute.data[j * 3], attribute.data[j * 3 + 1], attribute.data[j * 3 + 2]);
              break;
            case 4:
              iterator.element[attributeMap[attributeName]].set(attribute.data[j * 4], attribute.data[j * 4 + 1], attribute.data[j * 4 + 2], attribute.data[j * 4 + 3]);
              break;
          }
        }
        iterator.next();
      }
      iterator.end();
      vertexBuffers.push(vertexBuffer);
    }
    return vertexBuffers;
  }, _parseIndexBuffers:function(data, vertexBuffers) {
    var modelData = data.model;
    var indexBuffer = null;
    var indexData = null;
    var i;
    var numIndices = 0;
    for (i = 0;i < modelData.meshes.length;i++) {
      var meshData = modelData.meshes[i];
      if (meshData.indices !== undefined) {
        numIndices += meshData.indices.length;
      }
    }
    var maxVerts = 0;
    for (i = 0;i < vertexBuffers.length;i++) {
      maxVerts = Math.max(maxVerts, vertexBuffers[i].numVertices);
    }
    if (numIndices > 0) {
      if (maxVerts > 65535 && this._device.extUintElement) {
        indexBuffer = new pc.IndexBuffer(this._device, pc.INDEXFORMAT_UINT32, numIndices);
        indexData = new Uint32Array(indexBuffer.lock());
      } else {
        indexBuffer = new pc.IndexBuffer(this._device, pc.INDEXFORMAT_UINT16, numIndices);
        indexData = new Uint16Array(indexBuffer.lock());
      }
    }
    return {buffer:indexBuffer, data:indexData};
  }, _parseMeshes:function(data, skins, morphs, vertexBuffers, indexBuffer, indexData) {
    var modelData = data.model;
    var meshes = [];
    var indexBase = 0;
    var i;
    for (i = 0;i < modelData.meshes.length;i++) {
      var meshData = modelData.meshes[i];
      var meshAabb = meshData.aabb;
      var min = meshAabb.min;
      var max = meshAabb.max;
      var aabb = new pc.BoundingBox(new pc.Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new pc.Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
      var indexed = meshData.indices !== undefined;
      var mesh = new pc.Mesh;
      mesh.vertexBuffer = vertexBuffers[meshData.vertices];
      mesh.indexBuffer[0] = indexed ? indexBuffer : null;
      mesh.primitive[0].type = JSON_PRIMITIVE_TYPE[meshData.type];
      mesh.primitive[0].base = indexed ? meshData.base + indexBase : meshData.base;
      mesh.primitive[0].count = meshData.count;
      mesh.primitive[0].indexed = indexed;
      mesh.skin = meshData.skin !== undefined ? skins[meshData.skin] : null;
      mesh.morph = meshData.morph !== undefined ? morphs[meshData.morph] : null;
      mesh.aabb = aabb;
      if (indexed) {
        indexData.set(meshData.indices, indexBase);
        indexBase += meshData.indices.length;
      }
      meshes.push(mesh);
    }
    if (indexBuffer !== null) {
      indexBuffer.unlock();
    }
    return meshes;
  }, _parseMeshInstances:function(data, nodes, meshes, skins, skinInstances, morphs, morphInstances) {
    var modelData = data.model;
    var meshInstances = [];
    var i;
    for (i = 0;i < modelData.meshInstances.length;i++) {
      var meshInstanceData = modelData.meshInstances[i];
      var node = nodes[meshInstanceData.node];
      var mesh = meshes[meshInstanceData.mesh];
      var meshInstance = new pc.MeshInstance(node, mesh, pc.ModelHandler.DEFAULT_MATERIAL);
      if (mesh.skin) {
        var skinIndex = skins.indexOf(mesh.skin);
        meshInstance.skinInstance = skinInstances[skinIndex];
      }
      if (mesh.morph) {
        var morphIndex = morphs.indexOf(mesh.morph);
        meshInstance.morphInstance = morphInstances[morphIndex];
      }
      meshInstances.push(meshInstance);
    }
    return meshInstances;
  }});
  return {JsonModelParser:JsonModelParser};
}());
Object.assign(pc, function() {
  var SceneParser = function(app) {
    this._app = app;
  };
  Object.assign(SceneParser.prototype, {parse:function(data) {
    var entities = {};
    var id, i;
    var parent = null;
    for (id in data.entities) {
      entities[id] = this._createEntity(data.entities[id]);
      if (data.entities[id].parent === null) {
        parent = entities[id];
      }
    }
    for (id in data.entities) {
      var l = data.entities[id].children.length;
      for (i = 0;i < l;i++) {
        var resource_id = data.entities[id].children[i];
        if (entities[resource_id]) {
          entities[id].addChild(entities[resource_id]);
        }
      }
    }
    this._openComponentData(parent, data.entities);
    return parent;
  }, _createEntity:function(data) {
    var entity = new pc.Entity;
    var p = data.position;
    var r = data.rotation;
    var s = data.scale;
    entity.name = data.name;
    entity._guid = data.resource_id;
    entity.setLocalPosition(p[0], p[1], p[2]);
    entity.setLocalEulerAngles(r[0], r[1], r[2]);
    entity.setLocalScale(s[0], s[1], s[2]);
    entity._enabled = data.enabled !== undefined ? data.enabled : true;
    entity._enabledInHierarchy = entity._enabled;
    entity.template = data.template;
    if (data.tags) {
      for (var i = 0;i < data.tags.length;i++) {
        entity.tags.add(data.tags[i]);
      }
    }
    if (data.labels) {
      data.labels.forEach(function(label) {
        entity.addLabel(label);
      });
    }
    return entity;
  }, _openComponentData:function(entity, entities) {
    var systems = this._app.systems.list();
    var i, len = systems.length;
    var edata = entities[entity._guid];
    for (i = 0;i < len;i++) {
      var componentData = edata.components[systems[i].id];
      if (componentData) {
        this._app.systems[systems[i].id].addComponent(entity, componentData);
      }
    }
    var length = edata.children.length;
    var children = entity._children;
    for (i = 0;i < length;i++) {
      children[i] = this._openComponentData(children[i], entities);
    }
    return entity;
  }});
  return {SceneParser:SceneParser};
}());
Object.assign(pc, function() {
  var assetIdCounter = 0;
  var ABSOLUTE_URL = new RegExp("^" + "\\s*" + "(?:" + "[a-z]+[a-z0-9\\-\\+\\.]*" + ":" + ")?" + "//", "i");
  var Asset = function(name, type, file, data) {
    this._id = ++assetIdCounter;
    this.name = name || "";
    this.type = type;
    this.tags = new pc.Tags(this);
    this._preload = false;
    this.variants = new pc.AssetVariants(this);
    this._file = null;
    this._data = data || {};
    this._resources = [];
    this.loaded = false;
    this.loading = false;
    this.registry = null;
    pc.events.attach(this);
    if (file) {
      this.file = file;
    }
  };
  Object.assign(Asset.prototype, {getFileUrl:function() {
    var file = this.getPreferredFile();
    if (!file || !file.url) {
      return null;
    }
    var url = file.url;
    if (this.registry && this.registry.prefix && !ABSOLUTE_URL.test(url)) {
      url = this.registry.prefix + url;
    }
    if (this.type !== "script" && file.hash) {
      var separator = url.indexOf("?") !== -1 ? "&" : "?";
      url += separator + "t=" + file.hash;
    }
    return url;
  }, getPreferredFile:function() {
    if (!this.file) {
      return null;
    }
    if (this.type === "texture" || this.type === "textureatlas") {
      var device = this.registry._loader.getHandler("texture")._device;
      if (this.variants.pvr && device.extCompressedTexturePVRTC) {
        return this.variants.pvr;
      } else {
        if (this.variants.dxt && device.extCompressedTextureS3TC) {
          return this.variants.dxt;
        } else {
          if (this.variants.etc1 && device.extCompressedTextureETC1) {
            return this.variants.etc1;
          }
        }
      }
    }
    return this.file;
  }, ready:function(callback, scope) {
    scope = scope || this;
    if (this.resource) {
      callback.call(scope, this);
    } else {
      this.once("load", function(asset) {
        callback.call(scope, asset);
      });
    }
  }, reload:function() {
    if (!this.loaded) {
      return;
    }
    if (this.type === "cubemap") {
      this.registry._loader.patch(this, this.registry);
    } else {
      this.loaded = false;
      this.registry.load(this);
    }
  }, unload:function() {
    if (!this.loaded && !this.resource) {
      return;
    }
    this.fire("unload", this);
    this.registry.fire("unload:" + this.id, this);
    if (this.resource && this.resource.destroy) {
      this.resource.destroy();
    }
    this.resource = null;
    this.loaded = false;
    if (this.file) {
      this.registry._loader.clearCache(this.getFileUrl(), this.type);
    }
  }});
  Object.defineProperty(Asset.prototype, "id", {get:function() {
    return this._id;
  }, set:function(value) {
    this._id = value;
    if (value > assetIdCounter) {
      assetIdCounter = value;
    }
  }});
  Object.defineProperty(Asset.prototype, "file", {get:function() {
    return this._file;
  }, set:function(value) {
    var key;
    var valueAsBool = !!value;
    var fileAsBool = !!this._file;
    if (valueAsBool !== fileAsBool || value && this._file && value.hash !== this._file) {
      if (value) {
        if (!this._file) {
          this._file = {};
        }
        this._file.url = value.url;
        this._file.filename = value.filename;
        this._file.hash = value.hash;
        this._file.size = value.size;
        this._file.variants = this.variants;
        if (value.hasOwnProperty("variants")) {
          this.variants.clear();
          if (value.variants) {
            for (key in value.variants) {
              if (!value.variants[key]) {
                continue;
              }
              this.variants[key] = value.variants[key];
            }
          }
        }
        this.fire("change", this, "file", this._file, this._file);
        this.reload();
      } else {
        this._file = null;
        this.variants.clear();
      }
    } else {
      if (value && this._file && value.hasOwnProperty("variants")) {
        this.variants.clear();
        if (value.variants) {
          for (key in value.variants) {
            if (!value.variants[key]) {
              continue;
            }
            this.variants[key] = value.variants[key];
          }
        }
      }
    }
  }});
  Object.defineProperty(Asset.prototype, "data", {get:function() {
    return this._data;
  }, set:function(value) {
    var old = this._data;
    this._data = value;
    if (value !== old) {
      this.fire("change", this, "data", value, old);
      if (this.loaded) {
        this.registry._loader.patch(this, this.registry);
      }
    }
  }});
  Object.defineProperty(Asset.prototype, "resource", {get:function() {
    return this._resources[0];
  }, set:function(value) {
    var _old = this._resources[0];
    this._resources[0] = value;
    this.fire("change", this, "resource", value, _old);
  }});
  Object.defineProperty(Asset.prototype, "resources", {get:function() {
    return this._resources;
  }, set:function(value) {
    var _old = this._resources;
    this._resources = value;
    this.fire("change", this, "resources", value, _old);
  }});
  Object.defineProperty(Asset.prototype, "preload", {get:function() {
    return this._preload;
  }, set:function(value) {
    value = !!value;
    if (this._preload === value) {
      return;
    }
    this._preload = value;
    if (this._preload && !this.loaded && !this.loading && this.registry) {
      this.registry.load(this);
    }
  }});
  return {Asset:Asset, ASSET_ANIMATION:"animation", ASSET_AUDIO:"audio", ASSET_IMAGE:"image", ASSET_JSON:"json", ASSET_MODEL:"model", ASSET_MATERIAL:"material", ASSET_TEXT:"text", ASSET_TEXTURE:"texture", ASSET_CUBEMAP:"cubemap", ASSET_SHADER:"shader", ASSET_CSS:"css", ASSET_HTML:"html", ASSET_SCRIPT:"script", ABSOLUTE_URL:ABSOLUTE_URL};
}());
Object.assign(pc, function() {
  var properties = [];
  var AssetVariants = function(asset) {
    this.asset = asset;
  };
  var defineVariantProperty = function(name) {
    var field = "_" + name;
    properties.push(field);
    Object.defineProperty(AssetVariants.prototype, name, {get:function() {
      return this[field] || null;
    }, set:function(value) {
      var fieldAsBool = !!this[field];
      var valueAsBool = !!value;
      if (fieldAsBool !== valueAsBool || this[field] && value && this[field].hash !== value.hash) {
        if (value) {
          this[field] = {url:value.url, filename:value.filename, size:value.size, hash:value.hash, opt:value.opt || 0};
        } else {
          this[field] = null;
        }
        if (this.asset.file) {
          this.asset.fire("change", this.asset, "file", this.asset._file, this.asset._file);
          this.asset.reload();
        }
      }
    }});
  };
  defineVariantProperty("dxt");
  defineVariantProperty("pvr");
  defineVariantProperty("etc1");
  AssetVariants.prototype.clear = function() {
    for (var i = 0;i < properties.length;i++) {
      this[properties[i]] = null;
    }
  };
  return {AssetVariants:AssetVariants};
}());
Object.assign(pc, function() {
  var AssetRegistry = function(loader) {
    this._loader = loader;
    this._assets = [];
    this._cache = {};
    this._names = {};
    this._tags = new pc.TagsCache("_id");
    this._urls = {};
    this.prefix = null;
    Object.assign(this, pc.events);
  };
  Object.assign(AssetRegistry.prototype, {list:function(filters) {
    filters = filters || {};
    return this._assets.filter(function(asset) {
      var include = true;
      if (filters.preload !== undefined) {
        include = asset.preload === filters.preload;
      }
      return include;
    });
  }, add:function(asset) {
    var index = this._assets.push(asset) - 1;
    var url;
    this._cache[asset.id] = index;
    if (!this._names[asset.name]) {
      this._names[asset.name] = [];
    }
    this._names[asset.name].push(index);
    if (asset.file) {
      url = asset.file.url;
      this._urls[url] = index;
    }
    asset.registry = this;
    this._tags.addItem(asset);
    asset.tags.on("add", this._onTagAdd, this);
    asset.tags.on("remove", this._onTagRemove, this);
    this.fire("add", asset);
    this.fire("add:" + asset.id, asset);
    if (url) {
      this.fire("add:url:" + url, asset);
    }
    if (asset.preload) {
      this.load(asset);
    }
  }, remove:function(asset) {
    delete this._cache[asset.id];
    delete this._names[asset.name];
    var url = asset.file ? asset.file.url : null;
    if (url) {
      delete this._urls[url];
    }
    this._tags.removeItem(asset);
    asset.tags.off("add", this._onTagAdd, this);
    asset.tags.off("remove", this._onTagRemove, this);
    asset.fire("remove", asset);
    this.fire("remove", asset);
    this.fire("remove:" + asset.id, asset);
    if (url) {
      this.fire("remove:url:" + url, asset);
    }
  }, get:function(id) {
    var idx = this._cache[id];
    return this._assets[idx];
  }, getByUrl:function(url) {
    var idx = this._urls[url];
    return this._assets[idx];
  }, load:function(asset) {
    if (asset.loading) {
      return;
    }
    var self = this;
    if (asset.loaded) {
      if (asset.type === "cubemap") {
        self._loader.patch(asset, this);
      }
      return;
    }
    var load = !!asset.file;
    var file = asset.getPreferredFile();
    var _load = function() {
      var url = asset.getFileUrl();
      asset.loading = true;
      self._loader.load(url, asset.type, function(err, resource, extra) {
        asset.loaded = true;
        asset.loading = false;
        if (err) {
          self.fire("error", err, asset);
          self.fire("error:" + asset.id, err, asset);
          asset.fire("error", err, asset);
          return;
        }
        if (resource instanceof Array) {
          asset.resources = resource;
        } else {
          asset.resource = resource;
        }
        if (!pc.script.legacy && asset.type === "script") {
          var loader = self._loader.getHandler("script");
          if (loader._cache[asset.id] && loader._cache[asset.id].parentNode === document.head) {
            document.head.removeChild(loader._cache[asset.id]);
          }
          loader._cache[asset.id] = extra;
        }
        self._loader.patch(asset, self);
        self.fire("load", asset);
        self.fire("load:" + asset.id, asset);
        if (file && file.url) {
          self.fire("load:url:" + file.url, asset);
        }
        asset.fire("load", asset);
      }, asset);
    };
    var _open = function() {
      var resource = self._loader.open(asset.type, asset.data);
      if (resource instanceof Array) {
        asset.resources = resource;
      } else {
        asset.resource = resource;
      }
      asset.loaded = true;
      self._loader.patch(asset, self);
      self.fire("load", asset);
      self.fire("load:" + asset.id, asset);
      if (file && file.url) {
        self.fire("load:url:" + file.url, asset);
      }
      asset.fire("load", asset);
    };
    if (file && asset.type === "cubemap") {
      load = false;
      var url = asset.getFileUrl();
      this._loader.load(url, "texture", function(err, texture) {
        if (!err) {
          self._loader.patch({resource:texture, type:"texture", data:asset.data}, self);
          asset._dds = texture;
          _open();
        } else {
          self.fire("error", err, asset);
          self.fire("error:" + asset.id, err, asset);
          asset.fire("error", err, asset);
        }
      });
    }
    if (!file) {
      _open();
    } else {
      if (load) {
        this.fire("load:start", asset);
        this.fire("load:" + asset.id + ":start", asset);
        _load();
      }
    }
  }, loadFromUrl:function(url, type, callback) {
    var self = this;
    var name = pc.path.getBasename(url);
    var file = {url:url};
    var data = {};
    var asset = self.getByUrl(url);
    if (!asset) {
      asset = new pc.Asset(name, type, file, data);
      self.add(asset);
    }
    if (type === "model") {
      self._loadModel(asset, callback);
      return;
    }
    asset.once("load", function(asset) {
      callback(null, asset);
    });
    asset.once("error", function(err) {
      callback(err);
    });
    self.load(asset);
  }, _loadModel:function(asset, callback) {
    var self = this;
    var url = asset.getFileUrl();
    var dir = pc.path.getDirectory(url);
    var basename = pc.path.getBasename(url);
    var ext = pc.path.getExtension(url);
    var _loadAsset = function(asset) {
      asset.once("load", function(asset) {
        callback(null, asset);
      });
      asset.once("error", function(err) {
        callback(err);
      });
      self.load(asset);
    };
    if (ext === ".json") {
      var mappingUrl = pc.path.join(dir, basename.replace(".json", ".mapping.json"));
      this._loader.load(mappingUrl, "json", function(err, data) {
        if (err) {
          asset.data = {mapping:[]};
          _loadAsset(asset);
          return;
        }
        self._loadMaterials(dir, data, function(err, materials) {
          asset.data = data;
          _loadAsset(asset);
        });
      });
    } else {
      _loadAsset(asset);
    }
  }, _loadMaterials:function(dir, mapping, callback) {
    var self = this;
    var i;
    var count = mapping.mapping.length;
    var materials = [];
    var done = function(err, materials) {
      self._loadTextures(materials, function(err, textures) {
        callback(null, materials);
      });
    };
    if (count === 0) {
      callback(null, materials);
    }
    var onLoadAsset = function(err, asset) {
      materials.push(asset);
      count--;
      if (count === 0) {
        done(null, materials);
      }
    };
    for (i = 0;i < mapping.mapping.length;i++) {
      var path = mapping.mapping[i].path;
      if (path) {
        self.loadFromUrl(pc.path.join(dir, path), "material", onLoadAsset);
      } else {
        count--;
      }
    }
  }, _loadTextures:function(materials, callback) {
    var self = this;
    var i, j;
    var used = {};
    var urls = [];
    var textures = [];
    var count = 0;
    for (i = 0;i < materials.length;i++) {
      if (materials[i].data.parameters) {
        var params = materials[i].data.parameters;
        for (j = 0;j < params.length;j++) {
          if (params[j].type === "texture") {
            var url = materials[i].getFileUrl();
            var dir = pc.path.getDirectory(url);
            url = pc.path.join(dir, params[j].data);
            if (!used[url]) {
              used[url] = true;
              urls.push(url);
              count++;
            }
          }
        }
      } else {
        console.warn("Update material asset loader to support new material format");
      }
    }
    if (!count) {
      callback(null, textures);
      return;
    }
    var onLoadAsset = function(err, texture) {
      textures.push(texture);
      count--;
      if (err) {
        console.error(err);
      }
      if (count === 0) {
        callback(null, textures);
      }
    };
    for (i = 0;i < urls.length;i++) {
      self.loadFromUrl(urls[i], "texture", onLoadAsset);
    }
  }, findAll:function(name, type) {
    var self = this;
    var idxs = this._names[name];
    if (idxs) {
      var assets = idxs.map(function(idx) {
        return self._assets[idx];
      });
      if (type) {
        return assets.filter(function(asset) {
          return asset.type === type;
        });
      }
      return assets;
    }
    return [];
  }, _onTagAdd:function(tag, asset) {
    this._tags.add(tag, asset);
  }, _onTagRemove:function(tag, asset) {
    this._tags.remove(tag, asset);
  }, findByTag:function() {
    return this._tags.find(arguments);
  }, filter:function(callback) {
    var items = [];
    for (var i = 0, len = this._assets.length;i < len;i++) {
      if (callback(this._assets[i])) {
        items.push(this._assets[i]);
      }
    }
    return items;
  }, find:function(name, type) {
    var asset = this.findAll(name, type);
    return asset ? asset[0] : null;
  }, getAssetById:function(id) {
    console.warn("DEPRECATED: getAssetById() use get() instead");
    return this.get(id);
  }});
  return {AssetRegistry:AssetRegistry};
}());
Function.prototype.extendsFrom = function(Super) {
  var Self, Func;
  var Temp = function() {
  };
  Self = this;
  Func = function() {
    Super.apply(this, arguments);
    Self.apply(this, arguments);
    this.constructor = Self;
  };
  Func._super = Super.prototype;
  Temp.prototype = Super.prototype;
  Func.prototype = new Temp;
  return Func;
};
Object.assign(pc, function() {
  return {inherits:function(Self, Super) {
    var Temp = function() {
    };
    var Func = function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
      Super.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
      Self.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    };
    Func._super = Super.prototype;
    Temp.prototype = Super.prototype;
    Func.prototype = new Temp;
    return Func;
  }};
}());
pc.anim = {Animation:pc.Animation, Key:pc.Key, Node:pc.Node, Skeleton:pc.Skeleton};
pc.asset = {ASSET_ANIMATION:"animation", ASSET_AUDIO:"audio", ASSET_IMAGE:"image", ASSET_JSON:"json", ASSET_MODEL:"model", ASSET_MATERIAL:"material", ASSET_TEXT:"text", ASSET_TEXTURE:"texture", ASSET_CUBEMAP:"cubemap", ASSET_SCRIPT:"script"};
pc.audio = {AudioManager:pc.SoundManager, Channel:pc.Channel, Channel3d:pc.Channel3d, Listener:pc.Listener, Sound:pc.Sound};
pc.fw = {Application:pc.Application, Component:pc.Component, ComponentData:pc.ComponentData, ComponentSystem:pc.ComponentSystem, Entity:pc.Entity, FillMode:{NONE:pc.FILLMODE_NONE, FILL_WINDOW:pc.FILLMODE_FILL_WINDOW, KEEP_ASPECT:pc.FILLMODE_KEEP_ASPECT}, ResolutionMode:{AUTO:pc.RESOLUTION_AUTO, FIXED:pc.RESOLUTION_FIXED}};
Object.assign(pc.gfx, {drawQuadWithShader:pc.drawQuadWithShader, precalculatedTangents:pc.precalculatedTangents, programlib:pc.programlib, shaderChunks:pc.shaderChunks, ContextCreationError:pc.ContextCreationError, Device:pc.GraphicsDevice, IndexBuffer:pc.IndexBuffer, ProgramLibrary:pc.ProgramLibrary, RenderTarget:pc.RenderTarget, ScopeId:pc.ScopeId, Shader:pc.Shader, ShaderInput:pc.ShaderInput, Texture:pc.Texture, UnsupportedBrowserError:pc.UnsupportedBrowserError, VertexBuffer:pc.VertexBuffer, 
VertexFormat:pc.VertexFormat, VertexIterator:pc.VertexIterator});
(function() {
  function UnsupportedBrowserError(message) {
    this.name = "UnsupportedBrowserError";
    this.message = message || "";
  }
  UnsupportedBrowserError.prototype = Error.prototype;
  function ContextCreationError(message) {
    this.name = "ContextCreationError";
    this.message = message || "";
  }
  ContextCreationError.prototype = Error.prototype;
  pc.ContextCreationError = ContextCreationError;
  pc.UnsupportedBrowserError = UnsupportedBrowserError;
})();
Object.assign(pc.input, {getTouchTargetCoords:pc.getTouchTargetCoords, Controller:pc.Controller, GamePads:pc.GamePads, Keyboard:pc.Keyboard, KeyboardEvent:pc.KeyboardEvent, Mouse:pc.Mouse, MouseEvent:pc.MouseEvent, Touch:pc.Touch, TouchDevice:pc.TouchDevice, TouchEvent:pc.TouchEvent});
pc.math.INV_LOG2 = Math.LOG2E;
pc.math.intToBytes = pc.math.intToBytes32;
pc.math.bytesToInt = pc.math.bytesToInt32;
pc.posteffect = {createFullscreenQuad:pc.createFullscreenQuad, drawFullscreenQuad:pc.drawFullscreenQuad, PostEffect:pc.PostEffect, PostEffectQueue:pc.PostEffectQueue};
Object.assign(pc.scene, {partitionSkin:pc.partitionSkin, procedural:{calculateTangents:pc.calculateTangents, createMesh:pc.createMesh, createTorus:pc.createTorus, createCylinder:pc.createCylinder, createCapsule:pc.createCapsule, createCone:pc.createCone, createSphere:pc.createSphere, createPlane:pc.createPlane, createBox:pc.createBox}, BasicMaterial:pc.BasicMaterial, DepthMaterial:pc.DepthMaterial, ForwardRenderer:pc.ForwardRenderer, GraphNode:pc.GraphNode, Material:pc.Material, Command:pc.Command, 
Mesh:pc.Mesh, MeshInstance:pc.MeshInstance, Model:pc.Model, ParticleEmitter:pc.ParticleEmitter, PhongMaterial:pc.StandardMaterial, Picker:pc.Picker, PickMaterial:pc.PickMaterial, Projection:{ORTHOGRAPHIC:pc.PROJECTION_ORTHOGRAPHIC, PERSPECTIVE:pc.PROJECTION_PERSPECTIVE}, Scene:pc.Scene, Skin:pc.Skin, SkinInstance:pc.SkinInstance});
pc.shape = {Aabb:pc.BoundingBox, Sphere:pc.BoundingSphere, Plane:pc.Plane};
pc.time = {now:pc.now, Timer:pc.Timer};
pc.PhongMaterial = pc.StandardMaterial;
pc.BoundingSphere.prototype.intersectRay = pc.BoundingSphere.prototype.intersectsRay;
pc.ELEMENTTYPE_INT8 = pc.TYPE_INT8;
pc.ELEMENTTYPE_UINT8 = pc.TYPE_UINT8;
pc.ELEMENTTYPE_INT16 = pc.TYPE_INT16;
pc.ELEMENTTYPE_UINT16 = pc.TYPE_UINT16;
pc.ELEMENTTYPE_INT32 = pc.TYPE_INT32;
pc.ELEMENTTYPE_UINT32 = pc.TYPE_UINT32;
pc.ELEMENTTYPE_FLOAT32 = pc.TYPE_FLOAT32;
Object.defineProperty(pc.shaderChunks, "transformSkinnedVS", {get:function() {
  return "#define SKIN\n" + pc.shaderChunks.transformVS;
}});
Object.assign(pc.Application.prototype, function() {
  var tempGraphNode = new pc.GraphNode;
  var identityGraphNode = new pc.GraphNode;
  var meshInstanceArray = [];
  var _deprecationWarning = false;
  var ImmediateData = function(device) {
    this.lineVertexFormat = new pc.VertexFormat(device, [{semantic:pc.SEMANTIC_POSITION, components:3, type:pc.TYPE_FLOAT32}, {semantic:pc.SEMANTIC_COLOR, components:4, type:pc.TYPE_UINT8, normalize:true}]);
    this.lineBatches = [];
    this.layers = [];
    this.layerToBatch = {};
    this.quadMesh = null;
    this.cubeLocalPos = null;
    this.cubeWorldPos = null;
    this.identityGraphNode = new pc.GraphNode;
  };
  ImmediateData.prototype.addLayer = function(layer) {
    if (this.layers.indexOf(layer) < 0) {
      this.layers.push(layer);
    }
  };
  ImmediateData.prototype.getLayerIdx = function(layer) {
    return this.layerToBatch[layer.id];
  };
  ImmediateData.prototype.addLayerIdx = function(idx, layer) {
    this.layerToBatch[layer.id] = idx;
  };
  var LineBatch = function() {
    this.numLinesAllocated = 128;
    this.vb = null;
    this.vbRam = null;
    this.mesh = null;
    this.linesUsed = 0;
    this.material = null;
    this.meshInstance = null;
    this.layer = null;
  };
  Object.assign(LineBatch.prototype, {init:function(device, vertexFormat, layer, linesToAdd) {
    if (!this.mesh) {
      this.mesh = new pc.Mesh;
      this.mesh.primitive[0].type = pc.PRIMITIVE_LINES;
      this.mesh.primitive[0].base = 0;
      this.mesh.primitive[0].indexed = false;
      this.material = new pc.BasicMaterial;
      this.material.vertexColors = true;
      this.material.blend = true;
      this.material.blendType = pc.BLEND_NORMAL;
      this.material.update();
    }
    this.layer = layer;
    while (this.linesUsed + linesToAdd > this.numLinesAllocated) {
      if (this.vb) {
        this.vb.destroy();
        this.vb = null;
      }
      this.numLinesAllocated *= 2;
    }
    this.vertexFormat = vertexFormat;
    if (!this.vb) {
      this.vb = new pc.VertexBuffer(device, vertexFormat, this.numLinesAllocated * 2, pc.BUFFER_DYNAMIC);
      this.mesh.vertexBuffer = this.vb;
      this.vbRam = new DataView(this.vb.lock());
      if (!this.meshInstance) {
        identityGraphNode.worldTransform = pc.Mat4.IDENTITY;
        identityGraphNode._dirtyWorld = identityGraphNode._dirtyNormal = false;
        this.meshInstance = new pc.MeshInstance(identityGraphNode, this.mesh, this.material);
        this.meshInstance.cull = false;
      }
    }
  }, addLines:function(position, color) {
    var multiColor = !!color.length;
    var offset = this.linesUsed * 2 * this.vertexFormat.size;
    var clr;
    for (var i = 0;i < position.length;i++) {
      this.vbRam.setFloat32(offset, position[i].x, true);
      offset += 4;
      this.vbRam.setFloat32(offset, position[i].y, true);
      offset += 4;
      this.vbRam.setFloat32(offset, position[i].z, true);
      offset += 4;
      clr = multiColor ? color[i] : color;
      this.vbRam.setUint8(offset, clr.r * 255);
      offset += 1;
      this.vbRam.setUint8(offset, clr.g * 255);
      offset += 1;
      this.vbRam.setUint8(offset, clr.b * 255);
      offset += 1;
      this.vbRam.setUint8(offset, clr.a * 255);
      offset += 1;
    }
    this.linesUsed += position.length / 2;
  }, finalize:function() {
    if (this.linesUsed > 0) {
      this.vb.setData(this.vbRam.buffer);
      this.mesh.primitive[0].count = this.linesUsed * 2;
      meshInstanceArray[0] = this.meshInstance;
      this.layer.addMeshInstances(meshInstanceArray, true);
      this.linesUsed = 0;
    }
  }});
  function _initImmediate() {
    if (!this._immediateData) {
      this._immediateData = new ImmediateData(this.graphicsDevice);
      this.on("prerender", this._preRenderImmediate, this);
      this.on("postrender", this._postRenderImmediate, this);
    }
  }
  function _addLines(position, color, options) {
    if (options.layer === undefined) {
      options.layer = this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE);
    }
    if (options.depthTest === undefined) {
      options.depthTest = true;
    }
    this._initImmediate();
    var layer = options.layer;
    this._immediateData.addLayer(layer);
    var idx = this._immediateData.getLayerIdx(layer);
    if (idx === undefined) {
      var batch = new LineBatch;
      batch.init(this.graphicsDevice, this._immediateData.lineVertexFormat, layer, position.length / 2);
      batch.material.depthTest = options.depthTest;
      if (options.mask) {
        batch.meshInstance.mask = options.mask;
      }
      idx = this._immediateData.lineBatches.push(batch) - 1;
      this._immediateData.addLayerIdx(idx, layer);
    } else {
      this._immediateData.lineBatches[idx].init(this.graphicsDevice, this._immediateData.lineVertexFormat, layer, position.length / 2);
      this._immediateData.lineBatches[idx].material.depthTest = options.depthTest;
      if (options.mask) {
        this._immediateData.lineBatches[idx].meshInstance.mask = options.mask;
      }
    }
    this._immediateData.lineBatches[idx].addLines(position, color);
  }
  function renderLine(start, end, color) {
    var endColor = color;
    var options;
    var arg3 = arguments[3];
    var arg4 = arguments[4];
    if (arg3 instanceof pc.Color) {
      endColor = arg3;
      if (typeof arg4 === "number") {
        if (!_deprecationWarning) {
          console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead");
          _deprecationWarning = true;
        }
        if (arg4 === pc.LINEBATCH_OVERLAY) {
          options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE), depthTest:false};
        } else {
          options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE), depthTest:true};
        }
      } else {
        options = arg4;
      }
    } else {
      if (typeof arg3 === "number") {
        if (!_deprecationWarning) {
          console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead");
          _deprecationWarning = true;
        }
        endColor = color;
        if (arg3 === pc.LINEBATCH_OVERLAY) {
          options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE), depthTest:false};
        } else {
          options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE), depthTest:true};
        }
      } else {
        if (arg3) {
          options = arg3;
        } else {
          options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE), depthTest:true};
        }
      }
    }
    this._addLines([start, end], [color, endColor], options);
  }
  function renderLines(position, color, options) {
    if (!options) {
      options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE), depthTest:true};
    } else {
      if (typeof options === "number") {
        if (!_deprecationWarning) {
          console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead");
          _deprecationWarning = true;
        }
        if (options === pc.LINEBATCH_OVERLAY) {
          options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE), depthTest:false};
        } else {
          options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE), depthTest:true};
        }
      }
    }
    var multiColor = !!color.length;
    if (multiColor) {
      if (position.length !== color.length) {
        pc.log.error("renderLines: position/color arrays have different lengths");
        return;
      }
    }
    if (position.length % 2 !== 0) {
      pc.log.error("renderLines: array length is not divisible by 2");
      return;
    }
    this._addLines(position, color, options);
  }
  function renderWireCube(matrix, color, options) {
    var i;
    this._initImmediate();
    if (!this._immediateData.cubeLocalPos) {
      var x = 0.5;
      this._immediateData.cubeLocalPos = [new pc.Vec3(-x, -x, -x), new pc.Vec3(-x, x, -x), new pc.Vec3(x, x, -x), new pc.Vec3(x, -x, -x), new pc.Vec3(-x, -x, x), new pc.Vec3(-x, x, x), new pc.Vec3(x, x, x), new pc.Vec3(x, -x, x)];
      this._immediateData.cubeWorldPos = [new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3];
    }
    var cubeLocalPos = this._immediateData.cubeLocalPos;
    var cubeWorldPos = this._immediateData.cubeWorldPos;
    for (i = 0;i < 8;i++) {
      matrix.transformPoint(cubeLocalPos[i], cubeWorldPos[i]);
    }
    this.renderLines([cubeWorldPos[0], cubeWorldPos[1], cubeWorldPos[1], cubeWorldPos[2], cubeWorldPos[2], cubeWorldPos[3], cubeWorldPos[3], cubeWorldPos[0], cubeWorldPos[4], cubeWorldPos[5], cubeWorldPos[5], cubeWorldPos[6], cubeWorldPos[6], cubeWorldPos[7], cubeWorldPos[7], cubeWorldPos[4], cubeWorldPos[0], cubeWorldPos[4], cubeWorldPos[1], cubeWorldPos[5], cubeWorldPos[2], cubeWorldPos[6], cubeWorldPos[3], cubeWorldPos[7]], color, options);
  }
  function _preRenderImmediate() {
    for (var i = 0;i < this._immediateData.lineBatches.length;i++) {
      if (this._immediateData.lineBatches[i]) {
        this._immediateData.lineBatches[i].finalize();
      }
    }
  }
  function _postRenderImmediate() {
    for (var i = 0;i < this._immediateData.layers.length;i++) {
      this._immediateData.layers[i].clearMeshInstances(true);
    }
    this._immediateData.layers.length = 0;
  }
  function renderMeshInstance(meshInstance, options) {
    if (!options) {
      options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE)};
    }
    this._initImmediate();
    this._immediateData.addLayer(options.layer);
    meshInstanceArray[0] = meshInstance;
    options.layer.addMeshInstances(meshInstanceArray, true);
  }
  function renderMesh(mesh, material, matrix, options) {
    if (!options) {
      options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE)};
    }
    this._initImmediate();
    tempGraphNode.worldTransform = matrix;
    tempGraphNode._dirtyWorld = tempGraphNode._dirtyNormal = false;
    var instance = new pc.MeshInstance(tempGraphNode, mesh, material);
    instance.cull = false;
    if (options.mask) {
      instance.mask = options.mask;
    }
    this._immediateData.addLayer(options.layer);
    meshInstanceArray[0] = instance;
    options.layer.addMeshInstances(meshInstanceArray, true);
  }
  function renderQuad(matrix, material, options) {
    if (!options) {
      options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE)};
    }
    this._initImmediate();
    if (!this._immediateData.quadMesh) {
      var format = new pc.VertexFormat(this.graphicsDevice, [{semantic:pc.SEMANTIC_POSITION, components:3, type:pc.TYPE_FLOAT32}]);
      var quadVb = new pc.VertexBuffer(this.graphicsDevice, format, 4);
      var iterator = new pc.VertexIterator(quadVb);
      iterator.element[pc.SEMANTIC_POSITION].set(-0.5, -0.5, 0);
      iterator.next();
      iterator.element[pc.SEMANTIC_POSITION].set(0.5, -0.5, 0);
      iterator.next();
      iterator.element[pc.SEMANTIC_POSITION].set(-0.5, 0.5, 0);
      iterator.next();
      iterator.element[pc.SEMANTIC_POSITION].set(0.5, 0.5, 0);
      iterator.end();
      this._immediateData.quadMesh = new pc.Mesh;
      this._immediateData.quadMesh.vertexBuffer = quadVb;
      this._immediateData.quadMesh.primitive[0].type = pc.PRIMITIVE_TRISTRIP;
      this._immediateData.quadMesh.primitive[0].base = 0;
      this._immediateData.quadMesh.primitive[0].count = 4;
      this._immediateData.quadMesh.primitive[0].indexed = false;
    }
    tempGraphNode.worldTransform = matrix;
    tempGraphNode._dirtyWorld = tempGraphNode._dirtyNormal = false;
    var quad = new pc.MeshInstance(tempGraphNode, this._immediateData.quadMesh, material);
    quad.cull = false;
    meshInstanceArray[0] = quad;
    this._immediateData.addLayer(options.layer);
    options.layer.addMeshInstances(meshInstanceArray, true);
  }
  return {renderMeshInstance:renderMeshInstance, renderMesh:renderMesh, renderLine:renderLine, renderLines:renderLines, renderQuad:renderQuad, renderWireCube:renderWireCube, _addLines:_addLines, _initImmediate:_initImmediate, _preRenderImmediate:_preRenderImmediate, _postRenderImmediate:_postRenderImmediate};
}());
Object.assign(pc, function() {
  var maxSize = 2048;
  var maskBaked = 2;
  var maskLightmap = 4;
  var sceneLightmaps = [];
  var sceneLightmapsNode = [];
  var lmCamera;
  var tempVec = new pc.Vec3;
  var bounds = new pc.BoundingBox;
  var lightBounds = new pc.BoundingBox;
  var tempSphere = {};
  var PASS_COLOR = 0;
  var PASS_DIR = 1;
  var passTexName = ["texture_lightMap", "texture_dirLightMap"];
  var passMaterial = [];
  function collectModels(node, nodes, nodesMeshInstances, allNodes) {
    if (!node.enabled) {
      return;
    }
    var i;
    if (node.model && node.model.model && node.model.enabled) {
      if (allNodes) {
        allNodes.push(node);
      }
      if (node.model.data.lightmapped) {
        if (nodes) {
          var hasUv1 = true;
          var meshInstances = node.model.model.meshInstances;
          for (i = 0;i < meshInstances.length;i++) {
            if (!meshInstances[i].mesh.vertexBuffer.format.hasUv1) {
              hasUv1 = false;
              break;
            }
          }
          if (hasUv1) {
            var j;
            var isInstance;
            var notInstancedMeshInstances = [];
            for (i = 0;i < meshInstances.length;i++) {
              isInstance = false;
              for (j = 0;j < meshInstances.length;j++) {
                if (i !== j) {
                  if (meshInstances[i].mesh === meshInstances[j].mesh) {
                    isInstance = true;
                  }
                }
              }
              if (isInstance) {
                nodes.push(node);
                nodesMeshInstances.push([meshInstances[i]]);
              } else {
                notInstancedMeshInstances.push(meshInstances[i]);
              }
            }
            if (notInstancedMeshInstances.length > 0) {
              nodes.push(node);
              nodesMeshInstances.push(notInstancedMeshInstances);
            }
          }
        }
      }
    }
    for (i = 0;i < node._children.length;i++) {
      collectModels(node._children[i], nodes, nodesMeshInstances, allNodes);
    }
  }
  var Lightmapper = function(device, root, scene, renderer, assets) {
    this.device = device;
    this.root = root;
    this.scene = scene;
    this.renderer = renderer;
    this.assets = assets;
  };
  Object.assign(Lightmapper.prototype, {calculateLightmapSize:function(node) {
    var data, parent;
    var sizeMult = this.scene.lightmapSizeMultiplier || 16;
    var scale = tempVec;
    var area = {x:1, y:1, z:1, uv:1};
    if (node.model.asset) {
      data = this.assets.get(node.model.asset).data;
      if (data.area) {
        area.x = data.area.x;
        area.y = data.area.y;
        area.z = data.area.z;
        area.uv = data.area.uv;
      }
    } else {
      if (node.model._area) {
        data = node.model;
        if (data._area) {
          area.x = data._area.x;
          area.y = data._area.y;
          area.z = data._area.z;
          area.uv = data._area.uv;
        }
      }
    }
    var areaMult = node.model.lightmapSizeMultiplier || 1;
    area.x *= areaMult;
    area.y *= areaMult;
    area.z *= areaMult;
    scale.copy(node.localScale);
    parent = node._parent;
    while (parent) {
      scale.mul(parent.localScale);
      parent = parent._parent;
    }
    scale.x = Math.abs(scale.x);
    scale.y = Math.abs(scale.y);
    scale.z = Math.abs(scale.z);
    var totalArea = area.x * scale.y * scale.z + area.y * scale.x * scale.z + area.z * scale.x * scale.y;
    totalArea /= area.uv;
    totalArea = Math.sqrt(totalArea);
    return Math.min(pc.math.nextPowerOfTwo(totalArea * sizeMult), this.scene.lightmapMaxResolution || maxSize);
  }, bake:function(nodes, mode) {
    var i, j;
    var device = this.device;
    var scene = this.scene;
    var passCount = 1;
    if (mode === undefined) {
      mode = pc.BAKE_COLORDIR;
    }
    if (mode === pc.BAKE_COLORDIR) {
      passCount = 2;
    }
    var pass;
    var allNodes = [];
    var nodesMeshInstances = [];
    if (!nodes) {
      for (i = 0;i < sceneLightmaps.length;i++) {
        for (j = 0;j < sceneLightmaps[i].length;j++) {
          sceneLightmaps[i][j].destroy();
        }
      }
      sceneLightmaps = [];
      sceneLightmapsNode = [];
      nodes = [];
      collectModels(this.root, nodes, nodesMeshInstances, allNodes);
    } else {
      var k;
      for (i = sceneLightmapsNode.length - 1;i >= 0;i--) {
        for (j = 0;j < nodes.length;j++) {
          if (sceneLightmapsNode[i] === nodes[j]) {
            for (k = 0;k < sceneLightmaps[i].length;k++) {
              sceneLightmaps[i][k].destroy();
            }
            sceneLightmaps.splice(i, 1);
            sceneLightmapsNode.splice(i, 1);
          }
        }
      }
      var _nodes = [];
      for (i = 0;i < nodes.length;i++) {
        collectModels(nodes[i], _nodes, nodesMeshInstances);
      }
      nodes = _nodes;
      collectModels(this.root, null, null, allNodes);
    }
    if (nodes.length === 0) {
      device.fire("lightmapper:end", {timestamp:pc.now(), target:this});
      return;
    }
    var revertStatic = false;
    if (scene._needsStaticPrepare) {
      scene._needsStaticPrepare = false;
      revertStatic = true;
    }
    var texSize = [];
    var lmaps = [[], []];
    var texPool = {};
    var size;
    var tex;
    var blackTex = new pc.Texture(this.device, {width:4, height:4, format:pc.PIXELFORMAT_R8_G8_B8_A8, rgbm:true});
    for (i = 0;i < nodes.length;i++) {
      size = this.calculateLightmapSize(nodes[i]);
      texSize.push(size);
      for (pass = 0;pass < passCount;pass++) {
        tex = new pc.Texture(device, {width:size, height:size, format:pc.PIXELFORMAT_R8_G8_B8_A8, mipmaps:false, rgbm:pass === PASS_COLOR, minFilter:pc.FILTER_NEAREST, magFilter:pc.FILTER_NEAREST});
        lmaps[pass].push(tex);
      }
      if (!texPool[size]) {
        var tex2 = new pc.Texture(device, {width:size, height:size, format:pc.PIXELFORMAT_R8_G8_B8_A8, mipmaps:false, rgbm:true, minFilter:pc.FILTER_NEAREST, magFilter:pc.FILTER_NEAREST});
        var targ2 = new pc.RenderTarget(device, tex2, {depth:false});
        texPool[size] = targ2;
      }
    }
    var activeComp = scene.layers;
    activeComp._update();
    var lights = [];
    var origMask = [];
    var origShadowMode = [];
    var origEnabled = [];
    var sceneLights = activeComp._lights;
    var mask;
    for (i = 0;i < sceneLights.length;i++) {
      if (sceneLights[i]._enabled) {
        mask = sceneLights[i]._mask;
        if ((mask & maskLightmap) !== 0) {
          origMask.push(mask);
          origShadowMode.push(sceneLights[i].shadowUpdateMode);
          sceneLights[i]._mask = 4294967295;
          sceneLights[i].shadowUpdateMode = sceneLights[i]._type === pc.LIGHTTYPE_DIRECTIONAL ? pc.SHADOWUPDATE_REALTIME : pc.SHADOWUPDATE_THISFRAME;
          lights.push(sceneLights[i]);
          sceneLights[i].isStatic = false;
        }
      }
      origEnabled.push(sceneLights[i]._enabled);
      sceneLights[i].enabled = false;
    }
    var chunks = pc.shaderChunks;
    var xformUv1 = "#define UV1LAYOUT\n" + chunks.transformVS;
    var bakeLmEnd = chunks.bakeLmEndPS;
    var dilate = chunks.dilatePS;
    var dilateShader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, dilate, "lmDilate");
    var constantTexSource = device.scope.resolve("source");
    var constantPixelOffset = device.scope.resolve("pixelOffset");
    var constantBakeDir = device.scope.resolve("bakeDir");
    var pixelOffset = new pc.Vec2;
    var drawCalls = activeComp._meshInstances;
    for (i = 0;i < drawCalls.length;i++) {
      if (drawCalls[i].node) {
        drawCalls[i].node.getWorldTransform();
      }
    }
    var origFog = scene.fog;
    var origAmbientR = scene.ambientLight.data[0];
    var origAmbientG = scene.ambientLight.data[1];
    var origAmbientB = scene.ambientLight.data[2];
    scene.fog = pc.FOG_NONE;
    scene.ambientLight.data[0] = 0;
    scene.ambientLight.data[1] = 0;
    scene.ambientLight.data[2] = 0;
    if (!lmCamera) {
      lmCamera = new pc.Camera;
      lmCamera._node = new pc.GraphNode;
      lmCamera.clearColor[0] = 0;
      lmCamera.clearColor[1] = 0;
      lmCamera.clearColor[2] = 0;
      lmCamera.clearColor[3] = 0;
      lmCamera.clearDepth = 1;
      lmCamera.clearFlags = pc.CLEARFLAG_COLOR;
      lmCamera.clearStencil = null;
      lmCamera.frustumCulling = false;
    }
    var node;
    var lm, rcv, m;
    var origShaderDefs = [];
    origShaderDefs.length = sceneLightmapsNode.length;
    var shaderDefs;
    for (node = 0;node < allNodes.length;node++) {
      rcv = allNodes[node].model.model.meshInstances;
      shaderDefs = [];
      for (i = 0;i < rcv.length;i++) {
        shaderDefs.push(rcv[i]._shaderDefs);
        rcv[i]._shaderDefs &= ~(pc.SHADERDEF_LM | pc.SHADERDEF_DIRLM);
      }
      for (i = 0;i < sceneLightmapsNode.length;i++) {
        if (sceneLightmapsNode[i] === allNodes[node]) {
          origShaderDefs[i] = shaderDefs;
          break;
        }
      }
    }
    var origCastShadows = [];
    var casters = [];
    var meshes;
    for (node = 0;node < allNodes.length;node++) {
      origCastShadows[node] = allNodes[node].model.castShadows;
      allNodes[node].model.castShadows = allNodes[node].model.data.castShadowsLightmap;
      if (allNodes[node].model.data.castShadowsLightmap) {
        meshes = allNodes[node].model.meshInstances;
        for (i = 0;i < meshes.length;i++) {
          meshes[i].visibleThisFrame = true;
          casters.push(meshes[i]);
        }
      }
    }
    this.renderer.updateCpuSkinMatrices(casters);
    this.renderer.gpuUpdate(casters);
    var origMat = [];
    var nodeBounds = [];
    var nodeTarg = [[], []];
    var targ, targTmp, texTmp;
    var light, shadowCam;
    var nodeLightCount = [];
    nodeLightCount.length = nodes.length;
    var lmMaterial;
    for (pass = 0;pass < passCount;pass++) {
      if (!passMaterial[pass]) {
        lmMaterial = new pc.StandardMaterial;
        lmMaterial.chunks.transformVS = xformUv1;
        if (pass === PASS_COLOR) {
          lmMaterial.chunks.endPS = bakeLmEnd;
          lmMaterial.ambient = new pc.Color(0, 0, 0);
          lmMaterial.ambientTint = true;
          lmMaterial.lightMap = blackTex;
        } else {
          lmMaterial.chunks.basePS = chunks.basePS + "\nuniform sampler2D texture_dirLightMap;\nuniform float bakeDir;\n";
          lmMaterial.chunks.endPS = chunks.bakeDirLmEndPS;
        }
        lmMaterial.chunks.outputAlphaPS = "\n";
        lmMaterial.chunks.outputAlphaOpaquePS = "\n";
        lmMaterial.chunks.outputAlphaPremulPS = "\n";
        lmMaterial.cull = pc.CULLFACE_NONE;
        lmMaterial.forceUv1 = true;
        lmMaterial.update();
        lmMaterial.updateShader(device, scene);
        lmMaterial.name = "lmMaterial" + pass;
        passMaterial[pass] = lmMaterial;
      }
    }
    for (node = 0;node < nodes.length;node++) {
      rcv = nodesMeshInstances[node];
      nodeLightCount[node] = 0;
      if (rcv.length > 0) {
        bounds.copy(rcv[0].aabb);
        for (i = 0;i < rcv.length;i++) {
          rcv[i].node.getWorldTransform();
          bounds.add(rcv[i].aabb);
        }
      }
      var nbounds = new pc.BoundingBox;
      nbounds.copy(bounds);
      nodeBounds.push(nbounds);
      for (i = 0;i < rcv.length;i++) {
        m = rcv[i];
        m._shaderDefs &= ~(pc.SHADERDEF_LM | pc.SHADERDEF_DIRLM);
        m.mask = maskLightmap;
        m.deleteParameter("texture_lightMap");
        m.deleteParameter("texture_dirLightMap");
        m.setParameter("texture_lightMap", m.material.lightMap ? m.material.lightMap : blackTex);
        m.setParameter("texture_dirLightMap", blackTex);
      }
      for (pass = 0;pass < passCount;pass++) {
        lm = lmaps[pass][node];
        targ = new pc.RenderTarget(device, lm, {depth:false});
        nodeTarg[pass].push(targ);
      }
    }
    for (j = 0;j < lights.length;j++) {
      lights[j].enabled = false;
    }
    var lightArray = [[], [], []];
    var shadersUpdatedOn1stPass = false;
    var shadowMapRendered;
    for (i = 0;i < lights.length;i++) {
      lights[i].enabled = true;
      shadowMapRendered = false;
      lights[i]._cacheShadowMap = true;
      if (lights[i]._type !== pc.LIGHTTYPE_DIRECTIONAL) {
        lights[i]._node.getWorldTransform();
        lights[i].getBoundingSphere(tempSphere);
        lightBounds.center = tempSphere.center;
        lightBounds.halfExtents.x = tempSphere.radius;
        lightBounds.halfExtents.y = tempSphere.radius;
        lightBounds.halfExtents.z = tempSphere.radius;
      }
      if (lights[i]._type === pc.LIGHTTYPE_SPOT) {
        light = lights[i];
        shadowCam = this.renderer.getShadowCamera(device, light);
        shadowCam._node.setPosition(light._node.getPosition());
        shadowCam._node.setRotation(light._node.getRotation());
        shadowCam._node.rotateLocal(-90, 0, 0);
        shadowCam.projection = pc.PROJECTION_PERSPECTIVE;
        shadowCam.nearClip = light.attenuationEnd / 1000;
        shadowCam.farClip = light.attenuationEnd;
        shadowCam.aspectRatio = 1;
        shadowCam.fov = light._outerConeAngle * 2;
        this.renderer.updateCameraFrustum(shadowCam);
      }
      if (nodesMeshInstances.length > 0) {
        this.renderer.updateShaders(nodesMeshInstances[0]);
      }
      for (node = 0;node < nodes.length;node++) {
        rcv = nodesMeshInstances[node];
        bounds = nodeBounds[node];
        if (lights[i]._type === pc.LIGHTTYPE_DIRECTIONAL) {
          tempVec.copy(bounds.center);
          tempVec.y += bounds.halfExtents.y;
          lmCamera._node.setPosition(tempVec);
          lmCamera._node.setEulerAngles(-90, 0, 0);
          var frustumSize = Math.max(bounds.halfExtents.x, bounds.halfExtents.z);
          lmCamera.projection = pc.PROJECTION_ORTHOGRAPHIC;
          lmCamera.nearClip = 0;
          lmCamera.farClip = bounds.halfExtents.y * 2;
          lmCamera.aspectRatio = 1;
          lmCamera.orthoHeight = frustumSize;
        } else {
          if (!lightBounds.intersects(bounds)) {
            continue;
          }
        }
        if (lights[i]._type === pc.LIGHTTYPE_SPOT) {
          var nodeVisible = false;
          for (j = 0;j < rcv.length;j++) {
            if (this.renderer._isVisible(shadowCam, rcv[j])) {
              nodeVisible = true;
              break;
            }
          }
          if (!nodeVisible) {
            continue;
          }
        }
        if (lights[i]._type === pc.LIGHTTYPE_DIRECTIONAL) {
          lightArray[pc.LIGHTTYPE_DIRECTIONAL][0] = lights[i];
          lightArray[pc.LIGHTTYPE_POINT].length = 0;
          lightArray[pc.LIGHTTYPE_SPOT].length = 0;
          if (!shadowMapRendered && lights[i].castShadows) {
            this.renderer.cullDirectionalShadowmap(lights[i], casters, lmCamera, 0);
            this.renderer.renderShadows(lightArray[pc.LIGHTTYPE_DIRECTIONAL], 0);
            shadowMapRendered = true;
          }
        } else {
          lightArray[pc.LIGHTTYPE_DIRECTIONAL].length = 0;
          if (lights[i]._type === pc.LIGHTTYPE_POINT) {
            lightArray[pc.LIGHTTYPE_POINT][0] = lights[i];
            lightArray[pc.LIGHTTYPE_SPOT].length = 0;
            if (!shadowMapRendered && lights[i].castShadows) {
              this.renderer.cullLocalShadowmap(lights[i], casters);
              this.renderer.renderShadows(lightArray[pc.LIGHTTYPE_POINT]);
              shadowMapRendered = true;
            }
          } else {
            lightArray[pc.LIGHTTYPE_POINT].length = 0;
            lightArray[pc.LIGHTTYPE_SPOT][0] = lights[i];
            if (!shadowMapRendered && lights[i].castShadows) {
              this.renderer.cullLocalShadowmap(lights[i], casters);
              this.renderer.renderShadows(lightArray[pc.LIGHTTYPE_SPOT]);
              shadowMapRendered = true;
            }
          }
        }
        for (j = 0;j < rcv.length;j++) {
          origMat[j] = rcv[j].material;
        }
        for (pass = 0;pass < passCount;pass++) {
          lm = lmaps[pass][node];
          targ = nodeTarg[pass][node];
          targTmp = texPool[lm.width];
          texTmp = targTmp.colorBuffer;
          if (pass === 0) {
            shadersUpdatedOn1stPass = scene.updateShaders;
          } else {
            if (shadersUpdatedOn1stPass) {
              scene.updateShaders = true;
            }
          }
          for (j = 0;j < rcv.length;j++) {
            rcv[j].material = passMaterial[pass];
          }
          if (passCount > 1) {
            this.renderer.updateShaders(rcv);
          }
          this.renderer.setCamera(lmCamera, targTmp, true);
          if (pass === PASS_DIR) {
            constantBakeDir.setValue(lights[i].bakeDir ? 1 : 0);
          }
          this.renderer._forwardTime = 0;
          this.renderer._shadowMapTime = 0;
          this.renderer.renderForward(lmCamera, rcv, rcv.length, lightArray, pc.SHADER_FORWARDHDR);
          lmaps[pass][node] = texTmp;
          nodeTarg[pass][node] = targTmp;
          texPool[lm.width] = targ;
          for (j = 0;j < rcv.length;j++) {
            m = rcv[j];
            m.setParameter(passTexName[pass], texTmp);
            m._shaderDefs |= pc.SHADERDEF_LM;
          }
        }
        nodeLightCount[node]++;
        for (j = 0;j < rcv.length;j++) {
          rcv[j].material = origMat[j];
        }
      }
      lights[i].enabled = false;
      lights[i]._cacheShadowMap = false;
      if (lights[i]._isCachedShadowMap) {
        lights[i]._destroyShadowMap();
      }
    }
    var sceneLmaps;
    for (node = 0;node < nodes.length;node++) {
      rcv = nodesMeshInstances[node];
      sceneLmaps = [];
      for (pass = 0;pass < passCount;pass++) {
        lm = lmaps[pass][node];
        targ = nodeTarg[pass][node];
        targTmp = texPool[lm.width];
        texTmp = targTmp.colorBuffer;
        var numDilates2x = 4;
        pixelOffset.set(1 / lm.width, 1 / lm.height);
        constantPixelOffset.setValue(pixelOffset.data);
        for (i = 0;i < numDilates2x;i++) {
          constantTexSource.setValue(lm);
          pc.drawQuadWithShader(device, targTmp, dilateShader);
          constantTexSource.setValue(texTmp);
          pc.drawQuadWithShader(device, targ, dilateShader);
        }
        for (i = 0;i < rcv.length;i++) {
          m = rcv[i];
          m.mask = maskBaked;
          rcv[i].setParameter(passTexName[pass], lm);
          if (pass === PASS_DIR) {
            rcv[i]._shaderDefs |= pc.SHADERDEF_DIRLM;
          }
        }
        sceneLmaps[pass] = lm;
        if (pass === passCount - 1) {
          targ.destroy();
        }
      }
      sceneLightmaps.push(sceneLmaps);
      sceneLightmapsNode.push(nodes[node]);
    }
    for (var key in texPool) {
      if (texPool.hasOwnProperty(key)) {
        texPool[key].colorBuffer.destroy();
        texPool[key].destroy();
      }
    }
    for (i = 0;i < sceneLightmaps.length;i++) {
      for (j = 0;j < sceneLightmaps[i].length;j++) {
        tex = sceneLightmaps[i][j];
        tex.minFilter = pc.FILTER_LINEAR;
        tex.magFilter = pc.FILTER_LINEAR;
      }
    }
    for (node = 0;node < allNodes.length;node++) {
      allNodes[node].model.castShadows = origCastShadows[node];
    }
    for (i = 0;i < origShaderDefs.length;i++) {
      if (origShaderDefs[i]) {
        rcv = sceneLightmapsNode[i].model.model.meshInstances;
        for (j = 0;j < rcv.length;j++) {
          rcv[j]._shaderDefs |= origShaderDefs[i][j] & (pc.SHADERDEF_LM | pc.SHADERDEF_DIRLM);
        }
      }
    }
    for (i = 0;i < lights.length;i++) {
      lights[i]._mask = origMask[i];
      lights[i].shadowUpdateMode = origShadowMode[i];
    }
    for (i = 0;i < sceneLights.length;i++) {
      sceneLights[i].enabled = origEnabled[i];
    }
    scene.fog = origFog;
    scene.ambientLight.data[0] = origAmbientR;
    scene.ambientLight.data[1] = origAmbientG;
    scene.ambientLight.data[2] = origAmbientB;
    if (revertStatic) {
      scene._needsStaticPrepare = true;
    }
  }});
  return {Lightmapper:Lightmapper};
}());
Object.assign(pc, function() {
  var Batch = function(meshInstances, dynamic, batchGroupId) {
    this.origMeshInstances = meshInstances;
    this._aabb = new pc.BoundingBox;
    this.meshInstance = null;
    this.model = null;
    this.dynamic = dynamic;
    this.batchGroupId = batchGroupId;
    this.refCounter = 0;
  };
  var BatchGroup = function(id, name, dynamic, maxAabbSize, layers) {
    this.dynamic = dynamic;
    this.maxAabbSize = maxAabbSize;
    this.id = id;
    this.name = name;
    this.layers = layers === undefined ? [pc.LAYERID_WORLD] : layers;
  };
  var SkinBatchInstance = function(device, nodes, rootNode) {
    this.device = device;
    this.rootNode = rootNode;
    this._dirty = true;
    this.bones = nodes;
    var numBones = nodes.length;
    if (device.supportsBoneTextures) {
      var size;
      if (numBones > 256) {
        size = 64;
      } else {
        if (numBones > 64) {
          size = 32;
        } else {
          if (numBones > 16) {
            size = 16;
          } else {
            size = 8;
          }
        }
      }
      this.boneTexture = new pc.Texture(device, {width:size, height:size, format:pc.PIXELFORMAT_RGBA32F, mipmaps:false, minFilter:pc.FILTER_NEAREST, magFilter:pc.FILTER_NEAREST});
      this.matrixPalette = this.boneTexture.lock();
    } else {
      this.matrixPalette = new Float32Array(numBones * 16);
    }
  };
  Object.assign(SkinBatchInstance.prototype, {updateMatrices:function() {
  }, updateMatrixPalette:function() {
    var pe;
    var mp = this.matrixPalette;
    var base;
    for (var i = this.bones.length - 1;i >= 0;i--) {
      pe = this.bones[i].getWorldTransform().data;
      base = i * 16;
      mp[base] = pe[0];
      mp[base + 1] = pe[1];
      mp[base + 2] = pe[2];
      mp[base + 3] = pe[3];
      mp[base + 4] = pe[4];
      mp[base + 5] = pe[5];
      mp[base + 6] = pe[6];
      mp[base + 7] = pe[7];
      mp[base + 8] = pe[8];
      mp[base + 9] = pe[9];
      mp[base + 10] = pe[10];
      mp[base + 11] = pe[11];
      mp[base + 12] = pe[12];
      mp[base + 13] = pe[13];
      mp[base + 14] = pe[14];
      mp[base + 15] = pe[15];
    }
    if (this.device.supportsBoneTextures) {
      this.boneTexture.lock();
      this.boneTexture.unlock();
    }
  }});
  var BatchManager = function(device, root, scene) {
    this.device = device;
    this.rootNode = root;
    this.scene = scene;
    this._init = false;
    this._batchGroups = {};
    this._batchGroupCounter = 0;
    this._batchList = [];
    this._dirtyGroups = [];
  };
  BatchManager.prototype.addGroup = function(name, dynamic, maxAabbSize, id, layers) {
    if (id === undefined) {
      id = this._batchGroupCounter;
      this._batchGroupCounter++;
    }
    if (this._batchGroups[id]) {
      return;
    }
    var group;
    this._batchGroups[id] = group = new pc.BatchGroup(id, name, dynamic, maxAabbSize, layers);
    return group;
  };
  BatchManager.prototype.removeGroup = function(id) {
    if (!this._batchGroups[id]) {
      return;
    }
    var newBatchList = [];
    for (var i = 0;i < this._batchList.length;i++) {
      if (this._batchList[i].batchGroupId !== id) {
        newBatchList.push(this._batchList[i]);
        continue;
      }
      this.destroy(this._batchList[i]);
    }
    this._batchList = newBatchList;
    this._removeModelsFromBatchGroup(this.rootNode, id);
    delete this._batchGroups[id];
  };
  BatchManager.prototype._removeModelsFromBatchGroup = function(node, id) {
    if (!node.enabled) {
      return;
    }
    if (node.model && node.model.batchGroupId === id) {
      node.model.batchGroupId = -1;
    }
    if (node.element && node.element.batchGroupId === id) {
      node.element.batchGroupId = -1;
    }
    if (node.sprite && node.sprite.batchGroupId === id) {
      node.sprite.batchGroupId = -1;
    }
    for (var i = 0;i < node._children.length;i++) {
      this._removeModelsFromBatchGroup(node._children[i], id);
    }
  };
  BatchManager.prototype._collectAndRemoveModels = function(node, groupMeshInstances, groupIds) {
    if (!node.enabled) {
      return;
    }
    var i, arr;
    if (node.model && node.model.batchGroupId >= 0 && node.model.model && node.model.enabled) {
      if (!groupIds || groupIds && groupIds.indexOf(node.model.batchGroupId) >= 0) {
        arr = groupMeshInstances[node.model.batchGroupId];
        if (!arr) {
          arr = groupMeshInstances[node.model.batchGroupId] = [];
        }
        if (node.model.isStatic) {
          var drawCalls = this.scene.drawCalls;
          var nodeMeshInstances = node.model.meshInstances;
          for (i = 0;i < drawCalls.length;i++) {
            if (!drawCalls[i]._staticSource) {
              continue;
            }
            if (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) {
              continue;
            }
            groupMeshInstances[node.model.batchGroupId].push(drawCalls[i]);
          }
          for (i = 0;i < nodeMeshInstances.length;i++) {
            if (drawCalls.indexOf(nodeMeshInstances[i]) >= 0) {
              groupMeshInstances[node.model.batchGroupId].push(nodeMeshInstances[i]);
            }
          }
        } else {
          groupMeshInstances[node.model.batchGroupId] = arr.concat(node.model.meshInstances);
        }
        node.model.removeModelFromLayers(node.model.model);
      }
    }
    if (node.element && node.element.batchGroupId >= 0 && node.element.enabled) {
      if (!groupIds || groupIds && groupIds.indexOf(node.element.batchGroupId) >= 0) {
        arr = groupMeshInstances[node.element.batchGroupId];
        if (!arr) {
          arr = groupMeshInstances[node.element.batchGroupId] = [];
        }
        var valid = false;
        if (node.element._text) {
          groupMeshInstances[node.element.batchGroupId].push(node.element._text._model.meshInstances[0]);
          node.element.removeModelFromLayers(node.element._text._model);
          valid = true;
        } else {
          if (node.element._image) {
            groupMeshInstances[node.element.batchGroupId].push(node.element._image._model.meshInstances[0]);
            node.element.removeModelFromLayers(node.element._image._model);
            valid = true;
          }
        }
      }
    }
    if (node.sprite && node.sprite.batchGroupId >= 0 && node.sprite.enabled) {
      if (!groupIds || groupIds && groupIds.indexOf(node.sprite.batchGroupId) >= 0) {
        arr = groupMeshInstances[node.sprite.batchGroupId];
        if (!arr) {
          arr = groupMeshInstances[node.sprite.batchGroupId] = [];
        }
        if (node.sprite._meshInstance) {
          groupMeshInstances[node.sprite.batchGroupId].push(node.sprite._meshInstance);
          this.scene.removeModel(node.sprite._model);
          node.sprite._batchGroup = this._batchGroups[node.sprite.batchGroupId];
        }
      }
    }
    for (i = 0;i < node._children.length;i++) {
      this._collectAndRemoveModels(node._children[i], groupMeshInstances, groupIds);
    }
  };
  BatchManager.prototype.markGroupDirty = function(id) {
    if (this._dirtyGroups.indexOf(id) < 0) {
      this._dirtyGroups.push(id);
    }
  };
  BatchManager.prototype._registerEntities = function(batch, meshInstances) {
    var node;
    var ents = [];
    for (var i = 0;i < meshInstances.length;i++) {
      node = meshInstances[i].node;
      while (!node._app && node._parent) {
        node = node._parent;
      }
      if (!node._app) {
        continue;
      }
      ents.push(node);
    }
    this.register(batch, ents);
  };
  BatchManager.prototype.generate = function(groupIds) {
    var i, j;
    var groupMeshInstances = {};
    if (!groupIds) {
      for (i = 0;i < this._batchList.length;i++) {
        this.destroy(this._batchList[i]);
      }
      this._batchList.length = 0;
      this._collectAndRemoveModels(this.rootNode, groupMeshInstances);
      this._dirtyGroups.length = 0;
    } else {
      var newBatchList = [];
      for (i = 0;i < this._batchList.length;i++) {
        if (groupIds.indexOf(this._batchList[i].batchGroupId) < 0) {
          newBatchList.push(this._batchList[i]);
          continue;
        }
        this.destroy(this._batchList[i]);
      }
      this._batchList = newBatchList;
      this._collectAndRemoveModels(this.rootNode, groupMeshInstances, groupIds);
      if (groupIds === this._dirtyGroups) {
        this._dirtyGroups.length = 0;
      } else {
        var newDirtyGroups = [];
        for (i = 0;i < this._dirtyGroups.length;i++) {
          if (groupIds.indexOf(this._dirtyGroups[i]) < 0) {
            newDirtyGroups.push(this._dirtyGroups[i]);
          }
        }
        this._dirtyGroups = newDirtyGroups;
      }
    }
    var group, lists, groupData, batch;
    for (var groupId in groupMeshInstances) {
      if (!groupMeshInstances.hasOwnProperty(groupId)) {
        continue;
      }
      group = groupMeshInstances[groupId];
      groupData = this._batchGroups[groupId];
      if (!groupData) {
        continue;
      }
      lists = this.prepare(group, groupData.dynamic, groupData.maxAabbSize);
      for (i = 0;i < lists.length;i++) {
        batch = this.create(lists[i], groupData.dynamic, parseInt(groupId, 10));
        for (j = 0;j < groupData.layers.length;j++) {
          this.scene.layers.getLayerById(groupData.layers[j]).addMeshInstances(batch.model.meshInstances);
        }
        this._registerEntities(batch, lists[i]);
      }
    }
  };
  BatchManager.prototype.getGroupByName = function(name) {
    var groups = this._batchGroups;
    for (var group in groups) {
      if (!groups.hasOwnProperty(group)) {
        continue;
      }
      if (groups[group].name === name) {
        return groups[group];
      }
    }
    return null;
  };
  function paramsIdentical(a, b) {
    if (a && !b) {
      return false;
    }
    if (!a && b) {
      return false;
    }
    a = a.data;
    b = b.data;
    if (a === b) {
      return true;
    }
    if (a instanceof Float32Array && b instanceof Float32Array) {
      if (a.length !== b.length) {
        return false;
      }
      for (var i = 0;i < a.length;i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  BatchManager.prototype.prepare = function(meshInstances, dynamic, maxAabbSize) {
    if (meshInstances.length === 0) {
      return [];
    }
    if (maxAabbSize === undefined) {
      maxAabbSize = Number.POSITIVE_INFINITY;
    }
    var halfMaxAabbSize = maxAabbSize * 0.5;
    var maxInstanceCount = this.device.supportsBoneTextures ? 1024 : this.device.boneLimit;
    var i;
    var material, layer, vertCount, params, params2, param, paramFailed, lightList, defs;
    var aabb = new pc.BoundingBox;
    var testAabb = new pc.BoundingBox;
    var lists = [];
    var j = 0;
    var meshInstancesLeftA = meshInstances;
    var meshInstancesLeftB;
    var k;
    while (meshInstancesLeftA.length > 0) {
      lists[j] = [];
      meshInstancesLeftB = [];
      material = meshInstancesLeftA[0].material;
      layer = meshInstancesLeftA[0].layer;
      defs = meshInstancesLeftA[0]._shaderDefs;
      params = meshInstancesLeftA[0].parameters;
      lightList = meshInstancesLeftA[0]._staticLightList;
      vertCount = meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();
      aabb.copy(meshInstancesLeftA[0].aabb);
      for (i = 0;i < meshInstancesLeftA.length;i++) {
        if (i > 0) {
          if (material !== meshInstancesLeftA[i].material) {
            meshInstancesLeftB.push(meshInstancesLeftA[i]);
            continue;
          }
          if (layer !== meshInstancesLeftA[i].layer) {
            meshInstancesLeftB.push(meshInstancesLeftA[i]);
            continue;
          }
          if (defs !== meshInstancesLeftA[i]._shaderDefs) {
            meshInstancesLeftB.push(meshInstancesLeftA[i]);
            continue;
          }
          if (vertCount + meshInstancesLeftA[i].mesh.vertexBuffer.getNumVertices() > 65535) {
            meshInstancesLeftB.push(meshInstancesLeftA[i]);
            continue;
          }
          testAabb.copy(aabb);
          testAabb.add(meshInstancesLeftA[i].aabb);
          if (testAabb.halfExtents.x > halfMaxAabbSize || testAabb.halfExtents.y > halfMaxAabbSize || testAabb.halfExtents.z > halfMaxAabbSize) {
            meshInstancesLeftB.push(meshInstancesLeftA[i]);
            continue;
          }
          params2 = meshInstancesLeftA[i].parameters;
          paramFailed = false;
          for (param in params) {
            if (!params.hasOwnProperty(param)) {
              continue;
            }
            if (!paramsIdentical(params[param], params2[param])) {
              paramFailed = true;
              break;
            }
          }
          if (!paramFailed) {
            for (param in params2) {
              if (!params2.hasOwnProperty(param)) {
                continue;
              }
              if (!paramsIdentical(params2[param], params[param])) {
                paramFailed = true;
                break;
              }
            }
          }
          if (paramFailed) {
            meshInstancesLeftB.push(meshInstancesLeftA[i]);
            continue;
          }
          params2 = meshInstancesLeftA[i]._staticLightList;
          if (lightList && !params2 || !lightList && params2) {
            meshInstancesLeftB.push(meshInstancesLeftA[i]);
            continue;
          }
          if (lightList && params2) {
            paramFailed = false;
            for (k = 0;k < lightList.length;k++) {
              if (params2.indexOf(lightList[k]) < 0) {
                paramFailed = true;
                break;
              }
            }
            for (k = 0;k < params2.length;k++) {
              if (lightList.indexOf(params2[k]) < 0) {
                paramFailed = true;
                break;
              }
            }
            if (paramFailed) {
              meshInstancesLeftB.push(meshInstancesLeftA[i]);
              continue;
            }
          }
        }
        aabb.add(meshInstancesLeftA[i].aabb);
        vertCount += meshInstancesLeftA[i].mesh.vertexBuffer.getNumVertices();
        lists[j].push(meshInstancesLeftA[i]);
        if (dynamic && lists[j].length === maxInstanceCount) {
          if (i === meshInstancesLeftA.length) {
            meshInstancesLeftB = [];
          } else {
            meshInstancesLeftB = meshInstancesLeftA.slice(i + 1);
          }
          break;
        }
      }
      j++;
      meshInstancesLeftA = meshInstancesLeftB;
    }
    return lists;
  };
  BatchManager.prototype.create = function(meshInstances, dynamic, batchGroupId) {
    if (!this._init) {
      var boneLimit = "#define BONE_LIMIT " + this.device.getBoneLimit() + "\n";
      this.transformVS = boneLimit + "#define DYNAMICBATCH\n" + pc.shaderChunks.transformVS;
      this.skinTexVS = pc.shaderChunks.skinBatchTexVS;
      this.skinConstVS = pc.shaderChunks.skinBatchConstVS;
      this.vertexFormats = {};
      this._init = true;
    }
    var i, j;
    var batch = new pc.Batch(meshInstances, dynamic, batchGroupId);
    this._batchList.push(batch);
    var material = null;
    var mesh, elems, numVerts, vertSize;
    var hasPos, hasNormal, hasUv, hasUv2, hasTangent, hasColor;
    var batchNumVerts = 0;
    var batchNumIndices = 0;
    for (i = 0;i < meshInstances.length;i++) {
      if (!material) {
        material = meshInstances[i].material;
      } else {
        if (material !== meshInstances[i].material) {
          return;
        }
      }
      mesh = meshInstances[i].mesh;
      elems = mesh.vertexBuffer.format.elements;
      numVerts = mesh.vertexBuffer.numVertices;
      batchNumVerts += numVerts;
      for (j = 0;j < elems.length;j++) {
        if (elems[j].name === pc.SEMANTIC_POSITION) {
          hasPos = true;
        } else {
          if (elems[j].name === pc.SEMANTIC_NORMAL) {
            hasNormal = true;
          } else {
            if (elems[j].name === pc.SEMANTIC_TEXCOORD0) {
              hasUv = true;
            } else {
              if (elems[j].name === pc.SEMANTIC_TEXCOORD1) {
                hasUv2 = true;
              } else {
                if (elems[j].name === pc.SEMANTIC_TANGENT) {
                  hasTangent = true;
                } else {
                  if (elems[j].name === pc.SEMANTIC_COLOR) {
                    hasColor = true;
                  }
                }
              }
            }
          }
        }
      }
      batchNumIndices += mesh.primitive[0].count;
    }
    if (!hasPos) {
      return;
    }
    var entityIndexSizeF = dynamic ? 1 : 0;
    var batchVertSizeF = 3 + (hasNormal ? 3 : 0) + (hasUv ? 2 : 0) + (hasUv2 ? 2 : 0) + (hasTangent ? 4 : 0) + (hasColor ? 1 : 0) + entityIndexSizeF;
    var batchOffsetNF = 3;
    var batchOffsetUF = hasNormal ? 3 * 2 : 3;
    var batchOffsetU2F = (hasNormal ? 3 * 2 : 3) + (hasUv ? 2 : 0);
    var batchOffsetTF = (hasNormal ? 3 * 2 : 3) + (hasUv ? 2 : 0) + (hasUv2 ? 2 : 0);
    var batchOffsetCF = (hasNormal ? 3 * 2 : 3) + (hasUv ? 2 : 0) + (hasUv2 ? 2 : 0) + (hasTangent ? 4 : 0);
    var batchOffsetEF = (hasNormal ? 3 * 2 : 3) + (hasUv ? 2 : 0) + (hasUv2 ? 2 : 0) + (hasTangent ? 4 : 0) + (hasColor ? 1 : 0);
    var arrayBuffer = new ArrayBuffer(batchNumVerts * batchVertSizeF * 4);
    var batchData = new Float32Array(arrayBuffer);
    var batchData8 = new Uint8Array(arrayBuffer);
    var indexBuffer = new pc.IndexBuffer(this.device, pc.INDEXFORMAT_UINT16, batchNumIndices, pc.BUFFER_STATIC);
    var batchIndexData = new Uint16Array(indexBuffer.lock());
    var vertSizeF;
    var data, data8, indexBase, numIndices, indexData;
    var verticesOffset = 0;
    var indexOffset = 0;
    var vbOffset = 0;
    var offsetPF, offsetNF, offsetUF, offsetU2F, offsetTF, offsetCF;
    var transform, vec, vecData;
    if (!dynamic) {
      vec = new pc.Vec3;
      vecData = vec.data;
    }
    for (i = 0;i < meshInstances.length;i++) {
      mesh = meshInstances[i].mesh;
      elems = mesh.vertexBuffer.format.elements;
      numVerts = mesh.vertexBuffer.numVertices;
      vertSize = mesh.vertexBuffer.format.size;
      vertSizeF = vertSize / 4;
      for (j = 0;j < elems.length;j++) {
        if (elems[j].name === pc.SEMANTIC_POSITION) {
          offsetPF = elems[j].offset / 4;
        } else {
          if (elems[j].name === pc.SEMANTIC_NORMAL) {
            offsetNF = elems[j].offset / 4;
          } else {
            if (elems[j].name === pc.SEMANTIC_TEXCOORD0) {
              offsetUF = elems[j].offset / 4;
            } else {
              if (elems[j].name === pc.SEMANTIC_TEXCOORD1) {
                offsetU2F = elems[j].offset / 4;
              } else {
                if (elems[j].name === pc.SEMANTIC_TANGENT) {
                  offsetTF = elems[j].offset / 4;
                } else {
                  if (elems[j].name === pc.SEMANTIC_COLOR) {
                    offsetCF = elems[j].offset / 4;
                  }
                }
              }
            }
          }
        }
      }
      data = new Float32Array(mesh.vertexBuffer.storage);
      data8 = new Uint8Array(mesh.vertexBuffer.storage);
      if (dynamic) {
        for (j = 0;j < numVerts;j++) {
          batchData[j * batchVertSizeF + vbOffset] = data[j * vertSizeF + offsetPF];
          batchData[j * batchVertSizeF + vbOffset + 1] = data[j * vertSizeF + offsetPF + 1];
          batchData[j * batchVertSizeF + vbOffset + 2] = data[j * vertSizeF + offsetPF + 2];
          if (hasNormal) {
            batchData[j * batchVertSizeF + vbOffset + batchOffsetNF] = data[j * vertSizeF + offsetNF];
            batchData[j * batchVertSizeF + vbOffset + batchOffsetNF + 1] = data[j * vertSizeF + offsetNF + 1];
            batchData[j * batchVertSizeF + vbOffset + batchOffsetNF + 2] = data[j * vertSizeF + offsetNF + 2];
          }
          if (hasUv) {
            batchData[j * batchVertSizeF + vbOffset + batchOffsetUF] = data[j * vertSizeF + offsetUF];
            batchData[j * batchVertSizeF + vbOffset + batchOffsetUF + 1] = data[j * vertSizeF + offsetUF + 1];
          }
          if (hasUv2) {
            batchData[j * batchVertSizeF + vbOffset + batchOffsetU2F] = data[j * vertSizeF + offsetU2F];
            batchData[j * batchVertSizeF + vbOffset + batchOffsetU2F + 1] = data[j * vertSizeF + offsetU2F + 1];
          }
          if (hasTangent) {
            batchData[j * batchVertSizeF + vbOffset + batchOffsetTF] = data[j * vertSizeF + offsetTF];
            batchData[j * batchVertSizeF + vbOffset + batchOffsetTF + 1] = data[j * vertSizeF + offsetTF + 1];
            batchData[j * batchVertSizeF + vbOffset + batchOffsetTF + 2] = data[j * vertSizeF + offsetTF + 2];
            batchData[j * batchVertSizeF + vbOffset + batchOffsetTF + 3] = data[j * vertSizeF + offsetTF + 3];
          }
          if (hasColor) {
            batchData8[j * batchVertSizeF * 4 + vbOffset * 4 + batchOffsetCF * 4] = data8[j * vertSizeF * 4 + offsetCF * 4];
            batchData8[j * batchVertSizeF * 4 + vbOffset * 4 + batchOffsetCF * 4 + 1] = data8[j * vertSizeF * 4 + offsetCF * 4 + 1];
            batchData8[j * batchVertSizeF * 4 + vbOffset * 4 + batchOffsetCF * 4 + 2] = data8[j * vertSizeF * 4 + offsetCF * 4 + 2];
            batchData8[j * batchVertSizeF * 4 + vbOffset * 4 + batchOffsetCF * 4 + 3] = data8[j * vertSizeF * 4 + offsetCF * 4 + 3];
          }
          batchData[j * batchVertSizeF + batchOffsetEF + vbOffset] = i;
        }
      } else {
        transform = meshInstances[i].node.getWorldTransform();
        for (j = 0;j < numVerts;j++) {
          vec.set(data[j * vertSizeF + offsetPF], data[j * vertSizeF + offsetPF + 1], data[j * vertSizeF + offsetPF + 2]);
          transform.transformPoint(vec, vec);
          batchData[j * batchVertSizeF + vbOffset] = vecData[0];
          batchData[j * batchVertSizeF + vbOffset + 1] = vecData[1];
          batchData[j * batchVertSizeF + vbOffset + 2] = vecData[2];
          if (hasNormal) {
            vec.set(data[j * vertSizeF + offsetNF], data[j * vertSizeF + offsetNF + 1], data[j * vertSizeF + offsetNF + 2]);
            transform.transformVector(vec, vec);
            batchData[j * batchVertSizeF + vbOffset + batchOffsetNF] = vecData[0];
            batchData[j * batchVertSizeF + vbOffset + batchOffsetNF + 1] = vecData[1];
            batchData[j * batchVertSizeF + vbOffset + batchOffsetNF + 2] = vecData[2];
          }
          if (hasUv) {
            batchData[j * batchVertSizeF + vbOffset + batchOffsetUF] = data[j * vertSizeF + offsetUF];
            batchData[j * batchVertSizeF + vbOffset + batchOffsetUF + 1] = data[j * vertSizeF + offsetUF + 1];
          }
          if (hasUv2) {
            batchData[j * batchVertSizeF + vbOffset + batchOffsetU2F] = data[j * vertSizeF + offsetU2F];
            batchData[j * batchVertSizeF + vbOffset + batchOffsetU2F + 1] = data[j * vertSizeF + offsetU2F + 1];
          }
          if (hasTangent) {
            vec.set(data[j * vertSizeF + offsetTF], data[j * vertSizeF + offsetTF + 1], data[j * vertSizeF + offsetTF + 2]);
            transform.transformVector(vec, vec);
            batchData[j * batchVertSizeF + vbOffset + batchOffsetTF] = vecData[0];
            batchData[j * batchVertSizeF + vbOffset + batchOffsetTF + 1] = vecData[1];
            batchData[j * batchVertSizeF + vbOffset + batchOffsetTF + 2] = vecData[2];
            batchData[j * batchVertSizeF + vbOffset + batchOffsetTF + 3] = data[j * vertSizeF + offsetTF + 3];
          }
          if (hasColor) {
            batchData8[j * batchVertSizeF * 4 + vbOffset * 4 + batchOffsetCF * 4] = data8[j * vertSizeF * 4 + offsetCF * 4];
            batchData8[j * batchVertSizeF * 4 + vbOffset * 4 + batchOffsetCF * 4 + 1] = data8[j * vertSizeF * 4 + offsetCF * 4 + 1];
            batchData8[j * batchVertSizeF * 4 + vbOffset * 4 + batchOffsetCF * 4 + 2] = data8[j * vertSizeF * 4 + offsetCF * 4 + 2];
            batchData8[j * batchVertSizeF * 4 + vbOffset * 4 + batchOffsetCF * 4 + 3] = data8[j * vertSizeF * 4 + offsetCF * 4 + 3];
          }
        }
      }
      indexBase = mesh.primitive[0].base;
      numIndices = mesh.primitive[0].count;
      indexData = new Uint16Array(mesh.indexBuffer[0].storage);
      for (j = 0;j < numIndices;j++) {
        batchIndexData[j + indexOffset] = indexData[indexBase + j] + verticesOffset;
      }
      indexOffset += numIndices;
      verticesOffset += numVerts;
      vbOffset = verticesOffset * batchVertSizeF;
    }
    var vertexFormatId = 0;
    if (hasNormal) {
      vertexFormatId |= 1 << 1;
    }
    if (hasUv) {
      vertexFormatId |= 1 << 2;
    }
    if (hasUv2) {
      vertexFormatId |= 1 << 3;
    }
    if (hasTangent) {
      vertexFormatId |= 1 << 4;
    }
    if (hasColor) {
      vertexFormatId |= 1 << 5;
    }
    if (dynamic) {
      vertexFormatId |= 1 << 6;
    }
    var vertexFormat = this.vertexFormats[vertexFormatId];
    if (!vertexFormat) {
      var formatDesc = [];
      formatDesc.push({semantic:pc.SEMANTIC_POSITION, components:3, type:pc.ELEMENTTYPE_FLOAT32, normalize:false});
      if (hasNormal) {
        formatDesc.push({semantic:pc.SEMANTIC_NORMAL, components:3, type:pc.ELEMENTTYPE_FLOAT32, normalize:false});
      }
      if (hasUv) {
        formatDesc.push({semantic:pc.SEMANTIC_TEXCOORD0, components:2, type:pc.ELEMENTTYPE_FLOAT32, normalize:false});
      }
      if (hasUv2) {
        formatDesc.push({semantic:pc.SEMANTIC_TEXCOORD1, components:2, type:pc.ELEMENTTYPE_FLOAT32, normalize:false});
      }
      if (hasTangent) {
        formatDesc.push({semantic:pc.SEMANTIC_TANGENT, components:4, type:pc.ELEMENTTYPE_FLOAT32, normalize:false});
      }
      if (hasColor) {
        formatDesc.push({semantic:pc.SEMANTIC_COLOR, components:4, type:pc.ELEMENTTYPE_UINT8, normalize:true});
      }
      if (dynamic) {
        formatDesc.push({semantic:pc.SEMANTIC_BLENDINDICES, components:1, type:pc.ELEMENTTYPE_FLOAT32, normalize:false});
      }
      vertexFormat = this.vertexFormats[vertexFormatId] = new pc.VertexFormat(this.device, formatDesc);
    }
    var vertexBuffer = new pc.VertexBuffer(this.device, vertexFormat, batchNumVerts, pc.BUFFER_STATIC, batchData.buffer);
    indexBuffer.unlock();
    mesh = new pc.Mesh;
    mesh.vertexBuffer = vertexBuffer;
    mesh.indexBuffer[0] = indexBuffer;
    mesh.primitive[0].type = batch.origMeshInstances[0].mesh.primitive[0].type;
    mesh.primitive[0].base = 0;
    mesh.primitive[0].count = batchNumIndices;
    mesh.primitive[0].indexed = true;
    mesh.cull = false;
    if (dynamic) {
      material = material.clone();
      material.chunks.transformVS = this.transformVS;
      material.chunks.skinTexVS = this.skinTexVS;
      material.chunks.skinConstVS = this.skinConstVS;
      material.update();
    }
    var meshInstance = new pc.MeshInstance(this.rootNode, mesh, material);
    meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
    meshInstance.parameters = batch.origMeshInstances[0].parameters;
    meshInstance.isStatic = batch.origMeshInstances[0].isStatic;
    meshInstance.cull = batch.origMeshInstances[0].cull;
    meshInstance.layer = batch.origMeshInstances[0].layer;
    meshInstance._staticLightList = batch.origMeshInstances[0]._staticLightList;
    meshInstance._shaderDefs = batch.origMeshInstances[0]._shaderDefs;
    if (dynamic) {
      var nodes = [];
      for (i = 0;i < batch.origMeshInstances.length;i++) {
        nodes.push(batch.origMeshInstances[i].node);
      }
      meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
    }
    meshInstance._updateAabb = false;
    batch.meshInstance = meshInstance;
    this.update(batch);
    var newModel = new pc.Model;
    newModel.meshInstances = [batch.meshInstance];
    newModel.castShadows = batch.origMeshInstances[0].castShadows;
    batch.model = newModel;
    return batch;
  };
  BatchManager.prototype.update = function(batch) {
    batch._aabb.copy(batch.origMeshInstances[0].aabb);
    for (var i = 0;i < batch.origMeshInstances.length;i++) {
      if (i > 0) {
        batch._aabb.add(batch.origMeshInstances[i].aabb);
      }
    }
    batch.meshInstance.aabb = batch._aabb;
    batch._aabb._radiusVer = -1;
    batch.meshInstance._aabbVer = 0;
  };
  BatchManager.prototype.updateAll = function() {
    if (this._dirtyGroups.length > 0) {
      this.generate(this._dirtyGroups);
    }
    for (var i = 0;i < this._batchList.length;i++) {
      if (!this._batchList[i].dynamic) {
        continue;
      }
      this.update(this._batchList[i]);
    }
  };
  BatchManager.prototype.clone = function(batch, clonedMeshInstances) {
    var batch2 = new pc.Batch(clonedMeshInstances, batch.dynamic, batch.batchGroupId);
    this._batchList.push(batch2);
    var nodes = [];
    for (var i = 0;i < clonedMeshInstances.length;i++) {
      nodes.push(clonedMeshInstances[i].node);
    }
    batch2.meshInstance = new pc.MeshInstance(batch.meshInstance.node, batch.meshInstance.mesh, batch.meshInstance.material);
    batch2.meshInstance._updateAabb = false;
    batch2.meshInstance.parameters = clonedMeshInstances[0].parameters;
    batch2.meshInstance.isStatic = clonedMeshInstances[0].isStatic;
    batch2.meshInstance.cull = clonedMeshInstances[0].cull;
    batch2.meshInstance.layer = clonedMeshInstances[0].layer;
    batch2.meshInstance._staticLightList = clonedMeshInstances[0]._staticLightList;
    if (batch.dynamic) {
      batch2.meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
    }
    batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
    batch2.meshInstance._shader = batch.meshInstance._shader;
    var newModel = new pc.Model;
    newModel.meshInstances = [batch2.meshInstance];
    newModel.castShadows = batch.origMeshInstances[0].castShadows;
    batch2.model = newModel;
    return batch2;
  };
  BatchManager.prototype.destroy = function(batch) {
    batch.refCounter = 0;
    var layers = this._batchGroups[batch.batchGroupId].layers;
    for (var i = 0;i < layers.length;i++) {
      this.scene.layers.getLayerById(layers[i]).removeMeshInstances(batch.model.meshInstances);
    }
    batch.model.destroy();
  };
  BatchManager.prototype.decrement = function(batch) {
    batch.refCounter--;
    if (batch.refCounter === 0) {
      this.destroy(batch);
    }
  };
  BatchManager.prototype.register = function(batch, entities) {
    batch.refCounter = entities.length;
    var self = this;
    var callback = function() {
      self.decrement(batch);
    };
    for (var i = 0;i < entities.length;i++) {
      entities[i].once("destroy", callback);
    }
  };
  return {Batch:Batch, BatchGroup:BatchGroup, BatchManager:BatchManager};
}());

  return pc;
}));

